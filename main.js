import {
  A11yModule,
  ACLService,
  ALAIN_I18N_TOKEN,
  ANIMATION_MODULE_TYPE,
  APP_INITIALIZER,
  ActivatedRoute,
  AlainConfigService,
  AlainI18nBaseService,
  AlainThemeModule,
  AlipayCircleOutline,
  ApartmentOutline,
  ApiFill,
  ApiOutline,
  ApplicationRef,
  AppstoreOutline,
  ArrowDownOutline,
  ArrowUpOutline,
  AsyncPipe,
  AuditOutline,
  BACKSPACE,
  BehaviorSubject,
  BidiModule,
  BookOutline,
  BorderLeftOutline,
  BorderRightOutline,
  BoxPlotOutline,
  CalculatorOutline,
  CandyDate,
  CdkConnectedOverlay,
  CdkDrag,
  CdkDragHandle,
  CdkFixedSizeVirtualScroll,
  CdkMonitorFocus,
  CdkObserveContent,
  CdkOverlayOrigin,
  CdkPortalOutlet,
  CdkTrapFocus,
  CdkVirtualForOf,
  CdkVirtualScrollViewport,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  CheckCircleFill,
  CheckCircleOutline,
  CheckOutline,
  CheckSquareOutline,
  ClockCircleOutline,
  CloudOutline,
  CommonModule,
  Component,
  ComponentPortal,
  ConnectionPositionPair,
  ContainerOutline,
  ContentChild,
  ContentChildren,
  CopyrightOutline,
  CreditCardOutline,
  CurrencyPipe,
  CustomerServiceOutline,
  DA_SERVICE_TOKEN,
  DEFAULT_CURRENCY_CODE,
  DOCUMENT,
  DOWN_ARROW,
  DashboardOutline,
  DatabaseOutline,
  DateHelperService,
  DatePipe,
  DecimalPipe,
  DelonACLModule,
  DelonLocaleModule,
  DelonLocaleService,
  DesktopOutline,
  DestroyRef,
  DingdingOutline,
  Directionality,
  Directive,
  DislikeOutline,
  DollarCircleFill,
  DollarOutline,
  DomSanitizer,
  DownloadOutline,
  DrawerHelper,
  EMPTY,
  ENTER,
  ENVIRONMENT_INITIALIZER,
  ESCAPE,
  ElementRef,
  EventEmitter,
  FileDoneOutline,
  FilterOutline,
  FocusKeyManager,
  FocusMonitor,
  ForkOutline,
  FormOutline,
  FrownOutline,
  FullscreenExitOutline,
  FullscreenOutline,
  FunnelPlotOutline,
  GithubOutline,
  GlobalOutline,
  HTTP_INTERCEPTORS,
  HddOutline,
  Host,
  HostBinding,
  HostListener,
  HttpClient,
  HttpErrorResponse,
  HttpParams,
  HttpResponse,
  HttpResponseBase,
  I18nPipe,
  IGNORE_BASE_URL,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputBoolean,
  InputNumber,
  LEFT_ARROW,
  LOCALE_ID,
  LaptopOutline,
  LazyService,
  LikeOutline,
  LoadingOutline,
  Location,
  LockOutline,
  LogoutOutline,
  MailOutline,
  MediaMatcher,
  MenuFoldOutline,
  MenuService,
  MenuUnfoldOutline,
  MessageOutline,
  ModalHelper,
  NavigationCancel,
  NavigationEnd,
  NavigationError,
  NavigationStart,
  NgClass,
  NgForOf,
  NgIf,
  NgModule,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  NgZone,
  NumberSymbol,
  NzButtonComponent,
  NzButtonGroupComponent,
  NzButtonModule,
  NzCardComponent,
  NzCardModule,
  NzConfigService,
  NzDrawerComponent,
  NzDrawerContentDirective,
  NzDrawerModule,
  NzDrawerRef,
  NzI18nModule,
  NzI18nPipe,
  NzI18nService,
  NzIconDirective,
  NzIconModule,
  NzModalComponent,
  NzModalContentDirective,
  NzModalModule,
  NzModalService,
  NzNoAnimationDirective,
  NzNoAnimationModule,
  NzOutletModule,
  NzStringTemplateOutletDirective,
  NzTransitionPatchDirective,
  NzWaveDirective,
  NzWaveModule,
  Observable,
  ObserversModule,
  Optional,
  Output,
  Overlay,
  OverlayConfig,
  OverlayModule,
  OverlayRef,
  PLATFORM_ID,
  PREFIX,
  PRIMARY_OUTLET,
  PayCircleOutline,
  PieChartOutline,
  Pipe,
  Platform,
  PlatformModule,
  PortalModule,
  PrinterOutline,
  QueryList,
  RIGHT_ARROW,
  ROUTER_CONFIGURATION,
  ReloadOutline,
  Renderer2,
  RendererFactory2,
  ReplaySubject,
  ResponsiveService,
  RocketOutline,
  RouteConfigLoadEnd,
  RouteConfigLoadStart,
  Router,
  RouterLink,
  RouterModule,
  RouterOutlet,
  RuntimeError,
  SPACE,
  SafetyCertificateOutline,
  ScanOutline,
  ScrollService,
  ScrollingModule,
  Self,
  SettingOutline,
  SettingsService,
  ShareAltOutline,
  ShoppingCartOutline,
  SkipSelf,
  SmileOutline,
  SolutionOutline,
  SoundOutline,
  StarOutline,
  StopOutline,
  Subject,
  Subscription,
  TAB,
  TaobaoCircleOutline,
  TaobaoOutline,
  TeamOutline,
  TemplatePortal,
  TemplateRef,
  ThunderboltOutline,
  TitleService,
  ToolOutline,
  TranslationOutline,
  TrophyOutline,
  Type,
  UP_ARROW,
  UploadOutline,
  UsbOutline,
  UserOutline,
  VERSION,
  Version,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  ViewportRuler,
  WeiboCircleOutline,
  WithConfig,
  YNPipe,
  _HttpClient,
  __async,
  __commonJS,
  __decorate,
  __export,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM,
  animate,
  animationFrameScheduler,
  arraysEqual,
  asapScheduler,
  auditTime,
  authSimpleInterceptor,
  booleanAttribute,
  bootstrapApplication,
  buildFormatLongFn,
  buildLocalizeFn,
  buildMatchFn,
  buildMatchPatternFn,
  cancelRequestAnimationFrame,
  catchError,
  cloneDate,
  coerceElement,
  coerceNumberProperty,
  combineLatest,
  copy,
  createComponent,
  debounce,
  debounceTime,
  deepCopy,
  deepGet,
  deepMerge,
  deepMergeKey,
  defer,
  delay,
  distinctUntilChanged,
  enUS,
  en_US,
  en_US_default,
  endOfMonth,
  ensureInBounds,
  environment,
  filter,
  finalize,
  first,
  forkJoin,
  format,
  formatDate,
  formatNumber,
  forwardRef,
  from,
  fromEvent,
  getDOM,
  getEventPosition,
  getLocaleNumberSymbol,
  getStatusClassNames,
  getStyleAsText,
  hasModifierKey,
  inject,
  interval,
  isDevMode,
  isEmpty,
  isNil,
  isNonEmptyString,
  isNotNil,
  isObservable,
  isPlatformBrowser,
  isPresetColor,
  isPromise,
  isStatusColor,
  isSubscribable,
  isTemplateRef,
  isTouchEvent,
  isValid,
  lastValueFrom,
  makeEnvironmentProviders,
  map,
  mapTo,
  measureScrollbar,
  merge,
  mergeMap,
  normalizePassiveListenerOptions,
  normalizeRangeValue,
  of,
  padStart,
  pipe,
  presetColors,
  provideAlain,
  provideAnimations,
  provideAuth,
  provideHttpClient,
  provideNzConfig,
  provideRouter,
  query,
  registerLocaleData,
  reqAnimFrame,
  requiredArgs,
  scrollIntoView,
  setClassMetadata,
  shallowEqual,
  share,
  skip,
  stagger,
  startOfUTCWeek,
  startWith,
  state,
  statusColors,
  stepPreloader,
  style,
  switchMap,
  take,
  takeUntil,
  takeUntilDestroyed,
  tap,
  throttleTime,
  throwError,
  timeUnits,
  timer,
  toBoolean,
  toCssPixel,
  toDate,
  toNumber,
  transition,
  trigger,
  updateHostClass,
  valueFunctionProp,
  warn,
  warn2,
  withComponentInputBinding,
  withHashLocation,
  withInMemoryScrolling,
  withInterceptors,
  withLatestFrom,
  wrapIntoObservable,
  wrongSortOrder,
  yn,
  zhCN,
  zhTW,
  zh_CN,
  zh_TW,
  zip,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassMapInterpolate2,
  ɵɵclassMapInterpolate4,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceHTML,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵresolveDocument,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeStyle,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleMapInterpolate1,
  ɵɵstyleProp,
  ɵɵsyntheticHostListener,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵviewQuery
} from "./chunk-3KJTDGQP.js";

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? line : code_1.nil });
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node2 = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node2 {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node2 {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : __spreadValues({}, this.lhs.names);
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node2 {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node2 {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node2 {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from2, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from2;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from: from2, to } = this;
        return `for(${varKind} ${name}=${from2}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? "\n" : "" });
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from2, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from2, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from2) {
      for (const n in from2)
        names[n] = (names[n] || 0) + (from2[n] || 0);
      return names;
    }
    function addExprNames(names, from2) {
      return from2 instanceof code_1._CodeOrName ? addNames(names, from2.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from2) {
      for (const n in from2)
        names[n] = (names[n] || 0) - (from2[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from2, to, toName) => {
        const res = to === void 0 ? from2 : to instanceof codegen_1.Name ? (from2 instanceof codegen_1.Name ? mergeNames(gen, from2, to) : mergeToName(gen, from2, to), to) : from2 instanceof codegen_1.Name ? (mergeToName(gen, to, from2), from2) : mergeValues(from2, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from2, to) => gen.if((0, codegen_1._)`${to} !== true && ${from2} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from2} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from2})`));
        }),
        mergeToName: (gen, from2, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from2 === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from2);
          }
        }),
        mergeValues: (from2, to) => from2 === true ? true : __spreadValues(__spreadValues({}, from2), to),
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from2, to) => gen.if((0, codegen_1._)`${to} !== true && ${from2} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from2} === true ? true : ${to} > ${from2} ? ${to} : ${from2}`)),
        mergeToName: (gen, from2, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from2 === true ? true : (0, codegen_1._)`${to} > ${from2} ? ${to} : ${from2}`)),
        mergeValues: (from2, to) => from2 === true ? true : Math.max(from2, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type2;
    (function(Type3) {
      Type3[Type3["Num"] = 0] = "Num";
      Type3[Type3["Str"] = 1] = "Str";
    })(Type2 = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type2.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u4 = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u4);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u4})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData2(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema), { items: void 0, props: void 0 });
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData2($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData2;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
    "use strict";
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.URI = global.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge2() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map2(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first2 = _address$toLowerCase$2[1];
          var firstFields = first2 ? first2.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query2 = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query2;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? __spreadProps(__spreadValues({}, o.code), { optimize, regExp }) : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = __spreadValues(__spreadValues({}, opts), requiredOptions(opts));
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = __spreadValues({}, $dataRefSchema);
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        function runCompileAsync(_schema, _meta) {
          return __async(this, null, function* () {
            yield loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          });
        }
        function loadMetaSchema($ref) {
          return __async(this, null, function* () {
            if ($ref && !this.getSchema($ref)) {
              yield runCompileAsync.call(this, { $ref }, true);
            }
          });
        }
        function _compileAsync(sch) {
          return __async(this, null, function* () {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e) {
              if (!(e instanceof ref_error_1.default))
                throw e;
              checkLoaded.call(this, e);
              yield loadMissingSchema.call(this, e.missingSchema);
              return _compileAsync.call(this, sch);
            }
          });
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        function loadMissingSchema(ref) {
          return __async(this, null, function* () {
            const _schema = yield _loadSchema.call(this, ref);
            if (!this.refs[ref])
              yield loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
              this.addSchema(_schema, ref, meta);
          });
        }
        function _loadSchema(ref) {
          return __async(this, null, function* () {
            const p = this._loading[ref];
            if (p)
              return p;
            try {
              return yield this._loading[ref] = loadSchema(ref);
            } finally {
              delete this._loading[ref];
            }
          });
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = __spreadProps(__spreadValues({}, def), {
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        });
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name] = format2;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports.default = Ajv2;
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format2 = this.opts.formats[name];
        if (format2)
          this.addFormat(name, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = __spreadValues({}, this.opts);
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: __spreadProps(__spreadValues({}, definition), {
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        })
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u4 = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u4}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format2 = [format_1.default];
    exports.default = format2;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module.exports = exports = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(time, compareTime),
      "date-time": fmtDef(date_time, compareDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = __spreadProps(__spreadValues({}, exports.fullFormats), {
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    });
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function time(str, withTimeZone) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hour = +matches[1];
      const minute = +matches[2];
      const second = +matches[3];
      const timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
    }
    function compareTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
      t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format2 = fCxt.schema;
          const fmtDef = self.formats[format2];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format2}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format2,
            ref: fmtDef,
            code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format2)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    };
    exports.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats2(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list2 = opts.formats || formats_1.formatNames;
      addFormats2(ajv, list2, formats, exportName);
      if (opts.keywords)
        limit_1.default(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats2(ajv, list2, fs, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list2)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// node_modules/apexcharts/dist/apexcharts.common.js
var require_apexcharts_common = __commonJS({
  "node_modules/apexcharts/dist/apexcharts.common.js"(exports, module) {
    "use strict";
    function t(t2, e2) {
      var i2 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var a2 = Object.getOwnPropertySymbols(t2);
        e2 && (a2 = a2.filter(function(e3) {
          return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
        })), i2.push.apply(i2, a2);
      }
      return i2;
    }
    function e(e2) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var a2 = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? t(Object(a2), true).forEach(function(t2) {
          o(e2, t2, a2[t2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(a2)) : t(Object(a2)).forEach(function(t2) {
          Object.defineProperty(e2, t2, Object.getOwnPropertyDescriptor(a2, t2));
        });
      }
      return e2;
    }
    function i(t2) {
      return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, i(t2);
    }
    function a(t2, e2) {
      if (!(t2 instanceof e2))
        throw new TypeError("Cannot call a class as a function");
    }
    function s(t2, e2) {
      for (var i2 = 0; i2 < e2.length; i2++) {
        var a2 = e2[i2];
        a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(t2, a2.key, a2);
      }
    }
    function r(t2, e2, i2) {
      return e2 && s(t2.prototype, e2), i2 && s(t2, i2), t2;
    }
    function o(t2, e2, i2) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
    }
    function n(t2, e2) {
      if ("function" != typeof e2 && null !== e2)
        throw new TypeError("Super expression must either be null or a function");
      t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && h(t2, e2);
    }
    function l(t2) {
      return l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, l(t2);
    }
    function h(t2, e2) {
      return h = Object.setPrototypeOf || function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, h(t2, e2);
    }
    function c(t2) {
      if (void 0 === t2)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t2;
    }
    function d(t2) {
      var e2 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t3) {
          return false;
        }
      }();
      return function() {
        var i2, a2 = l(t2);
        if (e2) {
          var s2 = l(this).constructor;
          i2 = Reflect.construct(a2, arguments, s2);
        } else
          i2 = a2.apply(this, arguments);
        return function(t3, e3) {
          if (e3 && ("object" == typeof e3 || "function" == typeof e3))
            return e3;
          if (void 0 !== e3)
            throw new TypeError("Derived constructors may only return object or undefined");
          return c(t3);
        }(this, i2);
      };
    }
    function g(t2, e2) {
      return function(t3) {
        if (Array.isArray(t3))
          return t3;
      }(t2) || function(t3, e3) {
        var i2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
        if (null == i2)
          return;
        var a2, s2, r2 = [], o2 = true, n2 = false;
        try {
          for (i2 = i2.call(t3); !(o2 = (a2 = i2.next()).done) && (r2.push(a2.value), !e3 || r2.length !== e3); o2 = true)
            ;
        } catch (t4) {
          n2 = true, s2 = t4;
        } finally {
          try {
            o2 || null == i2.return || i2.return();
          } finally {
            if (n2)
              throw s2;
          }
        }
        return r2;
      }(t2, e2) || p(t2, e2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function u4(t2) {
      return function(t3) {
        if (Array.isArray(t3))
          return f(t3);
      }(t2) || function(t3) {
        if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
          return Array.from(t3);
      }(t2) || p(t2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function p(t2, e2) {
      if (t2) {
        if ("string" == typeof t2)
          return f(t2, e2);
        var i2 = Object.prototype.toString.call(t2).slice(8, -1);
        return "Object" === i2 && t2.constructor && (i2 = t2.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(t2) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? f(t2, e2) : void 0;
      }
    }
    function f(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var i2 = 0, a2 = new Array(e2); i2 < e2; i2++)
        a2[i2] = t2[i2];
      return a2;
    }
    var x = function() {
      function t2() {
        a(this, t2);
      }
      return r(t2, [{ key: "shadeRGBColor", value: function(t3, e2) {
        var i2 = e2.split(","), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = parseInt(i2[0].slice(4), 10), o2 = parseInt(i2[1], 10), n2 = parseInt(i2[2], 10);
        return "rgb(" + (Math.round((a2 - r2) * s2) + r2) + "," + (Math.round((a2 - o2) * s2) + o2) + "," + (Math.round((a2 - n2) * s2) + n2) + ")";
      } }, { key: "shadeHexColor", value: function(t3, e2) {
        var i2 = parseInt(e2.slice(1), 16), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = i2 >> 16, o2 = i2 >> 8 & 255, n2 = 255 & i2;
        return "#" + (16777216 + 65536 * (Math.round((a2 - r2) * s2) + r2) + 256 * (Math.round((a2 - o2) * s2) + o2) + (Math.round((a2 - n2) * s2) + n2)).toString(16).slice(1);
      } }, { key: "shadeColor", value: function(e2, i2) {
        return t2.isColorHex(i2) ? this.shadeHexColor(e2, i2) : this.shadeRGBColor(e2, i2);
      } }], [{ key: "bind", value: function(t3, e2) {
        return function() {
          return t3.apply(e2, arguments);
        };
      } }, { key: "isObject", value: function(t3) {
        return t3 && "object" === i(t3) && !Array.isArray(t3) && null != t3;
      } }, { key: "is", value: function(t3, e2) {
        return Object.prototype.toString.call(e2) === "[object " + t3 + "]";
      } }, { key: "listToArray", value: function(t3) {
        var e2, i2 = [];
        for (e2 = 0; e2 < t3.length; e2++)
          i2[e2] = t3[e2];
        return i2;
      } }, { key: "extend", value: function(t3, e2) {
        var i2 = this;
        "function" != typeof Object.assign && (Object.assign = function(t4) {
          if (null == t4)
            throw new TypeError("Cannot convert undefined or null to object");
          for (var e3 = Object(t4), i3 = 1; i3 < arguments.length; i3++) {
            var a3 = arguments[i3];
            if (null != a3)
              for (var s2 in a3)
                a3.hasOwnProperty(s2) && (e3[s2] = a3[s2]);
          }
          return e3;
        });
        var a2 = Object.assign({}, t3);
        return this.isObject(t3) && this.isObject(e2) && Object.keys(e2).forEach(function(s2) {
          i2.isObject(e2[s2]) && s2 in t3 ? a2[s2] = i2.extend(t3[s2], e2[s2]) : Object.assign(a2, o({}, s2, e2[s2]));
        }), a2;
      } }, { key: "extendArray", value: function(e2, i2) {
        var a2 = [];
        return e2.map(function(e3) {
          a2.push(t2.extend(i2, e3));
        }), e2 = a2;
      } }, { key: "monthMod", value: function(t3) {
        return t3 % 12;
      } }, { key: "clone", value: function(e2) {
        if (t2.is("Array", e2)) {
          for (var a2 = [], s2 = 0; s2 < e2.length; s2++)
            a2[s2] = this.clone(e2[s2]);
          return a2;
        }
        if (t2.is("Null", e2))
          return null;
        if (t2.is("Date", e2))
          return e2;
        if ("object" === i(e2)) {
          var r2 = {};
          for (var o2 in e2)
            e2.hasOwnProperty(o2) && (r2[o2] = this.clone(e2[o2]));
          return r2;
        }
        return e2;
      } }, { key: "log10", value: function(t3) {
        return Math.log(t3) / Math.LN10;
      } }, { key: "roundToBase10", value: function(t3) {
        return Math.pow(10, Math.floor(Math.log10(t3)));
      } }, { key: "roundToBase", value: function(t3, e2) {
        return Math.pow(e2, Math.floor(Math.log(t3) / Math.log(e2)));
      } }, { key: "parseNumber", value: function(t3) {
        return null === t3 ? t3 : parseFloat(t3);
      } }, { key: "stripNumber", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
        return Number.isInteger(t3) ? t3 : parseFloat(t3.toPrecision(e2));
      } }, { key: "randomId", value: function() {
        return (Math.random() + 1).toString(36).substring(4);
      } }, { key: "noExponents", value: function(t3) {
        var e2 = String(t3).split(/[eE]/);
        if (1 === e2.length)
          return e2[0];
        var i2 = "", a2 = t3 < 0 ? "-" : "", s2 = e2[0].replace(".", ""), r2 = Number(e2[1]) + 1;
        if (r2 < 0) {
          for (i2 = a2 + "0."; r2++; )
            i2 += "0";
          return i2 + s2.replace(/^-/, "");
        }
        for (r2 -= s2.length; r2--; )
          i2 += "0";
        return s2 + i2;
      } }, { key: "getDimensions", value: function(t3) {
        var e2 = getComputedStyle(t3, null), i2 = t3.clientHeight, a2 = t3.clientWidth;
        return i2 -= parseFloat(e2.paddingTop) + parseFloat(e2.paddingBottom), [a2 -= parseFloat(e2.paddingLeft) + parseFloat(e2.paddingRight), i2];
      } }, { key: "getBoundingClientRect", value: function(t3) {
        var e2 = t3.getBoundingClientRect();
        return { top: e2.top, right: e2.right, bottom: e2.bottom, left: e2.left, width: t3.clientWidth, height: t3.clientHeight, x: e2.left, y: e2.top };
      } }, { key: "getLargestStringFromArr", value: function(t3) {
        return t3.reduce(function(t4, e2) {
          return Array.isArray(e2) && (e2 = e2.reduce(function(t5, e3) {
            return t5.length > e3.length ? t5 : e3;
          })), t4.length > e2.length ? t4 : e2;
        }, 0);
      } }, { key: "hexToRgba", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
        "#" !== t3.substring(0, 1) && (t3 = "#999999");
        var i2 = t3.replace("#", "");
        i2 = i2.match(new RegExp("(.{" + i2.length / 3 + "})", "g"));
        for (var a2 = 0; a2 < i2.length; a2++)
          i2[a2] = parseInt(1 === i2[a2].length ? i2[a2] + i2[a2] : i2[a2], 16);
        return void 0 !== e2 && i2.push(e2), "rgba(" + i2.join(",") + ")";
      } }, { key: "getOpacityFromRGBA", value: function(t3) {
        return parseFloat(t3.replace(/^.*,(.+)\)/, "$1"));
      } }, { key: "rgb2hex", value: function(t3) {
        return (t3 = t3.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t3.length ? "#" + ("0" + parseInt(t3[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[3], 10).toString(16)).slice(-2) : "";
      } }, { key: "isColorHex", value: function(t3) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t3);
      } }, { key: "getPolygonPos", value: function(t3, e2) {
        for (var i2 = [], a2 = 2 * Math.PI / e2, s2 = 0; s2 < e2; s2++) {
          var r2 = {};
          r2.x = t3 * Math.sin(s2 * a2), r2.y = -t3 * Math.cos(s2 * a2), i2.push(r2);
        }
        return i2;
      } }, { key: "polarToCartesian", value: function(t3, e2, i2, a2) {
        var s2 = (a2 - 90) * Math.PI / 180;
        return { x: t3 + i2 * Math.cos(s2), y: e2 + i2 * Math.sin(s2) };
      } }, { key: "escapeString", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i2 = t3.toString().slice();
        return i2 = i2.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e2);
      } }, { key: "negToZero", value: function(t3) {
        return t3 < 0 ? 0 : t3;
      } }, { key: "moveIndexInArray", value: function(t3, e2, i2) {
        if (i2 >= t3.length)
          for (var a2 = i2 - t3.length + 1; a2--; )
            t3.push(void 0);
        return t3.splice(i2, 0, t3.splice(e2, 1)[0]), t3;
      } }, { key: "extractNumber", value: function(t3) {
        return parseFloat(t3.replace(/[^\d.]*/g, ""));
      } }, { key: "findAncestor", value: function(t3, e2) {
        for (; (t3 = t3.parentElement) && !t3.classList.contains(e2); )
          ;
        return t3;
      } }, { key: "setELstyles", value: function(t3, e2) {
        for (var i2 in e2)
          e2.hasOwnProperty(i2) && (t3.style.key = e2[i2]);
      } }, { key: "isNumber", value: function(t3) {
        return !isNaN(t3) && parseFloat(Number(t3)) === t3 && !isNaN(parseInt(t3, 10));
      } }, { key: "isFloat", value: function(t3) {
        return Number(t3) === t3 && t3 % 1 != 0;
      } }, { key: "isSafari", value: function() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      } }, { key: "isFirefox", value: function() {
        return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
      } }, { key: "isIE11", value: function() {
        if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1)
          return true;
      } }, { key: "isIE", value: function() {
        var t3 = window.navigator.userAgent, e2 = t3.indexOf("MSIE ");
        if (e2 > 0)
          return parseInt(t3.substring(e2 + 5, t3.indexOf(".", e2)), 10);
        if (t3.indexOf("Trident/") > 0) {
          var i2 = t3.indexOf("rv:");
          return parseInt(t3.substring(i2 + 3, t3.indexOf(".", i2)), 10);
        }
        var a2 = t3.indexOf("Edge/");
        return a2 > 0 && parseInt(t3.substring(a2 + 5, t3.indexOf(".", a2)), 10);
      } }]), t2;
    }();
    var b = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.setEasingFunctions();
      }
      return r(t2, [{ key: "setEasingFunctions", value: function() {
        var t3;
        if (!this.w.globals.easing) {
          switch (this.w.config.chart.animations.easing) {
            case "linear":
              t3 = "-";
              break;
            case "easein":
              t3 = "<";
              break;
            case "easeout":
              t3 = ">";
              break;
            case "easeinout":
            default:
              t3 = "<>";
              break;
            case "swing":
              t3 = function(t4) {
                var e2 = 1.70158;
                return (t4 -= 1) * t4 * ((e2 + 1) * t4 + e2) + 1;
              };
              break;
            case "bounce":
              t3 = function(t4) {
                return t4 < 1 / 2.75 ? 7.5625 * t4 * t4 : t4 < 2 / 2.75 ? 7.5625 * (t4 -= 1.5 / 2.75) * t4 + 0.75 : t4 < 2.5 / 2.75 ? 7.5625 * (t4 -= 2.25 / 2.75) * t4 + 0.9375 : 7.5625 * (t4 -= 2.625 / 2.75) * t4 + 0.984375;
              };
              break;
            case "elastic":
              t3 = function(t4) {
                return t4 === !!t4 ? t4 : Math.pow(2, -10 * t4) * Math.sin((t4 - 0.075) * (2 * Math.PI) / 0.3) + 1;
              };
          }
          this.w.globals.easing = t3;
        }
      } }, { key: "animateLine", value: function(t3, e2, i2, a2) {
        t3.attr(e2).animate(a2).attr(i2);
      } }, { key: "animateMarker", value: function(t3, e2, i2, a2, s2, r2) {
        e2 || (e2 = 0), t3.attr({ r: e2, width: e2, height: e2 }).animate(a2, s2).attr({ r: i2, width: i2.width, height: i2.height }).afterAll(function() {
          r2();
        });
      } }, { key: "animateCircle", value: function(t3, e2, i2, a2, s2) {
        t3.attr({ r: e2.r, cx: e2.cx, cy: e2.cy }).animate(a2, s2).attr({ r: i2.r, cx: i2.cx, cy: i2.cy });
      } }, { key: "animateRect", value: function(t3, e2, i2, a2, s2) {
        t3.attr(e2).animate(a2).attr(i2).afterAll(function() {
          return s2();
        });
      } }, { key: "animatePathsGradually", value: function(t3) {
        var e2 = t3.el, i2 = t3.realIndex, a2 = t3.j, s2 = t3.fill, r2 = t3.pathFrom, o2 = t3.pathTo, n2 = t3.speed, l2 = t3.delay, h2 = this.w, c2 = 0;
        h2.config.chart.animations.animateGradually.enabled && (c2 = h2.config.chart.animations.animateGradually.delay), h2.config.chart.animations.dynamicAnimation.enabled && h2.globals.dataChanged && "bar" !== h2.config.chart.type && (c2 = 0), this.morphSVG(e2, i2, a2, "line" !== h2.config.chart.type || h2.globals.comboCharts ? s2 : "stroke", r2, o2, n2, l2 * c2);
      } }, { key: "showDelayedElements", value: function() {
        this.w.globals.delayedElements.forEach(function(t3) {
          var e2 = t3.el;
          e2.classList.remove("apexcharts-element-hidden"), e2.classList.add("apexcharts-hidden-element-shown");
        });
      } }, { key: "animationCompleted", value: function(t3) {
        var e2 = this.w;
        e2.globals.animationEnded || (e2.globals.animationEnded = true, this.showDelayedElements(), "function" == typeof e2.config.chart.events.animationEnd && e2.config.chart.events.animationEnd(this.ctx, { el: t3, w: e2 }));
      } }, { key: "morphSVG", value: function(t3, e2, i2, a2, s2, r2, o2, n2) {
        var l2 = this, h2 = this.w;
        s2 || (s2 = t3.attr("pathFrom")), r2 || (r2 = t3.attr("pathTo"));
        var c2 = function(t4) {
          return "radar" === h2.config.chart.type && (o2 = 1), "M 0 ".concat(h2.globals.gridHeight);
        };
        (!s2 || s2.indexOf("undefined") > -1 || s2.indexOf("NaN") > -1) && (s2 = c2()), (!r2 || r2.indexOf("undefined") > -1 || r2.indexOf("NaN") > -1) && (r2 = c2()), h2.globals.shouldAnimate || (o2 = 1), t3.plot(s2).animate(1, h2.globals.easing, n2).plot(s2).animate(o2, h2.globals.easing, n2).plot(r2).afterAll(function() {
          x.isNumber(i2) ? i2 === h2.globals.series[h2.globals.maxValsInArrayIndex].length - 2 && h2.globals.shouldAnimate && l2.animationCompleted(t3) : "none" !== a2 && h2.globals.shouldAnimate && (!h2.globals.comboCharts && e2 === h2.globals.series.length - 1 || h2.globals.comboCharts) && l2.animationCompleted(t3), l2.showDelayedElements();
        });
      } }]), t2;
    }();
    var v = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "getDefaultFilter", value: function(t3, e2) {
        var i2 = this.w;
        t3.unfilter(true), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), "none" !== i2.config.states.normal.filter ? this.applyFilter(t3, e2, i2.config.states.normal.filter.type, i2.config.states.normal.filter.value) : i2.config.chart.dropShadow.enabled && this.dropShadow(t3, i2.config.chart.dropShadow, e2);
      } }, { key: "addNormalFilter", value: function(t3, e2) {
        var i2 = this.w;
        i2.config.chart.dropShadow.enabled && !t3.node.classList.contains("apexcharts-marker") && this.dropShadow(t3, i2.config.chart.dropShadow, e2);
      } }, { key: "addLightenFilter", value: function(t3, e2, i2) {
        var a2 = this, s2 = this.w, r2 = i2.intensity;
        t3.unfilter(true);
        new window.SVG.Filter();
        t3.filter(function(t4) {
          var i3 = s2.config.chart.dropShadow;
          (i3.enabled ? a2.addShadow(t4, e2, i3) : t4).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: r2 } });
        }), t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node);
      } }, { key: "addDarkenFilter", value: function(t3, e2, i2) {
        var a2 = this, s2 = this.w, r2 = i2.intensity;
        t3.unfilter(true);
        new window.SVG.Filter();
        t3.filter(function(t4) {
          var i3 = s2.config.chart.dropShadow;
          (i3.enabled ? a2.addShadow(t4, e2, i3) : t4).componentTransfer({ rgb: { type: "linear", slope: r2 } });
        }), t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node);
      } }, { key: "applyFilter", value: function(t3, e2, i2) {
        var a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5;
        switch (i2) {
          case "none":
            this.addNormalFilter(t3, e2);
            break;
          case "lighten":
            this.addLightenFilter(t3, e2, { intensity: a2 });
            break;
          case "darken":
            this.addDarkenFilter(t3, e2, { intensity: a2 });
        }
      } }, { key: "addShadow", value: function(t3, e2, i2) {
        var a2 = i2.blur, s2 = i2.top, r2 = i2.left, o2 = i2.color, n2 = i2.opacity, l2 = t3.flood(Array.isArray(o2) ? o2[e2] : o2, n2).composite(t3.sourceAlpha, "in").offset(r2, s2).gaussianBlur(a2).merge(t3.source);
        return t3.blend(t3.source, l2);
      } }, { key: "dropShadow", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a2 = e2.top, s2 = e2.left, r2 = e2.blur, o2 = e2.color, n2 = e2.opacity, l2 = e2.noUserSpaceOnUse, h2 = this.w;
        return t3.unfilter(true), x.isIE() && "radialBar" === h2.config.chart.type || (o2 = Array.isArray(o2) ? o2[i2] : o2, t3.filter(function(t4) {
          var e3 = null;
          e3 = x.isSafari() || x.isFirefox() || x.isIE() ? t4.flood(o2, n2).composite(t4.sourceAlpha, "in").offset(s2, a2).gaussianBlur(r2) : t4.flood(o2, n2).composite(t4.sourceAlpha, "in").offset(s2, a2).gaussianBlur(r2).merge(t4.source), t4.blend(t4.source, e3);
        }), l2 || t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node)), t3;
      } }, { key: "setSelectionFilter", value: function(t3, e2, i2) {
        var a2 = this.w;
        if (void 0 !== a2.globals.selectedDataPoints[e2] && a2.globals.selectedDataPoints[e2].indexOf(i2) > -1) {
          t3.node.setAttribute("selected", true);
          var s2 = a2.config.states.active.filter;
          "none" !== s2 && this.applyFilter(t3, e2, s2.type, s2.value);
        }
      } }, { key: "_scaleFilterSize", value: function(t3) {
        !function(e2) {
          for (var i2 in e2)
            e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
        }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
      } }]), t2;
    }();
    var m = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "roundPathCorners", value: function(t3, e2) {
        function i2(t4, e3, i3) {
          var s3 = e3.x - t4.x, r3 = e3.y - t4.y, o3 = Math.sqrt(s3 * s3 + r3 * r3);
          return a2(t4, e3, Math.min(1, i3 / o3));
        }
        function a2(t4, e3, i3) {
          return { x: t4.x + (e3.x - t4.x) * i3, y: t4.y + (e3.y - t4.y) * i3 };
        }
        function s2(t4, e3) {
          t4.length > 2 && (t4[t4.length - 2] = e3.x, t4[t4.length - 1] = e3.y);
        }
        function r2(t4) {
          return { x: parseFloat(t4[t4.length - 2]), y: parseFloat(t4[t4.length - 1]) };
        }
        t3.indexOf("NaN") > -1 && (t3 = "");
        var o2 = t3.split(/[,\s]/).reduce(function(t4, e3) {
          var i3 = e3.match("([a-zA-Z])(.+)");
          return i3 ? (t4.push(i3[1]), t4.push(i3[2])) : t4.push(e3), t4;
        }, []).reduce(function(t4, e3) {
          return parseFloat(e3) == e3 && t4.length ? t4[t4.length - 1].push(e3) : t4.push([e3]), t4;
        }, []), n2 = [];
        if (o2.length > 1) {
          var l2 = r2(o2[0]), h2 = null;
          "Z" == o2[o2.length - 1][0] && o2[0].length > 2 && (h2 = ["L", l2.x, l2.y], o2[o2.length - 1] = h2), n2.push(o2[0]);
          for (var c2 = 1; c2 < o2.length; c2++) {
            var d2 = n2[n2.length - 1], g2 = o2[c2], u5 = g2 == h2 ? o2[1] : o2[c2 + 1];
            if (u5 && d2 && d2.length > 2 && "L" == g2[0] && u5.length > 2 && "L" == u5[0]) {
              var p2, f2, x2 = r2(d2), b2 = r2(g2), v2 = r2(u5);
              p2 = i2(b2, x2, e2), f2 = i2(b2, v2, e2), s2(g2, p2), g2.origPoint = b2, n2.push(g2);
              var m2 = a2(p2, b2, 0.5), y2 = a2(b2, f2, 0.5), w2 = ["C", m2.x, m2.y, y2.x, y2.y, f2.x, f2.y];
              w2.origPoint = b2, n2.push(w2);
            } else
              n2.push(g2);
          }
          if (h2) {
            var k2 = r2(n2[n2.length - 1]);
            n2.push(["Z"]), s2(n2[0], k2);
          }
        } else
          n2 = o2;
        return n2.reduce(function(t4, e3) {
          return t4 + e3.join(" ") + " ";
        }, "");
      } }, { key: "drawLine", value: function(t3, e2, i2, a2) {
        var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, n2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
        return this.w.globals.dom.Paper.line().attr({ x1: t3, y1: e2, x2: i2, y2: a2, stroke: s2, "stroke-dasharray": r2, "stroke-width": o2, "stroke-linecap": n2 });
      } }, { key: "drawRect", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", o2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, n2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h2 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c2 = this.w.globals.dom.Paper.rect();
        return c2.attr({ x: t3, y: e2, width: i2 > 0 ? i2 : 0, height: a2 > 0 ? a2 : 0, rx: s2, ry: s2, opacity: o2, "stroke-width": null !== n2 ? n2 : 0, stroke: null !== l2 ? l2 : "none", "stroke-dasharray": h2 }), c2.node.setAttribute("fill", r2), c2;
      } }, { key: "drawPolygon", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
        return this.w.globals.dom.Paper.polygon(t3).attr({ fill: a2, stroke: e2, "stroke-width": i2 });
      } }, { key: "drawCircle", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        t3 < 0 && (t3 = 0);
        var i2 = this.w.globals.dom.Paper.circle(2 * t3);
        return null !== e2 && i2.attr(e2), i2;
      } }, { key: "drawPath", value: function(t3) {
        var e2 = t3.d, i2 = void 0 === e2 ? "" : e2, a2 = t3.stroke, s2 = void 0 === a2 ? "#a8a8a8" : a2, r2 = t3.strokeWidth, o2 = void 0 === r2 ? 1 : r2, n2 = t3.fill, l2 = t3.fillOpacity, h2 = void 0 === l2 ? 1 : l2, c2 = t3.strokeOpacity, d2 = void 0 === c2 ? 1 : c2, g2 = t3.classes, u5 = t3.strokeLinecap, p2 = void 0 === u5 ? null : u5, f2 = t3.strokeDashArray, x2 = void 0 === f2 ? 0 : f2, b2 = this.w;
        return null === p2 && (p2 = b2.config.stroke.lineCap), (i2.indexOf("undefined") > -1 || i2.indexOf("NaN") > -1) && (i2 = "M 0 ".concat(b2.globals.gridHeight)), b2.globals.dom.Paper.path(i2).attr({ fill: n2, "fill-opacity": h2, stroke: s2, "stroke-opacity": d2, "stroke-linecap": p2, "stroke-width": o2, "stroke-dasharray": x2, class: g2 });
      } }, { key: "group", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w.globals.dom.Paper.group();
        return null !== t3 && e2.attr(t3), e2;
      } }, { key: "move", value: function(t3, e2) {
        var i2 = ["M", t3, e2].join(" ");
        return i2;
      } }, { key: "line", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = null;
        return null === i2 ? a2 = [" L", t3, e2].join(" ") : "H" === i2 ? a2 = [" H", t3].join(" ") : "V" === i2 && (a2 = [" V", e2].join(" ")), a2;
      } }, { key: "curve", value: function(t3, e2, i2, a2, s2, r2) {
        var o2 = ["C", t3, e2, i2, a2, s2, r2].join(" ");
        return o2;
      } }, { key: "quadraticCurve", value: function(t3, e2, i2, a2) {
        return ["Q", t3, e2, i2, a2].join(" ");
      } }, { key: "arc", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = "A";
        arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (n2 = "a");
        var l2 = [n2, t3, e2, i2, a2, s2, r2, o2].join(" ");
        return l2;
      } }, { key: "renderPaths", value: function(t3) {
        var i2, a2 = t3.j, s2 = t3.realIndex, r2 = t3.pathFrom, o2 = t3.pathTo, n2 = t3.stroke, l2 = t3.strokeWidth, h2 = t3.strokeLinecap, c2 = t3.fill, d2 = t3.animationDelay, g2 = t3.initialSpeed, u5 = t3.dataChangeSpeed, p2 = t3.className, f2 = t3.shouldClipToGrid, x2 = void 0 === f2 || f2, m2 = t3.bindEventsOnPaths, y2 = void 0 === m2 || m2, w2 = t3.drawShadow, k2 = void 0 === w2 || w2, A2 = this.w, S2 = new v(this.ctx), C2 = new b(this.ctx), L2 = this.w.config.chart.animations.enabled, P2 = L2 && this.w.config.chart.animations.dynamicAnimation.enabled, I2 = !!(L2 && !A2.globals.resized || P2 && A2.globals.dataChanged && A2.globals.shouldAnimate);
        I2 ? i2 = r2 : (i2 = o2, A2.globals.animationEnded = true);
        var T2 = A2.config.stroke.dashArray, M2 = 0;
        M2 = Array.isArray(T2) ? T2[s2] : A2.config.stroke.dashArray;
        var z2 = this.drawPath({ d: i2, stroke: n2, strokeWidth: l2, fill: c2, fillOpacity: 1, classes: p2, strokeLinecap: h2, strokeDashArray: M2 });
        if (z2.attr("index", s2), x2 && z2.attr({ "clip-path": "url(#gridRectMask".concat(A2.globals.cuid, ")") }), "none" !== A2.config.states.normal.filter.type)
          S2.getDefaultFilter(z2, s2);
        else if (A2.config.chart.dropShadow.enabled && k2 && (!A2.config.chart.dropShadow.enabledOnSeries || A2.config.chart.dropShadow.enabledOnSeries && -1 !== A2.config.chart.dropShadow.enabledOnSeries.indexOf(s2))) {
          var X2 = A2.config.chart.dropShadow;
          S2.dropShadow(z2, X2, s2);
        }
        y2 && (z2.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z2)), z2.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z2)), z2.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z2))), z2.attr({ pathTo: o2, pathFrom: r2 });
        var E2 = { el: z2, j: a2, realIndex: s2, pathFrom: r2, pathTo: o2, fill: c2, strokeWidth: l2, delay: d2 };
        return !L2 || A2.globals.resized || A2.globals.dataChanged ? !A2.globals.resized && A2.globals.dataChanged || C2.showDelayedElements() : C2.animatePathsGradually(e(e({}, E2), {}, { speed: g2 })), A2.globals.dataChanged && P2 && I2 && C2.animatePathsGradually(e(e({}, E2), {}, { speed: u5 })), z2;
      } }, { key: "drawPattern", value: function(t3, e2, i2) {
        var a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
        return this.w.globals.dom.Paper.pattern(e2, i2, function(r2) {
          "horizontalLines" === t3 ? r2.line(0, 0, i2, 0).stroke({ color: a2, width: s2 + 1 }) : "verticalLines" === t3 ? r2.line(0, 0, 0, e2).stroke({ color: a2, width: s2 + 1 }) : "slantedLines" === t3 ? r2.line(0, 0, e2, i2).stroke({ color: a2, width: s2 }) : "squares" === t3 ? r2.rect(e2, i2).fill("none").stroke({ color: a2, width: s2 }) : "circles" === t3 && r2.circle(e2).fill("none").stroke({ color: a2, width: s2 });
        });
      } }, { key: "drawGradient", value: function(t3, e2, i2, a2, s2) {
        var r2, o2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, n2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, h2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c2 = this.w;
        e2.length < 9 && 0 === e2.indexOf("#") && (e2 = x.hexToRgba(e2, a2)), i2.length < 9 && 0 === i2.indexOf("#") && (i2 = x.hexToRgba(i2, s2));
        var d2 = 0, g2 = 1, u5 = 1, p2 = null;
        null !== n2 && (d2 = void 0 !== n2[0] ? n2[0] / 100 : 0, g2 = void 0 !== n2[1] ? n2[1] / 100 : 1, u5 = void 0 !== n2[2] ? n2[2] / 100 : 1, p2 = void 0 !== n2[3] ? n2[3] / 100 : null);
        var f2 = !("donut" !== c2.config.chart.type && "pie" !== c2.config.chart.type && "polarArea" !== c2.config.chart.type && "bubble" !== c2.config.chart.type);
        if (r2 = null === l2 || 0 === l2.length ? c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
          t4.at(d2, e2, a2), t4.at(g2, i2, s2), t4.at(u5, i2, s2), null !== p2 && t4.at(p2, e2, a2);
        }) : c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
          (Array.isArray(l2[h2]) ? l2[h2] : l2).forEach(function(e3) {
            t4.at(e3.offset / 100, e3.color, e3.opacity);
          });
        }), f2) {
          var b2 = c2.globals.gridWidth / 2, v2 = c2.globals.gridHeight / 2;
          "bubble" !== c2.config.chart.type ? r2.attr({ gradientUnits: "userSpaceOnUse", cx: b2, cy: v2, r: o2 }) : r2.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
        } else
          "vertical" === t3 ? r2.from(0, 0).to(0, 1) : "diagonal" === t3 ? r2.from(0, 0).to(1, 1) : "horizontal" === t3 ? r2.from(0, 1).to(1, 1) : "diagonal2" === t3 && r2.from(1, 0).to(0, 1);
        return r2;
      } }, { key: "getTextBasedOnMaxWidth", value: function(t3) {
        var e2 = t3.text, i2 = t3.maxWidth, a2 = t3.fontSize, s2 = t3.fontFamily, r2 = this.getTextRects(e2, a2, s2), o2 = r2.width / e2.length, n2 = Math.floor(i2 / o2);
        return i2 < r2.width ? e2.slice(0, n2 - 3) + "..." : e2;
      } }, { key: "drawText", value: function(t3) {
        var i2 = this, a2 = t3.x, s2 = t3.y, r2 = t3.text, o2 = t3.textAnchor, n2 = t3.fontSize, l2 = t3.fontFamily, h2 = t3.fontWeight, c2 = t3.foreColor, d2 = t3.opacity, g2 = t3.maxWidth, u5 = t3.cssClass, p2 = void 0 === u5 ? "" : u5, f2 = t3.isPlainText, x2 = void 0 === f2 || f2, b2 = t3.dominantBaseline, v2 = void 0 === b2 ? "auto" : b2, m2 = this.w;
        void 0 === r2 && (r2 = "");
        var y2 = r2;
        o2 || (o2 = "start"), c2 && c2.length || (c2 = m2.config.chart.foreColor), l2 = l2 || m2.config.chart.fontFamily, h2 = h2 || "regular";
        var w2, k2 = { maxWidth: g2, fontSize: n2 = n2 || "11px", fontFamily: l2 };
        return Array.isArray(r2) ? w2 = m2.globals.dom.Paper.text(function(t4) {
          for (var a3 = 0; a3 < r2.length; a3++)
            y2 = r2[a3], g2 && (y2 = i2.getTextBasedOnMaxWidth(e({ text: r2[a3] }, k2))), 0 === a3 ? t4.tspan(y2) : t4.tspan(y2).newLine();
        }) : (g2 && (y2 = this.getTextBasedOnMaxWidth(e({ text: r2 }, k2))), w2 = x2 ? m2.globals.dom.Paper.plain(r2) : m2.globals.dom.Paper.text(function(t4) {
          return t4.tspan(y2);
        })), w2.attr({ x: a2, y: s2, "text-anchor": o2, "dominant-baseline": v2, "font-size": n2, "font-family": l2, "font-weight": h2, fill: c2, class: "apexcharts-text " + p2 }), w2.node.style.fontFamily = l2, w2.node.style.opacity = d2, w2;
      } }, { key: "drawMarker", value: function(t3, e2, i2) {
        t3 = t3 || 0;
        var a2 = i2.pSize || 0, s2 = null;
        if ("square" === i2.shape || "rect" === i2.shape) {
          var r2 = void 0 === i2.pRadius ? a2 / 2 : i2.pRadius;
          null !== e2 && a2 || (a2 = 0, r2 = 0);
          var o2 = 1.2 * a2 + r2, n2 = this.drawRect(o2, o2, o2, o2, r2);
          n2.attr({ x: t3 - o2 / 2, y: e2 - o2 / 2, cx: t3, cy: e2, class: i2.class ? i2.class : "", fill: i2.pointFillColor, "fill-opacity": i2.pointFillOpacity ? i2.pointFillOpacity : 1, stroke: i2.pointStrokeColor, "stroke-width": i2.pointStrokeWidth ? i2.pointStrokeWidth : 0, "stroke-opacity": i2.pointStrokeOpacity ? i2.pointStrokeOpacity : 1 }), s2 = n2;
        } else
          "circle" !== i2.shape && i2.shape || (x.isNumber(e2) || (a2 = 0, e2 = 0), s2 = this.drawCircle(a2, { cx: t3, cy: e2, class: i2.class ? i2.class : "", stroke: i2.pointStrokeColor, fill: i2.pointFillColor, "fill-opacity": i2.pointFillOpacity ? i2.pointFillOpacity : 1, "stroke-width": i2.pointStrokeWidth ? i2.pointStrokeWidth : 0, "stroke-opacity": i2.pointStrokeOpacity ? i2.pointStrokeOpacity : 1 }));
        return s2;
      } }, { key: "pathMouseEnter", value: function(t3, e2) {
        var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
        if ("function" == typeof i2.config.chart.events.dataPointMouseEnter && i2.config.chart.events.dataPointMouseEnter(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseEnter", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), ("none" === i2.config.states.active.filter.type || "true" !== t3.node.getAttribute("selected")) && "none" !== i2.config.states.hover.filter.type && !i2.globals.isTouchDevice) {
          var o2 = i2.config.states.hover.filter;
          a2.applyFilter(t3, s2, o2.type, o2.value);
        }
      } }, { key: "pathMouseLeave", value: function(t3, e2) {
        var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
        "function" == typeof i2.config.chart.events.dataPointMouseLeave && i2.config.chart.events.dataPointMouseLeave(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseLeave", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), "none" !== i2.config.states.active.filter.type && "true" === t3.node.getAttribute("selected") || "none" !== i2.config.states.hover.filter.type && a2.getDefaultFilter(t3, s2);
      } }, { key: "pathMouseDown", value: function(t3, e2) {
        var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10), o2 = "false";
        if ("true" === t3.node.getAttribute("selected")) {
          if (t3.node.setAttribute("selected", "false"), i2.globals.selectedDataPoints[s2].indexOf(r2) > -1) {
            var n2 = i2.globals.selectedDataPoints[s2].indexOf(r2);
            i2.globals.selectedDataPoints[s2].splice(n2, 1);
          }
        } else {
          if (!i2.config.states.active.allowMultipleDataPointsSelection && i2.globals.selectedDataPoints.length > 0) {
            i2.globals.selectedDataPoints = [];
            var l2 = i2.globals.dom.Paper.select(".apexcharts-series path").members, h2 = i2.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, c2 = function(t4) {
              Array.prototype.forEach.call(t4, function(t5) {
                t5.node.setAttribute("selected", "false"), a2.getDefaultFilter(t5, s2);
              });
            };
            c2(l2), c2(h2);
          }
          t3.node.setAttribute("selected", "true"), o2 = "true", void 0 === i2.globals.selectedDataPoints[s2] && (i2.globals.selectedDataPoints[s2] = []), i2.globals.selectedDataPoints[s2].push(r2);
        }
        if ("true" === o2) {
          var d2 = i2.config.states.active.filter;
          if ("none" !== d2)
            a2.applyFilter(t3, s2, d2.type, d2.value);
          else if ("none" !== i2.config.states.hover.filter && !i2.globals.isTouchDevice) {
            var g2 = i2.config.states.hover.filter;
            a2.applyFilter(t3, s2, g2.type, g2.value);
          }
        } else if ("none" !== i2.config.states.active.filter.type)
          if ("none" === i2.config.states.hover.filter.type || i2.globals.isTouchDevice)
            a2.getDefaultFilter(t3, s2);
          else {
            g2 = i2.config.states.hover.filter;
            a2.applyFilter(t3, s2, g2.type, g2.value);
          }
        "function" == typeof i2.config.chart.events.dataPointSelection && i2.config.chart.events.dataPointSelection(e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }), e2 && this.ctx.events.fireEvent("dataPointSelection", [e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }]);
      } }, { key: "rotateAroundCenter", value: function(t3) {
        var e2 = {};
        return t3 && "function" == typeof t3.getBBox && (e2 = t3.getBBox()), { x: e2.x + e2.width / 2, y: e2.y + e2.height / 2 };
      } }, { key: "getTextRects", value: function(t3, e2, i2, a2) {
        var s2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r2 = this.w, o2 = this.drawText({ x: -200, y: -200, text: t3, textAnchor: "start", fontSize: e2, fontFamily: i2, foreColor: "#fff", opacity: 0 });
        a2 && o2.attr("transform", a2), r2.globals.dom.Paper.add(o2);
        var n2 = o2.bbox();
        return s2 || (n2 = o2.node.getBoundingClientRect()), o2.remove(), { width: n2.width, height: n2.height };
      } }, { key: "placeTextWithEllipsis", value: function(t3, e2, i2) {
        if ("function" == typeof t3.getComputedTextLength && (t3.textContent = e2, e2.length > 0 && t3.getComputedTextLength() >= i2 / 1.1)) {
          for (var a2 = e2.length - 3; a2 > 0; a2 -= 3)
            if (t3.getSubStringLength(0, a2) <= i2 / 1.1)
              return void (t3.textContent = e2.substring(0, a2) + "...");
          t3.textContent = ".";
        }
      } }], [{ key: "setAttrs", value: function(t3, e2) {
        for (var i2 in e2)
          e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
      } }]), t2;
    }();
    var y = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "getStackedSeriesTotals", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = this.w, i2 = [];
        if (0 === e2.globals.series.length)
          return i2;
        for (var a2 = 0; a2 < e2.globals.series[e2.globals.maxValsInArrayIndex].length; a2++) {
          for (var s2 = 0, r2 = 0; r2 < e2.globals.series.length; r2++)
            void 0 !== e2.globals.series[r2][a2] && -1 === t3.indexOf(r2) && (s2 += e2.globals.series[r2][a2]);
          i2.push(s2);
        }
        return i2;
      } }, { key: "getSeriesTotalByIndex", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return null === t3 ? this.w.config.series.reduce(function(t4, e2) {
          return t4 + e2;
        }, 0) : this.w.globals.series[t3].reduce(function(t4, e2) {
          return t4 + e2;
        }, 0);
      } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
        var t3 = this, e2 = this.w, i2 = [];
        return e2.globals.seriesGroups.forEach(function(a2) {
          var s2 = [];
          e2.config.series.forEach(function(t4, e3) {
            a2.indexOf(t4.name) > -1 && s2.push(e3);
          });
          var r2 = e2.globals.series.map(function(t4, e3) {
            return -1 === s2.indexOf(e3) ? e3 : -1;
          }).filter(function(t4) {
            return -1 !== t4;
          });
          i2.push(t3.getStackedSeriesTotals(r2));
        }), i2;
      } }, { key: "isSeriesNull", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return 0 === (null === t3 ? this.w.config.series.filter(function(t4) {
          return null !== t4;
        }) : this.w.config.series[t3].data.filter(function(t4) {
          return null !== t4;
        })).length;
      } }, { key: "seriesHaveSameValues", value: function(t3) {
        return this.w.globals.series[t3].every(function(t4, e2, i2) {
          return t4 === i2[0];
        });
      } }, { key: "getCategoryLabels", value: function(t3) {
        var e2 = this.w, i2 = t3.slice();
        return e2.config.xaxis.convertedCatToNumeric && (i2 = t3.map(function(t4, i3) {
          return e2.config.xaxis.labels.formatter(t4 - e2.globals.minX + 1);
        })), i2;
      } }, { key: "getLargestSeries", value: function() {
        var t3 = this.w;
        t3.globals.maxValsInArrayIndex = t3.globals.series.map(function(t4) {
          return t4.length;
        }).indexOf(Math.max.apply(Math, t3.globals.series.map(function(t4) {
          return t4.length;
        })));
      } }, { key: "getLargestMarkerSize", value: function() {
        var t3 = this.w, e2 = 0;
        return t3.globals.markers.size.forEach(function(t4) {
          e2 = Math.max(e2, t4);
        }), t3.config.markers.discrete && t3.config.markers.discrete.length && t3.config.markers.discrete.forEach(function(t4) {
          e2 = Math.max(e2, t4.size);
        }), e2 > 0 && (e2 += t3.config.markers.hover.sizeOffset + 1), t3.globals.markers.largestSize = e2, e2;
      } }, { key: "getSeriesTotals", value: function() {
        var t3 = this.w;
        t3.globals.seriesTotals = t3.globals.series.map(function(t4, e2) {
          var i2 = 0;
          if (Array.isArray(t4))
            for (var a2 = 0; a2 < t4.length; a2++)
              i2 += t4[a2];
          else
            i2 += t4;
          return i2;
        });
      } }, { key: "getSeriesTotalsXRange", value: function(t3, e2) {
        var i2 = this.w;
        return i2.globals.series.map(function(a2, s2) {
          for (var r2 = 0, o2 = 0; o2 < a2.length; o2++)
            i2.globals.seriesX[s2][o2] > t3 && i2.globals.seriesX[s2][o2] < e2 && (r2 += a2[o2]);
          return r2;
        });
      } }, { key: "getPercentSeries", value: function() {
        var t3 = this.w;
        t3.globals.seriesPercent = t3.globals.series.map(function(e2, i2) {
          var a2 = [];
          if (Array.isArray(e2))
            for (var s2 = 0; s2 < e2.length; s2++) {
              var r2 = t3.globals.stackedSeriesTotals[s2], o2 = 0;
              r2 && (o2 = 100 * e2[s2] / r2), a2.push(o2);
            }
          else {
            var n2 = 100 * e2 / t3.globals.seriesTotals.reduce(function(t4, e3) {
              return t4 + e3;
            }, 0);
            a2.push(n2);
          }
          return a2;
        });
      } }, { key: "getCalculatedRatios", value: function() {
        var t3, e2, i2, a2, s2 = this.w.globals, r2 = [], o2 = 0, n2 = [], l2 = 0.1, h2 = 0;
        if (s2.yRange = [], s2.isMultipleYAxis)
          for (var c2 = 0; c2 < s2.minYArr.length; c2++)
            s2.yRange.push(Math.abs(s2.minYArr[c2] - s2.maxYArr[c2])), n2.push(0);
        else
          s2.yRange.push(Math.abs(s2.minY - s2.maxY));
        s2.xRange = Math.abs(s2.maxX - s2.minX), s2.zRange = Math.abs(s2.maxZ - s2.minZ);
        for (var d2 = 0; d2 < s2.yRange.length; d2++)
          r2.push(s2.yRange[d2] / s2.gridHeight);
        if (e2 = s2.xRange / s2.gridWidth, i2 = Math.abs(s2.initialMaxX - s2.initialMinX) / s2.gridWidth, t3 = s2.yRange / s2.gridWidth, a2 = s2.xRange / s2.gridHeight, (o2 = s2.zRange / s2.gridHeight * 16) || (o2 = 1), s2.minY !== Number.MIN_VALUE && 0 !== Math.abs(s2.minY) && (s2.hasNegs = true), s2.isMultipleYAxis) {
          n2 = [];
          for (var g2 = 0; g2 < r2.length; g2++)
            n2.push(-s2.minYArr[g2] / r2[g2]);
        } else
          n2.push(-s2.minY / r2[0]), s2.minY !== Number.MIN_VALUE && 0 !== Math.abs(s2.minY) && (l2 = -s2.minY / t3, h2 = s2.minX / e2);
        return { yRatio: r2, invertedYRatio: t3, zRatio: o2, xRatio: e2, initialXRatio: i2, invertedXRatio: a2, baseLineInvertedY: l2, baseLineY: n2, baseLineX: h2 };
      } }, { key: "getLogSeries", value: function(t3) {
        var e2 = this, i2 = this.w;
        return i2.globals.seriesLog = t3.map(function(t4, a2) {
          return i2.config.yaxis[a2] && i2.config.yaxis[a2].logarithmic ? t4.map(function(t5) {
            return null === t5 ? null : e2.getLogVal(i2.config.yaxis[a2].logBase, t5, a2);
          }) : t4;
        }), i2.globals.invalidLogScale ? t3 : i2.globals.seriesLog;
      } }, { key: "getBaseLog", value: function(t3, e2) {
        return Math.log(e2) / Math.log(t3);
      } }, { key: "getLogVal", value: function(t3, e2, i2) {
        if (0 === e2)
          return 0;
        var a2 = this.w, s2 = 0 === a2.globals.minYArr[i2] ? -1 : this.getBaseLog(t3, a2.globals.minYArr[i2]), r2 = (0 === a2.globals.maxYArr[i2] ? 0 : this.getBaseLog(t3, a2.globals.maxYArr[i2])) - s2;
        return e2 < 1 ? e2 / r2 : (this.getBaseLog(t3, e2) - s2) / r2;
      } }, { key: "getLogYRatios", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = this.w.globals;
        return a2.yLogRatio = t3.slice(), a2.logYRange = a2.yRange.map(function(t4, s2) {
          if (i2.config.yaxis[s2] && e2.w.config.yaxis[s2].logarithmic) {
            var r2, o2 = -Number.MAX_VALUE, n2 = Number.MIN_VALUE;
            return a2.seriesLog.forEach(function(t5, e3) {
              t5.forEach(function(t6) {
                i2.config.yaxis[e3] && i2.config.yaxis[e3].logarithmic && (o2 = Math.max(t6, o2), n2 = Math.min(t6, n2));
              });
            }), r2 = Math.pow(a2.yRange[s2], Math.abs(n2 - o2) / a2.yRange[s2]), a2.yLogRatio[s2] = r2 / a2.gridHeight, r2;
          }
        }), a2.invalidLogScale ? t3.slice() : a2.yLogRatio;
      } }], [{ key: "checkComboSeries", value: function(t3) {
        var e2 = false, i2 = 0, a2 = 0;
        return t3.length && void 0 !== t3[0].type && t3.forEach(function(t4) {
          "bar" !== t4.type && "column" !== t4.type && "candlestick" !== t4.type && "boxPlot" !== t4.type || i2++, void 0 !== t4.type && a2++;
        }), a2 > 0 && (e2 = true), { comboBarCount: i2, comboCharts: e2 };
      } }, { key: "extendArrayProps", value: function(t3, e2, i2) {
        return e2.yaxis && (e2 = t3.extendYAxis(e2, i2)), e2.annotations && (e2.annotations.yaxis && (e2 = t3.extendYAxisAnnotations(e2)), e2.annotations.xaxis && (e2 = t3.extendXAxisAnnotations(e2)), e2.annotations.points && (e2 = t3.extendPointAnnotations(e2))), e2;
      } }]), t2;
    }();
    var w = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.annoCtx = e2;
      }
      return r(t2, [{ key: "setOrientations", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i2 = this.w;
        if ("vertical" === t3.label.orientation) {
          var a2 = null !== e2 ? e2 : 0, s2 = i2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a2, "']"));
          if (null !== s2) {
            var r2 = s2.getBoundingClientRect();
            s2.setAttribute("x", parseFloat(s2.getAttribute("x")) - r2.height + 4), "top" === t3.label.position ? s2.setAttribute("y", parseFloat(s2.getAttribute("y")) + r2.width) : s2.setAttribute("y", parseFloat(s2.getAttribute("y")) - r2.width);
            var o2 = this.annoCtx.graphics.rotateAroundCenter(s2), n2 = o2.x, l2 = o2.y;
            s2.setAttribute("transform", "rotate(-90 ".concat(n2, " ").concat(l2, ")"));
          }
        }
      } }, { key: "addBackgroundToAnno", value: function(t3, e2) {
        var i2 = this.w;
        if (!t3 || void 0 === e2.label.text || void 0 !== e2.label.text && !String(e2.label.text).trim())
          return null;
        var a2 = i2.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s2 = t3.getBoundingClientRect(), r2 = e2.label.style.padding.left, o2 = e2.label.style.padding.right, n2 = e2.label.style.padding.top, l2 = e2.label.style.padding.bottom;
        "vertical" === e2.label.orientation && (n2 = e2.label.style.padding.left, l2 = e2.label.style.padding.right, r2 = e2.label.style.padding.top, o2 = e2.label.style.padding.bottom);
        var h2 = s2.left - a2.left - r2, c2 = s2.top - a2.top - n2, d2 = this.annoCtx.graphics.drawRect(h2 - i2.globals.barPadForNumericAxis, c2, s2.width + r2 + o2, s2.height + n2 + l2, e2.label.borderRadius, e2.label.style.background, 1, e2.label.borderWidth, e2.label.borderColor, 0);
        return e2.id && d2.node.classList.add(e2.id), d2;
      } }, { key: "annotationsBackground", value: function() {
        var t3 = this, e2 = this.w, i2 = function(i3, a2, s2) {
          var r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(a2, "']"));
          if (r2) {
            var o2 = r2.parentNode, n2 = t3.addBackgroundToAnno(r2, i3);
            n2 && (o2.insertBefore(n2.node, r2), i3.label.mouseEnter && n2.node.addEventListener("mouseenter", i3.label.mouseEnter.bind(t3, i3)), i3.label.mouseLeave && n2.node.addEventListener("mouseleave", i3.label.mouseLeave.bind(t3, i3)), i3.label.click && n2.node.addEventListener("click", i3.label.click.bind(t3, i3)));
          }
        };
        e2.config.annotations.xaxis.map(function(t4, e3) {
          i2(t4, e3, "xaxis");
        }), e2.config.annotations.yaxis.map(function(t4, e3) {
          i2(t4, e3, "yaxis");
        }), e2.config.annotations.points.map(function(t4, e3) {
          i2(t4, e3, "point");
        });
      } }, { key: "getY1Y2", value: function(t3, e2) {
        var i2, a2 = "y1" === t3 ? e2.y : e2.y2, s2 = this.w;
        if (this.annoCtx.invertAxis) {
          var r2 = s2.globals.labels.indexOf(a2);
          s2.config.xaxis.convertedCatToNumeric && (r2 = s2.globals.categoryLabels.indexOf(a2));
          var o2 = s2.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r2 + 1) + ")");
          o2 && (i2 = parseFloat(o2.getAttribute("y"))), void 0 !== e2.seriesIndex && s2.globals.barHeight && (i2 = i2 - s2.globals.barHeight / 2 * (s2.globals.series.length - 1) + s2.globals.barHeight * e2.seriesIndex);
        } else {
          var n2;
          if (s2.config.yaxis[e2.yAxisIndex].logarithmic)
            n2 = (a2 = new y(this.annoCtx.ctx).getLogVal(a2, e2.yAxisIndex)) / s2.globals.yLogRatio[e2.yAxisIndex];
          else
            n2 = (a2 - s2.globals.minYArr[e2.yAxisIndex]) / (s2.globals.yRange[e2.yAxisIndex] / s2.globals.gridHeight);
          i2 = s2.globals.gridHeight - n2, !e2.marker || void 0 !== e2.y && null !== e2.y || (i2 = 0), s2.config.yaxis[e2.yAxisIndex] && s2.config.yaxis[e2.yAxisIndex].reversed && (i2 = n2);
        }
        return "string" == typeof a2 && a2.indexOf("px") > -1 && (i2 = parseFloat(a2)), i2;
      } }, { key: "getX1X2", value: function(t3, e2) {
        var i2 = this.w, a2 = this.annoCtx.invertAxis ? i2.globals.minY : i2.globals.minX, s2 = this.annoCtx.invertAxis ? i2.globals.maxY : i2.globals.maxX, r2 = this.annoCtx.invertAxis ? i2.globals.yRange[0] : i2.globals.xRange, o2 = (e2.x - a2) / (r2 / i2.globals.gridWidth);
        this.annoCtx.inversedReversedAxis && (o2 = (s2 - e2.x) / (r2 / i2.globals.gridWidth)), "category" !== i2.config.xaxis.type && !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || (o2 = this.getStringX(e2.x));
        var n2 = (e2.x2 - a2) / (r2 / i2.globals.gridWidth);
        return this.annoCtx.inversedReversedAxis && (n2 = (s2 - e2.x2) / (r2 / i2.globals.gridWidth)), "category" !== i2.config.xaxis.type && !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || (n2 = this.getStringX(e2.x2)), void 0 !== e2.x && null !== e2.x || !e2.marker || (o2 = i2.globals.gridWidth), "x1" === t3 && "string" == typeof e2.x && e2.x.indexOf("px") > -1 && (o2 = parseFloat(e2.x)), "x2" === t3 && "string" == typeof e2.x2 && e2.x2.indexOf("px") > -1 && (n2 = parseFloat(e2.x2)), void 0 !== e2.seriesIndex && i2.globals.barWidth && !this.annoCtx.invertAxis && (o2 = o2 - i2.globals.barWidth / 2 * (i2.globals.series.length - 1) + i2.globals.barWidth * e2.seriesIndex), "x1" === t3 ? o2 : n2;
      } }, { key: "getStringX", value: function(t3) {
        var e2 = this.w, i2 = t3;
        e2.config.xaxis.convertedCatToNumeric && e2.globals.categoryLabels.length && (t3 = e2.globals.categoryLabels.indexOf(t3) + 1);
        var a2 = e2.globals.labels.indexOf(t3), s2 = e2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a2 + 1) + ")");
        return s2 && (i2 = parseFloat(s2.getAttribute("x"))), i2;
      } }]), t2;
    }();
    var k = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.annoCtx = e2, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new w(this.annoCtx);
      }
      return r(t2, [{ key: "addXaxisAnnotation", value: function(t3, e2, i2) {
        var a2, s2 = this.w, r2 = this.helpers.getX1X2("x1", t3), o2 = t3.label.text, n2 = t3.strokeDashArray;
        if (x.isNumber(r2)) {
          if (null === t3.x2 || void 0 === t3.x2) {
            var l2 = this.annoCtx.graphics.drawLine(r2 + t3.offsetX, 0 + t3.offsetY, r2 + t3.offsetX, s2.globals.gridHeight + t3.offsetY, t3.borderColor, n2, t3.borderWidth);
            e2.appendChild(l2.node), t3.id && l2.node.classList.add(t3.id);
          } else {
            if ((a2 = this.helpers.getX1X2("x2", t3)) < r2) {
              var h2 = r2;
              r2 = a2, a2 = h2;
            }
            var c2 = this.annoCtx.graphics.drawRect(r2 + t3.offsetX, 0 + t3.offsetY, a2 - r2, s2.globals.gridHeight + t3.offsetY, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, n2);
            c2.node.classList.add("apexcharts-annotation-rect"), c2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(c2.node), t3.id && c2.node.classList.add(t3.id);
          }
          var d2 = this.annoCtx.graphics.getTextRects(o2, parseFloat(t3.label.style.fontSize)), g2 = "top" === t3.label.position ? 4 : "center" === t3.label.position ? s2.globals.gridHeight / 2 + ("vertical" === t3.label.orientation ? d2.width / 2 : 0) : s2.globals.gridHeight, u5 = this.annoCtx.graphics.drawText({ x: r2 + t3.label.offsetX, y: g2 + t3.label.offsetY - ("vertical" === t3.label.orientation ? "top" === t3.label.position ? d2.width / 2 - 12 : -d2.width / 2 : 0), text: o2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
          u5.attr({ rel: i2 }), e2.appendChild(u5.node), this.annoCtx.helpers.setOrientations(t3, i2);
        }
      } }, { key: "drawXAxisAnnotations", value: function() {
        var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
        return e2.config.annotations.xaxis.map(function(e3, a2) {
          t3.addXaxisAnnotation(e3, i2.node, a2);
        }), i2;
      } }]), t2;
    }();
    var A = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new w(this.annoCtx);
      }
      return r(t2, [{ key: "addYaxisAnnotation", value: function(t3, e2, i2) {
        var a2, s2 = this.w, r2 = t3.strokeDashArray, o2 = this.helpers.getY1Y2("y1", t3), n2 = t3.label.text;
        if (null === t3.y2 || void 0 === t3.y2) {
          var l2 = this.annoCtx.graphics.drawLine(0 + t3.offsetX, o2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 + t3.offsetY, t3.borderColor, r2, t3.borderWidth);
          e2.appendChild(l2.node), t3.id && l2.node.classList.add(t3.id);
        } else {
          if ((a2 = this.helpers.getY1Y2("y2", t3)) > o2) {
            var h2 = o2;
            o2 = a2, a2 = h2;
          }
          var c2 = this.annoCtx.graphics.drawRect(0 + t3.offsetX, a2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 - a2, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, r2);
          c2.node.classList.add("apexcharts-annotation-rect"), c2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(c2.node), t3.id && c2.node.classList.add(t3.id);
        }
        var d2 = "right" === t3.label.position ? s2.globals.gridWidth : "center" === t3.label.position ? s2.globals.gridWidth / 2 : 0, g2 = this.annoCtx.graphics.drawText({ x: d2 + t3.label.offsetX, y: (null != a2 ? a2 : o2) + t3.label.offsetY - 3, text: n2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        g2.attr({ rel: i2 }), e2.appendChild(g2.node);
      } }, { key: "_getYAxisAnnotationWidth", value: function(t3) {
        var e2 = this.w;
        e2.globals.gridWidth;
        return (t3.width.indexOf("%") > -1 ? e2.globals.gridWidth * parseInt(t3.width, 10) / 100 : parseInt(t3.width, 10)) + t3.offsetX;
      } }, { key: "drawYAxisAnnotations", value: function() {
        var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
        return e2.config.annotations.yaxis.map(function(e3, a2) {
          t3.addYaxisAnnotation(e3, i2.node, a2);
        }), i2;
      } }]), t2;
    }();
    var S = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new w(this.annoCtx);
      }
      return r(t2, [{ key: "addPointAnnotation", value: function(t3, e2, i2) {
        this.w;
        var a2 = this.helpers.getX1X2("x1", t3), s2 = this.helpers.getY1Y2("y1", t3);
        if (x.isNumber(a2)) {
          var r2 = { pSize: t3.marker.size, pointStrokeWidth: t3.marker.strokeWidth, pointFillColor: t3.marker.fillColor, pointStrokeColor: t3.marker.strokeColor, shape: t3.marker.shape, pRadius: t3.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t3.marker.cssClass, " ").concat(t3.id ? t3.id : "") }, o2 = this.annoCtx.graphics.drawMarker(a2 + t3.marker.offsetX, s2 + t3.marker.offsetY, r2);
          e2.appendChild(o2.node);
          var n2 = t3.label.text ? t3.label.text : "", l2 = this.annoCtx.graphics.drawText({ x: a2 + t3.label.offsetX, y: s2 + t3.label.offsetY - t3.marker.size - parseFloat(t3.label.style.fontSize) / 1.6, text: n2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
          if (l2.attr({ rel: i2 }), e2.appendChild(l2.node), t3.customSVG.SVG) {
            var h2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t3.customSVG.cssClass });
            h2.attr({ transform: "translate(".concat(a2 + t3.customSVG.offsetX, ", ").concat(s2 + t3.customSVG.offsetY, ")") }), h2.node.innerHTML = t3.customSVG.SVG, e2.appendChild(h2.node);
          }
          if (t3.image.path) {
            var c2 = t3.image.width ? t3.image.width : 20, d2 = t3.image.height ? t3.image.height : 20;
            o2 = this.annoCtx.addImage({ x: a2 + t3.image.offsetX - c2 / 2, y: s2 + t3.image.offsetY - d2 / 2, width: c2, height: d2, path: t3.image.path, appendTo: ".apexcharts-point-annotations" });
          }
          t3.mouseEnter && o2.node.addEventListener("mouseenter", t3.mouseEnter.bind(this, t3)), t3.mouseLeave && o2.node.addEventListener("mouseleave", t3.mouseLeave.bind(this, t3)), t3.click && o2.node.addEventListener("click", t3.click.bind(this, t3));
        }
      } }, { key: "drawPointAnnotations", value: function() {
        var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
        return e2.config.annotations.points.map(function(e3, a2) {
          t3.addPointAnnotation(e3, i2.node, a2);
        }), i2;
      } }]), t2;
    }();
    var C = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } };
    var L = function() {
      function t2() {
        a(this, t2), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
      }
      return r(t2, [{ key: "init", value: function() {
        return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "transparent", locales: [C], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackOnlyBar: true, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", dateFormatter: function(t3) {
          return new Date(t3).toDateString();
        } }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t3) {
          return t3;
        } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t3) {
          return t3 + "%";
        } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t3) {
          return t3.globals.seriesTotals.reduce(function(t4, e2) {
            return t4 + e2;
          }, 0) / t3.globals.series.length + "%";
        } } }, barLabels: { enabled: false, margin: 5, useSeriesColors: true, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(t3) {
          return t3;
        }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t3) {
          return t3;
        } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t3) {
          return t3;
        } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t3) {
          return t3.globals.seriesTotals.reduce(function(t4, e2) {
            return t4 + e2;
          }, 0);
        } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t3) {
          return null !== t3 ? t3 : "";
        }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: false }, markers: { width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 2 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", width: 8, height: 8, radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: true, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, hideEmptySeries: true, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t3) {
          return t3 ? t3 + ": " : "";
        } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
      } }]), t2;
    }();
    var P = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.graphics = new m(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new w(this), this.xAxisAnnotations = new k(this), this.yAxisAnnotations = new A(this), this.pointsAnnotations = new S(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
      }
      return r(t2, [{ key: "drawAxesAnnotations", value: function() {
        var t3 = this.w;
        if (t3.globals.axisCharts) {
          for (var e2 = this.yAxisAnnotations.drawYAxisAnnotations(), i2 = this.xAxisAnnotations.drawXAxisAnnotations(), a2 = this.pointsAnnotations.drawPointAnnotations(), s2 = t3.config.chart.animations.enabled, r2 = [e2, i2, a2], o2 = [i2.node, e2.node, a2.node], n2 = 0; n2 < 3; n2++)
            t3.globals.dom.elGraphical.add(r2[n2]), !s2 || t3.globals.resized || t3.globals.dataChanged || "scatter" !== t3.config.chart.type && "bubble" !== t3.config.chart.type && t3.globals.dataPoints > 1 && o2[n2].classList.add("apexcharts-element-hidden"), t3.globals.delayedElements.push({ el: o2[n2], index: 0 });
          this.helpers.annotationsBackground();
        }
      } }, { key: "drawImageAnnos", value: function() {
        var t3 = this;
        this.w.config.annotations.images.map(function(e2, i2) {
          t3.addImage(e2, i2);
        });
      } }, { key: "drawTextAnnos", value: function() {
        var t3 = this;
        this.w.config.annotations.texts.map(function(e2, i2) {
          t3.addText(e2, i2);
        });
      } }, { key: "addXaxisAnnotation", value: function(t3, e2, i2) {
        this.xAxisAnnotations.addXaxisAnnotation(t3, e2, i2);
      } }, { key: "addYaxisAnnotation", value: function(t3, e2, i2) {
        this.yAxisAnnotations.addYaxisAnnotation(t3, e2, i2);
      } }, { key: "addPointAnnotation", value: function(t3, e2, i2) {
        this.pointsAnnotations.addPointAnnotation(t3, e2, i2);
      } }, { key: "addText", value: function(t3, e2) {
        var i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, o2 = t3.foreColor, n2 = t3.fontSize, l2 = t3.fontFamily, h2 = t3.fontWeight, c2 = t3.cssClass, d2 = t3.backgroundColor, g2 = t3.borderWidth, u5 = t3.strokeDashArray, p2 = t3.borderRadius, f2 = t3.borderColor, x2 = t3.appendTo, b2 = void 0 === x2 ? ".apexcharts-svg" : x2, v2 = t3.paddingLeft, m2 = void 0 === v2 ? 4 : v2, y2 = t3.paddingRight, w2 = void 0 === y2 ? 4 : y2, k2 = t3.paddingBottom, A2 = void 0 === k2 ? 2 : k2, S2 = t3.paddingTop, C2 = void 0 === S2 ? 2 : S2, L2 = this.w, P2 = this.graphics.drawText({ x: i2, y: a2, text: s2, textAnchor: r2 || "start", fontSize: n2 || "12px", fontWeight: h2 || "regular", fontFamily: l2 || L2.config.chart.fontFamily, foreColor: o2 || L2.config.chart.foreColor, cssClass: c2 }), I2 = L2.globals.dom.baseEl.querySelector(b2);
        I2 && I2.appendChild(P2.node);
        var T2 = P2.bbox();
        if (s2) {
          var M2 = this.graphics.drawRect(T2.x - m2, T2.y - C2, T2.width + m2 + w2, T2.height + A2 + C2, p2, d2 || "transparent", 1, g2, f2, u5);
          I2.insertBefore(M2.node, P2.node);
        }
      } }, { key: "addImage", value: function(t3, e2) {
        var i2 = this.w, a2 = t3.path, s2 = t3.x, r2 = void 0 === s2 ? 0 : s2, o2 = t3.y, n2 = void 0 === o2 ? 0 : o2, l2 = t3.width, h2 = void 0 === l2 ? 20 : l2, c2 = t3.height, d2 = void 0 === c2 ? 20 : c2, g2 = t3.appendTo, u5 = void 0 === g2 ? ".apexcharts-svg" : g2, p2 = i2.globals.dom.Paper.image(a2);
        p2.size(h2, d2).move(r2, n2);
        var f2 = i2.globals.dom.baseEl.querySelector(u5);
        return f2 && f2.appendChild(p2.node), p2;
      } }, { key: "addXaxisAnnotationExternal", value: function(t3, e2, i2) {
        return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "xaxis", contextMethod: i2.addXaxisAnnotation }), i2;
      } }, { key: "addYaxisAnnotationExternal", value: function(t3, e2, i2) {
        return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "yaxis", contextMethod: i2.addYaxisAnnotation }), i2;
      } }, { key: "addPointAnnotationExternal", value: function(t3, e2, i2) {
        return void 0 === this.invertAxis && (this.invertAxis = i2.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "point", contextMethod: i2.addPointAnnotation }), i2;
      } }, { key: "addAnnotationExternal", value: function(t3) {
        var e2 = t3.params, i2 = t3.pushToMemory, a2 = t3.context, s2 = t3.type, r2 = t3.contextMethod, o2 = a2, n2 = o2.w, l2 = n2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations")), h2 = l2.childNodes.length + 1, c2 = new L(), d2 = Object.assign({}, "xaxis" === s2 ? c2.xAxisAnnotation : "yaxis" === s2 ? c2.yAxisAnnotation : c2.pointAnnotation), g2 = x.extend(d2, e2);
        switch (s2) {
          case "xaxis":
            this.addXaxisAnnotation(g2, l2, h2);
            break;
          case "yaxis":
            this.addYaxisAnnotation(g2, l2, h2);
            break;
          case "point":
            this.addPointAnnotation(g2, l2, h2);
        }
        var u5 = n2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(h2, "']")), p2 = this.helpers.addBackgroundToAnno(u5, g2);
        return p2 && l2.insertBefore(p2.node, u5), i2 && n2.globals.memory.methodsToExec.push({ context: o2, id: g2.id ? g2.id : x.randomId(), method: r2, label: "addAnnotation", params: e2 }), a2;
      } }, { key: "clearAnnotations", value: function(t3) {
        var e2 = t3.w, i2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
        e2.globals.memory.methodsToExec.map(function(t4, i3) {
          "addText" !== t4.label && "addAnnotation" !== t4.label || e2.globals.memory.methodsToExec.splice(i3, 1);
        }), i2 = x.listToArray(i2), Array.prototype.forEach.call(i2, function(t4) {
          for (; t4.firstChild; )
            t4.removeChild(t4.firstChild);
        });
      } }, { key: "removeAnnotation", value: function(t3, e2) {
        var i2 = t3.w, a2 = i2.globals.dom.baseEl.querySelectorAll(".".concat(e2));
        a2 && (i2.globals.memory.methodsToExec.map(function(t4, a3) {
          t4.id === e2 && i2.globals.memory.methodsToExec.splice(a3, 1);
        }), Array.prototype.forEach.call(a2, function(t4) {
          t4.parentElement.removeChild(t4);
        }));
      } }]), t2;
    }();
    var I = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      }
      return r(t2, [{ key: "isValidDate", value: function(t3) {
        return "number" != typeof t3 && !isNaN(this.parseDate(t3));
      } }, { key: "getTimeStamp", value: function(t3) {
        return Date.parse(t3) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toISOString().substr(0, 25)).getTime() : new Date(t3).getTime() : t3;
      } }, { key: "getDate", value: function(t3) {
        return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toUTCString()) : new Date(t3);
      } }, { key: "parseDate", value: function(t3) {
        var e2 = Date.parse(t3);
        if (!isNaN(e2))
          return this.getTimeStamp(t3);
        var i2 = Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
        return i2 = this.getTimeStamp(i2);
      } }, { key: "parseDateWithTimezone", value: function(t3) {
        return Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      } }, { key: "formatDate", value: function(t3, e2) {
        var i2 = this.w.globals.locale, a2 = this.w.config.xaxis.labels.datetimeUTC, s2 = ["\0"].concat(u4(i2.months)), r2 = [""].concat(u4(i2.shortMonths)), o2 = [""].concat(u4(i2.days)), n2 = [""].concat(u4(i2.shortDays));
        function l2(t4, e3) {
          var i3 = t4 + "";
          for (e3 = e3 || 2; i3.length < e3; )
            i3 = "0" + i3;
          return i3;
        }
        var h2 = a2 ? t3.getUTCFullYear() : t3.getFullYear();
        e2 = (e2 = (e2 = e2.replace(/(^|[^\\])yyyy+/g, "$1" + h2)).replace(/(^|[^\\])yy/g, "$1" + h2.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h2);
        var c2 = (a2 ? t3.getUTCMonth() : t3.getMonth()) + 1;
        e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])MMMM+/g, "$1" + s2[0])).replace(/(^|[^\\])MMM/g, "$1" + r2[0])).replace(/(^|[^\\])MM/g, "$1" + l2(c2))).replace(/(^|[^\\])M/g, "$1" + c2);
        var d2 = a2 ? t3.getUTCDate() : t3.getDate();
        e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])dddd+/g, "$1" + o2[0])).replace(/(^|[^\\])ddd/g, "$1" + n2[0])).replace(/(^|[^\\])dd/g, "$1" + l2(d2))).replace(/(^|[^\\])d/g, "$1" + d2);
        var g2 = a2 ? t3.getUTCHours() : t3.getHours(), p2 = g2 > 12 ? g2 - 12 : 0 === g2 ? 12 : g2;
        e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])HH+/g, "$1" + l2(g2))).replace(/(^|[^\\])H/g, "$1" + g2)).replace(/(^|[^\\])hh+/g, "$1" + l2(p2))).replace(/(^|[^\\])h/g, "$1" + p2);
        var f2 = a2 ? t3.getUTCMinutes() : t3.getMinutes();
        e2 = (e2 = e2.replace(/(^|[^\\])mm+/g, "$1" + l2(f2))).replace(/(^|[^\\])m/g, "$1" + f2);
        var x2 = a2 ? t3.getUTCSeconds() : t3.getSeconds();
        e2 = (e2 = e2.replace(/(^|[^\\])ss+/g, "$1" + l2(x2))).replace(/(^|[^\\])s/g, "$1" + x2);
        var b2 = a2 ? t3.getUTCMilliseconds() : t3.getMilliseconds();
        e2 = e2.replace(/(^|[^\\])fff+/g, "$1" + l2(b2, 3)), b2 = Math.round(b2 / 10), e2 = e2.replace(/(^|[^\\])ff/g, "$1" + l2(b2)), b2 = Math.round(b2 / 10);
        var v2 = g2 < 12 ? "AM" : "PM";
        e2 = (e2 = (e2 = e2.replace(/(^|[^\\])f/g, "$1" + b2)).replace(/(^|[^\\])TT+/g, "$1" + v2)).replace(/(^|[^\\])T/g, "$1" + v2.charAt(0));
        var m2 = v2.toLowerCase();
        e2 = (e2 = e2.replace(/(^|[^\\])tt+/g, "$1" + m2)).replace(/(^|[^\\])t/g, "$1" + m2.charAt(0));
        var y2 = -t3.getTimezoneOffset(), w2 = a2 || !y2 ? "Z" : y2 > 0 ? "+" : "-";
        if (!a2) {
          var k2 = (y2 = Math.abs(y2)) % 60;
          w2 += l2(Math.floor(y2 / 60)) + ":" + l2(k2);
        }
        e2 = e2.replace(/(^|[^\\])K/g, "$1" + w2);
        var A2 = (a2 ? t3.getUTCDay() : t3.getDay()) + 1;
        return e2 = (e2 = (e2 = (e2 = (e2 = e2.replace(new RegExp(o2[0], "g"), o2[A2])).replace(new RegExp(n2[0], "g"), n2[A2])).replace(new RegExp(s2[0], "g"), s2[c2])).replace(new RegExp(r2[0], "g"), r2[c2])).replace(/\\(.)/g, "$1");
      } }, { key: "getTimeUnitsfromTimestamp", value: function(t3, e2, i2) {
        var a2 = this.w;
        void 0 !== a2.config.xaxis.min && (t3 = a2.config.xaxis.min), void 0 !== a2.config.xaxis.max && (e2 = a2.config.xaxis.max);
        var s2 = this.getDate(t3), r2 = this.getDate(e2), o2 = this.formatDate(s2, "yyyy MM dd HH mm ss fff").split(" "), n2 = this.formatDate(r2, "yyyy MM dd HH mm ss fff").split(" ");
        return { minMillisecond: parseInt(o2[6], 10), maxMillisecond: parseInt(n2[6], 10), minSecond: parseInt(o2[5], 10), maxSecond: parseInt(n2[5], 10), minMinute: parseInt(o2[4], 10), maxMinute: parseInt(n2[4], 10), minHour: parseInt(o2[3], 10), maxHour: parseInt(n2[3], 10), minDate: parseInt(o2[2], 10), maxDate: parseInt(n2[2], 10), minMonth: parseInt(o2[1], 10) - 1, maxMonth: parseInt(n2[1], 10) - 1, minYear: parseInt(o2[0], 10), maxYear: parseInt(n2[0], 10) };
      } }, { key: "isLeapYear", value: function(t3) {
        return t3 % 4 == 0 && t3 % 100 != 0 || t3 % 400 == 0;
      } }, { key: "calculcateLastDaysOfMonth", value: function(t3, e2, i2) {
        return this.determineDaysOfMonths(t3, e2) - i2;
      } }, { key: "determineDaysOfYear", value: function(t3) {
        var e2 = 365;
        return this.isLeapYear(t3) && (e2 = 366), e2;
      } }, { key: "determineRemainingDaysOfYear", value: function(t3, e2, i2) {
        var a2 = this.daysCntOfYear[e2] + i2;
        return e2 > 1 && this.isLeapYear() && a2++, a2;
      } }, { key: "determineDaysOfMonths", value: function(t3, e2) {
        var i2 = 30;
        switch (t3 = x.monthMod(t3), true) {
          case this.months30.indexOf(t3) > -1:
            2 === t3 && (i2 = this.isLeapYear(e2) ? 29 : 28);
            break;
          case this.months31.indexOf(t3) > -1:
          default:
            i2 = 31;
        }
        return i2;
      } }]), t2;
    }();
    var T = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.tooltipKeyFormat = "dd MMM";
      }
      return r(t2, [{ key: "xLabelFormat", value: function(t3, e2, i2, a2) {
        var s2 = this.w;
        if ("datetime" === s2.config.xaxis.type && void 0 === s2.config.xaxis.labels.formatter && void 0 === s2.config.tooltip.x.formatter) {
          var r2 = new I(this.ctx);
          return r2.formatDate(r2.getDate(e2), s2.config.tooltip.x.format);
        }
        return t3(e2, i2, a2);
      } }, { key: "defaultGeneralFormatter", value: function(t3) {
        return Array.isArray(t3) ? t3.map(function(t4) {
          return t4;
        }) : t3;
      } }, { key: "defaultYFormatter", value: function(t3, e2, i2) {
        var a2 = this.w;
        return x.isNumber(t3) && (t3 = 0 !== a2.globals.yValueDecimal ? t3.toFixed(void 0 !== e2.decimalsInFloat ? e2.decimalsInFloat : a2.globals.yValueDecimal) : a2.globals.maxYArr[i2] - a2.globals.minYArr[i2] < 5 ? t3.toFixed(1) : t3.toFixed(0)), t3;
      } }, { key: "setLabelFormatters", value: function() {
        var t3 = this, e2 = this.w;
        return e2.globals.xaxisTooltipFormatter = function(e3) {
          return t3.defaultGeneralFormatter(e3);
        }, e2.globals.ttKeyFormatter = function(e3) {
          return t3.defaultGeneralFormatter(e3);
        }, e2.globals.ttZFormatter = function(t4) {
          return t4;
        }, e2.globals.legendFormatter = function(e3) {
          return t3.defaultGeneralFormatter(e3);
        }, void 0 !== e2.config.xaxis.labels.formatter ? e2.globals.xLabelFormatter = e2.config.xaxis.labels.formatter : e2.globals.xLabelFormatter = function(t4) {
          if (x.isNumber(t4)) {
            if (!e2.config.xaxis.convertedCatToNumeric && "numeric" === e2.config.xaxis.type) {
              if (x.isNumber(e2.config.xaxis.decimalsInFloat))
                return t4.toFixed(e2.config.xaxis.decimalsInFloat);
              var i2 = e2.globals.maxX - e2.globals.minX;
              return i2 > 0 && i2 < 100 ? t4.toFixed(1) : t4.toFixed(0);
            }
            if (e2.globals.isBarHorizontal) {
              if (e2.globals.maxY - e2.globals.minYArr < 4)
                return t4.toFixed(1);
            }
            return t4.toFixed(0);
          }
          return t4;
        }, "function" == typeof e2.config.tooltip.x.formatter ? e2.globals.ttKeyFormatter = e2.config.tooltip.x.formatter : e2.globals.ttKeyFormatter = e2.globals.xLabelFormatter, "function" == typeof e2.config.xaxis.tooltip.formatter && (e2.globals.xaxisTooltipFormatter = e2.config.xaxis.tooltip.formatter), (Array.isArray(e2.config.tooltip.y) || void 0 !== e2.config.tooltip.y.formatter) && (e2.globals.ttVal = e2.config.tooltip.y), void 0 !== e2.config.tooltip.z.formatter && (e2.globals.ttZFormatter = e2.config.tooltip.z.formatter), void 0 !== e2.config.legend.formatter && (e2.globals.legendFormatter = e2.config.legend.formatter), e2.config.yaxis.forEach(function(i2, a2) {
          void 0 !== i2.labels.formatter ? e2.globals.yLabelFormatters[a2] = i2.labels.formatter : e2.globals.yLabelFormatters[a2] = function(s2) {
            return e2.globals.xyCharts ? Array.isArray(s2) ? s2.map(function(e3) {
              return t3.defaultYFormatter(e3, i2, a2);
            }) : t3.defaultYFormatter(s2, i2, a2) : s2;
          };
        }), e2.globals;
      } }, { key: "heatmapLabelFormatters", value: function() {
        var t3 = this.w;
        if ("heatmap" === t3.config.chart.type) {
          t3.globals.yAxisScale[0].result = t3.globals.seriesNames.slice();
          var e2 = t3.globals.seriesNames.reduce(function(t4, e3) {
            return t4.length > e3.length ? t4 : e3;
          }, 0);
          t3.globals.yAxisScale[0].niceMax = e2, t3.globals.yAxisScale[0].niceMin = e2;
        }
      } }]), t2;
    }();
    var M = function(t2) {
      var e2, i2 = t2.isTimeline, a2 = t2.ctx, s2 = t2.seriesIndex, r2 = t2.dataPointIndex, o2 = t2.y1, n2 = t2.y2, l2 = t2.w, h2 = l2.globals.seriesRangeStart[s2][r2], c2 = l2.globals.seriesRangeEnd[s2][r2], d2 = l2.globals.labels[r2], g2 = l2.config.series[s2].name ? l2.config.series[s2].name : "", u5 = l2.globals.ttKeyFormatter, p2 = l2.config.tooltip.y.title.formatter, f2 = { w: l2, seriesIndex: s2, dataPointIndex: r2, start: h2, end: c2 };
      ("function" == typeof p2 && (g2 = p2(g2, f2)), null !== (e2 = l2.config.series[s2].data[r2]) && void 0 !== e2 && e2.x && (d2 = l2.config.series[s2].data[r2].x), i2) || "datetime" === l2.config.xaxis.type && (d2 = new T(a2).xLabelFormat(l2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new I(a2).formatDate, w: l2 }));
      "function" == typeof u5 && (d2 = u5(d2, f2)), Number.isFinite(o2) && Number.isFinite(n2) && (h2 = o2, c2 = n2);
      var x2 = "", b2 = "", v2 = l2.globals.colors[s2];
      if (void 0 === l2.config.tooltip.x.formatter)
        if ("datetime" === l2.config.xaxis.type) {
          var m2 = new I(a2);
          x2 = m2.formatDate(m2.getDate(h2), l2.config.tooltip.x.format), b2 = m2.formatDate(m2.getDate(c2), l2.config.tooltip.x.format);
        } else
          x2 = h2, b2 = c2;
      else
        x2 = l2.config.tooltip.x.formatter(h2), b2 = l2.config.tooltip.x.formatter(c2);
      return { start: h2, end: c2, startVal: x2, endVal: b2, ylabel: d2, color: v2, seriesName: g2 };
    };
    var z = function(t2) {
      var e2 = t2.color, i2 = t2.seriesName, a2 = t2.ylabel, s2 = t2.start, r2 = t2.end, o2 = t2.seriesIndex, n2 = t2.dataPointIndex, l2 = t2.ctx.tooltip.tooltipLabels.getFormatters(o2);
      s2 = l2.yLbFormatter(s2), r2 = l2.yLbFormatter(r2);
      var h2 = l2.yLbFormatter(t2.w.globals.series[o2][n2]), c2 = '<span class="value start-value">\n  '.concat(s2, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r2, "\n  </span>");
      return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e2 + '">' + (i2 || "") + '</span></div><div> <span class="category">' + a2 + ": </span> " + (t2.w.globals.comboCharts ? "rangeArea" === t2.w.config.series[o2].type || "rangeBar" === t2.w.config.series[o2].type ? c2 : "<span>".concat(h2, "</span>") : c2) + " </div></div>";
    };
    var X = function() {
      function t2(e2) {
        a(this, t2), this.opts = e2;
      }
      return r(t2, [{ key: "hideYAxis", value: function() {
        this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
      } }, { key: "line", value: function() {
        return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
      } }, { key: "sparkline", value: function(t3) {
        this.hideYAxis();
        return x.extend(t3, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
      } }, { key: "bar", value: function() {
        return { chart: { stacked: false, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
      } }, { key: "funnel", value: function() {
        return this.hideYAxis(), e(e({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
      } }, { key: "candlestick", value: function() {
        var t3 = this;
        return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
          var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
          return t3._getBoxTooltip(s2, i2, a2, ["Open", "High", "", "Low", "Close"], "candlestick");
        } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
      } }, { key: "boxPlot", value: function() {
        var t3 = this;
        return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
          var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
          return t3._getBoxTooltip(s2, i2, a2, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
        } }, markers: { size: 5, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
      } }, { key: "rangeBar", value: function() {
        return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t3, e2) {
          e2.ctx;
          var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w, r2 = function() {
            var t4 = s2.globals.seriesRangeStart[i2][a2];
            return s2.globals.seriesRangeEnd[i2][a2] - t4;
          };
          return s2.globals.comboCharts ? "rangeBar" === s2.config.series[i2].type || "rangeArea" === s2.config.series[i2].type ? r2() : t3 : r2();
        }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t3) {
          return t3.w.config.plotOptions && t3.w.config.plotOptions.bar && t3.w.config.plotOptions.bar.horizontal ? function(t4) {
            var i2 = M(e(e({}, t4), {}, { isTimeline: true })), a2 = i2.color, s2 = i2.seriesName, r2 = i2.ylabel, o2 = i2.startVal, n2 = i2.endVal;
            return z(e(e({}, t4), {}, { color: a2, seriesName: s2, ylabel: r2, start: o2, end: n2 }));
          }(t3) : function(t4) {
            var i2 = M(t4), a2 = i2.color, s2 = i2.seriesName, r2 = i2.ylabel, o2 = i2.start, n2 = i2.end;
            return z(e(e({}, t4), {}, { color: a2, seriesName: s2, ylabel: r2, start: o2, end: n2 }));
          }(t3);
        } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
      } }, { key: "dumbbell", value: function(t3) {
        var e2, i2;
        return null !== (e2 = t3.plotOptions.bar) && void 0 !== e2 && e2.barHeight || (t3.plotOptions.bar.barHeight = 2), null !== (i2 = t3.plotOptions.bar) && void 0 !== i2 && i2.columnWidth || (t3.plotOptions.bar.columnWidth = 2), t3;
      } }, { key: "area", value: function() {
        return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
      } }, { key: "rangeArea", value: function() {
        return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t3) {
          return function(t4) {
            var i2 = M(t4), a2 = i2.color, s2 = i2.seriesName, r2 = i2.ylabel, o2 = i2.start, n2 = i2.end;
            return z(e(e({}, t4), {}, { color: a2, seriesName: s2, ylabel: r2, start: o2, end: n2 }));
          }(t3);
        } } };
      } }, { key: "brush", value: function(t3) {
        return x.extend(t3, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
      } }, { key: "stacked100", value: function(t3) {
        t3.dataLabels = t3.dataLabels || {}, t3.dataLabels.formatter = t3.dataLabels.formatter || void 0;
        var e2 = t3.dataLabels.formatter;
        return t3.yaxis.forEach(function(e3, i2) {
          t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
        }), "bar" === t3.chart.type && (t3.dataLabels.formatter = e2 || function(t4) {
          return "number" == typeof t4 && t4 ? t4.toFixed(0) + "%" : t4;
        }), t3;
      } }, { key: "stackedBars", value: function() {
        var t3 = this.bar();
        return e(e({}, t3), {}, { plotOptions: e(e({}, t3.plotOptions), {}, { bar: e(e({}, t3.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
      } }, { key: "convertCatToNumeric", value: function(t3) {
        return t3.xaxis.convertedCatToNumeric = true, t3;
      } }, { key: "convertCatToNumericXaxis", value: function(t3, e2, i2) {
        t3.xaxis.type = "numeric", t3.xaxis.labels = t3.xaxis.labels || {}, t3.xaxis.labels.formatter = t3.xaxis.labels.formatter || function(t4) {
          return x.isNumber(t4) ? Math.floor(t4) : t4;
        };
        var a2 = t3.xaxis.labels.formatter, s2 = t3.xaxis.categories && t3.xaxis.categories.length ? t3.xaxis.categories : t3.labels;
        return i2 && i2.length && (s2 = i2.map(function(t4) {
          return Array.isArray(t4) ? t4 : String(t4);
        })), s2 && s2.length && (t3.xaxis.labels.formatter = function(t4) {
          return x.isNumber(t4) ? a2(s2[Math.floor(t4) - 1]) : a2(t4);
        }), t3.xaxis.categories = [], t3.labels = [], t3.xaxis.tickAmount = t3.xaxis.tickAmount || "dataPoints", t3;
      } }, { key: "bubble", value: function() {
        return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
      } }, { key: "scatter", value: function() {
        return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
      } }, { key: "heatmap", value: function() {
        return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
      } }, { key: "treemap", value: function() {
        return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
      } }, { key: "pie", value: function() {
        return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t3) {
          return t3.toFixed(1) + "%";
        }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
      } }, { key: "donut", value: function() {
        return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
          return t3.toFixed(1) + "%";
        }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
      } }, { key: "polarArea", value: function() {
        return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
          return t3.toFixed(1) + "%";
        }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
      } }, { key: "radar", value: function() {
        return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false }, xaxis: { labels: { formatter: function(t3) {
          return t3;
        }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
      } }, { key: "radialBar", value: function() {
        return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true } };
      } }, { key: "_getBoxTooltip", value: function(t3, e2, i2, a2, s2) {
        var r2 = t3.globals.seriesCandleO[e2][i2], o2 = t3.globals.seriesCandleH[e2][i2], n2 = t3.globals.seriesCandleM[e2][i2], l2 = t3.globals.seriesCandleL[e2][i2], h2 = t3.globals.seriesCandleC[e2][i2];
        return t3.config.series[e2].type && t3.config.series[e2].type !== s2 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t3.config.series[e2].name ? t3.config.series[e2].name : "series-" + (e2 + 1), ": <strong>").concat(t3.globals.series[e2][i2], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t3.config.chart.type, '">') + "<div>".concat(a2[0], ': <span class="value">') + r2 + "</span></div>" + "<div>".concat(a2[1], ': <span class="value">') + o2 + "</span></div>" + (n2 ? "<div>".concat(a2[2], ': <span class="value">') + n2 + "</span></div>" : "") + "<div>".concat(a2[3], ': <span class="value">') + l2 + "</span></div>" + "<div>".concat(a2[4], ': <span class="value">') + h2 + "</span></div></div>";
      } }]), t2;
    }();
    var E = function() {
      function t2(e2) {
        a(this, t2), this.opts = e2;
      }
      return r(t2, [{ key: "init", value: function(t3) {
        var e2 = t3.responsiveOverride, a2 = this.opts, s2 = new L(), r2 = new X(a2);
        this.chartType = a2.chart.type, a2 = this.extendYAxis(a2), a2 = this.extendAnnotations(a2);
        var o2 = s2.init(), n2 = {};
        if (a2 && "object" === i(a2)) {
          var l2, h2, c2, d2, g2, u5, p2, f2, b2, v2, m2 = {};
          m2 = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a2.chart.type) ? r2[a2.chart.type]() : r2.line(), null !== (l2 = a2.plotOptions) && void 0 !== l2 && null !== (h2 = l2.bar) && void 0 !== h2 && h2.isFunnel && (m2 = r2.funnel()), a2.chart.stacked && "bar" === a2.chart.type && (m2 = r2.stackedBars()), null !== (c2 = a2.chart.brush) && void 0 !== c2 && c2.enabled && (m2 = r2.brush(m2)), a2.chart.stacked && "100%" === a2.chart.stackType && (a2 = r2.stacked100(a2)), null !== (d2 = a2.plotOptions) && void 0 !== d2 && null !== (g2 = d2.bar) && void 0 !== g2 && g2.isDumbbell && (a2 = r2.dumbbell(a2)), "monotoneCubic" === (null === (u5 = a2) || void 0 === u5 || null === (p2 = u5.stroke) || void 0 === p2 ? void 0 : p2.curve) && (a2.stroke.curve = "smooth"), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a2), a2.xaxis = a2.xaxis || window.Apex.xaxis || {}, e2 || (a2.xaxis.convertedCatToNumeric = false), (null !== (f2 = (a2 = this.checkForCatToNumericXAxis(this.chartType, m2, a2)).chart.sparkline) && void 0 !== f2 && f2.enabled || null !== (b2 = window.Apex.chart) && void 0 !== b2 && null !== (v2 = b2.sparkline) && void 0 !== v2 && v2.enabled) && (m2 = r2.sparkline(m2)), n2 = x.extend(o2, m2);
        }
        var y2 = x.extend(n2, window.Apex);
        return o2 = x.extend(y2, a2), o2 = this.handleUserInputErrors(o2);
      } }, { key: "checkForCatToNumericXAxis", value: function(t3, e2, i2) {
        var a2, s2, r2 = new X(i2), o2 = ("bar" === t3 || "boxPlot" === t3) && (null === (a2 = i2.plotOptions) || void 0 === a2 || null === (s2 = a2.bar) || void 0 === s2 ? void 0 : s2.horizontal), n2 = "pie" === t3 || "polarArea" === t3 || "donut" === t3 || "radar" === t3 || "radialBar" === t3 || "heatmap" === t3, l2 = "datetime" !== i2.xaxis.type && "numeric" !== i2.xaxis.type, h2 = i2.xaxis.tickPlacement ? i2.xaxis.tickPlacement : e2.xaxis && e2.xaxis.tickPlacement;
        return o2 || n2 || !l2 || "between" === h2 || (i2 = r2.convertCatToNumeric(i2)), i2;
      } }, { key: "extendYAxis", value: function(t3, e2) {
        var i2 = new L();
        (void 0 === t3.yaxis || !t3.yaxis || Array.isArray(t3.yaxis) && 0 === t3.yaxis.length) && (t3.yaxis = {}), t3.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t3.yaxis = x.extend(t3.yaxis, window.Apex.yaxis)), t3.yaxis.constructor !== Array ? t3.yaxis = [x.extend(i2.yAxis, t3.yaxis)] : t3.yaxis = x.extendArray(t3.yaxis, i2.yAxis);
        var a2 = false;
        t3.yaxis.forEach(function(t4) {
          t4.logarithmic && (a2 = true);
        });
        var s2 = t3.series;
        return e2 && !s2 && (s2 = e2.config.series), a2 && s2.length !== t3.yaxis.length && s2.length && (t3.yaxis = s2.map(function(e3, a3) {
          if (e3.name || (s2[a3].name = "series-".concat(a3 + 1)), t3.yaxis[a3])
            return t3.yaxis[a3].seriesName = s2[a3].name, t3.yaxis[a3];
          var r2 = x.extend(i2.yAxis, t3.yaxis[0]);
          return r2.show = false, r2;
        })), a2 && s2.length > 1 && s2.length !== t3.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t3;
      } }, { key: "extendAnnotations", value: function(t3) {
        return void 0 === t3.annotations && (t3.annotations = {}, t3.annotations.yaxis = [], t3.annotations.xaxis = [], t3.annotations.points = []), t3 = this.extendYAxisAnnotations(t3), t3 = this.extendXAxisAnnotations(t3), t3 = this.extendPointAnnotations(t3);
      } }, { key: "extendYAxisAnnotations", value: function(t3) {
        var e2 = new L();
        return t3.annotations.yaxis = x.extendArray(void 0 !== t3.annotations.yaxis ? t3.annotations.yaxis : [], e2.yAxisAnnotation), t3;
      } }, { key: "extendXAxisAnnotations", value: function(t3) {
        var e2 = new L();
        return t3.annotations.xaxis = x.extendArray(void 0 !== t3.annotations.xaxis ? t3.annotations.xaxis : [], e2.xAxisAnnotation), t3;
      } }, { key: "extendPointAnnotations", value: function(t3) {
        var e2 = new L();
        return t3.annotations.points = x.extendArray(void 0 !== t3.annotations.points ? t3.annotations.points : [], e2.pointAnnotation), t3;
      } }, { key: "checkForDarkTheme", value: function(t3) {
        t3.theme && "dark" === t3.theme.mode && (t3.tooltip || (t3.tooltip = {}), "light" !== t3.tooltip.theme && (t3.tooltip.theme = "dark"), t3.chart.foreColor || (t3.chart.foreColor = "#f6f7f8"), t3.chart.background || (t3.chart.background = "#424242"), t3.theme.palette || (t3.theme.palette = "palette4"));
      } }, { key: "handleUserInputErrors", value: function(t3) {
        var e2 = t3;
        if (e2.tooltip.shared && e2.tooltip.intersect)
          throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
        if ("bar" === e2.chart.type && e2.plotOptions.bar.horizontal) {
          if (e2.yaxis.length > 1)
            throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
          e2.yaxis[0].reversed && (e2.yaxis[0].opposite = true), e2.xaxis.tooltip.enabled = false, e2.yaxis[0].tooltip.enabled = false, e2.chart.zoom.enabled = false;
        }
        return "bar" !== e2.chart.type && "rangeBar" !== e2.chart.type || e2.tooltip.shared && "barWidth" === e2.xaxis.crosshairs.width && e2.series.length > 1 && (e2.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e2.chart.type && "boxPlot" !== e2.chart.type || e2.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e2.chart.type, " chart is not supported.")), e2.yaxis[0].reversed = false), e2;
      } }]), t2;
    }();
    var Y = function() {
      function t2() {
        a(this, t2);
      }
      return r(t2, [{ key: "initGlobalVars", value: function(t3) {
        t3.series = [], t3.seriesCandleO = [], t3.seriesCandleH = [], t3.seriesCandleM = [], t3.seriesCandleL = [], t3.seriesCandleC = [], t3.seriesRangeStart = [], t3.seriesRangeEnd = [], t3.seriesRange = [], t3.seriesPercent = [], t3.seriesGoals = [], t3.seriesX = [], t3.seriesZ = [], t3.seriesNames = [], t3.seriesTotals = [], t3.seriesLog = [], t3.seriesColors = [], t3.stackedSeriesTotals = [], t3.seriesXvalues = [], t3.seriesYvalues = [], t3.labels = [], t3.hasXaxisGroups = false, t3.groups = [], t3.hasSeriesGroups = false, t3.seriesGroups = [], t3.categoryLabels = [], t3.timescaleLabels = [], t3.noLabelsProvided = false, t3.resizeTimer = null, t3.selectionResizeTimer = null, t3.delayedElements = [], t3.pointsArray = [], t3.dataLabelsRects = [], t3.isXNumeric = false, t3.skipLastTimelinelabel = false, t3.skipFirstTimelinelabel = false, t3.isDataXYZ = false, t3.isMultiLineX = false, t3.isMultipleYAxis = false, t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE, t3.minYArr = [], t3.maxYArr = [], t3.maxX = -Number.MAX_VALUE, t3.minX = Number.MAX_VALUE, t3.initialMaxX = -Number.MAX_VALUE, t3.initialMinX = Number.MAX_VALUE, t3.maxDate = 0, t3.minDate = Number.MAX_VALUE, t3.minZ = Number.MAX_VALUE, t3.maxZ = -Number.MAX_VALUE, t3.minXDiff = Number.MAX_VALUE, t3.yAxisScale = [], t3.xAxisScale = null, t3.xAxisTicksPositions = [], t3.yLabelsCoords = [], t3.yTitleCoords = [], t3.barPadForNumericAxis = 0, t3.padHorizontal = 0, t3.xRange = 0, t3.yRange = [], t3.zRange = 0, t3.dataPoints = 0, t3.xTickAmount = 0;
      } }, { key: "globalVars", value: function(t3) {
        return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t3.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: false, ignoreYAxisIndexes: [], yAxisSameScaleIndices: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: "zoom" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.zoom && t3.chart.zoom.enabled, panEnabled: "pan" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.pan, selectionEnabled: "selection" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, easing: null, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null };
      } }, { key: "init", value: function(t3) {
        var e2 = this.globalVars(t3);
        return this.initGlobalVars(e2), e2.initialConfig = x.extend({}, t3), e2.initialSeries = x.clone(t3.series), e2.lastXAxis = x.clone(e2.initialConfig.xaxis), e2.lastYAxis = x.clone(e2.initialConfig.yaxis), e2;
      } }]), t2;
    }();
    var F = function() {
      function t2(e2) {
        a(this, t2), this.opts = e2;
      }
      return r(t2, [{ key: "init", value: function() {
        var t3 = new E(this.opts).init({ responsiveOverride: false });
        return { config: t3, globals: new Y().init(t3) };
      } }]), t2;
    }();
    var R = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.opts = null, this.seriesIndex = 0;
      }
      return r(t2, [{ key: "clippedImgArea", value: function(t3) {
        var e2 = this.w, i2 = e2.config, a2 = parseInt(e2.globals.gridWidth, 10), s2 = parseInt(e2.globals.gridHeight, 10), r2 = a2 > s2 ? a2 : s2, o2 = t3.image, n2 = 0, l2 = 0;
        void 0 === t3.width && void 0 === t3.height ? void 0 !== i2.fill.image.width && void 0 !== i2.fill.image.height ? (n2 = i2.fill.image.width + 1, l2 = i2.fill.image.height) : (n2 = r2 + 1, l2 = r2) : (n2 = t3.width, l2 = t3.height);
        var h2 = document.createElementNS(e2.globals.SVGNS, "pattern");
        m.setAttrs(h2, { id: t3.patternID, patternUnits: t3.patternUnits ? t3.patternUnits : "userSpaceOnUse", width: n2 + "px", height: l2 + "px" });
        var c2 = document.createElementNS(e2.globals.SVGNS, "image");
        h2.appendChild(c2), c2.setAttributeNS(window.SVG.xlink, "href", o2), m.setAttrs(c2, { x: 0, y: 0, preserveAspectRatio: "none", width: n2 + "px", height: l2 + "px" }), c2.style.opacity = t3.opacity, e2.globals.dom.elDefs.node.appendChild(h2);
      } }, { key: "getSeriesIndex", value: function(t3) {
        var e2 = this.w, i2 = e2.config.chart.type;
        return ("bar" === i2 || "rangeBar" === i2) && e2.config.plotOptions.bar.distributed || "heatmap" === i2 || "treemap" === i2 ? this.seriesIndex = t3.seriesNumber : this.seriesIndex = t3.seriesNumber % e2.globals.series.length, this.seriesIndex;
      } }, { key: "fillPath", value: function(t3) {
        var e2 = this.w;
        this.opts = t3;
        var i2, a2, s2, r2 = this.w.config;
        this.seriesIndex = this.getSeriesIndex(t3);
        var o2 = this.getFillColors()[this.seriesIndex];
        void 0 !== e2.globals.seriesColors[this.seriesIndex] && (o2 = e2.globals.seriesColors[this.seriesIndex]), "function" == typeof o2 && (o2 = o2({ seriesIndex: this.seriesIndex, dataPointIndex: t3.dataPointIndex, value: t3.value, w: e2 }));
        var n2 = t3.fillType ? t3.fillType : this.getFillType(this.seriesIndex), l2 = Array.isArray(r2.fill.opacity) ? r2.fill.opacity[this.seriesIndex] : r2.fill.opacity;
        t3.color && (o2 = t3.color), o2 || (o2 = "#fff", console.warn("undefined color - ApexCharts"));
        var h2 = o2;
        if (-1 === o2.indexOf("rgb") ? o2.length < 9 && (h2 = x.hexToRgba(o2, l2)) : o2.indexOf("rgba") > -1 && (l2 = x.getOpacityFromRGBA(o2)), t3.opacity && (l2 = t3.opacity), "pattern" === n2 && (a2 = this.handlePatternFill({ fillConfig: t3.fillConfig, patternFill: a2, fillColor: o2, fillOpacity: l2, defaultColor: h2 })), "gradient" === n2 && (s2 = this.handleGradientFill({ fillConfig: t3.fillConfig, fillColor: o2, fillOpacity: l2, i: this.seriesIndex })), "image" === n2) {
          var c2 = r2.fill.image.src, d2 = t3.patternID ? t3.patternID : "";
          this.clippedImgArea({ opacity: l2, image: Array.isArray(c2) ? t3.seriesNumber < c2.length ? c2[t3.seriesNumber] : c2[0] : c2, width: t3.width ? t3.width : void 0, height: t3.height ? t3.height : void 0, patternUnits: t3.patternUnits, patternID: "pattern".concat(e2.globals.cuid).concat(t3.seriesNumber + 1).concat(d2) }), i2 = "url(#pattern".concat(e2.globals.cuid).concat(t3.seriesNumber + 1).concat(d2, ")");
        } else
          i2 = "gradient" === n2 ? s2 : "pattern" === n2 ? a2 : h2;
        return t3.solid && (i2 = h2), i2;
      } }, { key: "getFillType", value: function(t3) {
        var e2 = this.w;
        return Array.isArray(e2.config.fill.type) ? e2.config.fill.type[t3] : e2.config.fill.type;
      } }, { key: "getFillColors", value: function() {
        var t3 = this.w, e2 = t3.config, i2 = this.opts, a2 = [];
        return t3.globals.comboCharts ? "line" === t3.config.series[this.seriesIndex].type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors) : "line" === e2.chart.type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors), void 0 !== i2.fillColors && (a2 = [], Array.isArray(i2.fillColors) ? a2 = i2.fillColors.slice() : a2.push(i2.fillColors)), a2;
      } }, { key: "handlePatternFill", value: function(t3) {
        var e2 = t3.fillConfig, i2 = t3.patternFill, a2 = t3.fillColor, s2 = t3.fillOpacity, r2 = t3.defaultColor, o2 = this.w.config.fill;
        e2 && (o2 = e2);
        var n2 = this.opts, l2 = new m(this.ctx), h2 = Array.isArray(o2.pattern.strokeWidth) ? o2.pattern.strokeWidth[this.seriesIndex] : o2.pattern.strokeWidth, c2 = a2;
        Array.isArray(o2.pattern.style) ? i2 = void 0 !== o2.pattern.style[n2.seriesNumber] ? l2.drawPattern(o2.pattern.style[n2.seriesNumber], o2.pattern.width, o2.pattern.height, c2, h2, s2) : r2 : i2 = l2.drawPattern(o2.pattern.style, o2.pattern.width, o2.pattern.height, c2, h2, s2);
        return i2;
      } }, { key: "handleGradientFill", value: function(t3) {
        var i2 = t3.fillColor, a2 = t3.fillOpacity, s2 = t3.fillConfig, r2 = t3.i, o2 = this.w.config.fill;
        s2 && (o2 = e(e({}, o2), s2));
        var n2, l2 = this.opts, h2 = new m(this.ctx), c2 = new x(), d2 = o2.gradient.type, g2 = i2, u5 = void 0 === o2.gradient.opacityFrom ? a2 : Array.isArray(o2.gradient.opacityFrom) ? o2.gradient.opacityFrom[r2] : o2.gradient.opacityFrom;
        g2.indexOf("rgba") > -1 && (u5 = x.getOpacityFromRGBA(g2));
        var p2 = void 0 === o2.gradient.opacityTo ? a2 : Array.isArray(o2.gradient.opacityTo) ? o2.gradient.opacityTo[r2] : o2.gradient.opacityTo;
        if (void 0 === o2.gradient.gradientToColors || 0 === o2.gradient.gradientToColors.length)
          n2 = "dark" === o2.gradient.shade ? c2.shadeColor(-1 * parseFloat(o2.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? x.rgb2hex(i2) : i2) : c2.shadeColor(parseFloat(o2.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? x.rgb2hex(i2) : i2);
        else if (o2.gradient.gradientToColors[l2.seriesNumber]) {
          var f2 = o2.gradient.gradientToColors[l2.seriesNumber];
          n2 = f2, f2.indexOf("rgba") > -1 && (p2 = x.getOpacityFromRGBA(f2));
        } else
          n2 = i2;
        if (o2.gradient.gradientFrom && (g2 = o2.gradient.gradientFrom), o2.gradient.gradientTo && (n2 = o2.gradient.gradientTo), o2.gradient.inverseColors) {
          var b2 = g2;
          g2 = n2, n2 = b2;
        }
        return g2.indexOf("rgb") > -1 && (g2 = x.rgb2hex(g2)), n2.indexOf("rgb") > -1 && (n2 = x.rgb2hex(n2)), h2.drawGradient(d2, g2, n2, u5, p2, l2.size, o2.gradient.stops, o2.gradient.colorStops, r2);
      } }]), t2;
    }();
    var H = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "setGlobalMarkerSize", value: function() {
        var t3 = this.w;
        if (t3.globals.markers.size = Array.isArray(t3.config.markers.size) ? t3.config.markers.size : [t3.config.markers.size], t3.globals.markers.size.length > 0) {
          if (t3.globals.markers.size.length < t3.globals.series.length + 1)
            for (var e2 = 0; e2 <= t3.globals.series.length; e2++)
              void 0 === t3.globals.markers.size[e2] && t3.globals.markers.size.push(t3.globals.markers.size[0]);
        } else
          t3.globals.markers.size = t3.config.series.map(function(e3) {
            return t3.config.markers.size;
          });
      } }, { key: "plotChartMarkers", value: function(t3, e2, i2, a2) {
        var s2, r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o2 = this.w, n2 = e2, l2 = t3, h2 = null, c2 = new m(this.ctx), d2 = o2.config.markers.discrete && o2.config.markers.discrete.length;
        if ((o2.globals.markers.size[e2] > 0 || r2 || d2) && (h2 = c2.group({ class: r2 || d2 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(o2.globals.cuid, ")")), Array.isArray(l2.x))
          for (var g2 = 0; g2 < l2.x.length; g2++) {
            var u5 = i2;
            1 === i2 && 0 === g2 && (u5 = 0), 1 === i2 && 1 === g2 && (u5 = 1);
            var p2 = "apexcharts-marker";
            if ("line" !== o2.config.chart.type && "area" !== o2.config.chart.type || o2.globals.comboCharts || o2.config.tooltip.intersect || (p2 += " no-pointer-events"), (Array.isArray(o2.config.markers.size) ? o2.globals.markers.size[e2] > 0 : o2.config.markers.size > 0) || r2 || d2) {
              x.isNumber(l2.y[g2]) ? p2 += " w".concat(x.randomId()) : p2 = "apexcharts-nullpoint";
              var f2 = this.getMarkerConfig({ cssClass: p2, seriesIndex: e2, dataPointIndex: u5 });
              o2.config.series[n2].data[u5] && (o2.config.series[n2].data[u5].fillColor && (f2.pointFillColor = o2.config.series[n2].data[u5].fillColor), o2.config.series[n2].data[u5].strokeColor && (f2.pointStrokeColor = o2.config.series[n2].data[u5].strokeColor)), a2 && (f2.pSize = a2), (l2.x[g2] < 0 || l2.x[g2] > o2.globals.gridWidth || l2.y[g2] < -o2.globals.markers.largestSize || l2.y[g2] > o2.globals.gridHeight + o2.globals.markers.largestSize) && (f2.pSize = 0), (s2 = c2.drawMarker(l2.x[g2], l2.y[g2], f2)).attr("rel", u5), s2.attr("j", u5), s2.attr("index", e2), s2.node.setAttribute("default-marker-size", f2.pSize), new v(this.ctx).setSelectionFilter(s2, e2, u5), this.addEvents(s2), h2 && h2.add(s2);
            } else
              void 0 === o2.globals.pointsArray[e2] && (o2.globals.pointsArray[e2] = []), o2.globals.pointsArray[e2].push([l2.x[g2], l2.y[g2]]);
          }
        return h2;
      } }, { key: "getMarkerConfig", value: function(t3) {
        var e2 = t3.cssClass, i2 = t3.seriesIndex, a2 = t3.dataPointIndex, s2 = void 0 === a2 ? null : a2, r2 = t3.finishRadius, o2 = void 0 === r2 ? null : r2, n2 = this.w, l2 = this.getMarkerStyle(i2), h2 = n2.globals.markers.size[i2], c2 = n2.config.markers;
        return null !== s2 && c2.discrete.length && c2.discrete.map(function(t4) {
          t4.seriesIndex === i2 && t4.dataPointIndex === s2 && (l2.pointStrokeColor = t4.strokeColor, l2.pointFillColor = t4.fillColor, h2 = t4.size, l2.pointShape = t4.shape);
        }), { pSize: null === o2 ? h2 : o2, pRadius: c2.radius, width: Array.isArray(c2.width) ? c2.width[i2] : c2.width, height: Array.isArray(c2.height) ? c2.height[i2] : c2.height, pointStrokeWidth: Array.isArray(c2.strokeWidth) ? c2.strokeWidth[i2] : c2.strokeWidth, pointStrokeColor: l2.pointStrokeColor, pointFillColor: l2.pointFillColor, shape: l2.pointShape || (Array.isArray(c2.shape) ? c2.shape[i2] : c2.shape), class: e2, pointStrokeOpacity: Array.isArray(c2.strokeOpacity) ? c2.strokeOpacity[i2] : c2.strokeOpacity, pointStrokeDashArray: Array.isArray(c2.strokeDashArray) ? c2.strokeDashArray[i2] : c2.strokeDashArray, pointFillOpacity: Array.isArray(c2.fillOpacity) ? c2.fillOpacity[i2] : c2.fillOpacity, seriesIndex: i2 };
      } }, { key: "addEvents", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx);
        t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this.ctx, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this.ctx, t3)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this.ctx, t3)), t3.node.addEventListener("click", e2.config.markers.onClick), t3.node.addEventListener("dblclick", e2.config.markers.onDblClick), t3.node.addEventListener("touchstart", i2.pathMouseDown.bind(this.ctx, t3), { passive: true });
      } }, { key: "getMarkerStyle", value: function(t3) {
        var e2 = this.w, i2 = e2.globals.markers.colors, a2 = e2.config.markers.strokeColor || e2.config.markers.strokeColors;
        return { pointStrokeColor: Array.isArray(a2) ? a2[t3] : a2, pointFillColor: Array.isArray(i2) ? i2[t3] : i2 };
      } }]), t2;
    }();
    var D = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
      }
      return r(t2, [{ key: "draw", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = new m(this.ctx), r2 = i2.realIndex, o2 = i2.pointsPos, n2 = i2.zRatio, l2 = i2.elParent, h2 = s2.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a2.config.chart.type) });
        if (h2.attr("clip-path", "url(#gridRectMarkerMask".concat(a2.globals.cuid, ")")), Array.isArray(o2.x))
          for (var c2 = 0; c2 < o2.x.length; c2++) {
            var d2 = e2 + 1, g2 = true;
            0 === e2 && 0 === c2 && (d2 = 0), 0 === e2 && 1 === c2 && (d2 = 1);
            var u5 = 0, p2 = a2.globals.markers.size[r2];
            if (n2 !== 1 / 0) {
              var f2 = a2.config.plotOptions.bubble;
              p2 = a2.globals.seriesZ[r2][d2], f2.zScaling && (p2 /= n2), f2.minBubbleRadius && p2 < f2.minBubbleRadius && (p2 = f2.minBubbleRadius), f2.maxBubbleRadius && p2 > f2.maxBubbleRadius && (p2 = f2.maxBubbleRadius);
            }
            a2.config.chart.animations.enabled || (u5 = p2);
            var x2 = o2.x[c2], b2 = o2.y[c2];
            if (u5 = u5 || 0, null !== b2 && void 0 !== a2.globals.series[r2][d2] || (g2 = false), g2) {
              var v2 = this.drawPoint(x2, b2, u5, p2, r2, d2, e2);
              h2.add(v2);
            }
            l2.add(h2);
          }
      } }, { key: "drawPoint", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = this.w, l2 = s2, h2 = new b(this.ctx), c2 = new v(this.ctx), d2 = new R(this.ctx), g2 = new H(this.ctx), u5 = new m(this.ctx), p2 = g2.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: l2, dataPointIndex: r2, finishRadius: "bubble" === n2.config.chart.type || n2.globals.comboCharts && n2.config.series[s2] && "bubble" === n2.config.series[s2].type ? a2 : null });
        a2 = p2.pSize;
        var f2, x2 = d2.fillPath({ seriesNumber: s2, dataPointIndex: r2, color: p2.pointFillColor, patternUnits: "objectBoundingBox", value: n2.globals.series[s2][o2] });
        if ("circle" === p2.shape ? f2 = u5.drawCircle(i2) : "square" !== p2.shape && "rect" !== p2.shape || (f2 = u5.drawRect(0, 0, p2.width - p2.pointStrokeWidth / 2, p2.height - p2.pointStrokeWidth / 2, p2.pRadius)), n2.config.series[l2].data[r2] && n2.config.series[l2].data[r2].fillColor && (x2 = n2.config.series[l2].data[r2].fillColor), f2.attr({ x: t3 - p2.width / 2 - p2.pointStrokeWidth / 2, y: e2 - p2.height / 2 - p2.pointStrokeWidth / 2, cx: t3, cy: e2, fill: x2, "fill-opacity": p2.pointFillOpacity, stroke: p2.pointStrokeColor, r: a2, "stroke-width": p2.pointStrokeWidth, "stroke-dasharray": p2.pointStrokeDashArray, "stroke-opacity": p2.pointStrokeOpacity }), n2.config.chart.dropShadow.enabled) {
          var y2 = n2.config.chart.dropShadow;
          c2.dropShadow(f2, y2, s2);
        }
        if (!this.initialAnim || n2.globals.dataChanged || n2.globals.resized)
          n2.globals.animationEnded = true;
        else {
          var w2 = n2.config.chart.animations.speed;
          h2.animateMarker(f2, 0, "circle" === p2.shape ? a2 : { width: p2.width, height: p2.height }, w2, n2.globals.easing, function() {
            window.setTimeout(function() {
              h2.animationCompleted(f2);
            }, 100);
          });
        }
        if (n2.globals.dataChanged && "circle" === p2.shape)
          if (this.dynamicAnim) {
            var k2, A2, S2, C2, L2 = n2.config.chart.animations.dynamicAnimation.speed;
            null != (C2 = n2.globals.previousPaths[s2] && n2.globals.previousPaths[s2][o2]) && (k2 = C2.x, A2 = C2.y, S2 = void 0 !== C2.r ? C2.r : a2);
            for (var P2 = 0; P2 < n2.globals.collapsedSeries.length; P2++)
              n2.globals.collapsedSeries[P2].index === s2 && (L2 = 1, a2 = 0);
            0 === t3 && 0 === e2 && (a2 = 0), h2.animateCircle(f2, { cx: k2, cy: A2, r: S2 }, { cx: t3, cy: e2, r: a2 }, L2, n2.globals.easing);
          } else
            f2.attr({ r: a2 });
        return f2.attr({ rel: r2, j: r2, index: s2, "default-marker-size": a2 }), c2.setSelectionFilter(f2, s2, r2), g2.addEvents(f2), f2.node.classList.add("apexcharts-marker"), f2;
      } }, { key: "centerTextInBubble", value: function(t3) {
        var e2 = this.w;
        return { y: t3 += parseInt(e2.config.dataLabels.style.fontSize, 10) / 4 };
      } }]), t2;
    }();
    var O = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "dataLabelsCorrection", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = this.w, l2 = false, h2 = new m(this.ctx).getTextRects(i2, o2), c2 = h2.width, d2 = h2.height;
        e2 < 0 && (e2 = 0), e2 > n2.globals.gridHeight + d2 && (e2 = n2.globals.gridHeight + d2 / 2), void 0 === n2.globals.dataLabelsRects[a2] && (n2.globals.dataLabelsRects[a2] = []), n2.globals.dataLabelsRects[a2].push({ x: t3, y: e2, width: c2, height: d2 });
        var g2 = n2.globals.dataLabelsRects[a2].length - 2, u5 = void 0 !== n2.globals.lastDrawnDataLabelsIndexes[a2] ? n2.globals.lastDrawnDataLabelsIndexes[a2][n2.globals.lastDrawnDataLabelsIndexes[a2].length - 1] : 0;
        if (void 0 !== n2.globals.dataLabelsRects[a2][g2]) {
          var p2 = n2.globals.dataLabelsRects[a2][u5];
          (t3 > p2.x + p2.width || e2 > p2.y + p2.height || e2 + d2 < p2.y || t3 + c2 < p2.x) && (l2 = true);
        }
        return (0 === s2 || r2) && (l2 = true), { x: t3, y: e2, textRects: h2, drawnextLabel: l2 };
      } }, { key: "drawDataLabel", value: function(t3) {
        var e2 = this, i2 = t3.type, a2 = t3.pos, s2 = t3.i, r2 = t3.j, o2 = t3.isRangeStart, n2 = t3.strokeWidth, l2 = void 0 === n2 ? 2 : n2, h2 = this.w, c2 = new m(this.ctx), d2 = h2.config.dataLabels, g2 = 0, u5 = 0, p2 = r2, f2 = null;
        if (!d2.enabled || !Array.isArray(a2.x))
          return f2;
        f2 = c2.group({ class: "apexcharts-data-labels" });
        for (var x2 = 0; x2 < a2.x.length; x2++)
          if (g2 = a2.x[x2] + d2.offsetX, u5 = a2.y[x2] + d2.offsetY + l2, !isNaN(g2)) {
            1 === r2 && 0 === x2 && (p2 = 0), 1 === r2 && 1 === x2 && (p2 = 1);
            var b2 = h2.globals.series[s2][p2];
            "rangeArea" === i2 && (b2 = o2 ? h2.globals.seriesRangeStart[s2][p2] : h2.globals.seriesRangeEnd[s2][p2]);
            var v2 = "", y2 = function(t4) {
              return h2.config.dataLabels.formatter(t4, { ctx: e2.ctx, seriesIndex: s2, dataPointIndex: p2, w: h2 });
            };
            if ("bubble" === h2.config.chart.type)
              v2 = y2(b2 = h2.globals.seriesZ[s2][p2]), u5 = a2.y[x2], u5 = new D(this.ctx).centerTextInBubble(u5, s2, p2).y;
            else
              void 0 !== b2 && (v2 = y2(b2));
            this.plotDataLabelsText({ x: g2, y: u5, text: v2, i: s2, j: p2, parent: f2, offsetCorrection: true, dataLabelsConfig: h2.config.dataLabels });
          }
        return f2;
      } }, { key: "plotDataLabelsText", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx), a2 = t3.x, s2 = t3.y, r2 = t3.i, o2 = t3.j, n2 = t3.text, l2 = t3.textAnchor, h2 = t3.fontSize, c2 = t3.parent, d2 = t3.dataLabelsConfig, g2 = t3.color, u5 = t3.alwaysDrawDataLabel, p2 = t3.offsetCorrection;
        if (!(Array.isArray(e2.config.dataLabels.enabledOnSeries) && e2.config.dataLabels.enabledOnSeries.indexOf(r2) < 0)) {
          var f2 = { x: a2, y: s2, drawnextLabel: true, textRects: null };
          p2 && (f2 = this.dataLabelsCorrection(a2, s2, n2, r2, o2, u5, parseInt(d2.style.fontSize, 10))), e2.globals.zoomed || (a2 = f2.x, s2 = f2.y), f2.textRects && (a2 < -20 - f2.textRects.width || a2 > e2.globals.gridWidth + f2.textRects.width + 30) && (n2 = "");
          var x2 = e2.globals.dataLabels.style.colors[r2];
          (("bar" === e2.config.chart.type || "rangeBar" === e2.config.chart.type) && e2.config.plotOptions.bar.distributed || e2.config.dataLabels.distributed) && (x2 = e2.globals.dataLabels.style.colors[o2]), "function" == typeof x2 && (x2 = x2({ series: e2.globals.series, seriesIndex: r2, dataPointIndex: o2, w: e2 })), g2 && (x2 = g2);
          var b2 = d2.offsetX, y2 = d2.offsetY;
          if ("bar" !== e2.config.chart.type && "rangeBar" !== e2.config.chart.type || (b2 = 0, y2 = 0), f2.drawnextLabel) {
            var w2 = i2.drawText({ width: 100, height: parseInt(d2.style.fontSize, 10), x: a2 + b2, y: s2 + y2, foreColor: x2, textAnchor: l2 || d2.textAnchor, text: n2, fontSize: h2 || d2.style.fontSize, fontFamily: d2.style.fontFamily, fontWeight: d2.style.fontWeight || "normal" });
            if (w2.attr({ class: "apexcharts-datalabel", cx: a2, cy: s2 }), d2.dropShadow.enabled) {
              var k2 = d2.dropShadow;
              new v(this.ctx).dropShadow(w2, k2);
            }
            c2.add(w2), void 0 === e2.globals.lastDrawnDataLabelsIndexes[r2] && (e2.globals.lastDrawnDataLabelsIndexes[r2] = []), e2.globals.lastDrawnDataLabelsIndexes[r2].push(o2);
          }
        }
      } }, { key: "addBackgroundToDataLabel", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.config.dataLabels.background, s2 = a2.padding, r2 = a2.padding / 2, o2 = e2.width, n2 = e2.height, l2 = new m(this.ctx).drawRect(e2.x - s2, e2.y - r2 / 2, o2 + 2 * s2, n2 + r2, a2.borderRadius, "transparent" === i2.config.chart.background ? "#fff" : i2.config.chart.background, a2.opacity, a2.borderWidth, a2.borderColor);
        a2.dropShadow.enabled && new v(this.ctx).dropShadow(l2, a2.dropShadow);
        return l2;
      } }, { key: "dataLabelsBackground", value: function() {
        var t3 = this.w;
        if ("bubble" !== t3.config.chart.type)
          for (var e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i2 = 0; i2 < e2.length; i2++) {
            var a2 = e2[i2], s2 = a2.getBBox(), r2 = null;
            if (s2.width && s2.height && (r2 = this.addBackgroundToDataLabel(a2, s2)), r2) {
              a2.parentNode.insertBefore(r2.node, a2);
              var o2 = a2.getAttribute("fill");
              t3.config.chart.animations.enabled && !t3.globals.resized && !t3.globals.dataChanged ? r2.animate().attr({ fill: o2 }) : r2.attr({ fill: o2 }), a2.setAttribute("fill", t3.config.dataLabels.background.foreColor);
            }
          }
      } }, { key: "bringForward", value: function() {
        for (var t3 = this.w, e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a2 = 0; a2 < e2.length; a2++)
          i2 && i2.insertBefore(e2[a2], i2.nextSibling);
      } }]), t2;
    }();
    var N = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.legendInactiveClass = "legend-mouseover-inactive";
      }
      return r(t2, [{ key: "getAllSeriesEls", value: function() {
        return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
      } }, { key: "getSeriesByName", value: function(t3) {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(x.escapeString(t3), "']"));
      } }, { key: "isSeriesHidden", value: function(t3) {
        var e2 = this.getSeriesByName(t3), i2 = parseInt(e2.getAttribute("data:realIndex"), 10);
        return { isHidden: e2.classList.contains("apexcharts-series-collapsed"), realIndex: i2 };
      } }, { key: "addCollapsedClassToSeries", value: function(t3, e2) {
        var i2 = this.w;
        function a2(i3) {
          for (var a3 = 0; a3 < i3.length; a3++)
            i3[a3].index === e2 && t3.node.classList.add("apexcharts-series-collapsed");
        }
        a2(i2.globals.collapsedSeries), a2(i2.globals.ancillaryCollapsedSeries);
      } }, { key: "toggleSeries", value: function(t3) {
        var e2 = this.isSeriesHidden(t3);
        return this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, e2.isHidden), e2.isHidden;
      } }, { key: "showSeries", value: function(t3) {
        var e2 = this.isSeriesHidden(t3);
        e2.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, true);
      } }, { key: "hideSeries", value: function(t3) {
        var e2 = this.isSeriesHidden(t3);
        e2.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, false);
      } }, { key: "resetSeries", value: function() {
        var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = this.w, s2 = x.clone(a2.globals.initialSeries);
        a2.globals.previousPaths = [], i2 ? (a2.globals.collapsedSeries = [], a2.globals.ancillaryCollapsedSeries = [], a2.globals.collapsedSeriesIndices = [], a2.globals.ancillaryCollapsedSeriesIndices = []) : s2 = this.emptyCollapsedSeries(s2), a2.config.series = s2, t3 && (e2 && (a2.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled));
      } }, { key: "emptyCollapsedSeries", value: function(t3) {
        for (var e2 = this.w, i2 = 0; i2 < t3.length; i2++)
          e2.globals.collapsedSeriesIndices.indexOf(i2) > -1 && (t3[i2].data = []);
        return t3;
      } }, { key: "toggleSeriesOnHover", value: function(t3, e2) {
        var i2 = this.w;
        e2 || (e2 = t3.target);
        var a2 = i2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
        if ("mousemove" === t3.type) {
          var s2 = parseInt(e2.getAttribute("rel"), 10) - 1, r2 = null, o2 = null;
          i2.globals.axisCharts || "radialBar" === i2.config.chart.type ? i2.globals.axisCharts ? (r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s2, "']")), o2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s2, "']"))) : r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s2 + 1, "']")) : r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s2 + 1, "'] path"));
          for (var n2 = 0; n2 < a2.length; n2++)
            a2[n2].classList.add(this.legendInactiveClass);
          null !== r2 && (i2.globals.axisCharts || r2.parentNode.classList.remove(this.legendInactiveClass), r2.classList.remove(this.legendInactiveClass), null !== o2 && o2.classList.remove(this.legendInactiveClass));
        } else if ("mouseout" === t3.type)
          for (var l2 = 0; l2 < a2.length; l2++)
            a2[l2].classList.remove(this.legendInactiveClass);
      } }, { key: "highlightRangeInSeries", value: function(t3, e2) {
        var i2 = this, a2 = this.w, s2 = a2.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r2 = function(t4) {
          for (var e3 = 0; e3 < s2.length; e3++)
            s2[e3].classList[t4](i2.legendInactiveClass);
        };
        if ("mousemove" === t3.type) {
          var o2 = parseInt(e2.getAttribute("rel"), 10) - 1;
          r2("add"), function(t4) {
            for (var e3 = 0; e3 < s2.length; e3++) {
              var a3 = parseInt(s2[e3].getAttribute("val"), 10);
              a3 >= t4.from && a3 <= t4.to && s2[e3].classList.remove(i2.legendInactiveClass);
            }
          }(a2.config.plotOptions.heatmap.colorScale.ranges[o2]);
        } else
          "mouseout" === t3.type && r2("remove");
      } }, { key: "getActiveConfigSeriesIndex", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc", e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i2 = this.w, a2 = 0;
        if (i2.config.series.length > 1) {
          for (var s2 = i2.config.series.map(function(t4, a3) {
            return t4.data && t4.data.length > 0 && -1 === i2.globals.collapsedSeriesIndices.indexOf(a3) && (!i2.globals.comboCharts || 0 === e2.length || e2.length && e2.indexOf(i2.config.series[a3].type) > -1) ? a3 : -1;
          }), r2 = "asc" === t3 ? 0 : s2.length - 1; "asc" === t3 ? r2 < s2.length : r2 >= 0; "asc" === t3 ? r2++ : r2--)
            if (-1 !== s2[r2]) {
              a2 = s2[r2];
              break;
            }
        }
        return a2;
      } }, { key: "getBarSeriesIndices", value: function() {
        return this.w.globals.comboCharts ? this.w.config.series.map(function(t3, e2) {
          return "bar" === t3.type || "column" === t3.type ? e2 : -1;
        }).filter(function(t3) {
          return -1 !== t3;
        }) : this.w.config.series.map(function(t3, e2) {
          return e2;
        });
      } }, { key: "getPreviousPaths", value: function() {
        var t3 = this.w;
        function e2(e3, i3, a3) {
          for (var s3 = e3[i3].childNodes, r2 = { type: a3, paths: [], realIndex: e3[i3].getAttribute("data:realIndex") }, o2 = 0; o2 < s3.length; o2++)
            if (s3[o2].hasAttribute("pathTo")) {
              var n2 = s3[o2].getAttribute("pathTo");
              r2.paths.push({ d: n2 });
            }
          t3.globals.previousPaths.push(r2);
        }
        t3.globals.previousPaths = [];
        ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(i3) {
          for (var a3, s3 = (a3 = i3, t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a3, "-series .apexcharts-series"))), r2 = 0; r2 < s3.length; r2++)
            e2(s3, r2, i3);
        }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
        var i2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series"));
        if (i2.length > 0)
          for (var a2 = function(e3) {
            for (var i3 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e3, "'] rect")), a3 = [], s3 = function(t4) {
              var e4 = function(e5) {
                return i3[t4].getAttribute(e5);
              }, s4 = { x: parseFloat(e4("x")), y: parseFloat(e4("y")), width: parseFloat(e4("width")), height: parseFloat(e4("height")) };
              a3.push({ rect: s4, color: i3[t4].getAttribute("color") });
            }, r2 = 0; r2 < i3.length; r2++)
              s3(r2);
            t3.globals.previousPaths.push(a3);
          }, s2 = 0; s2 < i2.length; s2++)
            a2(s2);
        t3.globals.axisCharts || (t3.globals.previousPaths = t3.globals.series);
      } }, { key: "handlePrevBubbleScatterPaths", value: function(t3) {
        var e2 = this.w, i2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3, "-series .apexcharts-series"));
        if (i2.length > 0)
          for (var a2 = 0; a2 < i2.length; a2++) {
            for (var s2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3, "-series .apexcharts-series[data\\:realIndex='").concat(a2, "'] circle")), r2 = [], o2 = 0; o2 < s2.length; o2++)
              r2.push({ x: s2[o2].getAttribute("cx"), y: s2[o2].getAttribute("cy"), r: s2[o2].getAttribute("r") });
            e2.globals.previousPaths.push(r2);
          }
      } }, { key: "clearPreviousPaths", value: function() {
        var t3 = this.w;
        t3.globals.previousPaths = [], t3.globals.allSeriesCollapsed = false;
      } }, { key: "handleNoData", value: function() {
        var t3 = this.w, e2 = t3.config.noData, i2 = new m(this.ctx), a2 = t3.globals.svgWidth / 2, s2 = t3.globals.svgHeight / 2, r2 = "middle";
        if (t3.globals.noData = true, t3.globals.animationEnded = true, "left" === e2.align ? (a2 = 10, r2 = "start") : "right" === e2.align && (a2 = t3.globals.svgWidth - 10, r2 = "end"), "top" === e2.verticalAlign ? s2 = 50 : "bottom" === e2.verticalAlign && (s2 = t3.globals.svgHeight - 50), a2 += e2.offsetX, s2 = s2 + parseInt(e2.style.fontSize, 10) + 2 + e2.offsetY, void 0 !== e2.text && "" !== e2.text) {
          var o2 = i2.drawText({ x: a2, y: s2, text: e2.text, textAnchor: r2, fontSize: e2.style.fontSize, fontFamily: e2.style.fontFamily, foreColor: e2.style.color, opacity: 1, class: "apexcharts-text-nodata" });
          t3.globals.dom.Paper.add(o2);
        }
      } }, { key: "setNullSeriesToZeroValues", value: function(t3) {
        for (var e2 = this.w, i2 = 0; i2 < t3.length; i2++)
          if (0 === t3[i2].length)
            for (var a2 = 0; a2 < t3[e2.globals.maxValsInArrayIndex].length; a2++)
              t3[i2].push(0);
        return t3;
      } }, { key: "hasAllSeriesEqualX", value: function() {
        for (var t3 = true, e2 = this.w, i2 = this.filteredSeriesX(), a2 = 0; a2 < i2.length - 1; a2++)
          if (i2[a2][0] !== i2[a2 + 1][0]) {
            t3 = false;
            break;
          }
        return e2.globals.allSeriesHasEqualX = t3, t3;
      } }, { key: "filteredSeriesX", value: function() {
        var t3 = this.w.globals.seriesX.map(function(t4) {
          return t4.length > 0 ? t4 : [];
        });
        return t3;
      } }]), t2;
    }();
    var W = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new y(this.ctx);
      }
      return r(t2, [{ key: "isMultiFormat", value: function() {
        return this.isFormatXY() || this.isFormat2DArray();
      } }, { key: "isFormatXY", value: function() {
        var t3 = this.w.config.series.slice(), e2 = new N(this.ctx);
        if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data && t3[this.activeSeriesIndex].data.length > 0 && null !== t3[this.activeSeriesIndex].data[0] && void 0 !== t3[this.activeSeriesIndex].data[0].x && null !== t3[this.activeSeriesIndex].data[0])
          return true;
      } }, { key: "isFormat2DArray", value: function() {
        var t3 = this.w.config.series.slice(), e2 = new N(this.ctx);
        if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data && t3[this.activeSeriesIndex].data.length > 0 && void 0 !== t3[this.activeSeriesIndex].data[0] && null !== t3[this.activeSeriesIndex].data[0] && t3[this.activeSeriesIndex].data[0].constructor === Array)
          return true;
      } }, { key: "handleFormat2DArray", value: function(t3, e2) {
        for (var i2 = this.w.config, a2 = this.w.globals, s2 = "boxPlot" === i2.chart.type || "boxPlot" === i2.series[e2].type, r2 = 0; r2 < t3[e2].data.length; r2++)
          if (void 0 !== t3[e2].data[r2][1] && (Array.isArray(t3[e2].data[r2][1]) && 4 === t3[e2].data[r2][1].length && !s2 ? this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][1][3])) : t3[e2].data[r2].length >= 5 ? this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][4])) : this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][1])), a2.dataFormatXNumeric = true), "datetime" === i2.xaxis.type) {
            var o2 = new Date(t3[e2].data[r2][0]);
            o2 = new Date(o2).getTime(), this.twoDSeriesX.push(o2);
          } else
            this.twoDSeriesX.push(t3[e2].data[r2][0]);
        for (var n2 = 0; n2 < t3[e2].data.length; n2++)
          void 0 !== t3[e2].data[n2][2] && (this.threeDSeries.push(t3[e2].data[n2][2]), a2.isDataXYZ = true);
      } }, { key: "handleFormatXY", value: function(t3, e2) {
        var i2 = this.w.config, a2 = this.w.globals, s2 = new I(this.ctx), r2 = e2;
        a2.collapsedSeriesIndices.indexOf(e2) > -1 && (r2 = this.activeSeriesIndex);
        for (var o2 = 0; o2 < t3[e2].data.length; o2++)
          void 0 !== t3[e2].data[o2].y && (Array.isArray(t3[e2].data[o2].y) ? this.twoDSeries.push(x.parseNumber(t3[e2].data[o2].y[t3[e2].data[o2].y.length - 1])) : this.twoDSeries.push(x.parseNumber(t3[e2].data[o2].y))), void 0 !== t3[e2].data[o2].goals && Array.isArray(t3[e2].data[o2].goals) ? (void 0 === this.seriesGoals[e2] && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(t3[e2].data[o2].goals)) : (void 0 === this.seriesGoals[e2] && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(null));
        for (var n2 = 0; n2 < t3[r2].data.length; n2++) {
          var l2 = "string" == typeof t3[r2].data[n2].x, h2 = Array.isArray(t3[r2].data[n2].x), c2 = !h2 && !!s2.isValidDate(t3[r2].data[n2].x);
          if (l2 || c2)
            if (l2 || i2.xaxis.convertedCatToNumeric) {
              var d2 = a2.isBarHorizontal && a2.isRangeData;
              "datetime" !== i2.xaxis.type || d2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[n2].x), isNaN(t3[r2].data[n2].x) || "category" === this.w.config.xaxis.type || "string" == typeof t3[r2].data[n2].x || (a2.isXNumeric = true)) : this.twoDSeriesX.push(s2.parseDate(t3[r2].data[n2].x));
            } else
              "datetime" === i2.xaxis.type ? this.twoDSeriesX.push(s2.parseDate(t3[r2].data[n2].x.toString())) : (a2.dataFormatXNumeric = true, a2.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t3[r2].data[n2].x)));
          else
            h2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[n2].x)) : (a2.isXNumeric = true, a2.dataFormatXNumeric = true, this.twoDSeriesX.push(t3[r2].data[n2].x));
        }
        if (t3[e2].data[0] && void 0 !== t3[e2].data[0].z) {
          for (var g2 = 0; g2 < t3[e2].data.length; g2++)
            this.threeDSeries.push(t3[e2].data[g2].z);
          a2.isDataXYZ = true;
        }
      } }, { key: "handleRangeData", value: function(t3, e2) {
        var i2 = this.w.globals, a2 = {};
        return this.isFormat2DArray() ? a2 = this.handleRangeDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleRangeDataFormat("xy", t3, e2)), i2.seriesRangeStart.push(a2.start), i2.seriesRangeEnd.push(a2.end), i2.seriesRange.push(a2.rangeUniques), i2.seriesRange.forEach(function(t4, e3) {
          t4 && t4.forEach(function(t5, e4) {
            t5.y.forEach(function(e5, i3) {
              for (var a3 = 0; a3 < t5.y.length; a3++)
                if (i3 !== a3) {
                  var s2 = e5.y1, r2 = e5.y2, o2 = t5.y[a3].y1;
                  s2 <= t5.y[a3].y2 && o2 <= r2 && (t5.overlaps.indexOf(e5.rangeName) < 0 && t5.overlaps.push(e5.rangeName), t5.overlaps.indexOf(t5.y[a3].rangeName) < 0 && t5.overlaps.push(t5.y[a3].rangeName));
                }
            });
          });
        }), a2;
      } }, { key: "handleCandleStickBoxData", value: function(t3, e2) {
        var i2 = this.w.globals, a2 = {};
        return this.isFormat2DArray() ? a2 = this.handleCandleStickBoxDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleCandleStickBoxDataFormat("xy", t3, e2)), i2.seriesCandleO[e2] = a2.o, i2.seriesCandleH[e2] = a2.h, i2.seriesCandleM[e2] = a2.m, i2.seriesCandleL[e2] = a2.l, i2.seriesCandleC[e2] = a2.c, a2;
      } }, { key: "handleRangeDataFormat", value: function(t3, e2, i2) {
        var a2 = [], s2 = [], r2 = e2[i2].data.filter(function(t4, e3, i3) {
          return e3 === i3.findIndex(function(e4) {
            return e4.x === t4.x;
          });
        }).map(function(t4, e3) {
          return { x: t4.x, overlaps: [], y: [] };
        });
        if ("array" === t3)
          for (var o2 = 0; o2 < e2[i2].data.length; o2++)
            Array.isArray(e2[i2].data[o2]) ? (a2.push(e2[i2].data[o2][1][0]), s2.push(e2[i2].data[o2][1][1])) : (a2.push(e2[i2].data[o2]), s2.push(e2[i2].data[o2]));
        else if ("xy" === t3)
          for (var n2 = function(t4) {
            var o3 = Array.isArray(e2[i2].data[t4].y), n3 = x.randomId(), l3 = e2[i2].data[t4].x, h2 = { y1: o3 ? e2[i2].data[t4].y[0] : e2[i2].data[t4].y, y2: o3 ? e2[i2].data[t4].y[1] : e2[i2].data[t4].y, rangeName: n3 };
            e2[i2].data[t4].rangeName = n3;
            var c2 = r2.findIndex(function(t5) {
              return t5.x === l3;
            });
            r2[c2].y.push(h2), a2.push(h2.y1), s2.push(h2.y2);
          }, l2 = 0; l2 < e2[i2].data.length; l2++)
            n2(l2);
        return { start: a2, end: s2, rangeUniques: r2 };
      } }, { key: "handleCandleStickBoxDataFormat", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = "boxPlot" === a2.config.chart.type || "boxPlot" === a2.config.series[i2].type, r2 = [], o2 = [], n2 = [], l2 = [], h2 = [];
        if ("array" === t3)
          if (s2 && 6 === e2[i2].data[0].length || !s2 && 5 === e2[i2].data[0].length)
            for (var c2 = 0; c2 < e2[i2].data.length; c2++)
              r2.push(e2[i2].data[c2][1]), o2.push(e2[i2].data[c2][2]), s2 ? (n2.push(e2[i2].data[c2][3]), l2.push(e2[i2].data[c2][4]), h2.push(e2[i2].data[c2][5])) : (l2.push(e2[i2].data[c2][3]), h2.push(e2[i2].data[c2][4]));
          else
            for (var d2 = 0; d2 < e2[i2].data.length; d2++)
              Array.isArray(e2[i2].data[d2][1]) && (r2.push(e2[i2].data[d2][1][0]), o2.push(e2[i2].data[d2][1][1]), s2 ? (n2.push(e2[i2].data[d2][1][2]), l2.push(e2[i2].data[d2][1][3]), h2.push(e2[i2].data[d2][1][4])) : (l2.push(e2[i2].data[d2][1][2]), h2.push(e2[i2].data[d2][1][3])));
        else if ("xy" === t3)
          for (var g2 = 0; g2 < e2[i2].data.length; g2++)
            Array.isArray(e2[i2].data[g2].y) && (r2.push(e2[i2].data[g2].y[0]), o2.push(e2[i2].data[g2].y[1]), s2 ? (n2.push(e2[i2].data[g2].y[2]), l2.push(e2[i2].data[g2].y[3]), h2.push(e2[i2].data[g2].y[4])) : (l2.push(e2[i2].data[g2].y[2]), h2.push(e2[i2].data[g2].y[3])));
        return { o: r2, h: o2, m: n2, l: l2, c: h2 };
      } }, { key: "parseDataAxisCharts", value: function(t3) {
        var e2, i2 = this, a2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, s2 = this.w.config, r2 = this.w.globals, o2 = new I(a2), n2 = s2.labels.length > 0 ? s2.labels.slice() : s2.xaxis.categories.slice();
        if (r2.isRangeBar = "rangeBar" === s2.chart.type && r2.isBarHorizontal, r2.hasXaxisGroups = "category" === s2.xaxis.type && s2.xaxis.group.groups.length > 0, r2.hasXaxisGroups && (r2.groups = s2.xaxis.group.groups), r2.hasSeriesGroups = null === (e2 = t3[0]) || void 0 === e2 ? void 0 : e2.group, r2.hasSeriesGroups) {
          var l2 = [], h2 = u4(new Set(t3.map(function(t4) {
            return t4.group;
          })));
          t3.forEach(function(t4, e3) {
            var i3 = h2.indexOf(t4.group);
            l2[i3] || (l2[i3] = []), l2[i3].push(t4.name);
          }), r2.seriesGroups = l2;
        }
        for (var c2 = function() {
          for (var t4 = 0; t4 < n2.length; t4++)
            if ("string" == typeof n2[t4]) {
              if (!o2.isValidDate(n2[t4]))
                throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
              i2.twoDSeriesX.push(o2.parseDate(n2[t4]));
            } else
              i2.twoDSeriesX.push(n2[t4]);
        }, d2 = 0; d2 < t3.length; d2++) {
          if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t3[d2].data)
            return void console.error("It is a possibility that you may have not included 'data' property in series.");
          if ("rangeBar" !== s2.chart.type && "rangeArea" !== s2.chart.type && "rangeBar" !== t3[d2].type && "rangeArea" !== t3[d2].type || (r2.isRangeData = true, "rangeBar" !== s2.chart.type && "rangeArea" !== s2.chart.type || this.handleRangeData(t3, d2)), this.isMultiFormat())
            this.isFormat2DArray() ? this.handleFormat2DArray(t3, d2) : this.isFormatXY() && this.handleFormatXY(t3, d2), "candlestick" !== s2.chart.type && "candlestick" !== t3[d2].type && "boxPlot" !== s2.chart.type && "boxPlot" !== t3[d2].type || this.handleCandleStickBoxData(t3, d2), r2.series.push(this.twoDSeries), r2.labels.push(this.twoDSeriesX), r2.seriesX.push(this.twoDSeriesX), r2.seriesGoals = this.seriesGoals, d2 !== this.activeSeriesIndex || this.fallbackToCategory || (r2.isXNumeric = true);
          else {
            "datetime" === s2.xaxis.type ? (r2.isXNumeric = true, c2(), r2.seriesX.push(this.twoDSeriesX)) : "numeric" === s2.xaxis.type && (r2.isXNumeric = true, n2.length > 0 && (this.twoDSeriesX = n2, r2.seriesX.push(this.twoDSeriesX))), r2.labels.push(this.twoDSeriesX);
            var g2 = t3[d2].data.map(function(t4) {
              return x.parseNumber(t4);
            });
            r2.series.push(g2);
          }
          r2.seriesZ.push(this.threeDSeries), void 0 !== t3[d2].name ? r2.seriesNames.push(t3[d2].name) : r2.seriesNames.push("series-" + parseInt(d2 + 1, 10)), void 0 !== t3[d2].color ? r2.seriesColors.push(t3[d2].color) : r2.seriesColors.push(void 0);
        }
        return this.w;
      } }, { key: "parseDataNonAxisCharts", value: function(t3) {
        var e2 = this.w.globals, i2 = this.w.config;
        e2.series = t3.slice(), e2.seriesNames = i2.labels.slice();
        for (var a2 = 0; a2 < e2.series.length; a2++)
          void 0 === e2.seriesNames[a2] && e2.seriesNames.push("series-" + (a2 + 1));
        return this.w;
      } }, { key: "handleExternalLabelsData", value: function(t3) {
        var e2 = this.w.config, i2 = this.w.globals;
        if (e2.xaxis.categories.length > 0)
          i2.labels = e2.xaxis.categories;
        else if (e2.labels.length > 0)
          i2.labels = e2.labels.slice();
        else if (this.fallbackToCategory) {
          if (i2.labels = i2.labels[0], i2.seriesRange.length && (i2.seriesRange.map(function(t4) {
            t4.forEach(function(t5) {
              i2.labels.indexOf(t5.x) < 0 && t5.x && i2.labels.push(t5.x);
            });
          }), i2.labels = Array.from(new Set(i2.labels.map(JSON.stringify)), JSON.parse)), e2.xaxis.convertedCatToNumeric)
            new X(e2).convertCatToNumericXaxis(e2, this.ctx, i2.seriesX[0]), this._generateExternalLabels(t3);
        } else
          this._generateExternalLabels(t3);
      } }, { key: "_generateExternalLabels", value: function(t3) {
        var e2 = this.w.globals, i2 = this.w.config, a2 = [];
        if (e2.axisCharts) {
          if (e2.series.length > 0)
            if (this.isFormatXY())
              for (var s2 = i2.series.map(function(t4, e3) {
                return t4.data.filter(function(t5, e4, i3) {
                  return i3.findIndex(function(e5) {
                    return e5.x === t5.x;
                  }) === e4;
                });
              }), r2 = s2.reduce(function(t4, e3, i3, a3) {
                return a3[t4].length > e3.length ? t4 : i3;
              }, 0), o2 = 0; o2 < s2[r2].length; o2++)
                a2.push(o2 + 1);
            else
              for (var n2 = 0; n2 < e2.series[e2.maxValsInArrayIndex].length; n2++)
                a2.push(n2 + 1);
          e2.seriesX = [];
          for (var l2 = 0; l2 < t3.length; l2++)
            e2.seriesX.push(a2);
          this.w.globals.isBarHorizontal || (e2.isXNumeric = true);
        }
        if (0 === a2.length) {
          a2 = e2.axisCharts ? [] : e2.series.map(function(t4, e3) {
            return e3 + 1;
          });
          for (var h2 = 0; h2 < t3.length; h2++)
            e2.seriesX.push(a2);
        }
        e2.labels = a2, i2.xaxis.convertedCatToNumeric && (e2.categoryLabels = a2.map(function(t4) {
          return i2.xaxis.labels.formatter(t4);
        })), e2.noLabelsProvided = true;
      } }, { key: "parseData", value: function(t3) {
        var e2 = this.w, i2 = e2.config, a2 = e2.globals;
        if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a2.axisCharts ? (this.parseDataAxisCharts(t3), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t3), i2.chart.stacked) {
          var s2 = new N(this.ctx);
          a2.series = s2.setNullSeriesToZeroValues(a2.series);
        }
        this.coreUtils.getSeriesTotals(), a2.axisCharts && (a2.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a2.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a2.dataFormatXNumeric || a2.isXNumeric && ("numeric" !== i2.xaxis.type || 0 !== i2.labels.length || 0 !== i2.xaxis.categories.length) || this.handleExternalLabelsData(t3);
        for (var r2 = this.coreUtils.getCategoryLabels(a2.labels), o2 = 0; o2 < r2.length; o2++)
          if (Array.isArray(r2[o2])) {
            a2.isMultiLineX = true;
            break;
          }
      } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
        var t3 = this, e2 = this.w;
        e2.globals.ignoreYAxisIndexes = e2.globals.collapsedSeries.map(function(i2, a2) {
          if (t3.w.globals.isMultipleYAxis && !e2.config.chart.stacked)
            return i2.index;
        });
      } }]), t2;
    }();
    var B = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "getLabel", value: function(t3, e2, i2, a2) {
        var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", o2 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], n2 = this.w, l2 = void 0 === t3[a2] ? "" : t3[a2], h2 = l2, c2 = n2.globals.xLabelFormatter, d2 = n2.config.xaxis.labels.formatter, g2 = false, u5 = new T(this.ctx), p2 = l2;
        o2 && (h2 = u5.xLabelFormat(c2, l2, p2, { i: a2, dateFormatter: new I(this.ctx).formatDate, w: n2 }), void 0 !== d2 && (h2 = d2(l2, t3[a2], { i: a2, dateFormatter: new I(this.ctx).formatDate, w: n2 })));
        var f2, x2;
        e2.length > 0 ? (f2 = e2[a2].unit, x2 = null, e2.forEach(function(t4) {
          "month" === t4.unit ? x2 = "year" : "day" === t4.unit ? x2 = "month" : "hour" === t4.unit ? x2 = "day" : "minute" === t4.unit && (x2 = "hour");
        }), g2 = x2 === f2, i2 = e2[a2].position, h2 = e2[a2].value) : "datetime" === n2.config.xaxis.type && void 0 === d2 && (h2 = ""), void 0 === h2 && (h2 = ""), h2 = Array.isArray(h2) ? h2 : h2.toString();
        var b2 = new m(this.ctx), v2 = {};
        v2 = n2.globals.rotateXLabels && o2 ? b2.getTextRects(h2, parseInt(r2, 10), null, "rotate(".concat(n2.config.xaxis.labels.rotate, " 0 0)"), false) : b2.getTextRects(h2, parseInt(r2, 10));
        var y2 = !n2.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
        return !Array.isArray(h2) && (0 === h2.indexOf("NaN") || 0 === h2.toLowerCase().indexOf("invalid") || h2.toLowerCase().indexOf("infinity") >= 0 || s2.indexOf(h2) >= 0 && y2) && (h2 = ""), { x: i2, text: h2, textRect: v2, isBold: g2 };
      } }, { key: "checkLabelBasedOnTickamount", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = a2.config.xaxis.tickAmount;
        return "dataPoints" === s2 && (s2 = Math.round(a2.globals.gridWidth / 120)), s2 > i2 || t3 % Math.round(i2 / (s2 + 1)) == 0 || (e2.text = ""), e2;
      } }, { key: "checkForOverflowingLabels", value: function(t3, e2, i2, a2, s2) {
        var r2 = this.w;
        if (0 === t3 && r2.globals.skipFirstTimelinelabel && (e2.text = ""), t3 === i2 - 1 && r2.globals.skipLastTimelinelabel && (e2.text = ""), r2.config.xaxis.labels.hideOverlappingLabels && a2.length > 0) {
          var o2 = s2[s2.length - 1];
          e2.x < o2.textRect.width / (r2.globals.rotateXLabels ? Math.abs(r2.config.xaxis.labels.rotate) / 12 : 1.01) + o2.x && (e2.text = "");
        }
        return e2;
      } }, { key: "checkForReversedLabels", value: function(t3, e2) {
        var i2 = this.w;
        return i2.config.yaxis[t3] && i2.config.yaxis[t3].reversed && e2.reverse(), e2;
      } }, { key: "isYAxisHidden", value: function(t3) {
        var e2 = this.w, i2 = new y(this.ctx);
        return !e2.config.yaxis[t3].show || !e2.config.yaxis[t3].showForNullSeries && i2.isSeriesNull(t3) && -1 === e2.globals.collapsedSeriesIndices.indexOf(t3);
      } }, { key: "getYAxisForeColor", value: function(t3, e2) {
        var i2 = this.w;
        return Array.isArray(t3) && i2.globals.yAxisScale[e2] && this.ctx.theme.pushExtraColors(t3, i2.globals.yAxisScale[e2].result.length, false), t3;
      } }, { key: "drawYAxisTicks", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = this.w, l2 = new m(this.ctx), h2 = n2.globals.translateY;
        if (a2.show && e2 > 0) {
          true === n2.config.yaxis[s2].opposite && (t3 += a2.width);
          for (var c2 = e2; c2 >= 0; c2--) {
            var d2 = h2 + e2 / 10 + n2.config.yaxis[s2].labels.offsetY - 1;
            n2.globals.isBarHorizontal && (d2 = r2 * c2), "heatmap" === n2.config.chart.type && (d2 += r2 / 2);
            var g2 = l2.drawLine(t3 + i2.offsetX - a2.width + a2.offsetX, d2 + a2.offsetY, t3 + i2.offsetX + a2.offsetX, d2 + a2.offsetY, a2.color);
            o2.add(g2), h2 += r2;
          }
        }
      } }]), t2;
    }();
    var G = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "scaleSvgNode", value: function(t3, e2) {
        var i2 = parseFloat(t3.getAttributeNS(null, "width")), a2 = parseFloat(t3.getAttributeNS(null, "height"));
        t3.setAttributeNS(null, "width", i2 * e2), t3.setAttributeNS(null, "height", a2 * e2), t3.setAttributeNS(null, "viewBox", "0 0 " + i2 + " " + a2);
      } }, { key: "fixSvgStringForIe11", value: function(t3) {
        if (!x.isIE11())
          return t3.replace(/&nbsp;/g, "&#160;");
        var e2 = 0, i2 = t3.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(t4) {
          return 2 === ++e2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : t4;
        });
        return i2 = (i2 = i2.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
      } }, { key: "getSvgString", value: function(t3) {
        null == t3 && (t3 = 1);
        var e2 = this.w.globals.dom.Paper.svg();
        if (1 !== t3) {
          var i2 = this.w.globals.dom.Paper.node.cloneNode(true);
          this.scaleSvgNode(i2, t3), e2 = new XMLSerializer().serializeToString(i2);
        }
        return this.fixSvgStringForIe11(e2);
      } }, { key: "cleanup", value: function() {
        var t3 = this.w, e2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
        Array.prototype.forEach.call(a2, function(t4) {
          t4.setAttribute("width", 0);
        }), e2 && e2[0] && (e2[0].setAttribute("x", -500), e2[0].setAttribute("x1", -500), e2[0].setAttribute("x2", -500)), i2 && i2[0] && (i2[0].setAttribute("y", -100), i2[0].setAttribute("y1", -100), i2[0].setAttribute("y2", -100));
      } }, { key: "svgUrl", value: function() {
        this.cleanup();
        var t3 = this.getSvgString(), e2 = new Blob([t3], { type: "image/svg+xml;charset=utf-8" });
        return URL.createObjectURL(e2);
      } }, { key: "dataURI", value: function(t3) {
        var e2 = this;
        return new Promise(function(i2) {
          var a2 = e2.w, s2 = t3 ? t3.scale || t3.width / a2.globals.svgWidth : 1;
          e2.cleanup();
          var r2 = document.createElement("canvas");
          r2.width = a2.globals.svgWidth * s2, r2.height = parseInt(a2.globals.dom.elWrap.style.height, 10) * s2;
          var o2 = "transparent" === a2.config.chart.background ? "#fff" : a2.config.chart.background, n2 = r2.getContext("2d");
          n2.fillStyle = o2, n2.fillRect(0, 0, r2.width * s2, r2.height * s2);
          var l2 = e2.getSvgString(s2);
          if (window.canvg && x.isIE11()) {
            var h2 = window.canvg.Canvg.fromString(n2, l2, { ignoreClear: true, ignoreDimensions: true });
            h2.start();
            var c2 = r2.msToBlob();
            h2.stop(), i2({ blob: c2 });
          } else {
            var d2 = "data:image/svg+xml," + encodeURIComponent(l2), g2 = new Image();
            g2.crossOrigin = "anonymous", g2.onload = function() {
              if (n2.drawImage(g2, 0, 0), r2.msToBlob) {
                var t4 = r2.msToBlob();
                i2({ blob: t4 });
              } else {
                var e3 = r2.toDataURL("image/png");
                i2({ imgURI: e3 });
              }
            }, g2.src = d2;
          }
        });
      } }, { key: "exportToSVG", value: function() {
        this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
      } }, { key: "exportToPng", value: function() {
        var t3 = this;
        this.dataURI().then(function(e2) {
          var i2 = e2.imgURI, a2 = e2.blob;
          a2 ? navigator.msSaveOrOpenBlob(a2, t3.w.globals.chartID + ".png") : t3.triggerDownload(i2, t3.w.config.chart.toolbar.export.png.filename, ".png");
        });
      } }, { key: "exportToCSV", value: function(t3) {
        var e2 = this, i2 = t3.series, a2 = t3.fileName, s2 = t3.columnDelimiter, r2 = void 0 === s2 ? "," : s2, o2 = t3.lineDelimiter, n2 = void 0 === o2 ? "\n" : o2, l2 = this.w;
        i2 || (i2 = l2.config.series);
        var h2, c2, d2 = [], g2 = [], p2 = "", f2 = l2.globals.series.map(function(t4, e3) {
          return -1 === l2.globals.collapsedSeriesIndices.indexOf(e3) ? t4 : [];
        }), b2 = function(t4) {
          return "datetime" === l2.config.xaxis.type && String(t4).length >= 10;
        }, v2 = Math.max.apply(Math, u4(i2.map(function(t4) {
          return t4.data ? t4.data.length : 0;
        }))), m2 = new W(this.ctx), y2 = new B(this.ctx), w2 = function(t4) {
          var i3 = "";
          if (l2.globals.axisCharts) {
            if ("category" === l2.config.xaxis.type || l2.config.xaxis.convertedCatToNumeric)
              if (l2.globals.isBarHorizontal) {
                var a3 = l2.globals.yLabelFormatters[0], s3 = new N(e2.ctx).getActiveConfigSeriesIndex();
                i3 = a3(l2.globals.labels[t4], { seriesIndex: s3, dataPointIndex: t4, w: l2 });
              } else
                i3 = y2.getLabel(l2.globals.labels, l2.globals.timescaleLabels, 0, t4).text;
            "datetime" === l2.config.xaxis.type && (l2.config.xaxis.categories.length ? i3 = l2.config.xaxis.categories[t4] : l2.config.labels.length && (i3 = l2.config.labels[t4]));
          } else
            i3 = l2.config.labels[t4];
          return Array.isArray(i3) && (i3 = i3.join(" ")), x.isNumber(i3) ? i3 : i3.split(r2).join("");
        }, k2 = function(t4, e3) {
          if (d2.length && 0 === e3 && g2.push(d2.join(r2)), t4.data) {
            t4.data = t4.data.length && t4.data || u4(Array(v2)).map(function() {
              return "";
            });
            for (var a3 = 0; a3 < t4.data.length; a3++) {
              d2 = [];
              var s3 = w2(a3);
              if (s3 || (m2.isFormatXY() ? s3 = i2[e3].data[a3].x : m2.isFormat2DArray() && (s3 = i2[e3].data[a3] ? i2[e3].data[a3][0] : "")), 0 === e3) {
                d2.push(b2(s3) ? l2.config.chart.toolbar.export.csv.dateFormatter(s3) : x.isNumber(s3) ? s3 : s3.split(r2).join(""));
                for (var o3 = 0; o3 < l2.globals.series.length; o3++) {
                  var n3;
                  if (m2.isFormatXY())
                    d2.push(null === (n3 = i2[o3].data[a3]) || void 0 === n3 ? void 0 : n3.y);
                  else
                    d2.push(f2[o3][a3]);
                }
              }
              ("candlestick" === l2.config.chart.type || t4.type && "candlestick" === t4.type) && (d2.pop(), d2.push(l2.globals.seriesCandleO[e3][a3]), d2.push(l2.globals.seriesCandleH[e3][a3]), d2.push(l2.globals.seriesCandleL[e3][a3]), d2.push(l2.globals.seriesCandleC[e3][a3])), ("boxPlot" === l2.config.chart.type || t4.type && "boxPlot" === t4.type) && (d2.pop(), d2.push(l2.globals.seriesCandleO[e3][a3]), d2.push(l2.globals.seriesCandleH[e3][a3]), d2.push(l2.globals.seriesCandleM[e3][a3]), d2.push(l2.globals.seriesCandleL[e3][a3]), d2.push(l2.globals.seriesCandleC[e3][a3])), "rangeBar" === l2.config.chart.type && (d2.pop(), d2.push(l2.globals.seriesRangeStart[e3][a3]), d2.push(l2.globals.seriesRangeEnd[e3][a3])), d2.length && g2.push(d2.join(r2));
            }
          }
        };
        d2.push(l2.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l2.config.chart.type ? (d2.push("minimum"), d2.push("q1"), d2.push("median"), d2.push("q3"), d2.push("maximum")) : "candlestick" === l2.config.chart.type ? (d2.push("open"), d2.push("high"), d2.push("low"), d2.push("close")) : "rangeBar" === l2.config.chart.type ? (d2.push("minimum"), d2.push("maximum")) : i2.map(function(t4, e3) {
          var i3 = (t4.name ? t4.name : "series-".concat(e3)) + "";
          l2.globals.axisCharts && d2.push(i3.split(r2).join("") ? i3.split(r2).join("") : "series-".concat(e3));
        }), l2.globals.axisCharts || (d2.push(l2.config.chart.toolbar.export.csv.headerValue), g2.push(d2.join(r2))), l2.globals.allSeriesHasEqualX || !l2.globals.axisCharts || l2.config.xaxis.categories.length || l2.config.labels.length ? i2.map(function(t4, e3) {
          l2.globals.axisCharts ? k2(t4, e3) : ((d2 = []).push(l2.globals.labels[e3].split(r2).join("")), d2.push(f2[e3]), g2.push(d2.join(r2)));
        }) : (h2 = /* @__PURE__ */ new Set(), c2 = {}, i2.forEach(function(t4, e3) {
          null == t4 || t4.data.forEach(function(t5) {
            var a3, s3;
            if (m2.isFormatXY())
              a3 = t5.x, s3 = t5.y;
            else {
              if (!m2.isFormat2DArray())
                return;
              a3 = t5[0], s3 = t5[1];
            }
            c2[a3] || (c2[a3] = Array(i2.length).fill("")), c2[a3][e3] = s3, h2.add(a3);
          });
        }), d2.length && g2.push(d2.join(r2)), Array.from(h2).sort().forEach(function(t4) {
          g2.push([b2(t4) && "datetime" === l2.config.xaxis.type ? l2.config.chart.toolbar.export.csv.dateFormatter(t4) : x.isNumber(t4) ? t4 : t4.split(r2).join(""), c2[t4].join(r2)]);
        })), p2 += g2.join(n2), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + p2), a2 || l2.config.chart.toolbar.export.csv.filename, ".csv");
      } }, { key: "triggerDownload", value: function(t3, e2, i2) {
        var a2 = document.createElement("a");
        a2.href = t3, a2.download = (e2 || this.w.globals.chartID) + i2, document.body.appendChild(a2), a2.click(), document.body.removeChild(a2);
      } }]), t2;
    }();
    var V = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.elgrid = i2, this.w = e2.w;
        var s2 = this.w;
        this.axesUtils = new B(e2), this.xaxisLabels = s2.globals.labels.slice(), s2.globals.timescaleLabels.length > 0 && !s2.globals.isBarHorizontal && (this.xaxisLabels = s2.globals.timescaleLabels.slice()), s2.config.xaxis.overwriteCategories && (this.xaxisLabels = s2.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === s2.config.xaxis.position ? this.offY = 0 : this.offY = s2.globals.gridHeight + 1, this.offY = this.offY + s2.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === s2.config.chart.type && s2.config.plotOptions.bar.horizontal, this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s2.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s2.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s2.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s2.config.xaxis.axisBorder.height, this.yaxis = s2.config.yaxis[0];
      }
      return r(t2, [{ key: "drawXaxis", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = e2.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t3.config.xaxis.offsetX, ", ").concat(t3.config.xaxis.offsetY, ")") }), a2 = e2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t3.globals.translateXAxisX, ", ").concat(t3.globals.translateXAxisY, ")") });
        i2.add(a2);
        for (var s2 = [], r2 = 0; r2 < this.xaxisLabels.length; r2++)
          s2.push(this.xaxisLabels[r2]);
        if (this.drawXAxisLabelAndGroup(true, e2, a2, s2, t3.globals.isXNumeric, function(t4, e3) {
          return e3;
        }), t3.globals.hasXaxisGroups) {
          var o2 = t3.globals.groups;
          s2 = [];
          for (var n2 = 0; n2 < o2.length; n2++)
            s2.push(o2[n2].title);
          var l2 = {};
          t3.config.xaxis.group.style && (l2.xaxisFontSize = t3.config.xaxis.group.style.fontSize, l2.xaxisFontFamily = t3.config.xaxis.group.style.fontFamily, l2.xaxisForeColors = t3.config.xaxis.group.style.colors, l2.fontWeight = t3.config.xaxis.group.style.fontWeight, l2.cssClass = t3.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e2, a2, s2, false, function(t4, e3) {
            return o2[t4].cols * e3;
          }, l2);
        }
        if (void 0 !== t3.config.xaxis.title.text) {
          var h2 = e2.group({ class: "apexcharts-xaxis-title" }), c2 = e2.drawText({ x: t3.globals.gridWidth / 2 + t3.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t3.config.xaxis.position ? t3.globals.xAxisLabelsHeight : -t3.globals.xAxisLabelsHeight - 10) + t3.config.xaxis.title.offsetY, text: t3.config.xaxis.title.text, textAnchor: "middle", fontSize: t3.config.xaxis.title.style.fontSize, fontFamily: t3.config.xaxis.title.style.fontFamily, fontWeight: t3.config.xaxis.title.style.fontWeight, foreColor: t3.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t3.config.xaxis.title.style.cssClass });
          h2.add(c2), i2.add(h2);
        }
        if (t3.config.xaxis.axisBorder.show) {
          var d2 = t3.globals.barPadForNumericAxis, g2 = e2.drawLine(t3.globals.padHorizontal + t3.config.xaxis.axisBorder.offsetX - d2, this.offY, this.xaxisBorderWidth + d2, this.offY, t3.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
          this.elgrid && this.elgrid.elGridBorders && t3.config.grid.show ? this.elgrid.elGridBorders.add(g2) : i2.add(g2);
        }
        return i2;
      } }, { key: "drawXAxisLabelAndGroup", value: function(t3, e2, i2, a2, s2, r2) {
        var o2, n2 = this, l2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h2 = [], c2 = [], d2 = this.w, g2 = l2.xaxisFontSize || this.xaxisFontSize, u5 = l2.xaxisFontFamily || this.xaxisFontFamily, p2 = l2.xaxisForeColors || this.xaxisForeColors, f2 = l2.fontWeight || d2.config.xaxis.labels.style.fontWeight, x2 = l2.cssClass || d2.config.xaxis.labels.style.cssClass, b2 = d2.globals.padHorizontal, v2 = a2.length, m2 = "category" === d2.config.xaxis.type ? d2.globals.dataPoints : v2;
        if (0 === m2 && v2 > m2 && (m2 = v2), s2) {
          var y2 = m2 > 1 ? m2 - 1 : m2;
          o2 = d2.globals.gridWidth / Math.min(y2, v2 - 1), b2 = b2 + r2(0, o2) / 2 + d2.config.xaxis.labels.offsetX;
        } else
          o2 = d2.globals.gridWidth / m2, b2 = b2 + r2(0, o2) + d2.config.xaxis.labels.offsetX;
        for (var w2 = function(s3) {
          var l3 = b2 - r2(s3, o2) / 2 + d2.config.xaxis.labels.offsetX;
          0 === s3 && 1 === v2 && o2 / 2 === b2 && 1 === m2 && (l3 = d2.globals.gridWidth / 2);
          var y3 = n2.axesUtils.getLabel(a2, d2.globals.timescaleLabels, l3, s3, h2, g2, t3), w3 = 28;
          d2.globals.rotateXLabels && t3 && (w3 = 22), d2.config.xaxis.title.text && "top" === d2.config.xaxis.position && (w3 += parseFloat(d2.config.xaxis.title.style.fontSize) + 2), t3 || (w3 = w3 + parseFloat(g2) + (d2.globals.xAxisLabelsHeight - d2.globals.xAxisGroupLabelsHeight) + (d2.globals.rotateXLabels ? 10 : 0)), y3 = void 0 !== d2.config.xaxis.tickAmount && "dataPoints" !== d2.config.xaxis.tickAmount && "datetime" !== d2.config.xaxis.type ? n2.axesUtils.checkLabelBasedOnTickamount(s3, y3, v2) : n2.axesUtils.checkForOverflowingLabels(s3, y3, v2, h2, c2);
          if (d2.config.xaxis.labels.show) {
            var k3 = e2.drawText({ x: y3.x, y: n2.offY + d2.config.xaxis.labels.offsetY + w3 - ("top" === d2.config.xaxis.position ? d2.globals.xAxisHeight + d2.config.xaxis.axisTicks.height - 2 : 0), text: y3.text, textAnchor: "middle", fontWeight: y3.isBold ? 600 : f2, fontSize: g2, fontFamily: u5, foreColor: Array.isArray(p2) ? t3 && d2.config.xaxis.convertedCatToNumeric ? p2[d2.globals.minX + s3 - 1] : p2[s3] : p2, isPlainText: false, cssClass: (t3 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x2 });
            if (i2.add(k3), k3.on("click", function(t4) {
              if ("function" == typeof d2.config.chart.events.xAxisLabelClick) {
                var e3 = Object.assign({}, d2, { labelIndex: s3 });
                d2.config.chart.events.xAxisLabelClick(t4, n2.ctx, e3);
              }
            }), t3) {
              var A2 = document.createElementNS(d2.globals.SVGNS, "title");
              A2.textContent = Array.isArray(y3.text) ? y3.text.join(" ") : y3.text, k3.node.appendChild(A2), "" !== y3.text && (h2.push(y3.text), c2.push(y3));
            }
          }
          s3 < v2 - 1 && (b2 += r2(s3 + 1, o2));
        }, k2 = 0; k2 <= v2 - 1; k2++)
          w2(k2);
      } }, { key: "drawXaxisInversed", value: function(t3) {
        var e2, i2, a2 = this, s2 = this.w, r2 = new m(this.ctx), o2 = s2.config.yaxis[0].opposite ? s2.globals.translateYAxisX[t3] : 0, n2 = r2.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t3 }), l2 = r2.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o2 + ", 0)" });
        n2.add(l2);
        var h2 = [];
        if (s2.config.yaxis[t3].show)
          for (var c2 = 0; c2 < this.xaxisLabels.length; c2++)
            h2.push(this.xaxisLabels[c2]);
        e2 = s2.globals.gridHeight / h2.length, i2 = -e2 / 2.2;
        var d2 = s2.globals.yLabelFormatters[0], g2 = s2.config.yaxis[0].labels;
        if (g2.show)
          for (var u5 = function(o3) {
            var n3 = void 0 === h2[o3] ? "" : h2[o3];
            n3 = d2(n3, { seriesIndex: t3, dataPointIndex: o3, w: s2 });
            var c3 = a2.axesUtils.getYAxisForeColor(g2.style.colors, t3), u6 = 0;
            Array.isArray(n3) && (u6 = n3.length / 2 * parseInt(g2.style.fontSize, 10));
            var p3 = g2.offsetX - 15, f3 = "end";
            a2.yaxis.opposite && (f3 = "start"), "left" === s2.config.yaxis[0].labels.align ? (p3 = g2.offsetX, f3 = "start") : "center" === s2.config.yaxis[0].labels.align ? (p3 = g2.offsetX, f3 = "middle") : "right" === s2.config.yaxis[0].labels.align && (f3 = "end");
            var x3 = r2.drawText({ x: p3, y: i2 + e2 + g2.offsetY - u6, text: n3, textAnchor: f3, foreColor: Array.isArray(c3) ? c3[o3] : c3, fontSize: g2.style.fontSize, fontFamily: g2.style.fontFamily, fontWeight: g2.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + g2.style.cssClass, maxWidth: g2.maxWidth });
            l2.add(x3), x3.on("click", function(t4) {
              if ("function" == typeof s2.config.chart.events.xAxisLabelClick) {
                var e3 = Object.assign({}, s2, { labelIndex: o3 });
                s2.config.chart.events.xAxisLabelClick(t4, a2.ctx, e3);
              }
            });
            var b3 = document.createElementNS(s2.globals.SVGNS, "title");
            if (b3.textContent = Array.isArray(n3) ? n3.join(" ") : n3, x3.node.appendChild(b3), 0 !== s2.config.yaxis[t3].labels.rotate) {
              var v3 = r2.rotateAroundCenter(x3.node);
              x3.node.setAttribute("transform", "rotate(".concat(s2.config.yaxis[t3].labels.rotate, " 0 ").concat(v3.y, ")"));
            }
            i2 += e2;
          }, p2 = 0; p2 <= h2.length - 1; p2++)
            u5(p2);
        if (void 0 !== s2.config.yaxis[0].title.text) {
          var f2 = r2.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o2 + ", 0)" }), x2 = r2.drawText({ x: s2.config.yaxis[0].title.offsetX, y: s2.globals.gridHeight / 2 + s2.config.yaxis[0].title.offsetY, text: s2.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s2.config.yaxis[0].title.style.color, fontSize: s2.config.yaxis[0].title.style.fontSize, fontWeight: s2.config.yaxis[0].title.style.fontWeight, fontFamily: s2.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s2.config.yaxis[0].title.style.cssClass });
          f2.add(x2), n2.add(f2);
        }
        var b2 = 0;
        this.isCategoryBarHorizontal && s2.config.yaxis[0].opposite && (b2 = s2.globals.gridWidth);
        var v2 = s2.config.xaxis.axisBorder;
        if (v2.show) {
          var y2 = r2.drawLine(s2.globals.padHorizontal + v2.offsetX + b2, 1 + v2.offsetY, s2.globals.padHorizontal + v2.offsetX + b2, s2.globals.gridHeight + v2.offsetY, v2.color, 0);
          this.elgrid && this.elgrid.elGridBorders && s2.config.grid.show ? this.elgrid.elGridBorders.add(y2) : n2.add(y2);
        }
        return s2.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b2, h2.length, s2.config.yaxis[0].axisBorder, s2.config.yaxis[0].axisTicks, 0, e2, n2), n2;
      } }, { key: "drawXaxisTicks", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = t3;
        if (!(t3 < 0 || t3 - 2 > a2.globals.gridWidth)) {
          var r2 = this.offY + a2.config.xaxis.axisTicks.offsetY;
          if (e2 = e2 + r2 + a2.config.xaxis.axisTicks.height, "top" === a2.config.xaxis.position && (e2 = r2 - a2.config.xaxis.axisTicks.height), a2.config.xaxis.axisTicks.show) {
            var o2 = new m(this.ctx).drawLine(t3 + a2.config.xaxis.axisTicks.offsetX, r2 + a2.config.xaxis.offsetY, s2 + a2.config.xaxis.axisTicks.offsetX, e2 + a2.config.xaxis.offsetY, a2.config.xaxis.axisTicks.color);
            i2.add(o2), o2.node.classList.add("apexcharts-xaxis-tick");
          }
        }
      } }, { key: "getXAxisTicksPositions", value: function() {
        var t3 = this.w, e2 = [], i2 = this.xaxisLabels.length, a2 = t3.globals.padHorizontal;
        if (t3.globals.timescaleLabels.length > 0)
          for (var s2 = 0; s2 < i2; s2++)
            a2 = this.xaxisLabels[s2].position, e2.push(a2);
        else
          for (var r2 = i2, o2 = 0; o2 < r2; o2++) {
            var n2 = r2;
            t3.globals.isXNumeric && "bar" !== t3.config.chart.type && (n2 -= 1), a2 += t3.globals.gridWidth / n2, e2.push(a2);
          }
        return e2;
      } }, { key: "xAxisLabelCorrections", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
        if (t3.globals.rotateXLabels || t3.config.xaxis.labels.rotateAlways)
          for (var o2 = 0; o2 < a2.length; o2++) {
            var n2 = e2.rotateAroundCenter(a2[o2]);
            n2.y = n2.y - 1, n2.x = n2.x + 1, a2[o2].setAttribute("transform", "rotate(".concat(t3.config.xaxis.labels.rotate, " ").concat(n2.x, " ").concat(n2.y, ")")), a2[o2].setAttribute("text-anchor", "end");
            i2.setAttribute("transform", "translate(0, ".concat(-10, ")"));
            var l2 = a2[o2].childNodes;
            t3.config.xaxis.labels.trim && Array.prototype.forEach.call(l2, function(i3) {
              e2.placeTextWithEllipsis(i3, i3.textContent, t3.globals.xAxisLabelsHeight - ("bottom" === t3.config.legend.position ? 20 : 10));
            });
          }
        else
          !function() {
            for (var i3 = t3.globals.gridWidth / (t3.globals.labels.length + 1), s3 = 0; s3 < a2.length; s3++) {
              var r3 = a2[s3].childNodes;
              t3.config.xaxis.labels.trim && "datetime" !== t3.config.xaxis.type && Array.prototype.forEach.call(r3, function(t4) {
                e2.placeTextWithEllipsis(t4, t4.textContent, i3);
              });
            }
          }();
        if (s2.length > 0) {
          var h2 = s2[s2.length - 1].getBBox(), c2 = s2[0].getBBox();
          h2.x < -20 && s2[s2.length - 1].parentNode.removeChild(s2[s2.length - 1]), c2.x + c2.width > t3.globals.gridWidth && !t3.globals.isBarHorizontal && s2[0].parentNode.removeChild(s2[0]);
          for (var d2 = 0; d2 < r2.length; d2++)
            e2.placeTextWithEllipsis(r2[d2], r2[d2].textContent, t3.config.yaxis[0].labels.maxWidth - (t3.config.yaxis[0].title.text ? 2 * parseFloat(t3.config.yaxis[0].title.style.fontSize) : 0) - 15);
        }
      } }]), t2;
    }();
    var j = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var i2 = this.w;
        this.xaxisLabels = i2.globals.labels.slice(), this.axesUtils = new B(e2), this.isRangeBar = i2.globals.seriesRange.length && i2.globals.isBarHorizontal, i2.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i2.globals.timescaleLabels.slice());
      }
      return r(t2, [{ key: "drawGridArea", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w, i2 = new m(this.ctx);
        null === t3 && (t3 = i2.group({ class: "apexcharts-grid" }));
        var a2 = i2.drawLine(e2.globals.padHorizontal, 1, e2.globals.padHorizontal, e2.globals.gridHeight, "transparent"), s2 = i2.drawLine(e2.globals.padHorizontal, e2.globals.gridHeight, e2.globals.gridWidth, e2.globals.gridHeight, "transparent");
        return t3.add(s2), t3.add(a2), t3;
      } }, { key: "drawGrid", value: function() {
        var t3 = null;
        return this.w.globals.axisCharts && (t3 = this.renderGrid(), this.drawGridArea(t3.el)), t3;
      } }, { key: "createGridMask", value: function() {
        var t3 = this.w, e2 = t3.globals, i2 = new m(this.ctx), a2 = Array.isArray(t3.config.stroke.width) ? 0 : t3.config.stroke.width;
        if (Array.isArray(t3.config.stroke.width)) {
          var s2 = 0;
          t3.config.stroke.width.forEach(function(t4) {
            s2 = Math.max(s2, t4);
          }), a2 = s2;
        }
        e2.dom.elGridRectMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e2.cuid)), e2.dom.elGridRectMarkerMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e2.cuid)), e2.dom.elForecastMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e2.cuid)), e2.dom.elNonForecastMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e2.cuid));
        var r2 = t3.config.chart.type, o2 = 0, n2 = 0;
        ("bar" === r2 || "rangeBar" === r2 || "candlestick" === r2 || "boxPlot" === r2 || t3.globals.comboBarCount > 0) && t3.globals.isXNumeric && !t3.globals.isBarHorizontal && (o2 = t3.config.grid.padding.left, n2 = t3.config.grid.padding.right, e2.barPadForNumericAxis > o2 && (o2 = e2.barPadForNumericAxis, n2 = e2.barPadForNumericAxis)), e2.dom.elGridRect = i2.drawRect(-a2 - o2 - 2, 2 * -a2 - 2, e2.gridWidth + a2 + n2 + o2 + 4, e2.gridHeight + 4 * a2 + 4, 0, "#fff");
        var l2 = t3.globals.markers.largestSize + 1;
        e2.dom.elGridRectMarker = i2.drawRect(2 * -l2, 2 * -l2, e2.gridWidth + 4 * l2, e2.gridHeight + 4 * l2, 0, "#fff"), e2.dom.elGridRectMask.appendChild(e2.dom.elGridRect.node), e2.dom.elGridRectMarkerMask.appendChild(e2.dom.elGridRectMarker.node);
        var h2 = e2.dom.baseEl.querySelector("defs");
        h2.appendChild(e2.dom.elGridRectMask), h2.appendChild(e2.dom.elForecastMask), h2.appendChild(e2.dom.elNonForecastMask), h2.appendChild(e2.dom.elGridRectMarkerMask);
      } }, { key: "_drawGridLines", value: function(t3) {
        var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, o2 = t3.xCount, n2 = t3.parent, l2 = this.w;
        if (!(0 === e2 && l2.globals.skipFirstTimelinelabel || e2 === o2 - 1 && l2.globals.skipLastTimelinelabel && !l2.config.xaxis.labels.formatter || "radar" === l2.config.chart.type)) {
          l2.config.grid.xaxis.lines.show && this._drawGridLine({ i: e2, x1: i2, y1: a2, x2: s2, y2: r2, xCount: o2, parent: n2 });
          var h2 = 0;
          if (l2.globals.hasXaxisGroups && "between" === l2.config.xaxis.tickPlacement) {
            var c2 = l2.globals.groups;
            if (c2) {
              for (var d2 = 0, g2 = 0; d2 < e2 && g2 < c2.length; g2++)
                d2 += c2[g2].cols;
              d2 === e2 && (h2 = 0.6 * l2.globals.xAxisLabelsHeight);
            }
          }
          new V(this.ctx).drawXaxisTicks(i2, h2, l2.globals.dom.elGraphical);
        }
      } }, { key: "_drawGridLine", value: function(t3) {
        var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, o2 = t3.xCount, n2 = t3.parent, l2 = this.w, h2 = false, c2 = n2.node.classList.contains("apexcharts-gridlines-horizontal"), d2 = l2.config.grid.strokeDashArray, g2 = l2.globals.barPadForNumericAxis;
        (0 === a2 && 0 === r2 || 0 === i2 && 0 === s2) && (h2 = true), a2 === l2.globals.gridHeight && r2 === l2.globals.gridHeight && (h2 = true), !l2.globals.isBarHorizontal || 0 !== e2 && e2 !== o2 - 1 || (h2 = true);
        var u5 = new m(this).drawLine(i2 - (c2 ? g2 : 0), a2, s2 + (c2 ? g2 : 0), r2, l2.config.grid.borderColor, d2);
        u5.node.classList.add("apexcharts-gridline"), h2 && l2.config.grid.show ? this.elGridBorders.add(u5) : n2.add(u5);
      } }, { key: "_drawGridBandRect", value: function(t3) {
        var e2 = t3.c, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, o2 = t3.type, n2 = this.w, l2 = new m(this.ctx), h2 = n2.globals.barPadForNumericAxis;
        if ("column" !== o2 || "datetime" !== n2.config.xaxis.type) {
          var c2 = n2.config.grid[o2].colors[e2], d2 = l2.drawRect(i2 - ("row" === o2 ? h2 : 0), a2, s2 + ("row" === o2 ? 2 * h2 : 0), r2, 0, c2, n2.config.grid[o2].opacity);
          this.elg.add(d2), d2.attr("clip-path", "url(#gridRectMask".concat(n2.globals.cuid, ")")), d2.node.classList.add("apexcharts-grid-".concat(o2));
        }
      } }, { key: "_drawXYLines", value: function(t3) {
        var e2 = this, i2 = t3.xCount, a2 = t3.tickAmount, s2 = this.w;
        if (s2.config.grid.xaxis.lines.show || s2.config.xaxis.axisTicks.show) {
          var r2, o2 = s2.globals.padHorizontal, n2 = s2.globals.gridHeight;
          s2.globals.timescaleLabels.length ? function(t4) {
            for (var a3 = t4.xC, s3 = t4.x1, r3 = t4.y1, o3 = t4.x2, n3 = t4.y2, l3 = 0; l3 < a3; l3++)
              s3 = e2.xaxisLabels[l3].position, o3 = e2.xaxisLabels[l3].position, e2._drawGridLines({ i: l3, x1: s3, y1: r3, x2: o3, y2: n3, xCount: i2, parent: e2.elgridLinesV });
          }({ xC: i2, x1: o2, y1: 0, x2: r2, y2: n2 }) : (s2.globals.isXNumeric && (i2 = s2.globals.xAxisScale.result.length), function(t4) {
            for (var a3 = t4.xC, r3 = t4.x1, o3 = t4.y1, n3 = t4.x2, l3 = t4.y2, h3 = 0; h3 < a3 + (s2.globals.isXNumeric ? 0 : 1); h3++)
              0 === h3 && 1 === a3 && 1 === s2.globals.dataPoints && (n3 = r3 = s2.globals.gridWidth / 2), e2._drawGridLines({ i: h3, x1: r3, y1: o3, x2: n3, y2: l3, xCount: i2, parent: e2.elgridLinesV }), n3 = r3 += s2.globals.gridWidth / (s2.globals.isXNumeric ? a3 - 1 : a3);
          }({ xC: i2, x1: o2, y1: 0, x2: r2, y2: n2 }));
        }
        if (s2.config.grid.yaxis.lines.show) {
          var l2 = 0, h2 = 0, c2 = s2.globals.gridWidth, d2 = a2 + 1;
          this.isRangeBar && (d2 = s2.globals.labels.length);
          for (var g2 = 0; g2 < d2 + (this.isRangeBar ? 1 : 0); g2++)
            this._drawGridLine({ i: g2, xCount: d2 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l2, x2: c2, y2: h2, parent: this.elgridLinesH }), h2 = l2 += s2.globals.gridHeight / (this.isRangeBar ? d2 : a2);
        }
      } }, { key: "_drawInvertedXYLines", value: function(t3) {
        var e2 = t3.xCount, i2 = this.w;
        if (i2.config.grid.xaxis.lines.show || i2.config.xaxis.axisTicks.show)
          for (var a2, s2 = i2.globals.padHorizontal, r2 = i2.globals.gridHeight, o2 = 0; o2 < e2 + 1; o2++) {
            i2.config.grid.xaxis.lines.show && this._drawGridLine({ i: o2, xCount: e2 + 1, x1: s2, y1: 0, x2: a2, y2: r2, parent: this.elgridLinesV }), new V(this.ctx).drawXaxisTicks(s2, 0, i2.globals.dom.elGraphical), a2 = s2 = s2 + i2.globals.gridWidth / e2 + 0.3;
          }
        if (i2.config.grid.yaxis.lines.show)
          for (var n2 = 0, l2 = 0, h2 = i2.globals.gridWidth, c2 = 0; c2 < i2.globals.dataPoints + 1; c2++)
            this._drawGridLine({ i: c2, xCount: i2.globals.dataPoints + 1, x1: 0, y1: n2, x2: h2, y2: l2, parent: this.elgridLinesH }), l2 = n2 += i2.globals.gridHeight / i2.globals.dataPoints;
      } }, { key: "renderGrid", value: function() {
        var t3 = this.w, e2 = new m(this.ctx);
        this.elg = e2.group({ class: "apexcharts-grid" }), this.elgridLinesH = e2.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = e2.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = e2.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t3.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
        for (var i2, a2 = t3.globals.yAxisScale.length ? t3.globals.yAxisScale[0].result.length - 1 : 5, s2 = 0; s2 < t3.globals.series.length && (void 0 !== t3.globals.yAxisScale[s2] && (a2 = t3.globals.yAxisScale[s2].result.length - 1), !(a2 > 2)); s2++)
          ;
        if (!t3.globals.isBarHorizontal || this.isRangeBar) {
          var r2, o2, n2;
          if (i2 = this.xaxisLabels.length, this.isRangeBar)
            i2--, a2 = t3.globals.labels.length, t3.config.xaxis.tickAmount && t3.config.xaxis.labels.formatter && (i2 = t3.config.xaxis.tickAmount), (null === (r2 = t3.globals.yAxisScale) || void 0 === r2 || null === (o2 = r2[0]) || void 0 === o2 || null === (n2 = o2.result) || void 0 === n2 ? void 0 : n2.length) > 0 && "datetime" !== t3.config.xaxis.type && (i2 = t3.globals.yAxisScale[0].result.length - 1);
          this._drawXYLines({ xCount: i2, tickAmount: a2 });
        } else
          i2 = a2, a2 = t3.globals.xTickAmount, this._drawInvertedXYLines({ xCount: i2, tickAmount: a2 });
        return this.drawGridBands(i2, a2), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t3.globals.gridWidth / i2 };
      } }, { key: "drawGridBands", value: function(t3, e2) {
        var i2 = this.w;
        if (void 0 !== i2.config.grid.row.colors && i2.config.grid.row.colors.length > 0)
          for (var a2 = 0, s2 = i2.globals.gridHeight / e2, r2 = i2.globals.gridWidth, o2 = 0, n2 = 0; o2 < e2; o2++, n2++)
            n2 >= i2.config.grid.row.colors.length && (n2 = 0), this._drawGridBandRect({ c: n2, x1: 0, y1: a2, x2: r2, y2: s2, type: "row" }), a2 += i2.globals.gridHeight / e2;
        if (void 0 !== i2.config.grid.column.colors && i2.config.grid.column.colors.length > 0)
          for (var l2 = i2.globals.isBarHorizontal || "on" !== i2.config.xaxis.tickPlacement || "category" !== i2.config.xaxis.type && !i2.config.xaxis.convertedCatToNumeric ? t3 : t3 - 1, h2 = i2.globals.padHorizontal, c2 = i2.globals.padHorizontal + i2.globals.gridWidth / l2, d2 = i2.globals.gridHeight, g2 = 0, u5 = 0; g2 < t3; g2++, u5++)
            u5 >= i2.config.grid.column.colors.length && (u5 = 0), this._drawGridBandRect({ c: u5, x1: h2, y1: 0, x2: c2, y2: d2, type: "column" }), h2 += i2.globals.gridWidth / l2;
      } }]), t2;
    }();
    var _ = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "niceScale", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 ? arguments[4] : void 0, r2 = this.w, o2 = Math.abs(e2 - t3);
        if ("dataPoints" === (i2 = this._adjustTicksForSmallRange(i2, a2, o2)) && (i2 = r2.globals.dataPoints - 1), t3 === Number.MIN_VALUE && 0 === e2 || !x.isNumber(t3) && !x.isNumber(e2) || t3 === Number.MIN_VALUE && e2 === -Number.MAX_VALUE)
          return t3 = 0, e2 = i2, this.linearScale(t3, e2, i2, a2, r2.config.yaxis[a2].stepSize);
        t3 > e2 ? (console.warn("axis.min cannot be greater than axis.max"), e2 = t3 + 0.1) : t3 === e2 && (t3 = 0 === t3 ? 0 : t3 - 0.5, e2 = 0 === e2 ? 2 : e2 + 0.5);
        var n2 = [];
        o2 < 1 && s2 && ("candlestick" === r2.config.chart.type || "candlestick" === r2.config.series[a2].type || "boxPlot" === r2.config.chart.type || "boxPlot" === r2.config.series[a2].type || r2.globals.isRangeData) && (e2 *= 1.01);
        var l2 = i2 + 1;
        l2 < 2 ? l2 = 2 : l2 > 2 && (l2 -= 2);
        var h2 = o2 / l2, c2 = Math.floor(x.log10(h2)), d2 = Math.pow(10, c2), g2 = Math.round(h2 / d2);
        g2 < 1 && (g2 = 1);
        var u5 = g2 * d2;
        r2.config.yaxis[a2].stepSize && (u5 = r2.config.yaxis[a2].stepSize), r2.globals.isBarHorizontal && r2.config.xaxis.stepSize && "datetime" !== r2.config.xaxis.type && (u5 = r2.config.xaxis.stepSize);
        var p2 = u5 * Math.floor(t3 / u5), f2 = u5 * Math.ceil(e2 / u5), b2 = p2;
        if (s2 && o2 > 2) {
          for (; n2.push(x.stripNumber(b2, 7)), !((b2 += u5) > f2); )
            ;
          return { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
        }
        var v2 = t3;
        (n2 = []).push(x.stripNumber(v2, 7));
        for (var m2 = Math.abs(e2 - t3) / i2, y2 = 0; y2 <= i2; y2++)
          v2 += m2, n2.push(v2);
        return n2[n2.length - 2] >= e2 && n2.pop(), { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
      } }, { key: "linearScale", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0, r2 = Math.abs(e2 - t3);
        "dataPoints" === (i2 = this._adjustTicksForSmallRange(i2, a2, r2)) && (i2 = this.w.globals.dataPoints - 1), s2 || (s2 = r2 / i2), i2 === Number.MAX_VALUE && (i2 = 5, s2 = 1);
        for (var o2 = [], n2 = t3; i2 >= 0; )
          o2.push(n2), n2 += s2, i2 -= 1;
        return { result: o2, niceMin: o2[0], niceMax: o2[o2.length - 1] };
      } }, { key: "logarithmicScaleNice", value: function(t3, e2, i2) {
        e2 <= 0 && (e2 = Math.max(t3, i2)), t3 <= 0 && (t3 = Math.min(e2, i2));
        for (var a2 = [], s2 = Math.ceil(Math.log(e2) / Math.log(i2) + 1), r2 = Math.floor(Math.log(t3) / Math.log(i2)); r2 < s2; r2++)
          a2.push(Math.pow(i2, r2));
        return { result: a2, niceMin: a2[0], niceMax: a2[a2.length - 1] };
      } }, { key: "logarithmicScale", value: function(t3, e2, i2) {
        e2 <= 0 && (e2 = Math.max(t3, i2)), t3 <= 0 && (t3 = Math.min(e2, i2));
        for (var a2 = [], s2 = Math.log(e2) / Math.log(i2), r2 = Math.log(t3) / Math.log(i2), o2 = s2 - r2, n2 = Math.round(o2), l2 = o2 / n2, h2 = 0, c2 = r2; h2 < n2; h2++, c2 += l2)
          a2.push(Math.pow(i2, c2));
        return a2.push(Math.pow(i2, s2)), { result: a2, niceMin: t3, niceMax: e2 };
      } }, { key: "_adjustTicksForSmallRange", value: function(t3, e2, i2) {
        var a2 = t3;
        if (void 0 !== e2 && this.w.config.yaxis[e2].labels.formatter && void 0 === this.w.config.yaxis[e2].tickAmount) {
          var s2 = Number(this.w.config.yaxis[e2].labels.formatter(1));
          x.isNumber(s2) && 0 === this.w.globals.yValueDecimal && (a2 = Math.ceil(i2));
        }
        return a2 < t3 ? a2 : t3;
      } }, { key: "setYScaleForIndex", value: function(t3, e2, i2) {
        var a2 = this.w.globals, s2 = this.w.config, r2 = a2.isBarHorizontal ? s2.xaxis : s2.yaxis[t3];
        void 0 === a2.yAxisScale[t3] && (a2.yAxisScale[t3] = []);
        var o2 = Math.abs(i2 - e2);
        if (r2.logarithmic && o2 <= 5 && (a2.invalidLogScale = true), r2.logarithmic && o2 > 5)
          a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = this.logarithmicScale(e2, i2, r2.logBase), a2.yAxisScale[t3] = r2.forceNiceScale ? this.logarithmicScaleNice(e2, i2, r2.logBase) : this.logarithmicScale(e2, i2, r2.logBase);
        else if (i2 !== -Number.MAX_VALUE && x.isNumber(i2))
          if (a2.allSeriesCollapsed = false, void 0 === r2.min && void 0 === r2.max || r2.forceNiceScale) {
            var n2 = void 0 === s2.yaxis[t3].max && void 0 === s2.yaxis[t3].min || s2.yaxis[t3].forceNiceScale;
            a2.yAxisScale[t3] = this.niceScale(e2, i2, r2.tickAmount ? r2.tickAmount : o2 < 5 && o2 > 1 ? o2 + 1 : 5, t3, n2);
          } else
            a2.yAxisScale[t3] = this.linearScale(e2, i2, r2.tickAmount, t3, s2.yaxis[t3].stepSize);
        else
          a2.yAxisScale[t3] = this.linearScale(0, 5, 5, t3, s2.yaxis[t3].stepSize);
      } }, { key: "setXScale", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.globals, s2 = Math.abs(e2 - t3);
        return e2 !== -Number.MAX_VALUE && x.isNumber(e2) ? a2.xAxisScale = this.linearScale(t3, e2, i2.config.xaxis.tickAmount ? i2.config.xaxis.tickAmount : s2 < 5 && s2 > 1 ? s2 + 1 : 5, 0, i2.config.xaxis.stepSize) : a2.xAxisScale = this.linearScale(0, 5, 5), a2.xAxisScale;
      } }, { key: "setMultipleYScales", value: function() {
        var t3 = this, e2 = this.w.globals, i2 = this.w.config, a2 = e2.minYArr.concat([]), s2 = e2.maxYArr.concat([]), r2 = [];
        i2.yaxis.forEach(function(e3, o2) {
          var n2 = o2;
          i2.series.forEach(function(t4, i3) {
            t4.name === e3.seriesName && (n2 = i3, o2 !== i3 ? r2.push({ index: i3, similarIndex: o2, alreadyExists: true }) : r2.push({ index: i3 }));
          });
          var l2 = a2[n2], h2 = s2[n2];
          t3.setYScaleForIndex(o2, l2, h2);
        }), this.sameScaleInMultipleAxes(a2, s2, r2);
      } }, { key: "sameScaleInMultipleAxes", value: function(t3, e2, i2) {
        var a2 = this, s2 = this.w.config, r2 = this.w.globals, o2 = [];
        i2.forEach(function(t4) {
          t4.alreadyExists && (void 0 === o2[t4.index] && (o2[t4.index] = []), o2[t4.index].push(t4.index), o2[t4.index].push(t4.similarIndex));
        }), r2.yAxisSameScaleIndices = o2, o2.forEach(function(t4, e3) {
          o2.forEach(function(i3, a3) {
            var s3, r3;
            e3 !== a3 && (s3 = t4, r3 = i3, s3.filter(function(t5) {
              return -1 !== r3.indexOf(t5);
            })).length > 0 && (o2[e3] = o2[e3].concat(o2[a3]));
          });
        });
        var n2 = o2.map(function(t4) {
          return t4.filter(function(e3, i3) {
            return t4.indexOf(e3) === i3;
          });
        }).map(function(t4) {
          return t4.sort();
        });
        o2 = o2.filter(function(t4) {
          return !!t4;
        });
        var l2 = n2.slice(), h2 = l2.map(function(t4) {
          return JSON.stringify(t4);
        });
        l2 = l2.filter(function(t4, e3) {
          return h2.indexOf(JSON.stringify(t4)) === e3;
        });
        var c2 = [], d2 = [];
        t3.forEach(function(t4, i3) {
          l2.forEach(function(a3, s3) {
            a3.indexOf(i3) > -1 && (void 0 === c2[s3] && (c2[s3] = [], d2[s3] = []), c2[s3].push({ key: i3, value: t4 }), d2[s3].push({ key: i3, value: e2[i3] }));
          });
        });
        var g2 = Array.apply(null, Array(l2.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), u5 = Array.apply(null, Array(l2.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
        c2.forEach(function(t4, e3) {
          t4.forEach(function(t5, i3) {
            g2[e3] = Math.min(t5.value, g2[e3]);
          });
        }), d2.forEach(function(t4, e3) {
          t4.forEach(function(t5, i3) {
            u5[e3] = Math.max(t5.value, u5[e3]);
          });
        }), t3.forEach(function(t4, e3) {
          d2.forEach(function(t5, i3) {
            var o3 = g2[i3], n3 = u5[i3];
            s2.chart.stacked && (n3 = 0, t5.forEach(function(t6, e4) {
              t6.value !== -Number.MAX_VALUE && (n3 += t6.value), o3 !== Number.MIN_VALUE && (o3 += c2[i3][e4].value);
            })), t5.forEach(function(i4, l3) {
              t5[l3].key === e3 && (void 0 !== s2.yaxis[e3].min && (o3 = "function" == typeof s2.yaxis[e3].min ? s2.yaxis[e3].min(r2.minY) : s2.yaxis[e3].min), void 0 !== s2.yaxis[e3].max && (n3 = "function" == typeof s2.yaxis[e3].max ? s2.yaxis[e3].max(r2.maxY) : s2.yaxis[e3].max), a2.setYScaleForIndex(e3, o3, n3));
            });
          });
        });
      } }, { key: "autoScaleY", value: function(t3, e2, i2) {
        t3 || (t3 = this);
        var a2 = t3.w;
        if (a2.globals.isMultipleYAxis || a2.globals.collapsedSeries.length)
          return console.warn("autoScaleYaxis not supported in a multi-yaxis chart."), e2;
        var s2 = a2.globals.seriesX[0], r2 = a2.config.chart.stacked;
        return e2.forEach(function(t4, o2) {
          for (var n2 = 0, l2 = 0; l2 < s2.length; l2++)
            if (s2[l2] >= i2.xaxis.min) {
              n2 = l2;
              break;
            }
          var h2, c2, d2 = a2.globals.minYArr[o2], g2 = a2.globals.maxYArr[o2], u5 = a2.globals.stackedSeriesTotals;
          a2.globals.series.forEach(function(o3, l3) {
            var p2 = o3[n2];
            r2 ? (p2 = u5[n2], h2 = c2 = p2, u5.forEach(function(t5, e3) {
              s2[e3] <= i2.xaxis.max && s2[e3] >= i2.xaxis.min && (t5 > c2 && null !== t5 && (c2 = t5), o3[e3] < h2 && null !== o3[e3] && (h2 = o3[e3]));
            })) : (h2 = c2 = p2, o3.forEach(function(t5, e3) {
              if (s2[e3] <= i2.xaxis.max && s2[e3] >= i2.xaxis.min) {
                var r3 = t5, o4 = t5;
                a2.globals.series.forEach(function(i3, a3) {
                  null !== t5 && (r3 = Math.min(i3[e3], r3), o4 = Math.max(i3[e3], o4));
                }), o4 > c2 && null !== o4 && (c2 = o4), r3 < h2 && null !== r3 && (h2 = r3);
              }
            })), void 0 === h2 && void 0 === c2 && (h2 = d2, c2 = g2), c2 *= c2 < 0 ? 0.9 : 1.1, 0 === (h2 *= h2 < 0 ? 1.1 : 0.9) && 0 === c2 && (h2 = -1, c2 = 1), c2 < 0 && c2 < g2 && (c2 = g2), h2 < 0 && h2 > d2 && (h2 = d2), e2.length > 1 ? (e2[l3].min = void 0 === t4.min ? h2 : t4.min, e2[l3].max = void 0 === t4.max ? c2 : t4.max) : (e2[0].min = void 0 === t4.min ? h2 : t4.min, e2[0].max = void 0 === t4.max ? c2 : t4.max);
          });
        }), e2;
      } }]), t2;
    }();
    var U = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.scales = new _(e2);
      }
      return r(t2, [{ key: "init", value: function() {
        this.setYRange(), this.setXRange(), this.setZRange();
      } }, { key: "getMinYMaxY", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w.config, r2 = this.w.globals, o2 = -Number.MAX_VALUE, n2 = Number.MIN_VALUE;
        null === a2 && (a2 = t3 + 1);
        var l2 = r2.series, h2 = l2, c2 = l2;
        "candlestick" === s2.chart.type ? (h2 = r2.seriesCandleL, c2 = r2.seriesCandleH) : "boxPlot" === s2.chart.type ? (h2 = r2.seriesCandleO, c2 = r2.seriesCandleC) : r2.isRangeData && (h2 = r2.seriesRangeStart, c2 = r2.seriesRangeEnd);
        for (var d2 = t3; d2 < a2; d2++) {
          r2.dataPoints = Math.max(r2.dataPoints, l2[d2].length), r2.categoryLabels.length && (r2.dataPoints = r2.categoryLabels.filter(function(t4) {
            return void 0 !== t4;
          }).length), r2.labels.length && "datetime" !== s2.xaxis.type && 0 !== r2.series.reduce(function(t4, e3) {
            return t4 + e3.length;
          }, 0) && (r2.dataPoints = Math.max(r2.dataPoints, r2.labels.length));
          for (var g2 = 0; g2 < r2.series[d2].length; g2++) {
            var u5 = l2[d2][g2];
            null !== u5 && x.isNumber(u5) ? (void 0 !== c2[d2][g2] && (o2 = Math.max(o2, c2[d2][g2]), e2 = Math.min(e2, c2[d2][g2])), void 0 !== h2[d2][g2] && (e2 = Math.min(e2, h2[d2][g2]), i2 = Math.max(i2, h2[d2][g2])), "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type && "rangeArea" === this.w.config.chart.type && "rangeBar" === this.w.config.chart.type || ("candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || void 0 !== r2.seriesCandleC[d2][g2] && (o2 = Math.max(o2, r2.seriesCandleO[d2][g2]), o2 = Math.max(o2, r2.seriesCandleH[d2][g2]), o2 = Math.max(o2, r2.seriesCandleL[d2][g2]), o2 = Math.max(o2, r2.seriesCandleC[d2][g2]), "boxPlot" === this.w.config.chart.type && (o2 = Math.max(o2, r2.seriesCandleM[d2][g2]))), !s2.series[d2].type || "candlestick" === s2.series[d2].type && "boxPlot" === s2.series[d2].type && "rangeArea" === s2.series[d2].type && "rangeBar" === s2.series[d2].type || (o2 = Math.max(o2, r2.series[d2][g2]), e2 = Math.min(e2, r2.series[d2][g2])), i2 = o2), r2.seriesGoals[d2] && r2.seriesGoals[d2][g2] && Array.isArray(r2.seriesGoals[d2][g2]) && r2.seriesGoals[d2][g2].forEach(function(t4) {
              n2 !== Number.MIN_VALUE && (n2 = Math.min(n2, t4.value), e2 = n2), o2 = Math.max(o2, t4.value), i2 = o2;
            }), x.isFloat(u5) && (u5 = x.noExponents(u5), r2.yValueDecimal = Math.max(r2.yValueDecimal, u5.toString().split(".")[1].length)), n2 > h2[d2][g2] && h2[d2][g2] < 0 && (n2 = h2[d2][g2])) : r2.hasNullValues = true;
          }
        }
        return "rangeBar" === s2.chart.type && r2.seriesRangeStart.length && r2.isBarHorizontal && (n2 = e2), "bar" === s2.chart.type && (n2 < 0 && o2 < 0 && (o2 = 0), n2 === Number.MIN_VALUE && (n2 = 0)), { minY: n2, maxY: o2, lowestY: e2, highestY: i2 };
      } }, { key: "setYRange", value: function() {
        var t3 = this.w.globals, e2 = this.w.config;
        t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE;
        var i2 = Number.MAX_VALUE;
        if (t3.isMultipleYAxis)
          for (var a2 = 0; a2 < t3.series.length; a2++) {
            var s2 = this.getMinYMaxY(a2, i2, null, a2 + 1);
            t3.minYArr.push(s2.minY), t3.maxYArr.push(s2.maxY), i2 = s2.lowestY;
          }
        var r2 = this.getMinYMaxY(0, i2, null, t3.series.length);
        if (t3.minY = r2.minY, t3.maxY = r2.maxY, i2 = r2.lowestY, e2.chart.stacked && this._setStackedMinMax(), ("line" === e2.chart.type || "area" === e2.chart.type || "candlestick" === e2.chart.type || "boxPlot" === e2.chart.type || "rangeBar" === e2.chart.type && !t3.isBarHorizontal) && t3.minY === Number.MIN_VALUE && i2 !== -Number.MAX_VALUE && i2 !== t3.maxY) {
          var o2 = t3.maxY - i2;
          (i2 >= 0 && i2 <= 10 || void 0 !== e2.yaxis[0].min || void 0 !== e2.yaxis[0].max) && (o2 = 0), t3.minY = i2 - 5 * o2 / 100, i2 > 0 && t3.minY < 0 && (t3.minY = 0), t3.maxY = t3.maxY + 5 * o2 / 100;
        }
        if (e2.yaxis.forEach(function(e3, i3) {
          void 0 !== e3.max && ("number" == typeof e3.max ? t3.maxYArr[i3] = e3.max : "function" == typeof e3.max && (t3.maxYArr[i3] = e3.max(t3.isMultipleYAxis ? t3.maxYArr[i3] : t3.maxY)), t3.maxY = t3.maxYArr[i3]), void 0 !== e3.min && ("number" == typeof e3.min ? t3.minYArr[i3] = e3.min : "function" == typeof e3.min && (t3.minYArr[i3] = e3.min(t3.isMultipleYAxis ? t3.minYArr[i3] === Number.MIN_VALUE ? 0 : t3.minYArr[i3] : t3.minY)), t3.minY = t3.minYArr[i3]);
        }), t3.isBarHorizontal) {
          ["min", "max"].forEach(function(i3) {
            void 0 !== e2.xaxis[i3] && "number" == typeof e2.xaxis[i3] && ("min" === i3 ? t3.minY = e2.xaxis[i3] : t3.maxY = e2.xaxis[i3]);
          });
        }
        return t3.isMultipleYAxis ? (this.scales.setMultipleYScales(), t3.minY = i2, t3.yAxisScale.forEach(function(e3, i3) {
          t3.minYArr[i3] = e3.niceMin, t3.maxYArr[i3] = e3.niceMax;
        })) : (this.scales.setYScaleForIndex(0, t3.minY, t3.maxY), t3.minY = t3.yAxisScale[0].niceMin, t3.maxY = t3.yAxisScale[0].niceMax, t3.minYArr[0] = t3.yAxisScale[0].niceMin, t3.maxYArr[0] = t3.yAxisScale[0].niceMax), { minY: t3.minY, maxY: t3.maxY, minYArr: t3.minYArr, maxYArr: t3.maxYArr, yAxisScale: t3.yAxisScale };
      } }, { key: "setXRange", value: function() {
        var t3 = this.w.globals, e2 = this.w.config, i2 = "numeric" === e2.xaxis.type || "datetime" === e2.xaxis.type || "category" === e2.xaxis.type && !t3.noLabelsProvided || t3.noLabelsProvided || t3.isXNumeric;
        if (t3.isXNumeric && function() {
          for (var e3 = 0; e3 < t3.series.length; e3++)
            if (t3.labels[e3])
              for (var i3 = 0; i3 < t3.labels[e3].length; i3++)
                null !== t3.labels[e3][i3] && x.isNumber(t3.labels[e3][i3]) && (t3.maxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.initialMaxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.minX = Math.min(t3.minX, t3.labels[e3][i3]), t3.initialMinX = Math.min(t3.minX, t3.labels[e3][i3]));
        }(), t3.noLabelsProvided && 0 === e2.xaxis.categories.length && (t3.maxX = t3.labels[t3.labels.length - 1], t3.initialMaxX = t3.labels[t3.labels.length - 1], t3.minX = 1, t3.initialMinX = 1), t3.isXNumeric || t3.noLabelsProvided || t3.dataFormatXNumeric) {
          var a2;
          if (void 0 === e2.xaxis.tickAmount ? (a2 = Math.round(t3.svgWidth / 150), "numeric" === e2.xaxis.type && t3.dataPoints < 30 && (a2 = t3.dataPoints - 1), a2 > t3.dataPoints && 0 !== t3.dataPoints && (a2 = t3.dataPoints - 1)) : "dataPoints" === e2.xaxis.tickAmount ? (t3.series.length > 1 && (a2 = t3.series[t3.maxValsInArrayIndex].length - 1), t3.isXNumeric && (a2 = t3.maxX - t3.minX - 1)) : a2 = e2.xaxis.tickAmount, t3.xTickAmount = a2, void 0 !== e2.xaxis.max && "number" == typeof e2.xaxis.max && (t3.maxX = e2.xaxis.max), void 0 !== e2.xaxis.min && "number" == typeof e2.xaxis.min && (t3.minX = e2.xaxis.min), void 0 !== e2.xaxis.range && (t3.minX = t3.maxX - e2.xaxis.range), t3.minX !== Number.MAX_VALUE && t3.maxX !== -Number.MAX_VALUE)
            if (e2.xaxis.convertedCatToNumeric && !t3.dataFormatXNumeric) {
              for (var s2 = [], r2 = t3.minX - 1; r2 < t3.maxX; r2++)
                s2.push(r2 + 1);
              t3.xAxisScale = { result: s2, niceMin: s2[0], niceMax: s2[s2.length - 1] };
            } else
              t3.xAxisScale = this.scales.setXScale(t3.minX, t3.maxX);
          else
            t3.xAxisScale = this.scales.linearScale(0, a2, a2, 0, e2.xaxis.stepSize), t3.noLabelsProvided && t3.labels.length > 0 && (t3.xAxisScale = this.scales.linearScale(1, t3.labels.length, a2 - 1, 0, e2.xaxis.stepSize), t3.seriesX = t3.labels.slice());
          i2 && (t3.labels = t3.xAxisScale.result.slice());
        }
        return t3.isBarHorizontal && t3.labels.length && (t3.xTickAmount = t3.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t3.minX, maxX: t3.maxX };
      } }, { key: "setZRange", value: function() {
        var t3 = this.w.globals;
        if (t3.isDataXYZ) {
          for (var e2 = 0; e2 < t3.series.length; e2++)
            if (void 0 !== t3.seriesZ[e2])
              for (var i2 = 0; i2 < t3.seriesZ[e2].length; i2++)
                null !== t3.seriesZ[e2][i2] && x.isNumber(t3.seriesZ[e2][i2]) && (t3.maxZ = Math.max(t3.maxZ, t3.seriesZ[e2][i2]), t3.minZ = Math.min(t3.minZ, t3.seriesZ[e2][i2]));
        }
      } }, { key: "_handleSingleDataPoint", value: function() {
        var t3 = this.w.globals, e2 = this.w.config;
        if (t3.minX === t3.maxX) {
          var i2 = new I(this.ctx);
          if ("datetime" === e2.xaxis.type) {
            var a2 = i2.getDate(t3.minX);
            e2.xaxis.labels.datetimeUTC ? a2.setUTCDate(a2.getUTCDate() - 2) : a2.setDate(a2.getDate() - 2), t3.minX = new Date(a2).getTime();
            var s2 = i2.getDate(t3.maxX);
            e2.xaxis.labels.datetimeUTC ? s2.setUTCDate(s2.getUTCDate() + 2) : s2.setDate(s2.getDate() + 2), t3.maxX = new Date(s2).getTime();
          } else
            ("numeric" === e2.xaxis.type || "category" === e2.xaxis.type && !t3.noLabelsProvided) && (t3.minX = t3.minX - 2, t3.initialMinX = t3.minX, t3.maxX = t3.maxX + 2, t3.initialMaxX = t3.maxX);
        }
      } }, { key: "_getMinXDiff", value: function() {
        var t3 = this.w.globals;
        t3.isXNumeric && t3.seriesX.forEach(function(e2, i2) {
          1 === e2.length && e2.push(t3.seriesX[t3.maxValsInArrayIndex][t3.seriesX[t3.maxValsInArrayIndex].length - 1]);
          var a2 = e2.slice();
          a2.sort(function(t4, e3) {
            return t4 - e3;
          }), a2.forEach(function(e3, i3) {
            if (i3 > 0) {
              var s2 = e3 - a2[i3 - 1];
              s2 > 0 && (t3.minXDiff = Math.min(s2, t3.minXDiff));
            }
          }), 1 !== t3.dataPoints && t3.minXDiff !== Number.MAX_VALUE || (t3.minXDiff = 0.5);
        });
      } }, { key: "_setStackedMinMax", value: function() {
        var t3 = this, e2 = this.w.globals;
        if (e2.series.length) {
          var i2 = e2.seriesGroups;
          i2.length || (i2 = [this.w.config.series.map(function(t4) {
            return t4.name;
          })]);
          var a2 = {}, s2 = {};
          i2.forEach(function(i3) {
            a2[i3] = [], s2[i3] = [], t3.w.config.series.map(function(t4, e3) {
              return i3.indexOf(t4.name) > -1 ? e3 : null;
            }).filter(function(t4) {
              return null !== t4;
            }).forEach(function(r2) {
              for (var o2 = 0; o2 < e2.series[e2.maxValsInArrayIndex].length; o2++) {
                var n2, l2;
                void 0 === a2[i3][o2] && (a2[i3][o2] = 0, s2[i3][o2] = 0), (t3.w.config.chart.stacked && !e2.comboCharts || t3.w.config.chart.stacked && e2.comboCharts && (!t3.w.config.chart.stackOnlyBar || "bar" === (null === (n2 = t3.w.config.series) || void 0 === n2 || null === (l2 = n2[r2]) || void 0 === l2 ? void 0 : l2.type))) && null !== e2.series[r2][o2] && x.isNumber(e2.series[r2][o2]) && (e2.series[r2][o2] > 0 ? a2[i3][o2] += parseFloat(e2.series[r2][o2]) + 1e-4 : s2[i3][o2] += parseFloat(e2.series[r2][o2]));
              }
            });
          }), Object.entries(a2).forEach(function(t4) {
            var i3 = g(t4, 1)[0];
            a2[i3].forEach(function(t5, r2) {
              e2.maxY = Math.max(e2.maxY, a2[i3][r2]), e2.minY = Math.min(e2.minY, s2[i3][r2]);
            });
          });
        }
      } }]), t2;
    }();
    var q = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.elgrid = i2, this.w = e2.w;
        var s2 = this.w;
        this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.axisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === s2.config.chart.type && s2.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === s2.config.xaxis.position && (this.xAxisoffX = s2.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new B(e2);
      }
      return r(t2, [{ key: "drawYaxis", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = i2.config.yaxis[t3].labels.style, r2 = s2.fontSize, o2 = s2.fontFamily, n2 = s2.fontWeight, l2 = a2.group({ class: "apexcharts-yaxis", rel: t3, transform: "translate(" + i2.globals.translateYAxisX[t3] + ", 0)" });
        if (this.axesUtils.isYAxisHidden(t3))
          return l2;
        var h2 = a2.group({ class: "apexcharts-yaxis-texts-g" });
        l2.add(h2);
        var c2 = i2.globals.yAxisScale[t3].result.length - 1, d2 = i2.globals.gridHeight / c2, g2 = i2.globals.translateY, u5 = i2.globals.yLabelFormatters[t3], p2 = i2.globals.yAxisScale[t3].result.slice();
        p2 = this.axesUtils.checkForReversedLabels(t3, p2);
        var f2 = "";
        if (i2.config.yaxis[t3].labels.show)
          for (var x2 = function(l3) {
            var x3 = p2[l3];
            x3 = u5(x3, l3, i2);
            var b3 = i2.config.yaxis[t3].labels.padding;
            i2.config.yaxis[t3].opposite && 0 !== i2.config.yaxis.length && (b3 *= -1);
            var v3 = "end";
            i2.config.yaxis[t3].opposite && (v3 = "start"), "left" === i2.config.yaxis[t3].labels.align ? v3 = "start" : "center" === i2.config.yaxis[t3].labels.align ? v3 = "middle" : "right" === i2.config.yaxis[t3].labels.align && (v3 = "end");
            var m2 = e2.axesUtils.getYAxisForeColor(s2.colors, t3), y3 = i2.config.yaxis[t3].labels.offsetY;
            "heatmap" === i2.config.chart.type && (y3 -= (i2.globals.gridHeight / i2.globals.series.length - 1) / 2);
            var w3 = a2.drawText({ x: b3, y: g2 + c2 / 10 + y3 + 1, text: x3, textAnchor: v3, fontSize: r2, fontFamily: o2, fontWeight: n2, maxWidth: i2.config.yaxis[t3].labels.maxWidth, foreColor: Array.isArray(m2) ? m2[l3] : m2, isPlainText: false, cssClass: "apexcharts-yaxis-label " + s2.cssClass });
            l3 === c2 && (f2 = w3), h2.add(w3);
            var k3 = document.createElementNS(i2.globals.SVGNS, "title");
            if (k3.textContent = Array.isArray(x3) ? x3.join(" ") : x3, w3.node.appendChild(k3), 0 !== i2.config.yaxis[t3].labels.rotate) {
              var A3 = a2.rotateAroundCenter(f2.node), S3 = a2.rotateAroundCenter(w3.node);
              w3.node.setAttribute("transform", "rotate(".concat(i2.config.yaxis[t3].labels.rotate, " ").concat(A3.x, " ").concat(S3.y, ")"));
            }
            g2 += d2;
          }, b2 = c2; b2 >= 0; b2--)
            x2(b2);
        if (void 0 !== i2.config.yaxis[t3].title.text) {
          var v2 = a2.group({ class: "apexcharts-yaxis-title" }), y2 = 0;
          i2.config.yaxis[t3].opposite && (y2 = i2.globals.translateYAxisX[t3]);
          var w2 = a2.drawText({ x: y2, y: i2.globals.gridHeight / 2 + i2.globals.translateY + i2.config.yaxis[t3].title.offsetY, text: i2.config.yaxis[t3].title.text, textAnchor: "end", foreColor: i2.config.yaxis[t3].title.style.color, fontSize: i2.config.yaxis[t3].title.style.fontSize, fontWeight: i2.config.yaxis[t3].title.style.fontWeight, fontFamily: i2.config.yaxis[t3].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + i2.config.yaxis[t3].title.style.cssClass });
          v2.add(w2), l2.add(v2);
        }
        var k2 = i2.config.yaxis[t3].axisBorder, A2 = 31 + k2.offsetX;
        if (i2.config.yaxis[t3].opposite && (A2 = -31 - k2.offsetX), k2.show) {
          var S2 = a2.drawLine(A2, i2.globals.translateY + k2.offsetY - 2, A2, i2.globals.gridHeight + i2.globals.translateY + k2.offsetY + 2, k2.color, 0, k2.width);
          l2.add(S2);
        }
        return i2.config.yaxis[t3].axisTicks.show && this.axesUtils.drawYAxisTicks(A2, c2, k2, i2.config.yaxis[t3].axisTicks, t3, d2, l2), l2;
      } }, { key: "drawYaxisInversed", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx), a2 = i2.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s2 = i2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e2.globals.translateXAxisX, ", ").concat(e2.globals.translateXAxisY, ")") });
        a2.add(s2);
        var r2 = e2.globals.yAxisScale[t3].result.length - 1, o2 = e2.globals.gridWidth / r2 + 0.1, n2 = o2 + e2.config.xaxis.labels.offsetX, l2 = e2.globals.xLabelFormatter, h2 = e2.globals.yAxisScale[t3].result.slice(), c2 = e2.globals.timescaleLabels;
        c2.length > 0 && (this.xaxisLabels = c2.slice(), r2 = (h2 = c2.slice()).length), h2 = this.axesUtils.checkForReversedLabels(t3, h2);
        var d2 = c2.length;
        if (e2.config.xaxis.labels.show)
          for (var g2 = d2 ? 0 : r2; d2 ? g2 < d2 : g2 >= 0; d2 ? g2++ : g2--) {
            var u5 = h2[g2];
            u5 = l2(u5, g2, e2);
            var p2 = e2.globals.gridWidth + e2.globals.padHorizontal - (n2 - o2 + e2.config.xaxis.labels.offsetX);
            if (c2.length) {
              var f2 = this.axesUtils.getLabel(h2, c2, p2, g2, this.drawnLabels, this.xaxisFontSize);
              p2 = f2.x, u5 = f2.text, this.drawnLabels.push(f2.text), 0 === g2 && e2.globals.skipFirstTimelinelabel && (u5 = ""), g2 === h2.length - 1 && e2.globals.skipLastTimelinelabel && (u5 = "");
            }
            var x2 = i2.drawText({ x: p2, y: this.xAxisoffX + e2.config.xaxis.labels.offsetY + 30 - ("top" === e2.config.xaxis.position ? e2.globals.xAxisHeight + e2.config.xaxis.axisTicks.height - 2 : 0), text: u5, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t3] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e2.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label " + e2.config.xaxis.labels.style.cssClass });
            s2.add(x2), x2.tspan(u5);
            var b2 = document.createElementNS(e2.globals.SVGNS, "title");
            b2.textContent = u5, x2.node.appendChild(b2), n2 += o2;
          }
        return this.inversedYAxisTitleText(a2), this.inversedYAxisBorder(a2), a2;
      } }, { key: "inversedYAxisBorder", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx), a2 = e2.config.xaxis.axisBorder;
        if (a2.show) {
          var s2 = 0;
          "bar" === e2.config.chart.type && e2.globals.isXNumeric && (s2 -= 15);
          var r2 = i2.drawLine(e2.globals.padHorizontal + s2 + a2.offsetX, this.xAxisoffX, e2.globals.gridWidth, this.xAxisoffX, a2.color, 0, a2.height);
          this.elgrid && this.elgrid.elGridBorders && e2.config.grid.show ? this.elgrid.elGridBorders.add(r2) : t3.add(r2);
        }
      } }, { key: "inversedYAxisTitleText", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx);
        if (void 0 !== e2.config.xaxis.title.text) {
          var a2 = i2.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s2 = i2.drawText({ x: e2.globals.gridWidth / 2 + e2.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e2.config.xaxis.title.style.fontSize) + e2.config.xaxis.title.offsetY + 20, text: e2.config.xaxis.title.text, textAnchor: "middle", fontSize: e2.config.xaxis.title.style.fontSize, fontFamily: e2.config.xaxis.title.style.fontFamily, fontWeight: e2.config.xaxis.title.style.fontWeight, foreColor: e2.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e2.config.xaxis.title.style.cssClass });
          a2.add(s2), t3.add(a2);
        }
      } }, { key: "yAxisTitleRotate", value: function(t3, e2) {
        var i2 = this.w, a2 = new m(this.ctx), s2 = { width: 0, height: 0 }, r2 = { width: 0, height: 0 }, o2 = i2.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-texts-g"));
        null !== o2 && (s2 = o2.getBoundingClientRect());
        var n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-title text"));
        if (null !== n2 && (r2 = n2.getBoundingClientRect()), null !== n2) {
          var l2 = this.xPaddingForYAxisTitle(t3, s2, r2, e2);
          n2.setAttribute("x", l2.xPos - (e2 ? 10 : 0));
        }
        if (null !== n2) {
          var h2 = a2.rotateAroundCenter(n2);
          n2.setAttribute("transform", "rotate(".concat(e2 ? -1 * i2.config.yaxis[t3].title.rotate : i2.config.yaxis[t3].title.rotate, " ").concat(h2.x, " ").concat(h2.y, ")"));
        }
      } }, { key: "xPaddingForYAxisTitle", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = 0, o2 = 0, n2 = 10;
        return void 0 === s2.config.yaxis[t3].title.text || t3 < 0 ? { xPos: o2, padd: 0 } : (a2 ? (o2 = e2.width + s2.config.yaxis[t3].title.offsetX + i2.width / 2 + n2 / 2, 0 === (r2 += 1) && (o2 -= n2 / 2)) : (o2 = -1 * e2.width + s2.config.yaxis[t3].title.offsetX + n2 / 2 + i2.width / 2, s2.globals.isBarHorizontal && (n2 = 25, o2 = -1 * e2.width - s2.config.yaxis[t3].title.offsetX - n2)), { xPos: o2, padd: n2 });
      } }, { key: "setYAxisXPosition", value: function(t3, e2) {
        var i2 = this.w, a2 = 0, s2 = 0, r2 = 18, o2 = 1;
        i2.config.yaxis.length > 1 && (this.multipleYs = true), i2.config.yaxis.map(function(n2, l2) {
          var h2 = i2.globals.ignoreYAxisIndexes.indexOf(l2) > -1 || !n2.show || n2.floating || 0 === t3[l2].width, c2 = t3[l2].width + e2[l2].width;
          n2.opposite ? i2.globals.isBarHorizontal ? (s2 = i2.globals.gridWidth + i2.globals.translateX - 1, i2.globals.translateYAxisX[l2] = s2 - n2.labels.offsetX) : (s2 = i2.globals.gridWidth + i2.globals.translateX + o2, h2 || (o2 = o2 + c2 + 20), i2.globals.translateYAxisX[l2] = s2 - n2.labels.offsetX + 20) : (a2 = i2.globals.translateX - r2, h2 || (r2 = r2 + c2 + 20), i2.globals.translateYAxisX[l2] = a2 + n2.labels.offsetX);
        });
      } }, { key: "setYAxisTextAlignments", value: function() {
        var t3 = this.w, e2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
        (e2 = x.listToArray(e2)).forEach(function(e3, i2) {
          var a2 = t3.config.yaxis[i2];
          if (a2 && !a2.floating && void 0 !== a2.labels.align) {
            var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-texts-g")), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-label"));
            r2 = x.listToArray(r2);
            var o2 = s2.getBoundingClientRect();
            "left" === a2.labels.align ? (r2.forEach(function(t4, e4) {
              t4.setAttribute("text-anchor", "start");
            }), a2.opposite || s2.setAttribute("transform", "translate(-".concat(o2.width, ", 0)"))) : "center" === a2.labels.align ? (r2.forEach(function(t4, e4) {
              t4.setAttribute("text-anchor", "middle");
            }), s2.setAttribute("transform", "translate(".concat(o2.width / 2 * (a2.opposite ? 1 : -1), ", 0)"))) : "right" === a2.labels.align && (r2.forEach(function(t4, e4) {
              t4.setAttribute("text-anchor", "end");
            }), a2.opposite && s2.setAttribute("transform", "translate(".concat(o2.width, ", 0)")));
          }
        });
      } }]), t2;
    }();
    var Z = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.documentEvent = x.bind(this.documentEvent, this);
      }
      return r(t2, [{ key: "addEventListener", value: function(t3, e2) {
        var i2 = this.w;
        i2.globals.events.hasOwnProperty(t3) ? i2.globals.events[t3].push(e2) : i2.globals.events[t3] = [e2];
      } }, { key: "removeEventListener", value: function(t3, e2) {
        var i2 = this.w;
        if (i2.globals.events.hasOwnProperty(t3)) {
          var a2 = i2.globals.events[t3].indexOf(e2);
          -1 !== a2 && i2.globals.events[t3].splice(a2, 1);
        }
      } }, { key: "fireEvent", value: function(t3, e2) {
        var i2 = this.w;
        if (i2.globals.events.hasOwnProperty(t3)) {
          e2 && e2.length || (e2 = []);
          for (var a2 = i2.globals.events[t3], s2 = a2.length, r2 = 0; r2 < s2; r2++)
            a2[r2].apply(null, e2);
        }
      } }, { key: "setupEventHandlers", value: function() {
        var t3 = this, e2 = this.w, i2 = this.ctx, a2 = e2.globals.dom.baseEl.querySelector(e2.globals.chartClass);
        this.ctx.eventList.forEach(function(t4) {
          a2.addEventListener(t4, function(t5) {
            var a3 = Object.assign({}, e2, { seriesIndex: e2.globals.capturedSeriesIndex, dataPointIndex: e2.globals.capturedDataPointIndex });
            "mousemove" === t5.type || "touchmove" === t5.type ? "function" == typeof e2.config.chart.events.mouseMove && e2.config.chart.events.mouseMove(t5, i2, a3) : "mouseleave" === t5.type || "touchleave" === t5.type ? "function" == typeof e2.config.chart.events.mouseLeave && e2.config.chart.events.mouseLeave(t5, i2, a3) : ("mouseup" === t5.type && 1 === t5.which || "touchend" === t5.type) && ("function" == typeof e2.config.chart.events.click && e2.config.chart.events.click(t5, i2, a3), i2.ctx.events.fireEvent("click", [t5, i2, a3]));
          }, { capture: false, passive: true });
        }), this.ctx.eventList.forEach(function(i3) {
          e2.globals.dom.baseEl.addEventListener(i3, t3.documentEvent, { passive: true });
        }), this.ctx.core.setupBrushHandler();
      } }, { key: "documentEvent", value: function(t3) {
        var e2 = this.w, i2 = t3.target.className;
        if ("click" === t3.type) {
          var a2 = e2.globals.dom.baseEl.querySelector(".apexcharts-menu");
          a2 && a2.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i2 && a2.classList.remove("apexcharts-menu-open");
        }
        e2.globals.clientX = "touchmove" === t3.type ? t3.touches[0].clientX : t3.clientX, e2.globals.clientY = "touchmove" === t3.type ? t3.touches[0].clientY : t3.clientY;
      } }]), t2;
    }();
    var $ = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "setCurrentLocaleValues", value: function(t3) {
        var e2 = this.w.config.chart.locales;
        window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e2 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
        var i2 = e2.filter(function(e3) {
          return e3.name === t3;
        })[0];
        if (!i2)
          throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
        var a2 = x.extend(C, i2);
        this.w.globals.locale = a2.options;
      } }]), t2;
    }();
    var J = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "drawAxis", value: function(t3, e2) {
        var i2, a2, s2 = this, r2 = this.w.globals, o2 = this.w.config, n2 = new V(this.ctx, e2), l2 = new q(this.ctx, e2);
        r2.axisCharts && "radar" !== t3 && (r2.isBarHorizontal ? (a2 = l2.drawYaxisInversed(0), i2 = n2.drawXaxisInversed(0), r2.dom.elGraphical.add(i2), r2.dom.elGraphical.add(a2)) : (i2 = n2.drawXaxis(), r2.dom.elGraphical.add(i2), o2.yaxis.map(function(t4, e3) {
          if (-1 === r2.ignoreYAxisIndexes.indexOf(e3) && (a2 = l2.drawYaxis(e3), r2.dom.Paper.add(a2), "back" === s2.w.config.grid.position)) {
            var i3 = r2.dom.Paper.children()[1];
            i3.remove(), r2.dom.Paper.add(i3);
          }
        })));
      } }]), t2;
    }();
    var Q = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "drawXCrosshairs", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = new v(this.ctx), a2 = t3.config.xaxis.crosshairs.fill.gradient, s2 = t3.config.xaxis.crosshairs.dropShadow, r2 = t3.config.xaxis.crosshairs.fill.type, o2 = a2.colorFrom, n2 = a2.colorTo, l2 = a2.opacityFrom, h2 = a2.opacityTo, c2 = a2.stops, d2 = s2.enabled, g2 = s2.left, u5 = s2.top, p2 = s2.blur, f2 = s2.color, b2 = s2.opacity, y2 = t3.config.xaxis.crosshairs.fill.color;
        if (t3.config.xaxis.crosshairs.show) {
          "gradient" === r2 && (y2 = e2.drawGradient("vertical", o2, n2, l2, h2, null, c2, null));
          var w2 = e2.drawRect();
          1 === t3.config.xaxis.crosshairs.width && (w2 = e2.drawLine());
          var k2 = t3.globals.gridHeight;
          (!x.isNumber(k2) || k2 < 0) && (k2 = 0);
          var A2 = t3.config.xaxis.crosshairs.width;
          (!x.isNumber(A2) || A2 < 0) && (A2 = 0), w2.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: k2, width: A2, height: k2, fill: y2, filter: "none", "fill-opacity": t3.config.xaxis.crosshairs.opacity, stroke: t3.config.xaxis.crosshairs.stroke.color, "stroke-width": t3.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t3.config.xaxis.crosshairs.stroke.dashArray }), d2 && (w2 = i2.dropShadow(w2, { left: g2, top: u5, blur: p2, color: f2, opacity: b2 })), t3.globals.dom.elGraphical.add(w2);
        }
      } }, { key: "drawYCrosshairs", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = t3.config.yaxis[0].crosshairs, a2 = t3.globals.barPadForNumericAxis;
        if (t3.config.yaxis[0].crosshairs.show) {
          var s2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, i2.stroke.dashArray, i2.stroke.width);
          s2.attr({ class: "apexcharts-ycrosshairs" }), t3.globals.dom.elGraphical.add(s2);
        }
        var r2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, 0, 0);
        r2.attr({ class: "apexcharts-ycrosshairs-hidden" }), t3.globals.dom.elGraphical.add(r2);
      } }]), t2;
    }();
    var K = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "checkResponsiveConfig", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = i2.config;
        if (0 !== a2.responsive.length) {
          var s2 = a2.responsive.slice();
          s2.sort(function(t4, e3) {
            return t4.breakpoint > e3.breakpoint ? 1 : e3.breakpoint > t4.breakpoint ? -1 : 0;
          }).reverse();
          var r2 = new E({}), o2 = function() {
            var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a3 = s2[0].breakpoint, o3 = window.innerWidth > 0 ? window.innerWidth : screen.width;
            if (o3 > a3) {
              var n3 = y.extendArrayProps(r2, i2.globals.initialConfig, i2);
              t4 = x.extend(n3, t4), t4 = x.extend(i2.config, t4), e2.overrideResponsiveOptions(t4);
            } else
              for (var l2 = 0; l2 < s2.length; l2++)
                o3 < s2[l2].breakpoint && (t4 = y.extendArrayProps(r2, s2[l2].options, i2), t4 = x.extend(i2.config, t4), e2.overrideResponsiveOptions(t4));
          };
          if (t3) {
            var n2 = y.extendArrayProps(r2, t3, i2);
            n2 = x.extend(i2.config, n2), o2(n2 = x.extend(n2, t3));
          } else
            o2({});
        }
      } }, { key: "overrideResponsiveOptions", value: function(t3) {
        var e2 = new E(t3).init({ responsiveOverride: true });
        this.w.config = e2;
      } }]), t2;
    }();
    var tt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.colors = [], this.w = e2.w;
        var i2 = this.w;
        this.isColorFn = false, this.isHeatmapDistributed = "treemap" === i2.config.chart.type && i2.config.plotOptions.treemap.distributed || "heatmap" === i2.config.chart.type && i2.config.plotOptions.heatmap.distributed, this.isBarDistributed = i2.config.plotOptions.bar.distributed && ("bar" === i2.config.chart.type || "rangeBar" === i2.config.chart.type);
      }
      return r(t2, [{ key: "init", value: function() {
        this.setDefaultColors();
      } }, { key: "setDefaultColors", value: function() {
        var t3, e2 = this, i2 = this.w, a2 = new x();
        if (i2.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i2.config.theme.mode)), void 0 === i2.config.colors || 0 === (null === (t3 = i2.config.colors) || void 0 === t3 ? void 0 : t3.length) ? i2.globals.colors = this.predefined() : (i2.globals.colors = i2.config.colors, Array.isArray(i2.config.colors) && i2.config.colors.length > 0 && "function" == typeof i2.config.colors[0] && (i2.globals.colors = i2.config.series.map(function(t4, a3) {
          var s3 = i2.config.colors[a3];
          return s3 || (s3 = i2.config.colors[0]), "function" == typeof s3 ? (e2.isColorFn = true, s3({ value: i2.globals.axisCharts ? i2.globals.series[a3][0] ? i2.globals.series[a3][0] : 0 : i2.globals.series[a3], seriesIndex: a3, dataPointIndex: a3, w: i2 })) : s3;
        }))), i2.globals.seriesColors.map(function(t4, e3) {
          t4 && (i2.globals.colors[e3] = t4);
        }), i2.config.theme.monochrome.enabled) {
          var s2 = [], r2 = i2.globals.series.length;
          (this.isBarDistributed || this.isHeatmapDistributed) && (r2 = i2.globals.series[0].length * i2.globals.series.length);
          for (var o2 = i2.config.theme.monochrome.color, n2 = 1 / (r2 / i2.config.theme.monochrome.shadeIntensity), l2 = i2.config.theme.monochrome.shadeTo, h2 = 0, c2 = 0; c2 < r2; c2++) {
            var d2 = void 0;
            "dark" === l2 ? (d2 = a2.shadeColor(-1 * h2, o2), h2 += n2) : (d2 = a2.shadeColor(h2, o2), h2 += n2), s2.push(d2);
          }
          i2.globals.colors = s2.slice();
        }
        var g2 = i2.globals.colors.slice();
        this.pushExtraColors(i2.globals.colors);
        ["fill", "stroke"].forEach(function(t4) {
          void 0 === i2.config[t4].colors ? i2.globals[t4].colors = e2.isColorFn ? i2.config.colors : g2 : i2.globals[t4].colors = i2.config[t4].colors.slice(), e2.pushExtraColors(i2.globals[t4].colors);
        }), void 0 === i2.config.dataLabels.style.colors ? i2.globals.dataLabels.style.colors = g2 : i2.globals.dataLabels.style.colors = i2.config.dataLabels.style.colors.slice(), this.pushExtraColors(i2.globals.dataLabels.style.colors, 50), void 0 === i2.config.plotOptions.radar.polygons.fill.colors ? i2.globals.radarPolygons.fill.colors = ["dark" === i2.config.theme.mode ? "#424242" : "none"] : i2.globals.radarPolygons.fill.colors = i2.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(i2.globals.radarPolygons.fill.colors, 20), void 0 === i2.config.markers.colors ? i2.globals.markers.colors = g2 : i2.globals.markers.colors = i2.config.markers.colors.slice(), this.pushExtraColors(i2.globals.markers.colors);
      } }, { key: "pushExtraColors", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = e2 || a2.globals.series.length;
        if (null === i2 && (i2 = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a2.config.chart.type && a2.config.plotOptions.heatmap.colorScale.inverse), i2 && a2.globals.series.length && (s2 = a2.globals.series[a2.globals.maxValsInArrayIndex].length * a2.globals.series.length), t3.length < s2)
          for (var r2 = s2 - t3.length, o2 = 0; o2 < r2; o2++)
            t3.push(t3[o2]);
      } }, { key: "updateThemeOptions", value: function(t3) {
        t3.chart = t3.chart || {}, t3.tooltip = t3.tooltip || {};
        var e2 = t3.theme.mode || "light", i2 = t3.theme.palette ? t3.theme.palette : "dark" === e2 ? "palette4" : "palette1", a2 = t3.chart.foreColor ? t3.chart.foreColor : "dark" === e2 ? "#f6f7f8" : "#373d3f";
        return t3.tooltip.theme = e2, t3.chart.foreColor = a2, t3.theme.palette = i2, t3;
      } }, { key: "predefined", value: function() {
        switch (this.w.config.theme.palette) {
          case "palette1":
          default:
            this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
            break;
          case "palette2":
            this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
            break;
          case "palette3":
            this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
            break;
          case "palette4":
            this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
            break;
          case "palette5":
            this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
            break;
          case "palette6":
            this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
            break;
          case "palette7":
            this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
            break;
          case "palette8":
            this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
            break;
          case "palette9":
            this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
            break;
          case "palette10":
            this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
        }
        return this.colors;
      } }]), t2;
    }();
    var et = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "draw", value: function() {
        this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
      } }, { key: "drawTitleSubtitle", value: function(t3) {
        var e2 = this.w, i2 = "title" === t3 ? e2.config.title : e2.config.subtitle, a2 = e2.globals.svgWidth / 2, s2 = i2.offsetY, r2 = "middle";
        if ("left" === i2.align ? (a2 = 10, r2 = "start") : "right" === i2.align && (a2 = e2.globals.svgWidth - 10, r2 = "end"), a2 += i2.offsetX, s2 = s2 + parseInt(i2.style.fontSize, 10) + i2.margin / 2, void 0 !== i2.text) {
          var o2 = new m(this.ctx).drawText({ x: a2, y: s2, text: i2.text, textAnchor: r2, fontSize: i2.style.fontSize, fontFamily: i2.style.fontFamily, fontWeight: i2.style.fontWeight, foreColor: i2.style.color, opacity: 1 });
          o2.node.setAttribute("class", "apexcharts-".concat(t3, "-text")), e2.globals.dom.Paper.add(o2);
        }
      } }]), t2;
    }();
    var it = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.dCtx = e2;
      }
      return r(t2, [{ key: "getTitleSubtitleCoords", value: function(t3) {
        var e2 = this.w, i2 = 0, a2 = 0, s2 = "title" === t3 ? e2.config.title.floating : e2.config.subtitle.floating, r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(t3, "-text"));
        if (null !== r2 && !s2) {
          var o2 = r2.getBoundingClientRect();
          i2 = o2.width, a2 = e2.globals.axisCharts ? o2.height + 5 : o2.height;
        }
        return { width: i2, height: a2 };
      } }, { key: "getLegendsRect", value: function() {
        var t3 = this.w, e2 = t3.globals.dom.elLegendWrap;
        t3.config.legend.height || "top" !== t3.config.legend.position && "bottom" !== t3.config.legend.position || (e2.style.maxHeight = t3.globals.svgHeight / 2 + "px");
        var i2 = Object.assign({}, x.getBoundingClientRect(e2));
        return null !== e2 && !t3.config.legend.floating && t3.config.legend.show ? this.dCtx.lgRect = { x: i2.x, y: i2.y, height: i2.height, width: 0 === i2.height ? 0 : i2.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, "left" !== t3.config.legend.position && "right" !== t3.config.legend.position || 1.5 * this.dCtx.lgRect.width > t3.globals.svgWidth && (this.dCtx.lgRect.width = t3.globals.svgWidth / 1.5), this.dCtx.lgRect;
      } }, { key: "getLargestStringFromMultiArr", value: function(t3, e2) {
        var i2 = t3;
        if (this.w.globals.isMultiLineX) {
          var a2 = e2.map(function(t4, e3) {
            return Array.isArray(t4) ? t4.length : 1;
          }), s2 = Math.max.apply(Math, u4(a2));
          i2 = e2[a2.indexOf(s2)];
        }
        return i2;
      } }]), t2;
    }();
    var at = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.dCtx = e2;
      }
      return r(t2, [{ key: "getxAxisLabelsCoords", value: function() {
        var t3, e2 = this.w, i2 = e2.globals.labels.slice();
        if (e2.config.xaxis.convertedCatToNumeric && 0 === i2.length && (i2 = e2.globals.categoryLabels), e2.globals.timescaleLabels.length > 0) {
          var a2 = this.getxAxisTimeScaleLabelsCoords();
          t3 = { width: a2.width, height: a2.height }, e2.globals.rotateXLabels = false;
        } else {
          this.dCtx.lgWidthForSideLegends = "left" !== e2.config.legend.position && "right" !== e2.config.legend.position || e2.config.legend.floating ? 0 : this.dCtx.lgRect.width;
          var s2 = e2.globals.xLabelFormatter, r2 = x.getLargestStringFromArr(i2), o2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, i2);
          e2.globals.isBarHorizontal && (o2 = r2 = e2.globals.yAxisScale[0].result.reduce(function(t4, e3) {
            return t4.length > e3.length ? t4 : e3;
          }, 0));
          var n2 = new T(this.dCtx.ctx), l2 = r2;
          r2 = n2.xLabelFormat(s2, r2, l2, { i: void 0, dateFormatter: new I(this.dCtx.ctx).formatDate, w: e2 }), o2 = n2.xLabelFormat(s2, o2, l2, { i: void 0, dateFormatter: new I(this.dCtx.ctx).formatDate, w: e2 }), (e2.config.xaxis.convertedCatToNumeric && void 0 === r2 || "" === String(r2).trim()) && (o2 = r2 = "1");
          var h2 = new m(this.dCtx.ctx), c2 = h2.getTextRects(r2, e2.config.xaxis.labels.style.fontSize), d2 = c2;
          if (r2 !== o2 && (d2 = h2.getTextRects(o2, e2.config.xaxis.labels.style.fontSize)), (t3 = { width: c2.width >= d2.width ? c2.width : d2.width, height: c2.height >= d2.height ? c2.height : d2.height }).width * i2.length > e2.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e2.config.xaxis.labels.rotate || e2.config.xaxis.labels.rotateAlways) {
            if (!e2.globals.isBarHorizontal) {
              e2.globals.rotateXLabels = true;
              var g2 = function(t4) {
                return h2.getTextRects(t4, e2.config.xaxis.labels.style.fontSize, e2.config.xaxis.labels.style.fontFamily, "rotate(".concat(e2.config.xaxis.labels.rotate, " 0 0)"), false);
              };
              c2 = g2(r2), r2 !== o2 && (d2 = g2(o2)), t3.height = (c2.height > d2.height ? c2.height : d2.height) / 1.5, t3.width = c2.width > d2.width ? c2.width : d2.width;
            }
          } else
            e2.globals.rotateXLabels = false;
        }
        return e2.config.xaxis.labels.show || (t3 = { width: 0, height: 0 }), { width: t3.width, height: t3.height };
      } }, { key: "getxAxisGroupLabelsCoords", value: function() {
        var t3, e2 = this.w;
        if (!e2.globals.hasXaxisGroups)
          return { width: 0, height: 0 };
        var i2, a2 = (null === (t3 = e2.config.xaxis.group.style) || void 0 === t3 ? void 0 : t3.fontSize) || e2.config.xaxis.labels.style.fontSize, s2 = e2.globals.groups.map(function(t4) {
          return t4.title;
        }), r2 = x.getLargestStringFromArr(s2), o2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, s2), n2 = new m(this.dCtx.ctx), l2 = n2.getTextRects(r2, a2), h2 = l2;
        return r2 !== o2 && (h2 = n2.getTextRects(o2, a2)), i2 = { width: l2.width >= h2.width ? l2.width : h2.width, height: l2.height >= h2.height ? l2.height : h2.height }, e2.config.xaxis.labels.show || (i2 = { width: 0, height: 0 }), { width: i2.width, height: i2.height };
      } }, { key: "getxAxisTitleCoords", value: function() {
        var t3 = this.w, e2 = 0, i2 = 0;
        if (void 0 !== t3.config.xaxis.title.text) {
          var a2 = new m(this.dCtx.ctx).getTextRects(t3.config.xaxis.title.text, t3.config.xaxis.title.style.fontSize);
          e2 = a2.width, i2 = a2.height;
        }
        return { width: e2, height: i2 };
      } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
        var t3, e2 = this.w;
        this.dCtx.timescaleLabels = e2.globals.timescaleLabels.slice();
        var i2 = this.dCtx.timescaleLabels.map(function(t4) {
          return t4.value;
        }), a2 = i2.reduce(function(t4, e3) {
          return void 0 === t4 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t4.length > e3.length ? t4 : e3;
        }, 0);
        return 1.05 * (t3 = new m(this.dCtx.ctx).getTextRects(a2, e2.config.xaxis.labels.style.fontSize)).width * i2.length > e2.globals.gridWidth && 0 !== e2.config.xaxis.labels.rotate && (e2.globals.overlappingXLabels = true), t3;
      } }, { key: "additionalPaddingXLabels", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = i2.globals, s2 = i2.config, r2 = s2.xaxis.type, o2 = t3.width;
        a2.skipLastTimelinelabel = false, a2.skipFirstTimelinelabel = false;
        var n2 = i2.config.yaxis[0].opposite && i2.globals.isBarHorizontal, l2 = function(t4, n3) {
          s2.yaxis.length > 1 && function(t5) {
            return -1 !== a2.collapsedSeriesIndices.indexOf(t5);
          }(n3) || function(t5) {
            if (e2.dCtx.timescaleLabels && e2.dCtx.timescaleLabels.length) {
              var n4 = e2.dCtx.timescaleLabels[0], l3 = e2.dCtx.timescaleLabels[e2.dCtx.timescaleLabels.length - 1].position + o2 / 1.75 - e2.dCtx.yAxisWidthRight, h2 = n4.position - o2 / 1.75 + e2.dCtx.yAxisWidthLeft, c2 = "right" === i2.config.legend.position && e2.dCtx.lgRect.width > 0 ? e2.dCtx.lgRect.width : 0;
              l3 > a2.svgWidth - a2.translateX - c2 && (a2.skipLastTimelinelabel = true), h2 < -(t5.show && !t5.floating || "bar" !== s2.chart.type && "candlestick" !== s2.chart.type && "rangeBar" !== s2.chart.type && "boxPlot" !== s2.chart.type ? 10 : o2 / 1.75) && (a2.skipFirstTimelinelabel = true);
            } else
              "datetime" === r2 ? e2.dCtx.gridPad.right < o2 && !a2.rotateXLabels && (a2.skipLastTimelinelabel = true) : "datetime" !== r2 && e2.dCtx.gridPad.right < o2 / 2 - e2.dCtx.yAxisWidthRight && !a2.rotateXLabels && !i2.config.xaxis.labels.trim && ("between" !== i2.config.xaxis.tickPlacement || i2.globals.isBarHorizontal) && (e2.dCtx.xPadRight = o2 / 2 + 1);
          }(t4);
        };
        s2.yaxis.forEach(function(t4, i3) {
          n2 ? (e2.dCtx.gridPad.left < o2 && (e2.dCtx.xPadLeft = o2 / 2 + 1), e2.dCtx.xPadRight = o2 / 2 + 1) : l2(t4, i3);
        });
      } }]), t2;
    }();
    var st = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.dCtx = e2;
      }
      return r(t2, [{ key: "getyAxisLabelsCoords", value: function() {
        var t3 = this, e2 = this.w, i2 = [], a2 = 10, s2 = new B(this.dCtx.ctx);
        return e2.config.yaxis.map(function(r2, o2) {
          var n2 = { seriesIndex: o2, dataPointIndex: -1, w: e2 }, l2 = e2.globals.yAxisScale[o2], h2 = 0;
          if (!s2.isYAxisHidden(o2) && r2.labels.show && void 0 !== r2.labels.minWidth && (h2 = r2.labels.minWidth), !s2.isYAxisHidden(o2) && r2.labels.show && l2.result.length) {
            var c2 = e2.globals.yLabelFormatters[o2], d2 = l2.niceMin === Number.MIN_VALUE ? 0 : l2.niceMin, g2 = l2.result.reduce(function(t4, e3) {
              var i3, a3;
              return (null === (i3 = String(c2(t4, n2))) || void 0 === i3 ? void 0 : i3.length) > (null === (a3 = String(c2(e3, n2))) || void 0 === a3 ? void 0 : a3.length) ? t4 : e3;
            }, d2), u5 = g2 = c2(g2, n2);
            if (void 0 !== g2 && 0 !== g2.length || (g2 = l2.niceMax), e2.globals.isBarHorizontal) {
              a2 = 0;
              var p2 = e2.globals.labels.slice();
              g2 = x.getLargestStringFromArr(p2), g2 = c2(g2, { seriesIndex: o2, dataPointIndex: -1, w: e2 }), u5 = t3.dCtx.dimHelpers.getLargestStringFromMultiArr(g2, p2);
            }
            var f2 = new m(t3.dCtx.ctx), b2 = "rotate(".concat(r2.labels.rotate, " 0 0)"), v2 = f2.getTextRects(g2, r2.labels.style.fontSize, r2.labels.style.fontFamily, b2, false), y2 = v2;
            g2 !== u5 && (y2 = f2.getTextRects(u5, r2.labels.style.fontSize, r2.labels.style.fontFamily, b2, false)), i2.push({ width: (h2 > y2.width || h2 > v2.width ? h2 : y2.width > v2.width ? y2.width : v2.width) + a2, height: y2.height > v2.height ? y2.height : v2.height });
          } else
            i2.push({ width: 0, height: 0 });
        }), i2;
      } }, { key: "getyAxisTitleCoords", value: function() {
        var t3 = this, e2 = this.w, i2 = [];
        return e2.config.yaxis.map(function(e3, a2) {
          if (e3.show && void 0 !== e3.title.text) {
            var s2 = new m(t3.dCtx.ctx), r2 = "rotate(".concat(e3.title.rotate, " 0 0)"), o2 = s2.getTextRects(e3.title.text, e3.title.style.fontSize, e3.title.style.fontFamily, r2, false);
            i2.push({ width: o2.width, height: o2.height });
          } else
            i2.push({ width: 0, height: 0 });
        }), i2;
      } }, { key: "getTotalYAxisWidth", value: function() {
        var t3 = this.w, e2 = 0, i2 = 0, a2 = 0, s2 = t3.globals.yAxisScale.length > 1 ? 10 : 0, r2 = new B(this.dCtx.ctx), o2 = function(o3, n2) {
          var l2 = t3.config.yaxis[n2].floating, h2 = 0;
          o3.width > 0 && !l2 ? (h2 = o3.width + s2, function(e3) {
            return t3.globals.ignoreYAxisIndexes.indexOf(e3) > -1;
          }(n2) && (h2 = h2 - o3.width - s2)) : h2 = l2 || r2.isYAxisHidden(n2) ? 0 : 5, t3.config.yaxis[n2].opposite ? a2 += h2 : i2 += h2, e2 += h2;
        };
        return t3.globals.yLabelsCoords.map(function(t4, e3) {
          o2(t4, e3);
        }), t3.globals.yTitleCoords.map(function(t4, e3) {
          o2(t4, e3);
        }), t3.globals.isBarHorizontal && !t3.config.yaxis[0].floating && (e2 = t3.globals.yLabelsCoords[0].width + t3.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i2, this.dCtx.yAxisWidthRight = a2, e2;
      } }]), t2;
    }();
    var rt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.dCtx = e2;
      }
      return r(t2, [{ key: "gridPadForColumnsInNumericAxis", value: function(t3) {
        var e2 = this.w;
        if (e2.globals.noData || e2.globals.allSeriesCollapsed)
          return 0;
        var i2 = function(t4) {
          return "bar" === t4 || "rangeBar" === t4 || "candlestick" === t4 || "boxPlot" === t4;
        }, a2 = e2.config.chart.type, s2 = 0, r2 = i2(a2) ? e2.config.series.length : 1;
        if (e2.globals.comboBarCount > 0 && (r2 = e2.globals.comboBarCount), e2.globals.collapsedSeries.forEach(function(t4) {
          i2(t4.type) && (r2 -= 1);
        }), e2.config.chart.stacked && (r2 = 1), (i2(a2) || e2.globals.comboBarCount > 0) && e2.globals.isXNumeric && !e2.globals.isBarHorizontal && r2 > 0) {
          var o2, n2, l2 = Math.abs(e2.globals.initialMaxX - e2.globals.initialMinX);
          l2 <= 3 && (l2 = e2.globals.dataPoints), o2 = l2 / t3, e2.globals.minXDiff && e2.globals.minXDiff / o2 > 0 && (n2 = e2.globals.minXDiff / o2), n2 > t3 / 2 && (n2 /= 2), (s2 = n2 / r2 * parseInt(e2.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s2 = 1), s2 = s2 / (r2 > 1 ? 1 : 1.5) + 5, e2.globals.barPadForNumericAxis = s2;
        }
        return s2;
      } }, { key: "gridPadFortitleSubtitle", value: function() {
        var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dCtx.isSparkline || !e2.globals.axisCharts ? 0 : 10;
        ["title", "subtitle"].forEach(function(i3) {
          void 0 !== e2.config[i3].text ? a2 += e2.config[i3].margin : a2 += t3.dCtx.isSparkline || !e2.globals.axisCharts ? 0 : 5;
        }), !e2.config.legend.show || "bottom" !== e2.config.legend.position || e2.config.legend.floating || e2.globals.axisCharts || (a2 += 10);
        var s2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
        i2.gridHeight = i2.gridHeight - s2.height - r2.height - a2, i2.translateY = i2.translateY + s2.height + r2.height + a2;
      } }, { key: "setGridXPosForDualYAxis", value: function(t3, e2) {
        var i2 = this.w, a2 = new B(this.dCtx.ctx);
        i2.config.yaxis.map(function(s2, r2) {
          -1 !== i2.globals.ignoreYAxisIndexes.indexOf(r2) || s2.floating || a2.isYAxisHidden(r2) || (s2.opposite && (i2.globals.translateX = i2.globals.translateX - (e2[r2].width + t3[r2].width) - parseInt(i2.config.yaxis[r2].labels.style.fontSize, 10) / 1.2 - 12), i2.globals.translateX < 2 && (i2.globals.translateX = 2));
        });
      } }]), t2;
    }();
    var ot = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new it(this), this.dimYAxis = new st(this), this.dimXAxis = new at(this), this.dimGrid = new rt(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
      }
      return r(t2, [{ key: "plotCoords", value: function() {
        var t3 = this, e2 = this.w, i2 = e2.globals;
        this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && ((e2.config.markers.discrete.length > 0 || e2.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(e3) {
          var i3 = g(e3, 2), a3 = i3[0], s2 = i3[1];
          t3.gridPad[a3] = Math.max(s2, t3.w.globals.markers.largestSize / 1.5);
        }), this.gridPad.top = Math.max(e2.config.stroke.width / 2, this.gridPad.top), this.gridPad.bottom = Math.max(e2.config.stroke.width / 2, this.gridPad.bottom)), i2.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i2.gridHeight = i2.gridHeight - this.gridPad.top - this.gridPad.bottom, i2.gridWidth = i2.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
        var a2 = this.dimGrid.gridPadForColumnsInNumericAxis(i2.gridWidth);
        i2.gridWidth = i2.gridWidth - 2 * a2, i2.translateX = i2.translateX + this.gridPad.left + this.xPadLeft + (a2 > 0 ? a2 + 4 : 0), i2.translateY = i2.translateY + this.gridPad.top;
      } }, { key: "setDimensionsForAxisCharts", value: function() {
        var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dimYAxis.getyAxisLabelsCoords(), s2 = this.dimYAxis.getyAxisTitleCoords();
        e2.globals.yLabelsCoords = [], e2.globals.yTitleCoords = [], e2.config.yaxis.map(function(t4, i3) {
          e2.globals.yLabelsCoords.push({ width: a2[i3].width, index: i3 }), e2.globals.yTitleCoords.push({ width: s2[i3].width, index: i3 });
        }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
        var r2 = this.dimXAxis.getxAxisLabelsCoords(), o2 = this.dimXAxis.getxAxisGroupLabelsCoords(), n2 = this.dimXAxis.getxAxisTitleCoords();
        this.conditionalChecksForAxisCoords(r2, n2, o2), i2.translateXAxisY = e2.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i2.translateXAxisX = e2.globals.rotateXLabels && e2.globals.isXNumeric && e2.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e2.globals.isBarHorizontal && (i2.rotateXLabels = false, i2.translateXAxisY = parseInt(e2.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i2.translateXAxisY = i2.translateXAxisY + e2.config.xaxis.labels.offsetY, i2.translateXAxisX = i2.translateXAxisX + e2.config.xaxis.labels.offsetX;
        var l2 = this.yAxisWidth, h2 = this.xAxisHeight;
        i2.xAxisLabelsHeight = this.xAxisHeight - n2.height, i2.xAxisGroupLabelsHeight = i2.xAxisLabelsHeight - r2.height, i2.xAxisLabelsWidth = this.xAxisWidth, i2.xAxisHeight = this.xAxisHeight;
        var c2 = 10;
        ("radar" === e2.config.chart.type || this.isSparkline) && (l2 = 0, h2 = i2.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || "treemap" === e2.config.chart.type) && (l2 = 0, h2 = 0, c2 = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r2);
        var d2 = function() {
          i2.translateX = l2, i2.gridHeight = i2.svgHeight - t3.lgRect.height - h2 - (t3.isSparkline || "treemap" === e2.config.chart.type ? 0 : e2.globals.rotateXLabels ? 10 : 15), i2.gridWidth = i2.svgWidth - l2;
        };
        switch ("top" === e2.config.xaxis.position && (c2 = i2.xAxisHeight - e2.config.xaxis.axisTicks.height - 5), e2.config.legend.position) {
          case "bottom":
            i2.translateY = c2, d2();
            break;
          case "top":
            i2.translateY = this.lgRect.height + c2, d2();
            break;
          case "left":
            i2.translateY = c2, i2.translateX = this.lgRect.width + l2, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2;
            break;
          case "right":
            i2.translateY = c2, i2.translateX = l2, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 5;
            break;
          default:
            throw new Error("Legend position not supported");
        }
        this.dimGrid.setGridXPosForDualYAxis(s2, a2), new q(this.ctx).setYAxisXPosition(a2, s2);
      } }, { key: "setDimensionsForNonAxisCharts", value: function() {
        var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = 0;
        t3.config.legend.show && !t3.config.legend.floating && (a2 = 20);
        var s2 = "pie" === i2.chart.type || "polarArea" === i2.chart.type || "donut" === i2.chart.type ? "pie" : "radialBar", r2 = i2.plotOptions[s2].offsetY, o2 = i2.plotOptions[s2].offsetX;
        if (!i2.legend.show || i2.legend.floating)
          return e2.gridHeight = e2.svgHeight - i2.grid.padding.left + i2.grid.padding.right, e2.gridWidth = e2.gridHeight, e2.translateY = r2, void (e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2);
        switch (i2.legend.position) {
          case "bottom":
            e2.gridHeight = e2.svgHeight - this.lgRect.height - e2.goldenPadding, e2.gridWidth = e2.svgWidth, e2.translateY = r2 - 10, e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2;
            break;
          case "top":
            e2.gridHeight = e2.svgHeight - this.lgRect.height - e2.goldenPadding, e2.gridWidth = e2.svgWidth, e2.translateY = this.lgRect.height + r2 + 10, e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2;
            break;
          case "left":
            e2.gridWidth = e2.svgWidth - this.lgRect.width - a2, e2.gridHeight = "auto" !== i2.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = o2 + this.lgRect.width + a2;
            break;
          case "right":
            e2.gridWidth = e2.svgWidth - this.lgRect.width - a2 - 5, e2.gridHeight = "auto" !== i2.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = o2 + 10;
            break;
          default:
            throw new Error("Legend position not supported");
        }
      } }, { key: "conditionalChecksForAxisCoords", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = a2.globals.hasXaxisGroups ? 2 : 1, r2 = i2.height + t3.height + e2.height, o2 = a2.globals.isMultiLineX ? 1.2 : a2.globals.LINE_HEIGHT_RATIO, n2 = a2.globals.rotateXLabels ? 22 : 10, l2 = a2.globals.rotateXLabels && "bottom" === a2.config.legend.position ? 10 : 0;
        this.xAxisHeight = r2 * o2 + s2 * n2 + l2, this.xAxisWidth = t3.width, this.xAxisHeight - e2.height > a2.config.xaxis.labels.maxHeight && (this.xAxisHeight = a2.config.xaxis.labels.maxHeight), a2.config.xaxis.labels.minHeight && this.xAxisHeight < a2.config.xaxis.labels.minHeight && (this.xAxisHeight = a2.config.xaxis.labels.minHeight), a2.config.xaxis.floating && (this.xAxisHeight = 0);
        var h2 = 0, c2 = 0;
        a2.config.yaxis.forEach(function(t4) {
          h2 += t4.labels.minWidth, c2 += t4.labels.maxWidth;
        }), this.yAxisWidth < h2 && (this.yAxisWidth = h2), this.yAxisWidth > c2 && (this.yAxisWidth = c2);
      } }]), t2;
    }();
    var nt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.lgCtx = e2;
      }
      return r(t2, [{ key: "getLegendStyles", value: function() {
        var t3, e2, i2, a2 = document.createElement("style");
        a2.setAttribute("type", "text/css");
        var s2 = (null === (t3 = this.lgCtx.ctx) || void 0 === t3 || null === (e2 = t3.opts) || void 0 === e2 || null === (i2 = e2.chart) || void 0 === i2 ? void 0 : i2.nonce) || this.w.config.chart.nonce;
        s2 && a2.setAttribute("nonce", s2);
        var r2 = document.createTextNode("	\n    	\n      .apexcharts-legend {	\n        display: flex;	\n        overflow: auto;	\n        padding: 0 10px;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {	\n        flex-wrap: wrap	\n      }	\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	\n        flex-direction: column;	\n        bottom: 0;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	\n        justify-content: flex-start;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {	\n        justify-content: center;  	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {	\n        justify-content: flex-end;	\n      }	\n      .apexcharts-legend-series {	\n        cursor: pointer;	\n        line-height: normal;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{	\n        display: flex;	\n        align-items: center;	\n      }	\n      .apexcharts-legend-text {	\n        position: relative;	\n        font-size: 14px;	\n      }	\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {	\n        pointer-events: none;	\n      }	\n      .apexcharts-legend-marker {	\n        position: relative;	\n        display: inline-block;	\n        cursor: pointer;	\n        margin-right: 3px;	\n        border-style: solid;\n      }	\n      	\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{	\n        display: inline-block;	\n      }	\n      .apexcharts-legend-series.apexcharts-no-click {	\n        cursor: auto;	\n      }	\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {	\n        display: none !important;	\n      }	\n      .apexcharts-inactive-legend {	\n        opacity: 0.45;	\n      }");
        return a2.appendChild(r2), a2;
      } }, { key: "getLegendBBox", value: function() {
        var t3 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e2 = t3.width;
        return { clwh: t3.height, clww: e2 };
      } }, { key: "appendToForeignObject", value: function() {
        this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
      } }, { key: "toggleDataSeries", value: function(t3, e2) {
        var i2 = this, a2 = this.w;
        if (a2.globals.axisCharts || "radialBar" === a2.config.chart.type) {
          a2.globals.resized = true;
          var s2 = null, r2 = null;
          if (a2.globals.risingSeries = [], a2.globals.axisCharts ? (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t3, "']")), r2 = parseInt(s2.getAttribute("data:realIndex"), 10)) : (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t3 + 1, "']")), r2 = parseInt(s2.getAttribute("rel"), 10) - 1), e2)
            [{ cs: a2.globals.collapsedSeries, csi: a2.globals.collapsedSeriesIndices }, { cs: a2.globals.ancillaryCollapsedSeries, csi: a2.globals.ancillaryCollapsedSeriesIndices }].forEach(function(t4) {
              i2.riseCollapsedSeries(t4.cs, t4.csi, r2);
            });
          else
            this.hideSeries({ seriesEl: s2, realIndex: r2 });
        } else {
          var o2 = a2.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t3 + 1, "'] path")), n2 = a2.config.chart.type;
          if ("pie" === n2 || "polarArea" === n2 || "donut" === n2) {
            var l2 = a2.config.plotOptions.pie.donut.labels;
            new m(this.lgCtx.ctx).pathMouseDown(o2.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(o2.members[0].node, l2);
          }
          o2.fire("click");
        }
      } }, { key: "hideSeries", value: function(t3) {
        var e2 = t3.seriesEl, i2 = t3.realIndex, a2 = this.w, s2 = x.clone(a2.config.series);
        if (a2.globals.axisCharts) {
          var r2 = false;
          if (a2.config.yaxis[i2] && a2.config.yaxis[i2].show && a2.config.yaxis[i2].showAlways && (r2 = true, a2.globals.ancillaryCollapsedSeriesIndices.indexOf(i2) < 0 && (a2.globals.ancillaryCollapsedSeries.push({ index: i2, data: s2[i2].data.slice(), type: e2.parentNode.className.baseVal.split("-")[1] }), a2.globals.ancillaryCollapsedSeriesIndices.push(i2))), !r2) {
            a2.globals.collapsedSeries.push({ index: i2, data: s2[i2].data.slice(), type: e2.parentNode.className.baseVal.split("-")[1] }), a2.globals.collapsedSeriesIndices.push(i2);
            var o2 = a2.globals.risingSeries.indexOf(i2);
            a2.globals.risingSeries.splice(o2, 1);
          }
        } else
          a2.globals.collapsedSeries.push({ index: i2, data: s2[i2] }), a2.globals.collapsedSeriesIndices.push(i2);
        for (var n2 = e2.childNodes, l2 = 0; l2 < n2.length; l2++)
          n2[l2].classList.contains("apexcharts-series-markers-wrap") && (n2[l2].classList.contains("apexcharts-hide") ? n2[l2].classList.remove("apexcharts-hide") : n2[l2].classList.add("apexcharts-hide"));
        a2.globals.allSeriesCollapsed = a2.globals.collapsedSeries.length === a2.config.series.length, s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
      } }, { key: "riseCollapsedSeries", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = x.clone(a2.config.series);
        if (t3.length > 0) {
          for (var r2 = 0; r2 < t3.length; r2++)
            t3[r2].index === i2 && (a2.globals.axisCharts ? (s2[i2].data = t3[r2].data.slice(), t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2)) : (s2[i2] = t3[r2].data, t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2)));
          s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
        }
      } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t3) {
        var e2 = this.w;
        return e2.globals.axisCharts ? t3.forEach(function(i2, a2) {
          e2.globals.collapsedSeriesIndices.indexOf(a2) > -1 && (t3[a2].data = []);
        }) : t3.forEach(function(i2, a2) {
          e2.globals.collapsedSeriesIndices.indexOf(a2) > -1 && (t3[a2] = 0);
        }), t3;
      } }]), t2;
    }();
    var lt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new nt(this);
      }
      return r(t2, [{ key: "init", value: function() {
        var t3 = this.w, e2 = t3.globals, i2 = t3.config;
        if ((i2.legend.showForSingleSeries && 1 === e2.series.length || this.isBarsDistributed || e2.series.length > 1 || !e2.axisCharts) && i2.legend.show) {
          for (; e2.dom.elLegendWrap.firstChild; )
            e2.dom.elLegendWrap.removeChild(e2.dom.elLegendWrap.firstChild);
          this.drawLegends(), x.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i2.legend.position || "top" === i2.legend.position ? this.legendAlignHorizontal() : "right" !== i2.legend.position && "left" !== i2.legend.position || this.legendAlignVertical();
        }
      } }, { key: "drawLegends", value: function() {
        var t3 = this, e2 = this.w, i2 = e2.config.legend.fontFamily, a2 = e2.globals.seriesNames, s2 = e2.globals.colors.slice();
        if ("heatmap" === e2.config.chart.type) {
          var r2 = e2.config.plotOptions.heatmap.colorScale.ranges;
          a2 = r2.map(function(t4) {
            return t4.name ? t4.name : t4.from + " - " + t4.to;
          }), s2 = r2.map(function(t4) {
            return t4.color;
          });
        } else
          this.isBarsDistributed && (a2 = e2.globals.labels.slice());
        e2.config.legend.customLegendItems.length && (a2 = e2.config.legend.customLegendItems);
        for (var o2 = e2.globals.legendFormatter, n2 = e2.config.legend.inverseOrder, l2 = n2 ? a2.length - 1 : 0; n2 ? l2 >= 0 : l2 <= a2.length - 1; n2 ? l2-- : l2++) {
          var h2, c2 = o2(a2[l2], { seriesIndex: l2, w: e2 }), d2 = false, g2 = false;
          if (e2.globals.collapsedSeries.length > 0)
            for (var u5 = 0; u5 < e2.globals.collapsedSeries.length; u5++)
              e2.globals.collapsedSeries[u5].index === l2 && (d2 = true);
          if (e2.globals.ancillaryCollapsedSeriesIndices.length > 0)
            for (var p2 = 0; p2 < e2.globals.ancillaryCollapsedSeriesIndices.length; p2++)
              e2.globals.ancillaryCollapsedSeriesIndices[p2] === l2 && (g2 = true);
          var f2 = document.createElement("span");
          f2.classList.add("apexcharts-legend-marker");
          var b2 = e2.config.legend.markers.offsetX, v2 = e2.config.legend.markers.offsetY, w2 = e2.config.legend.markers.height, k2 = e2.config.legend.markers.width, A2 = e2.config.legend.markers.strokeWidth, S2 = e2.config.legend.markers.strokeColor, C2 = e2.config.legend.markers.radius, L2 = f2.style;
          L2.background = s2[l2], L2.color = s2[l2], L2.setProperty("background", s2[l2], "important"), e2.config.legend.markers.fillColors && e2.config.legend.markers.fillColors[l2] && (L2.background = e2.config.legend.markers.fillColors[l2]), void 0 !== e2.globals.seriesColors[l2] && (L2.background = e2.globals.seriesColors[l2], L2.color = e2.globals.seriesColors[l2]), L2.height = Array.isArray(w2) ? parseFloat(w2[l2]) + "px" : parseFloat(w2) + "px", L2.width = Array.isArray(k2) ? parseFloat(k2[l2]) + "px" : parseFloat(k2) + "px", L2.left = (Array.isArray(b2) ? parseFloat(b2[l2]) : parseFloat(b2)) + "px", L2.top = (Array.isArray(v2) ? parseFloat(v2[l2]) : parseFloat(v2)) + "px", L2.borderWidth = Array.isArray(A2) ? A2[l2] : A2, L2.borderColor = Array.isArray(S2) ? S2[l2] : S2, L2.borderRadius = Array.isArray(C2) ? parseFloat(C2[l2]) + "px" : parseFloat(C2) + "px", e2.config.legend.markers.customHTML && (Array.isArray(e2.config.legend.markers.customHTML) ? e2.config.legend.markers.customHTML[l2] && (f2.innerHTML = e2.config.legend.markers.customHTML[l2]()) : f2.innerHTML = e2.config.legend.markers.customHTML()), m.setAttrs(f2, { rel: l2 + 1, "data:collapsed": d2 || g2 }), (d2 || g2) && f2.classList.add("apexcharts-inactive-legend");
          var P2 = document.createElement("div"), I2 = document.createElement("span");
          I2.classList.add("apexcharts-legend-text"), I2.innerHTML = Array.isArray(c2) ? c2.join(" ") : c2;
          var T2 = e2.config.legend.labels.useSeriesColors ? e2.globals.colors[l2] : Array.isArray(e2.config.legend.labels.colors) ? null === (h2 = e2.config.legend.labels.colors) || void 0 === h2 ? void 0 : h2[l2] : e2.config.legend.labels.colors;
          T2 || (T2 = e2.config.chart.foreColor), I2.style.color = T2, I2.style.fontSize = parseFloat(e2.config.legend.fontSize) + "px", I2.style.fontWeight = e2.config.legend.fontWeight, I2.style.fontFamily = i2 || e2.config.chart.fontFamily, m.setAttrs(I2, { rel: l2 + 1, i: l2, "data:default-text": encodeURIComponent(c2), "data:collapsed": d2 || g2 }), P2.appendChild(f2), P2.appendChild(I2);
          var M2 = new y(this.ctx);
          if (!e2.config.legend.showForZeroSeries)
            0 === M2.getSeriesTotalByIndex(l2) && M2.seriesHaveSameValues(l2) && !M2.isSeriesNull(l2) && -1 === e2.globals.collapsedSeriesIndices.indexOf(l2) && -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(l2) && P2.classList.add("apexcharts-hidden-zero-series");
          e2.config.legend.showForNullSeries || M2.isSeriesNull(l2) && -1 === e2.globals.collapsedSeriesIndices.indexOf(l2) && -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(l2) && P2.classList.add("apexcharts-hidden-null-series"), e2.globals.dom.elLegendWrap.appendChild(P2), e2.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e2.config.legend.horizontalAlign)), e2.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e2.config.legend.position), P2.classList.add("apexcharts-legend-series"), P2.style.margin = "".concat(e2.config.legend.itemMargin.vertical, "px ").concat(e2.config.legend.itemMargin.horizontal, "px"), e2.globals.dom.elLegendWrap.style.width = e2.config.legend.width ? e2.config.legend.width + "px" : "", e2.globals.dom.elLegendWrap.style.height = e2.config.legend.height ? e2.config.legend.height + "px" : "", m.setAttrs(P2, { rel: l2 + 1, seriesName: x.escapeString(a2[l2]), "data:collapsed": d2 || g2 }), (d2 || g2) && P2.classList.add("apexcharts-inactive-legend"), e2.config.legend.onItemClick.toggleDataSeries || P2.classList.add("apexcharts-no-click");
        }
        e2.globals.dom.elWrap.addEventListener("click", t3.onLegendClick, true), e2.config.legend.onItemHover.highlightDataSeries && 0 === e2.config.legend.customLegendItems.length && (e2.globals.dom.elWrap.addEventListener("mousemove", t3.onLegendHovered, true), e2.globals.dom.elWrap.addEventListener("mouseout", t3.onLegendHovered, true));
      } }, { key: "setLegendWrapXY", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.globals.dom.elLegendWrap, s2 = a2.getBoundingClientRect(), r2 = 0, o2 = 0;
        if ("bottom" === i2.config.legend.position)
          o2 += i2.globals.svgHeight - s2.height / 2;
        else if ("top" === i2.config.legend.position) {
          var n2 = new ot(this.ctx), l2 = n2.dimHelpers.getTitleSubtitleCoords("title").height, h2 = n2.dimHelpers.getTitleSubtitleCoords("subtitle").height;
          o2 = o2 + (l2 > 0 ? l2 - 10 : 0) + (h2 > 0 ? h2 - 10 : 0);
        }
        a2.style.position = "absolute", r2 = r2 + t3 + i2.config.legend.offsetX, o2 = o2 + e2 + i2.config.legend.offsetY, a2.style.left = r2 + "px", a2.style.top = o2 + "px", "bottom" === i2.config.legend.position ? (a2.style.top = "auto", a2.style.bottom = 5 - i2.config.legend.offsetY + "px") : "right" === i2.config.legend.position && (a2.style.left = "auto", a2.style.right = 25 + i2.config.legend.offsetX + "px");
        ["width", "height"].forEach(function(t4) {
          a2.style[t4] && (a2.style[t4] = parseInt(i2.config.legend[t4], 10) + "px");
        });
      } }, { key: "legendAlignHorizontal", value: function() {
        var t3 = this.w;
        t3.globals.dom.elLegendWrap.style.right = 0;
        var e2 = this.legendHelpers.getLegendBBox(), i2 = new ot(this.ctx), a2 = i2.dimHelpers.getTitleSubtitleCoords("title"), s2 = i2.dimHelpers.getTitleSubtitleCoords("subtitle"), r2 = 0;
        "bottom" === t3.config.legend.position ? r2 = -e2.clwh / 1.8 : "top" === t3.config.legend.position && (r2 = a2.height + s2.height + t3.config.title.margin + t3.config.subtitle.margin - 10), this.setLegendWrapXY(20, r2);
      } }, { key: "legendAlignVertical", value: function() {
        var t3 = this.w, e2 = this.legendHelpers.getLegendBBox(), i2 = 0;
        "left" === t3.config.legend.position && (i2 = 20), "right" === t3.config.legend.position && (i2 = t3.globals.svgWidth - e2.clww - 10), this.setLegendWrapXY(i2, 20);
      } }, { key: "onLegendHovered", value: function(t3) {
        var e2 = this.w, i2 = t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker");
        if ("heatmap" === e2.config.chart.type || this.isBarsDistributed) {
          if (i2) {
            var a2 = parseInt(t3.target.getAttribute("rel"), 10) - 1;
            this.ctx.events.fireEvent("legendHover", [this.ctx, a2, this.w]), new N(this.ctx).highlightRangeInSeries(t3, t3.target);
          }
        } else
          !t3.target.classList.contains("apexcharts-inactive-legend") && i2 && new N(this.ctx).toggleSeriesOnHover(t3, t3.target);
      } }, { key: "onLegendClick", value: function(t3) {
        var e2 = this.w;
        if (!e2.config.legend.customLegendItems.length && (t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker"))) {
          var i2 = parseInt(t3.target.getAttribute("rel"), 10) - 1, a2 = "true" === t3.target.getAttribute("data:collapsed"), s2 = this.w.config.chart.events.legendClick;
          "function" == typeof s2 && s2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i2, this.w]);
          var r2 = this.w.config.legend.markers.onClick;
          "function" == typeof r2 && t3.target.classList.contains("apexcharts-legend-marker") && (r2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i2, this.w])), "treemap" !== e2.config.chart.type && "heatmap" !== e2.config.chart.type && !this.isBarsDistributed && e2.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i2, a2);
        }
      } }]), t2;
    }();
    var ht = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var i2 = this.w;
        this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = i2.globals.minX, this.maxX = i2.globals.maxX;
      }
      return r(t2, [{ key: "createToolbar", value: function() {
        var t3 = this, e2 = this.w, i2 = function() {
          return document.createElement("div");
        }, a2 = i2();
        if (a2.setAttribute("class", "apexcharts-toolbar"), a2.style.top = e2.config.chart.toolbar.offsetY + "px", a2.style.right = 3 - e2.config.chart.toolbar.offsetX + "px", e2.globals.dom.elWrap.appendChild(a2), this.elZoom = i2(), this.elZoomIn = i2(), this.elZoomOut = i2(), this.elPan = i2(), this.elSelection = i2(), this.elZoomReset = i2(), this.elMenuIcon = i2(), this.elMenu = i2(), this.elCustomIcons = [], this.t = e2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
          for (var s2 = 0; s2 < this.t.customIcons.length; s2++)
            this.elCustomIcons.push(i2());
        var r2 = [], o2 = function(i3, a3, s3) {
          var o3 = i3.toLowerCase();
          t3.t[o3] && e2.config.chart.zoom.enabled && r2.push({ el: a3, icon: "string" == typeof t3.t[o3] ? t3.t[o3] : s3, title: t3.localeValues[i3], class: "apexcharts-".concat(o3, "-icon") });
        };
        o2("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), o2("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
        var n2 = function(i3) {
          t3.t[i3] && e2.config.chart[i3].enabled && r2.push({ el: "zoom" === i3 ? t3.elZoom : t3.elSelection, icon: "string" == typeof t3.t[i3] ? t3.t[i3] : "zoom" === i3 ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t3.localeValues["zoom" === i3 ? "selectionZoom" : "selection"], class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i3, "-icon") });
        };
        n2("zoom"), n2("selection"), this.t.pan && e2.config.chart.zoom.enabled && r2.push({ el: this.elPan, icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o2("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r2.push({ el: this.elMenuIcon, icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
        for (var l2 = 0; l2 < this.elCustomIcons.length; l2++)
          r2.push({ el: this.elCustomIcons[l2], icon: this.t.customIcons[l2].icon, title: this.t.customIcons[l2].title, index: this.t.customIcons[l2].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l2].class });
        r2.forEach(function(t4, e3) {
          t4.index && x.moveIndexInArray(r2, e3, t4.index);
        });
        for (var h2 = 0; h2 < r2.length; h2++)
          m.setAttrs(r2[h2].el, { class: r2[h2].class, title: r2[h2].title }), r2[h2].el.innerHTML = r2[h2].icon, a2.appendChild(r2[h2].el);
        this._createHamburgerMenu(a2), e2.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e2.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e2.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
      } }, { key: "_createHamburgerMenu", value: function(t3) {
        this.elMenuItems = [], t3.appendChild(this.elMenu), m.setAttrs(this.elMenu, { class: "apexcharts-menu" });
        for (var e2 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i2 = 0; i2 < e2.length; i2++)
          this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i2].innerHTML = e2[i2].title, m.setAttrs(this.elMenuItems[i2], { class: "apexcharts-menu-item ".concat(e2[i2].name), title: e2[i2].title }), this.elMenu.appendChild(this.elMenuItems[i2]);
      } }, { key: "addToolbarEventListeners", value: function() {
        var t3 = this;
        this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e3) {
          e3.classList.contains("exportSVG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "svg")) : e3.classList.contains("exportPNG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "png")) : e3.classList.contains("exportCSV") && e3.addEventListener("click", t3.handleDownload.bind(t3, "csv"));
        });
        for (var e2 = 0; e2 < this.t.customIcons.length; e2++)
          this.elCustomIcons[e2].addEventListener("click", this.t.customIcons[e2].click.bind(this, this.ctx, this.ctx.w));
      } }, { key: "toggleZoomSelection", value: function(t3) {
        this.ctx.getSyncedCharts().forEach(function(e2) {
          e2.ctx.toolbar.toggleOtherControls();
          var i2 = "selection" === t3 ? e2.ctx.toolbar.elSelection : e2.ctx.toolbar.elZoom, a2 = "selection" === t3 ? "selectionEnabled" : "zoomEnabled";
          e2.w.globals[a2] = !e2.w.globals[a2], i2.classList.contains(e2.ctx.toolbar.selectedClass) ? i2.classList.remove(e2.ctx.toolbar.selectedClass) : i2.classList.add(e2.ctx.toolbar.selectedClass);
        });
      } }, { key: "getToolbarIconsReference", value: function() {
        var t3 = this.w;
        this.elZoom || (this.elZoom = t3.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t3.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t3.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
      } }, { key: "enableZoomPanFromToolbar", value: function(t3) {
        this.toggleOtherControls(), "pan" === t3 ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
        var e2 = "pan" === t3 ? this.elPan : this.elZoom, i2 = "pan" === t3 ? this.elZoom : this.elPan;
        e2 && e2.classList.add(this.selectedClass), i2 && i2.classList.remove(this.selectedClass);
      } }, { key: "togglePanning", value: function() {
        this.ctx.getSyncedCharts().forEach(function(t3) {
          t3.ctx.toolbar.toggleOtherControls(), t3.w.globals.panEnabled = !t3.w.globals.panEnabled, t3.ctx.toolbar.elPan.classList.contains(t3.ctx.toolbar.selectedClass) ? t3.ctx.toolbar.elPan.classList.remove(t3.ctx.toolbar.selectedClass) : t3.ctx.toolbar.elPan.classList.add(t3.ctx.toolbar.selectedClass);
        });
      } }, { key: "toggleOtherControls", value: function() {
        var t3 = this, e2 = this.w;
        e2.globals.panEnabled = false, e2.globals.zoomEnabled = false, e2.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e3) {
          e3 && e3.classList.remove(t3.selectedClass);
        });
      } }, { key: "handleZoomIn", value: function() {
        var t3 = this.w;
        t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY);
        var e2 = (this.minX + this.maxX) / 2, i2 = (this.minX + e2) / 2, a2 = (this.maxX + e2) / 2, s2 = this._getNewMinXMaxX(i2, a2);
        t3.globals.disableZoomIn || this.zoomUpdateOptions(s2.minX, s2.maxX);
      } }, { key: "handleZoomOut", value: function() {
        var t3 = this.w;
        if (t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY), !("datetime" === t3.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
          var e2 = (this.minX + this.maxX) / 2, i2 = this.minX - (e2 - this.minX), a2 = this.maxX - (e2 - this.maxX), s2 = this._getNewMinXMaxX(i2, a2);
          t3.globals.disableZoomOut || this.zoomUpdateOptions(s2.minX, s2.maxX);
        }
      } }, { key: "_getNewMinXMaxX", value: function(t3, e2) {
        var i2 = this.w.config.xaxis.convertedCatToNumeric;
        return { minX: i2 ? Math.floor(t3) : t3, maxX: i2 ? Math.floor(e2) : e2 };
      } }, { key: "zoomUpdateOptions", value: function(t3, e2) {
        var i2 = this.w;
        if (void 0 !== t3 || void 0 !== e2) {
          if (!(i2.config.xaxis.convertedCatToNumeric && (t3 < 1 && (t3 = 1, e2 = i2.globals.dataPoints), e2 - t3 < 2))) {
            var a2 = { min: t3, max: e2 }, s2 = this.getBeforeZoomRange(a2);
            s2 && (a2 = s2.xaxis);
            var r2 = { xaxis: a2 }, o2 = x.clone(i2.globals.initialConfig.yaxis);
            if (i2.config.chart.zoom.autoScaleYaxis)
              o2 = new _(this.ctx).autoScaleY(this.ctx, o2, { xaxis: a2 });
            i2.config.chart.group || (r2.yaxis = o2), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r2, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a2, o2);
          }
        } else
          this.handleZoomReset();
      } }, { key: "zoomCallback", value: function(t3, e2) {
        "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, { xaxis: t3, yaxis: e2 });
      } }, { key: "getBeforeZoomRange", value: function(t3, e2) {
        var i2 = null;
        return "function" == typeof this.ev.beforeZoom && (i2 = this.ev.beforeZoom(this, { xaxis: t3, yaxis: e2 })), i2;
      } }, { key: "toggleMenu", value: function() {
        var t3 = this;
        window.setTimeout(function() {
          t3.elMenu.classList.contains("apexcharts-menu-open") ? t3.elMenu.classList.remove("apexcharts-menu-open") : t3.elMenu.classList.add("apexcharts-menu-open");
        }, 0);
      } }, { key: "handleDownload", value: function(t3) {
        var e2 = this.w, i2 = new G(this.ctx);
        switch (t3) {
          case "svg":
            i2.exportToSVG(this.ctx);
            break;
          case "png":
            i2.exportToPng(this.ctx);
            break;
          case "csv":
            i2.exportToCSV({ series: e2.config.series, columnDelimiter: e2.config.chart.toolbar.export.csv.columnDelimiter });
        }
      } }, { key: "handleZoomReset", value: function(t3) {
        this.ctx.getSyncedCharts().forEach(function(t4) {
          var e2 = t4.w;
          if (e2.globals.lastXAxis.min = e2.globals.initialConfig.xaxis.min, e2.globals.lastXAxis.max = e2.globals.initialConfig.xaxis.max, t4.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e2.config.chart.events.beforeResetZoom) {
            var i2 = e2.config.chart.events.beforeResetZoom(t4, e2);
            i2 && t4.updateHelpers.revertDefaultAxisMinMax(i2);
          }
          "function" == typeof e2.config.chart.events.zoomed && t4.ctx.toolbar.zoomCallback({ min: e2.config.xaxis.min, max: e2.config.xaxis.max }), e2.globals.zoomed = false;
          var a2 = t4.ctx.series.emptyCollapsedSeries(x.clone(e2.globals.initialSeries));
          t4.updateHelpers._updateSeries(a2, e2.config.chart.animations.dynamicAnimation.enabled);
        });
      } }, { key: "destroy", value: function() {
        this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
      } }]), t2;
    }();
    var ct = function(t2) {
      n(i2, ht);
      var e2 = d(i2);
      function i2(t3) {
        var s2;
        return a(this, i2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.dragged = false, s2.graphics = new m(s2.ctx), s2.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], s2.clientX = 0, s2.clientY = 0, s2.startX = 0, s2.endX = 0, s2.dragX = 0, s2.startY = 0, s2.endY = 0, s2.dragY = 0, s2.moveDirection = "none", s2;
      }
      return r(i2, [{ key: "init", value: function(t3) {
        var e3 = this, i3 = t3.xyRatios, a2 = this.w, s2 = this;
        this.xyRatios = i3, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a2.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a2.globals.dom.elGraphical.add(this.zoomRect), a2.globals.dom.elGraphical.add(this.selectionRect), "x" === a2.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a2.globals.gridWidth, maxY: a2.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a2.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a2.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a2.globals.dom.baseEl.querySelector("".concat(a2.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t4) {
          e3.hoverArea.addEventListener(t4, s2.svgMouseEvents.bind(s2, i3), { capture: false, passive: true });
        });
      } }, { key: "destroy", value: function() {
        this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
      } }, { key: "svgMouseEvents", value: function(t3, e3) {
        var i3 = this.w, a2 = this, s2 = this.ctx.toolbar, r2 = i3.globals.zoomEnabled ? i3.config.chart.zoom.type : i3.config.chart.selection.type, o2 = i3.config.chart.toolbar.autoSelected;
        if (e3.shiftKey ? (this.shiftWasPressed = true, s2.enableZoomPanFromToolbar("pan" === o2 ? "zoom" : "pan")) : this.shiftWasPressed && (s2.enableZoomPanFromToolbar(o2), this.shiftWasPressed = false), e3.target) {
          var n2, l2 = e3.target.classList;
          if (e3.target.parentNode && null !== e3.target.parentNode && (n2 = e3.target.parentNode.classList), !(l2.contains("apexcharts-selection-rect") || l2.contains("apexcharts-legend-marker") || l2.contains("apexcharts-legend-text") || n2 && n2.contains("apexcharts-toolbar"))) {
            if (a2.clientX = "touchmove" === e3.type || "touchstart" === e3.type ? e3.touches[0].clientX : "touchend" === e3.type ? e3.changedTouches[0].clientX : e3.clientX, a2.clientY = "touchmove" === e3.type || "touchstart" === e3.type ? e3.touches[0].clientY : "touchend" === e3.type ? e3.changedTouches[0].clientY : e3.clientY, "mousedown" === e3.type && 1 === e3.which) {
              var h2 = a2.gridRect.getBoundingClientRect();
              a2.startX = a2.clientX - h2.left, a2.startY = a2.clientY - h2.top, a2.dragged = false, a2.w.globals.mousedown = true;
            }
            if (("mousemove" === e3.type && 1 === e3.which || "touchmove" === e3.type) && (a2.dragged = true, i3.globals.panEnabled ? (i3.globals.selection = null, a2.w.globals.mousedown && a2.panDragging({ context: a2, zoomtype: r2, xyRatios: t3 })) : (a2.w.globals.mousedown && i3.globals.zoomEnabled || a2.w.globals.mousedown && i3.globals.selectionEnabled) && (a2.selection = a2.selectionDrawing({ context: a2, zoomtype: r2 }))), "mouseup" === e3.type || "touchend" === e3.type || "mouseleave" === e3.type) {
              var c2 = a2.gridRect.getBoundingClientRect();
              a2.w.globals.mousedown && (a2.endX = a2.clientX - c2.left, a2.endY = a2.clientY - c2.top, a2.dragX = Math.abs(a2.endX - a2.startX), a2.dragY = Math.abs(a2.endY - a2.startY), (i3.globals.zoomEnabled || i3.globals.selectionEnabled) && a2.selectionDrawn({ context: a2, zoomtype: r2 }), i3.globals.panEnabled && i3.config.xaxis.convertedCatToNumeric && a2.delayedPanScrolled()), i3.globals.zoomEnabled && a2.hideSelectionRect(this.selectionRect), a2.dragged = false, a2.w.globals.mousedown = false;
            }
            this.makeSelectionRectDraggable();
          }
        }
      } }, { key: "makeSelectionRectDraggable", value: function() {
        var t3 = this.w;
        if (this.selectionRect) {
          var e3 = this.selectionRect.node.getBoundingClientRect();
          e3.width > 0 && e3.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: t3.globals.gridWidth, maxY: t3.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
        }
      } }, { key: "preselectedSelection", value: function() {
        var t3 = this.w, e3 = this.xyRatios;
        if (!t3.globals.zoomEnabled) {
          if (void 0 !== t3.globals.selection && null !== t3.globals.selection)
            this.drawSelectionRect(t3.globals.selection);
          else if (void 0 !== t3.config.chart.selection.xaxis.min && void 0 !== t3.config.chart.selection.xaxis.max) {
            var i3 = (t3.config.chart.selection.xaxis.min - t3.globals.minX) / e3.xRatio, a2 = t3.globals.gridWidth - (t3.globals.maxX - t3.config.chart.selection.xaxis.max) / e3.xRatio - i3;
            t3.globals.isRangeBar && (i3 = (t3.config.chart.selection.xaxis.min - t3.globals.yAxisScale[0].niceMin) / e3.invertedYRatio, a2 = (t3.config.chart.selection.xaxis.max - t3.config.chart.selection.xaxis.min) / e3.invertedYRatio);
            var s2 = { x: i3, y: 0, width: a2, height: t3.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: true };
            this.drawSelectionRect(s2), this.makeSelectionRectDraggable(), "function" == typeof t3.config.chart.events.selection && t3.config.chart.events.selection(this.ctx, { xaxis: { min: t3.config.chart.selection.xaxis.min, max: t3.config.chart.selection.xaxis.max }, yaxis: {} });
          }
        }
      } }, { key: "drawSelectionRect", value: function(t3) {
        var e3 = t3.x, i3 = t3.y, a2 = t3.width, s2 = t3.height, r2 = t3.translateX, o2 = void 0 === r2 ? 0 : r2, n2 = t3.translateY, l2 = void 0 === n2 ? 0 : n2, h2 = this.w, c2 = this.zoomRect, d2 = this.selectionRect;
        if (this.dragged || null !== h2.globals.selection) {
          var g2 = { transform: "translate(" + o2 + ", " + l2 + ")" };
          h2.globals.zoomEnabled && this.dragged && (a2 < 0 && (a2 = 1), c2.attr({ x: e3, y: i3, width: a2, height: s2, fill: h2.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h2.config.chart.zoom.zoomedArea.fill.opacity, stroke: h2.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h2.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h2.config.chart.zoom.zoomedArea.stroke.opacity }), m.setAttrs(c2.node, g2)), h2.globals.selectionEnabled && (d2.attr({ x: e3, y: i3, width: a2 > 0 ? a2 : 0, height: s2 > 0 ? s2 : 0, fill: h2.config.chart.selection.fill.color, "fill-opacity": h2.config.chart.selection.fill.opacity, stroke: h2.config.chart.selection.stroke.color, "stroke-width": h2.config.chart.selection.stroke.width, "stroke-dasharray": h2.config.chart.selection.stroke.dashArray, "stroke-opacity": h2.config.chart.selection.stroke.opacity }), m.setAttrs(d2.node, g2));
        }
      } }, { key: "hideSelectionRect", value: function(t3) {
        t3 && t3.attr({ x: 0, y: 0, width: 0, height: 0 });
      } }, { key: "selectionDrawing", value: function(t3) {
        var e3 = t3.context, i3 = t3.zoomtype, a2 = this.w, s2 = e3, r2 = this.gridRect.getBoundingClientRect(), o2 = s2.startX - 1, n2 = s2.startY, l2 = false, h2 = false, c2 = s2.clientX - r2.left - o2, d2 = s2.clientY - r2.top - n2, g2 = {};
        return Math.abs(c2 + o2) > a2.globals.gridWidth ? c2 = a2.globals.gridWidth - o2 : s2.clientX - r2.left < 0 && (c2 = o2), o2 > s2.clientX - r2.left && (l2 = true, c2 = Math.abs(c2)), n2 > s2.clientY - r2.top && (h2 = true, d2 = Math.abs(d2)), g2 = "x" === i3 ? { x: l2 ? o2 - c2 : o2, y: 0, width: c2, height: a2.globals.gridHeight } : "y" === i3 ? { x: 0, y: h2 ? n2 - d2 : n2, width: a2.globals.gridWidth, height: d2 } : { x: l2 ? o2 - c2 : o2, y: h2 ? n2 - d2 : n2, width: c2, height: d2 }, s2.drawSelectionRect(g2), s2.selectionDragging("resizing"), g2;
      } }, { key: "selectionDragging", value: function(t3, e3) {
        var i3 = this, a2 = this.w, s2 = this.xyRatios, r2 = this.selectionRect, o2 = 0;
        "resizing" === t3 && (o2 = 30);
        var n2 = function(t4) {
          return parseFloat(r2.node.getAttribute(t4));
        }, l2 = { x: n2("x"), y: n2("y"), width: n2("width"), height: n2("height") };
        a2.globals.selection = l2, "function" == typeof a2.config.chart.events.selection && a2.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
          var t4, e4, o3, n3, l3 = i3.gridRect.getBoundingClientRect(), h2 = r2.node.getBoundingClientRect();
          a2.globals.isRangeBar ? (t4 = a2.globals.yAxisScale[0].niceMin + (h2.left - l3.left) * s2.invertedYRatio, e4 = a2.globals.yAxisScale[0].niceMin + (h2.right - l3.left) * s2.invertedYRatio, o3 = 0, n3 = 1) : (t4 = a2.globals.xAxisScale.niceMin + (h2.left - l3.left) * s2.xRatio, e4 = a2.globals.xAxisScale.niceMin + (h2.right - l3.left) * s2.xRatio, o3 = a2.globals.yAxisScale[0].niceMin + (l3.bottom - h2.bottom) * s2.yRatio[0], n3 = a2.globals.yAxisScale[0].niceMax - (h2.top - l3.top) * s2.yRatio[0]);
          var c2 = { xaxis: { min: t4, max: e4 }, yaxis: { min: o3, max: n3 } };
          a2.config.chart.events.selection(i3.ctx, c2), a2.config.chart.brush.enabled && void 0 !== a2.config.chart.events.brushScrolled && a2.config.chart.events.brushScrolled(i3.ctx, c2);
        }, o2));
      } }, { key: "selectionDrawn", value: function(t3) {
        var e3 = t3.context, i3 = t3.zoomtype, a2 = this.w, s2 = e3, r2 = this.xyRatios, o2 = this.ctx.toolbar;
        if (s2.startX > s2.endX) {
          var n2 = s2.startX;
          s2.startX = s2.endX, s2.endX = n2;
        }
        if (s2.startY > s2.endY) {
          var l2 = s2.startY;
          s2.startY = s2.endY, s2.endY = l2;
        }
        var h2 = void 0, c2 = void 0;
        a2.globals.isRangeBar ? (h2 = a2.globals.yAxisScale[0].niceMin + s2.startX * r2.invertedYRatio, c2 = a2.globals.yAxisScale[0].niceMin + s2.endX * r2.invertedYRatio) : (h2 = a2.globals.xAxisScale.niceMin + s2.startX * r2.xRatio, c2 = a2.globals.xAxisScale.niceMin + s2.endX * r2.xRatio);
        var d2 = [], g2 = [];
        if (a2.config.yaxis.forEach(function(t4, e4) {
          d2.push(a2.globals.yAxisScale[e4].niceMax - r2.yRatio[e4] * s2.startY), g2.push(a2.globals.yAxisScale[e4].niceMax - r2.yRatio[e4] * s2.endY);
        }), s2.dragged && (s2.dragX > 10 || s2.dragY > 10) && h2 !== c2) {
          if (a2.globals.zoomEnabled) {
            var u5 = x.clone(a2.globals.initialConfig.yaxis), p2 = x.clone(a2.globals.initialConfig.xaxis);
            if (a2.globals.zoomed = true, a2.config.xaxis.convertedCatToNumeric && (h2 = Math.floor(h2), c2 = Math.floor(c2), h2 < 1 && (h2 = 1, c2 = a2.globals.dataPoints), c2 - h2 < 2 && (c2 = h2 + 1)), "xy" !== i3 && "x" !== i3 || (p2 = { min: h2, max: c2 }), "xy" !== i3 && "y" !== i3 || u5.forEach(function(t4, e4) {
              u5[e4].min = g2[e4], u5[e4].max = d2[e4];
            }), a2.config.chart.zoom.autoScaleYaxis) {
              var f2 = new _(s2.ctx);
              u5 = f2.autoScaleY(s2.ctx, u5, { xaxis: p2 });
            }
            if (o2) {
              var b2 = o2.getBeforeZoomRange(p2, u5);
              b2 && (p2 = b2.xaxis ? b2.xaxis : p2, u5 = b2.yaxis ? b2.yaxis : u5);
            }
            var v2 = { xaxis: p2 };
            a2.config.chart.group || (v2.yaxis = u5), s2.ctx.updateHelpers._updateOptions(v2, false, s2.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a2.config.chart.events.zoomed && o2.zoomCallback(p2, u5);
          } else if (a2.globals.selectionEnabled) {
            var m2, y2 = null;
            m2 = { min: h2, max: c2 }, "xy" !== i3 && "y" !== i3 || (y2 = x.clone(a2.config.yaxis)).forEach(function(t4, e4) {
              y2[e4].min = g2[e4], y2[e4].max = d2[e4];
            }), a2.globals.selection = s2.selection, "function" == typeof a2.config.chart.events.selection && a2.config.chart.events.selection(s2.ctx, { xaxis: m2, yaxis: y2 });
          }
        }
      } }, { key: "panDragging", value: function(t3) {
        var e3 = t3.context, i3 = this.w, a2 = e3;
        if (void 0 !== i3.globals.lastClientPosition.x) {
          var s2 = i3.globals.lastClientPosition.x - a2.clientX, r2 = i3.globals.lastClientPosition.y - a2.clientY;
          Math.abs(s2) > Math.abs(r2) && s2 > 0 ? this.moveDirection = "left" : Math.abs(s2) > Math.abs(r2) && s2 < 0 ? this.moveDirection = "right" : Math.abs(r2) > Math.abs(s2) && r2 > 0 ? this.moveDirection = "up" : Math.abs(r2) > Math.abs(s2) && r2 < 0 && (this.moveDirection = "down");
        }
        i3.globals.lastClientPosition = { x: a2.clientX, y: a2.clientY };
        var o2 = i3.globals.isRangeBar ? i3.globals.minY : i3.globals.minX, n2 = i3.globals.isRangeBar ? i3.globals.maxY : i3.globals.maxX;
        i3.config.xaxis.convertedCatToNumeric || a2.panScrolled(o2, n2);
      } }, { key: "delayedPanScrolled", value: function() {
        var t3 = this.w, e3 = t3.globals.minX, i3 = t3.globals.maxX, a2 = (t3.globals.maxX - t3.globals.minX) / 2;
        "left" === this.moveDirection ? (e3 = t3.globals.minX + a2, i3 = t3.globals.maxX + a2) : "right" === this.moveDirection && (e3 = t3.globals.minX - a2, i3 = t3.globals.maxX - a2), e3 = Math.floor(e3), i3 = Math.floor(i3), this.updateScrolledChart({ xaxis: { min: e3, max: i3 } }, e3, i3);
      } }, { key: "panScrolled", value: function(t3, e3) {
        var i3 = this.w, a2 = this.xyRatios, s2 = x.clone(i3.globals.initialConfig.yaxis), r2 = a2.xRatio, o2 = i3.globals.minX, n2 = i3.globals.maxX;
        i3.globals.isRangeBar && (r2 = a2.invertedYRatio, o2 = i3.globals.minY, n2 = i3.globals.maxY), "left" === this.moveDirection ? (t3 = o2 + i3.globals.gridWidth / 15 * r2, e3 = n2 + i3.globals.gridWidth / 15 * r2) : "right" === this.moveDirection && (t3 = o2 - i3.globals.gridWidth / 15 * r2, e3 = n2 - i3.globals.gridWidth / 15 * r2), i3.globals.isRangeBar || (t3 < i3.globals.initialMinX || e3 > i3.globals.initialMaxX) && (t3 = o2, e3 = n2);
        var l2 = { min: t3, max: e3 };
        i3.config.chart.zoom.autoScaleYaxis && (s2 = new _(this.ctx).autoScaleY(this.ctx, s2, { xaxis: l2 }));
        var h2 = { xaxis: { min: t3, max: e3 } };
        i3.config.chart.group || (h2.yaxis = s2), this.updateScrolledChart(h2, t3, e3);
      } }, { key: "updateScrolledChart", value: function(t3, e3, i3) {
        var a2 = this.w;
        this.ctx.updateHelpers._updateOptions(t3, false, false), "function" == typeof a2.config.chart.events.scrolled && a2.config.chart.events.scrolled(this.ctx, { xaxis: { min: e3, max: i3 } });
      } }]), i2;
    }();
    var dt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx;
      }
      return r(t2, [{ key: "getNearestValues", value: function(t3) {
        var e2 = t3.hoverArea, i2 = t3.elGrid, a2 = t3.clientX, s2 = t3.clientY, r2 = this.w, o2 = i2.getBoundingClientRect(), n2 = o2.width, l2 = o2.height, h2 = n2 / (r2.globals.dataPoints - 1), c2 = l2 / r2.globals.dataPoints, d2 = this.hasBars();
        !r2.globals.comboCharts && !d2 || r2.config.xaxis.convertedCatToNumeric || (h2 = n2 / r2.globals.dataPoints);
        var g2 = a2 - o2.left - r2.globals.barPadForNumericAxis, u5 = s2 - o2.top;
        g2 < 0 || u5 < 0 || g2 > n2 || u5 > l2 ? (e2.classList.remove("hovering-zoom"), e2.classList.remove("hovering-pan")) : r2.globals.zoomEnabled ? (e2.classList.remove("hovering-pan"), e2.classList.add("hovering-zoom")) : r2.globals.panEnabled && (e2.classList.remove("hovering-zoom"), e2.classList.add("hovering-pan"));
        var p2 = Math.round(g2 / h2), f2 = Math.floor(u5 / c2);
        d2 && !r2.config.xaxis.convertedCatToNumeric && (p2 = Math.ceil(g2 / h2), p2 -= 1);
        var b2 = null, v2 = null, m2 = r2.globals.seriesXvalues.map(function(t4) {
          return t4.filter(function(t5) {
            return x.isNumber(t5);
          });
        }), y2 = r2.globals.seriesYvalues.map(function(t4) {
          return t4.filter(function(t5) {
            return x.isNumber(t5);
          });
        });
        if (r2.globals.isXNumeric) {
          var w2 = this.ttCtx.getElGrid().getBoundingClientRect(), k2 = g2 * (w2.width / n2), A2 = u5 * (w2.height / l2);
          b2 = (v2 = this.closestInMultiArray(k2, A2, m2, y2)).index, p2 = v2.j, null !== b2 && (m2 = r2.globals.seriesXvalues[b2], p2 = (v2 = this.closestInArray(k2, m2)).index);
        }
        return r2.globals.capturedSeriesIndex = null === b2 ? -1 : b2, (!p2 || p2 < 1) && (p2 = 0), r2.globals.isBarHorizontal ? r2.globals.capturedDataPointIndex = f2 : r2.globals.capturedDataPointIndex = p2, { capturedSeries: b2, j: r2.globals.isBarHorizontal ? f2 : p2, hoverX: g2, hoverY: u5 };
      } }, { key: "closestInMultiArray", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = 0, o2 = null, n2 = -1;
        s2.globals.series.length > 1 ? r2 = this.getFirstActiveXArray(i2) : o2 = 0;
        var l2 = i2[r2][0], h2 = Math.abs(t3 - l2);
        if (i2.forEach(function(e3) {
          e3.forEach(function(e4, i3) {
            var a3 = Math.abs(t3 - e4);
            a3 <= h2 && (h2 = a3, n2 = i3);
          });
        }), -1 !== n2) {
          var c2 = a2[r2][n2], d2 = Math.abs(e2 - c2);
          o2 = r2, a2.forEach(function(t4, i3) {
            var a3 = Math.abs(e2 - t4[n2]);
            a3 <= d2 && (d2 = a3, o2 = i3);
          });
        }
        return { index: o2, j: n2 };
      } }, { key: "getFirstActiveXArray", value: function(t3) {
        for (var e2 = this.w, i2 = 0, a2 = t3.map(function(t4, e3) {
          return t4.length > 0 ? e3 : -1;
        }), s2 = 0; s2 < a2.length; s2++)
          if (-1 !== a2[s2] && -1 === e2.globals.collapsedSeriesIndices.indexOf(s2) && -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2)) {
            i2 = a2[s2];
            break;
          }
        return i2;
      } }, { key: "closestInArray", value: function(t3, e2) {
        for (var i2 = e2[0], a2 = null, s2 = Math.abs(t3 - i2), r2 = 0; r2 < e2.length; r2++) {
          var o2 = Math.abs(t3 - e2[r2]);
          o2 < s2 && (s2 = o2, a2 = r2);
        }
        return { index: a2 };
      } }, { key: "isXoverlap", value: function(t3) {
        var e2 = [], i2 = this.w.globals.seriesX.filter(function(t4) {
          return void 0 !== t4[0];
        });
        if (i2.length > 0)
          for (var a2 = 0; a2 < i2.length - 1; a2++)
            void 0 !== i2[a2][t3] && void 0 !== i2[a2 + 1][t3] && i2[a2][t3] !== i2[a2 + 1][t3] && e2.push("unEqual");
        return 0 === e2.length;
      } }, { key: "isInitialSeriesSameLen", value: function() {
        for (var t3 = true, e2 = this.w.globals.initialSeries, i2 = 0; i2 < e2.length - 1; i2++)
          if (e2[i2].data.length !== e2[i2 + 1].data.length) {
            t3 = false;
            break;
          }
        return t3;
      } }, { key: "getBarsHeight", value: function(t3) {
        return u4(t3).reduce(function(t4, e2) {
          return t4 + e2.getBBox().height;
        }, 0);
      } }, { key: "getElMarkers", value: function(t3) {
        return "number" == typeof t3 ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
      } }, { key: "getAllMarkers", value: function() {
        var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
        (t3 = u4(t3)).sort(function(t4, e3) {
          var i2 = Number(t4.getAttribute("data:realIndex")), a2 = Number(e3.getAttribute("data:realIndex"));
          return a2 < i2 ? 1 : a2 > i2 ? -1 : 0;
        });
        var e2 = [];
        return t3.forEach(function(t4) {
          e2.push(t4.querySelector(".apexcharts-marker"));
        }), e2;
      } }, { key: "hasMarkers", value: function(t3) {
        return this.getElMarkers(t3).length > 0;
      } }, { key: "getElBars", value: function() {
        return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
      } }, { key: "hasBars", value: function() {
        return this.getElBars().length > 0;
      } }, { key: "getHoverMarkerSize", value: function(t3) {
        var e2 = this.w, i2 = e2.config.markers.hover.size;
        return void 0 === i2 && (i2 = e2.globals.markers.size[t3] + e2.config.markers.hover.sizeOffset), i2;
      } }, { key: "toggleAllTooltipSeriesGroups", value: function(t3) {
        var e2 = this.w, i2 = this.ttCtx;
        0 === i2.allTooltipSeriesGroups.length && (i2.allTooltipSeriesGroups = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
        for (var a2 = i2.allTooltipSeriesGroups, s2 = 0; s2 < a2.length; s2++)
          "enable" === t3 ? (a2[s2].classList.add("apexcharts-active"), a2[s2].style.display = e2.config.tooltip.items.display) : (a2[s2].classList.remove("apexcharts-active"), a2[s2].style.display = "none");
      } }]), t2;
    }();
    var gt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.ctx = e2.ctx, this.ttCtx = e2, this.tooltipUtil = new dt(e2);
      }
      return r(t2, [{ key: "drawSeriesTexts", value: function(t3) {
        var e2 = t3.shared, i2 = void 0 === e2 || e2, a2 = t3.ttItems, s2 = t3.i, r2 = void 0 === s2 ? 0 : s2, o2 = t3.j, n2 = void 0 === o2 ? null : o2, l2 = t3.y1, h2 = t3.y2, c2 = t3.e, d2 = this.w;
        void 0 !== d2.config.tooltip.custom ? this.handleCustomTooltip({ i: r2, j: n2, y1: l2, y2: h2, w: d2 }) : this.toggleActiveInactiveSeries(i2);
        var g2 = this.getValuesToPrint({ i: r2, j: n2 });
        this.printLabels({ i: r2, j: n2, values: g2, ttItems: a2, shared: i2, e: c2 });
        var u5 = this.ttCtx.getElTooltip();
        this.ttCtx.tooltipRect.ttWidth = u5.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u5.getBoundingClientRect().height;
      } }, { key: "printLabels", value: function(t3) {
        var i2, a2 = this, s2 = t3.i, r2 = t3.j, o2 = t3.values, n2 = t3.ttItems, l2 = t3.shared, h2 = t3.e, c2 = this.w, d2 = [], g2 = function(t4) {
          return c2.globals.seriesGoals[t4] && c2.globals.seriesGoals[t4][r2] && Array.isArray(c2.globals.seriesGoals[t4][r2]);
        }, u5 = o2.xVal, p2 = o2.zVal, f2 = o2.xAxisTTVal, x2 = "", b2 = c2.globals.colors[s2];
        null !== r2 && c2.config.plotOptions.bar.distributed && (b2 = c2.globals.colors[r2]);
        for (var v2 = function(t4, o3) {
          var v3 = a2.getFormatters(s2);
          x2 = a2.getSeriesName({ fn: v3.yLbTitleFormatter, index: s2, seriesIndex: s2, j: r2 }), "treemap" === c2.config.chart.type && (x2 = v3.yLbTitleFormatter(String(c2.config.series[s2].data[r2].x), { series: c2.globals.series, seriesIndex: s2, dataPointIndex: r2, w: c2 }));
          var m3 = c2.config.tooltip.inverseOrder ? o3 : t4;
          if (c2.globals.axisCharts) {
            var y3 = function(t5) {
              var e2, i3, a3, s3;
              return c2.globals.isRangeData ? v3.yLbFormatter(null === (e2 = c2.globals.seriesRangeStart) || void 0 === e2 || null === (i3 = e2[t5]) || void 0 === i3 ? void 0 : i3[r2], { series: c2.globals.seriesRangeStart, seriesIndex: t5, dataPointIndex: r2, w: c2 }) + " - " + v3.yLbFormatter(null === (a3 = c2.globals.seriesRangeEnd) || void 0 === a3 || null === (s3 = a3[t5]) || void 0 === s3 ? void 0 : s3[r2], { series: c2.globals.seriesRangeEnd, seriesIndex: t5, dataPointIndex: r2, w: c2 }) : v3.yLbFormatter(c2.globals.series[t5][r2], { series: c2.globals.series, seriesIndex: t5, dataPointIndex: r2, w: c2 });
            };
            if (l2)
              v3 = a2.getFormatters(m3), x2 = a2.getSeriesName({ fn: v3.yLbTitleFormatter, index: m3, seriesIndex: s2, j: r2 }), b2 = c2.globals.colors[m3], i2 = y3(m3), g2(m3) && (d2 = c2.globals.seriesGoals[m3][r2].map(function(t5) {
                return { attrs: t5, val: v3.yLbFormatter(t5.value, { seriesIndex: m3, dataPointIndex: r2, w: c2 }) };
              }));
            else {
              var w2, k2 = null == h2 || null === (w2 = h2.target) || void 0 === w2 ? void 0 : w2.getAttribute("fill");
              k2 && (b2 = -1 !== k2.indexOf("url") ? document.querySelector(k2.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : k2), i2 = y3(s2), g2(s2) && Array.isArray(c2.globals.seriesGoals[s2][r2]) && (d2 = c2.globals.seriesGoals[s2][r2].map(function(t5) {
                return { attrs: t5, val: v3.yLbFormatter(t5.value, { seriesIndex: s2, dataPointIndex: r2, w: c2 }) };
              }));
            }
          }
          null === r2 && (i2 = v3.yLbFormatter(c2.globals.series[s2], e(e({}, c2), {}, { seriesIndex: s2, dataPointIndex: s2 }))), a2.DOMHandling({ i: s2, t: m3, j: r2, ttItems: n2, values: { val: i2, goalVals: d2, xVal: u5, xAxisTTVal: f2, zVal: p2 }, seriesName: x2, shared: l2, pColor: b2 });
        }, m2 = 0, y2 = c2.globals.series.length - 1; m2 < c2.globals.series.length; m2++, y2--)
          v2(m2, y2);
      } }, { key: "getFormatters", value: function(t3) {
        var e2, i2 = this.w, a2 = i2.globals.yLabelFormatters[t3];
        return void 0 !== i2.globals.ttVal ? Array.isArray(i2.globals.ttVal) ? (a2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].formatter, e2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].title && i2.globals.ttVal[t3].title.formatter) : (a2 = i2.globals.ttVal.formatter, "function" == typeof i2.globals.ttVal.title.formatter && (e2 = i2.globals.ttVal.title.formatter)) : e2 = i2.config.tooltip.y.title.formatter, "function" != typeof a2 && (a2 = i2.globals.yLabelFormatters[0] ? i2.globals.yLabelFormatters[0] : function(t4) {
          return t4;
        }), "function" != typeof e2 && (e2 = function(t4) {
          return t4;
        }), { yLbFormatter: a2, yLbTitleFormatter: e2 };
      } }, { key: "getSeriesName", value: function(t3) {
        var e2 = t3.fn, i2 = t3.index, a2 = t3.seriesIndex, s2 = t3.j, r2 = this.w;
        return e2(String(r2.globals.seriesNames[i2]), { series: r2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: r2 });
      } }, { key: "DOMHandling", value: function(t3) {
        t3.i;
        var e2 = t3.t, i2 = t3.j, a2 = t3.ttItems, s2 = t3.values, r2 = t3.seriesName, o2 = t3.shared, n2 = t3.pColor, l2 = this.w, h2 = this.ttCtx, c2 = s2.val, d2 = s2.goalVals, g2 = s2.xVal, u5 = s2.xAxisTTVal, p2 = s2.zVal, f2 = null;
        f2 = a2[e2].children, l2.config.tooltip.fillSeriesColor && (a2[e2].style.backgroundColor = n2, f2[0].style.display = "none"), h2.showTooltipTitle && (null === h2.tooltipTitle && (h2.tooltipTitle = l2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h2.tooltipTitle.innerHTML = g2), h2.isXAxisTooltipEnabled && (h2.xaxisTooltipText.innerHTML = "" !== u5 ? u5 : g2);
        var x2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-label");
        x2 && (x2.innerHTML = r2 || "");
        var b2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-value");
        b2 && (b2.innerHTML = void 0 !== c2 ? c2 : ""), f2[0] && f2[0].classList.contains("apexcharts-tooltip-marker") && (l2.config.tooltip.marker.fillColors && Array.isArray(l2.config.tooltip.marker.fillColors) && (n2 = l2.config.tooltip.marker.fillColors[e2]), f2[0].style.backgroundColor = n2), l2.config.tooltip.marker.show || (f2[0].style.display = "none");
        var v2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-label"), m2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-value");
        if (d2.length && l2.globals.seriesGoals[e2]) {
          var y2 = function() {
            var t4 = "<div >", e3 = "<div>";
            d2.forEach(function(i3, a3) {
              t4 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i3.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i3.attrs.name, "</div>"), e3 += "<div>".concat(i3.val, "</div>");
            }), v2.innerHTML = t4 + "</div>", m2.innerHTML = e3 + "</div>";
          };
          o2 ? l2.globals.seriesGoals[e2][i2] && Array.isArray(l2.globals.seriesGoals[e2][i2]) ? y2() : (v2.innerHTML = "", m2.innerHTML = "") : y2();
        } else
          v2.innerHTML = "", m2.innerHTML = "";
        null !== p2 && (a2[e2].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l2.config.tooltip.z.title, a2[e2].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== p2 ? p2 : "");
        if (o2 && f2[0]) {
          if (l2.config.tooltip.hideEmptySeries) {
            var w2 = a2[e2].querySelector(".apexcharts-tooltip-marker"), k2 = a2[e2].querySelector(".apexcharts-tooltip-text");
            0 == parseFloat(c2) ? (w2.style.display = "none", k2.style.display = "none") : (w2.style.display = "block", k2.style.display = "block");
          }
          null == c2 || l2.globals.ancillaryCollapsedSeriesIndices.indexOf(e2) > -1 || l2.globals.collapsedSeriesIndices.indexOf(e2) > -1 ? f2[0].parentNode.style.display = "none" : f2[0].parentNode.style.display = l2.config.tooltip.items.display;
        }
      } }, { key: "toggleActiveInactiveSeries", value: function(t3) {
        var e2 = this.w;
        if (t3)
          this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
        else {
          this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
          var i2 = e2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
          i2 && (i2.classList.add("apexcharts-active"), i2.style.display = e2.config.tooltip.items.display);
        }
      } }, { key: "getValuesToPrint", value: function(t3) {
        var e2 = t3.i, i2 = t3.j, a2 = this.w, s2 = this.ctx.series.filteredSeriesX(), r2 = "", o2 = "", n2 = null, l2 = null, h2 = { series: a2.globals.series, seriesIndex: e2, dataPointIndex: i2, w: a2 }, c2 = a2.globals.ttZFormatter;
        null === i2 ? l2 = a2.globals.series[e2] : a2.globals.isXNumeric && "treemap" !== a2.config.chart.type ? (r2 = s2[e2][i2], 0 === s2[e2].length && (r2 = s2[this.tooltipUtil.getFirstActiveXArray(s2)][i2])) : r2 = void 0 !== a2.globals.labels[i2] ? a2.globals.labels[i2] : "";
        var d2 = r2;
        a2.globals.isXNumeric && "datetime" === a2.config.xaxis.type ? r2 = new T(this.ctx).xLabelFormat(a2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new I(this.ctx).formatDate, w: this.w }) : r2 = a2.globals.isBarHorizontal ? a2.globals.yLabelFormatters[0](d2, h2) : a2.globals.xLabelFormatter(d2, h2);
        return void 0 !== a2.config.tooltip.x.formatter && (r2 = a2.globals.ttKeyFormatter(d2, h2)), a2.globals.seriesZ.length > 0 && a2.globals.seriesZ[e2].length > 0 && (n2 = c2(a2.globals.seriesZ[e2][i2], a2)), o2 = "function" == typeof a2.config.xaxis.tooltip.formatter ? a2.globals.xaxisTooltipFormatter(d2, h2) : r2, { val: Array.isArray(l2) ? l2.join(" ") : l2, xVal: Array.isArray(r2) ? r2.join(" ") : r2, xAxisTTVal: Array.isArray(o2) ? o2.join(" ") : o2, zVal: n2 };
      } }, { key: "handleCustomTooltip", value: function(t3) {
        var e2 = t3.i, i2 = t3.j, a2 = t3.y1, s2 = t3.y2, r2 = t3.w, o2 = this.ttCtx.getElTooltip(), n2 = r2.config.tooltip.custom;
        Array.isArray(n2) && n2[e2] && (n2 = n2[e2]), o2.innerHTML = n2({ ctx: this.ctx, series: r2.globals.series, seriesIndex: e2, dataPointIndex: i2, y1: a2, y2: s2, w: r2 });
      } }]), t2;
    }();
    var ut = function() {
      function t2(e2) {
        a(this, t2), this.ttCtx = e2, this.ctx = e2.ctx, this.w = e2.w;
      }
      return r(t2, [{ key: "moveXCrosshairs", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i2 = this.ttCtx, a2 = this.w, s2 = i2.getElXCrosshairs(), r2 = t3 - i2.xcrosshairsWidth / 2, o2 = a2.globals.labels.slice().length;
        if (null !== e2 && (r2 = a2.globals.gridWidth / o2 * e2), null === s2 || a2.globals.isBarHorizontal || (s2.setAttribute("x", r2), s2.setAttribute("x1", r2), s2.setAttribute("x2", r2), s2.setAttribute("y2", a2.globals.gridHeight), s2.classList.add("apexcharts-active")), r2 < 0 && (r2 = 0), r2 > a2.globals.gridWidth && (r2 = a2.globals.gridWidth), i2.isXAxisTooltipEnabled) {
          var n2 = r2;
          "tickWidth" !== a2.config.xaxis.crosshairs.width && "barWidth" !== a2.config.xaxis.crosshairs.width || (n2 = r2 + i2.xcrosshairsWidth / 2), this.moveXAxisTooltip(n2);
        }
      } }, { key: "moveYCrosshairs", value: function(t3) {
        var e2 = this.ttCtx;
        null !== e2.ycrosshairs && m.setAttrs(e2.ycrosshairs, { y1: t3, y2: t3 }), null !== e2.ycrosshairsHidden && m.setAttrs(e2.ycrosshairsHidden, { y1: t3, y2: t3 });
      } }, { key: "moveXAxisTooltip", value: function(t3) {
        var e2 = this.w, i2 = this.ttCtx;
        if (null !== i2.xaxisTooltip && 0 !== i2.xcrosshairsWidth) {
          i2.xaxisTooltip.classList.add("apexcharts-active");
          var a2 = i2.xaxisOffY + e2.config.xaxis.tooltip.offsetY + e2.globals.translateY + 1 + e2.config.xaxis.offsetY;
          if (t3 -= i2.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t3)) {
            t3 += e2.globals.translateX;
            var s2;
            s2 = new m(this.ctx).getTextRects(i2.xaxisTooltipText.innerHTML), i2.xaxisTooltipText.style.minWidth = s2.width + "px", i2.xaxisTooltip.style.left = t3 + "px", i2.xaxisTooltip.style.top = a2 + "px";
          }
        }
      } }, { key: "moveYAxisTooltip", value: function(t3) {
        var e2 = this.w, i2 = this.ttCtx;
        null === i2.yaxisTTEls && (i2.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        var a2 = parseInt(i2.ycrosshairsHidden.getAttribute("y1"), 10), s2 = e2.globals.translateY + a2, r2 = i2.yaxisTTEls[t3].getBoundingClientRect().height, o2 = e2.globals.translateYAxisX[t3] - 2;
        e2.config.yaxis[t3].opposite && (o2 -= 26), s2 -= r2 / 2, -1 === e2.globals.ignoreYAxisIndexes.indexOf(t3) ? (i2.yaxisTTEls[t3].classList.add("apexcharts-active"), i2.yaxisTTEls[t3].style.top = s2 + "px", i2.yaxisTTEls[t3].style.left = o2 + e2.config.yaxis[t3].tooltip.offsetX + "px") : i2.yaxisTTEls[t3].classList.remove("apexcharts-active");
      } }, { key: "moveTooltip", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = this.ttCtx, r2 = s2.getElTooltip(), o2 = s2.tooltipRect, n2 = null !== i2 ? parseFloat(i2) : 1, l2 = parseFloat(t3) + n2 + 5, h2 = parseFloat(e2) + n2 / 2;
        if (l2 > a2.globals.gridWidth / 2 && (l2 = l2 - o2.ttWidth - n2 - 10), l2 > a2.globals.gridWidth - o2.ttWidth - 10 && (l2 = a2.globals.gridWidth - o2.ttWidth), l2 < -20 && (l2 = -20), a2.config.tooltip.followCursor) {
          var c2 = s2.getElGrid().getBoundingClientRect();
          (l2 = s2.e.clientX - c2.left) > a2.globals.gridWidth / 2 && (l2 -= s2.tooltipRect.ttWidth), (h2 = s2.e.clientY + a2.globals.translateY - c2.top) > a2.globals.gridHeight / 2 && (h2 -= s2.tooltipRect.ttHeight);
        } else
          a2.globals.isBarHorizontal || o2.ttHeight / 2 + h2 > a2.globals.gridHeight && (h2 = a2.globals.gridHeight - o2.ttHeight + a2.globals.translateY);
        isNaN(l2) || (l2 += a2.globals.translateX, r2.style.left = l2 + "px", r2.style.top = h2 + "px");
      } }, { key: "moveMarkers", value: function(t3, e2) {
        var i2 = this.w, a2 = this.ttCtx;
        if (i2.globals.markers.size[t3] > 0)
          for (var s2 = i2.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-marker")), r2 = 0; r2 < s2.length; r2++)
            parseInt(s2[r2].getAttribute("rel"), 10) === e2 && (a2.marker.resetPointsSize(), a2.marker.enlargeCurrentPoint(e2, s2[r2]));
        else
          a2.marker.resetPointsSize(), this.moveDynamicPointOnHover(e2, t3);
      } }, { key: "moveDynamicPointOnHover", value: function(t3, e2) {
        var i2, a2, s2 = this.w, r2 = this.ttCtx, o2 = s2.globals.pointsArray, n2 = r2.tooltipUtil.getHoverMarkerSize(e2), l2 = s2.config.series[e2].type;
        if (!l2 || "column" !== l2 && "candlestick" !== l2 && "boxPlot" !== l2) {
          i2 = o2[e2][t3][0], a2 = o2[e2][t3][1] ? o2[e2][t3][1] : 0;
          var h2 = s2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e2, "'] .apexcharts-series-markers circle"));
          h2 && a2 < s2.globals.gridHeight && a2 > 0 && (h2.setAttribute("r", n2), h2.setAttribute("cx", i2), h2.setAttribute("cy", a2)), this.moveXCrosshairs(i2), r2.fixedTooltip || this.moveTooltip(i2, a2, n2);
        }
      } }, { key: "moveDynamicPointsOnHover", value: function(t3) {
        var e2, i2 = this.ttCtx, a2 = i2.w, s2 = 0, r2 = 0, o2 = a2.globals.pointsArray;
        e2 = new N(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
        var n2 = i2.tooltipUtil.getHoverMarkerSize(e2);
        o2[e2] && (s2 = o2[e2][t3][0], r2 = o2[e2][t3][1]);
        var l2 = i2.tooltipUtil.getAllMarkers();
        if (null !== l2)
          for (var h2 = 0; h2 < a2.globals.series.length; h2++) {
            var c2 = o2[h2];
            if (a2.globals.comboCharts && void 0 === c2 && l2.splice(h2, 0, null), c2 && c2.length) {
              var d2 = o2[h2][t3][1], g2 = void 0;
              if (l2[h2].setAttribute("cx", s2), "rangeArea" === a2.config.chart.type && !a2.globals.comboCharts) {
                var u5 = t3 + a2.globals.series[h2].length;
                g2 = o2[h2][u5][1], d2 -= Math.abs(d2 - g2) / 2;
              }
              null !== d2 && !isNaN(d2) && d2 < a2.globals.gridHeight + n2 && d2 + n2 > 0 ? (l2[h2] && l2[h2].setAttribute("r", n2), l2[h2] && l2[h2].setAttribute("cy", d2)) : l2[h2] && l2[h2].setAttribute("r", 0);
            }
          }
        this.moveXCrosshairs(s2), i2.fixedTooltip || this.moveTooltip(s2, r2 || a2.globals.gridHeight, n2);
      } }, { key: "moveStickyTooltipOverBars", value: function(t3, e2) {
        var i2 = this.w, a2 = this.ttCtx, s2 = i2.globals.columnSeries ? i2.globals.columnSeries.length : i2.globals.series.length, r2 = s2 >= 2 && s2 % 2 == 0 ? Math.floor(s2 / 2) : Math.floor(s2 / 2) + 1;
        i2.globals.isBarHorizontal && (r2 = new N(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
        var o2 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "']"));
        o2 || "number" != typeof e2 || (o2 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "']")));
        var n2 = o2 ? parseFloat(o2.getAttribute("cx")) : 0, l2 = o2 ? parseFloat(o2.getAttribute("cy")) : 0, h2 = o2 ? parseFloat(o2.getAttribute("barWidth")) : 0, c2 = a2.getElGrid().getBoundingClientRect(), d2 = o2 && (o2.classList.contains("apexcharts-candlestick-area") || o2.classList.contains("apexcharts-boxPlot-area"));
        i2.globals.isXNumeric ? (o2 && !d2 && (n2 -= s2 % 2 != 0 ? h2 / 2 : 0), o2 && d2 && i2.globals.comboCharts && (n2 -= h2 / 2)) : i2.globals.isBarHorizontal || (n2 = a2.xAxisTicksPositions[t3 - 1] + a2.dataPointsDividedWidth / 2, isNaN(n2) && (n2 = a2.xAxisTicksPositions[t3] - a2.dataPointsDividedWidth / 2)), i2.globals.isBarHorizontal ? l2 -= a2.tooltipRect.ttHeight : i2.config.tooltip.followCursor ? l2 = a2.e.clientY - c2.top - a2.tooltipRect.ttHeight / 2 : l2 + a2.tooltipRect.ttHeight + 15 > i2.globals.gridHeight && (l2 = i2.globals.gridHeight), i2.globals.isBarHorizontal || this.moveXCrosshairs(n2), a2.fixedTooltip || this.moveTooltip(n2, l2 || i2.globals.gridHeight);
      } }]), t2;
    }();
    var pt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx, this.tooltipPosition = new ut(e2);
      }
      return r(t2, [{ key: "drawDynamicPoints", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = new H(this.ctx), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        a2 = u4(a2), t3.config.chart.stacked && a2.sort(function(t4, e3) {
          return parseFloat(t4.getAttribute("data:realIndex")) - parseFloat(e3.getAttribute("data:realIndex"));
        });
        for (var s2 = 0; s2 < a2.length; s2++) {
          var r2 = a2[s2].querySelector(".apexcharts-series-markers-wrap");
          if (null !== r2) {
            var o2 = void 0, n2 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
            "line" !== t3.config.chart.type && "area" !== t3.config.chart.type || t3.globals.comboCharts || t3.config.tooltip.intersect || (n2 += " no-pointer-events");
            var l2 = i2.getMarkerConfig({ cssClass: n2, seriesIndex: Number(r2.getAttribute("data:realIndex")) });
            (o2 = e2.drawMarker(0, 0, l2)).node.setAttribute("default-marker-size", 0);
            var h2 = document.createElementNS(t3.globals.SVGNS, "g");
            h2.classList.add("apexcharts-series-markers"), h2.appendChild(o2.node), r2.appendChild(h2);
          }
        }
      } }, { key: "enlargeCurrentPoint", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w;
        "bubble" !== s2.config.chart.type && this.newPointSize(t3, e2);
        var r2 = e2.getAttribute("cx"), o2 = e2.getAttribute("cy");
        if (null !== i2 && null !== a2 && (r2 = i2, o2 = a2), this.tooltipPosition.moveXCrosshairs(r2), !this.fixedTooltip) {
          if ("radar" === s2.config.chart.type) {
            var n2 = this.ttCtx.getElGrid().getBoundingClientRect();
            r2 = this.ttCtx.e.clientX - n2.left;
          }
          this.tooltipPosition.moveTooltip(r2, o2, s2.config.markers.hover.size);
        }
      } }, { key: "enlargePoints", value: function(t3) {
        for (var e2 = this.w, i2 = this, a2 = this.ttCtx, s2 = t3, r2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o2 = e2.config.markers.hover.size, n2 = 0; n2 < r2.length; n2++) {
          var l2 = r2[n2].getAttribute("rel"), h2 = r2[n2].getAttribute("index");
          if (void 0 === o2 && (o2 = e2.globals.markers.size[h2] + e2.config.markers.hover.sizeOffset), s2 === parseInt(l2, 10)) {
            i2.newPointSize(s2, r2[n2]);
            var c2 = r2[n2].getAttribute("cx"), d2 = r2[n2].getAttribute("cy");
            i2.tooltipPosition.moveXCrosshairs(c2), a2.fixedTooltip || i2.tooltipPosition.moveTooltip(c2, d2, o2);
          } else
            i2.oldPointSize(r2[n2]);
        }
      } }, { key: "newPointSize", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.config.markers.hover.size, s2 = 0 === t3 ? e2.parentNode.firstChild : e2.parentNode.lastChild;
        if ("0" !== s2.getAttribute("default-marker-size")) {
          var r2 = parseInt(s2.getAttribute("index"), 10);
          void 0 === a2 && (a2 = i2.globals.markers.size[r2] + i2.config.markers.hover.sizeOffset), a2 < 0 && (a2 = 0), s2.setAttribute("r", a2);
        }
      } }, { key: "oldPointSize", value: function(t3) {
        var e2 = parseFloat(t3.getAttribute("default-marker-size"));
        t3.setAttribute("r", e2);
      } }, { key: "resetPointsSize", value: function() {
        for (var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e2 = 0; e2 < t3.length; e2++) {
          var i2 = parseFloat(t3[e2].getAttribute("default-marker-size"));
          x.isNumber(i2) && i2 >= 0 ? t3[e2].setAttribute("r", i2) : t3[e2].setAttribute("r", 0);
        }
      } }]), t2;
    }();
    var ft = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w;
        var i2 = this.w;
        this.ttCtx = e2, this.isVerticalGroupedRangeBar = !i2.globals.isBarHorizontal && "rangeBar" === i2.config.chart.type && i2.config.plotOptions.bar.rangeBarGroupRows;
      }
      return r(t2, [{ key: "getAttr", value: function(t3, e2) {
        return parseFloat(t3.target.getAttribute(e2));
      } }, { key: "handleHeatTreeTooltip", value: function(t3) {
        var e2 = t3.e, i2 = t3.opt, a2 = t3.x, s2 = t3.y, r2 = t3.type, o2 = this.ttCtx, n2 = this.w;
        if (e2.target.classList.contains("apexcharts-".concat(r2, "-rect"))) {
          var l2 = this.getAttr(e2, "i"), h2 = this.getAttr(e2, "j"), c2 = this.getAttr(e2, "cx"), d2 = this.getAttr(e2, "cy"), g2 = this.getAttr(e2, "width"), u5 = this.getAttr(e2, "height");
          if (o2.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: l2, j: h2, shared: false, e: e2 }), n2.globals.capturedSeriesIndex = l2, n2.globals.capturedDataPointIndex = h2, a2 = c2 + o2.tooltipRect.ttWidth / 2 + g2, s2 = d2 + o2.tooltipRect.ttHeight / 2 - u5 / 2, o2.tooltipPosition.moveXCrosshairs(c2 + g2 / 2), a2 > n2.globals.gridWidth / 2 && (a2 = c2 - o2.tooltipRect.ttWidth / 2 + g2), o2.w.config.tooltip.followCursor) {
            var p2 = n2.globals.dom.elWrap.getBoundingClientRect();
            a2 = n2.globals.clientX - p2.left - (a2 > n2.globals.gridWidth / 2 ? o2.tooltipRect.ttWidth : 0), s2 = n2.globals.clientY - p2.top - (s2 > n2.globals.gridHeight / 2 ? o2.tooltipRect.ttHeight : 0);
          }
        }
        return { x: a2, y: s2 };
      } }, { key: "handleMarkerTooltip", value: function(t3) {
        var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = t3.x, o2 = t3.y, n2 = this.w, l2 = this.ttCtx;
        if (a2.target.classList.contains("apexcharts-marker")) {
          var h2 = parseInt(s2.paths.getAttribute("cx"), 10), c2 = parseInt(s2.paths.getAttribute("cy"), 10), d2 = parseFloat(s2.paths.getAttribute("val"));
          if (i2 = parseInt(s2.paths.getAttribute("rel"), 10), e2 = parseInt(s2.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l2.intersect) {
            var g2 = x.findAncestor(s2.paths, "apexcharts-series");
            g2 && (e2 = parseInt(g2.getAttribute("data:realIndex"), 10));
          }
          if (l2.tooltipLabels.drawSeriesTexts({ ttItems: s2.ttItems, i: e2, j: i2, shared: !l2.showOnIntersect && n2.config.tooltip.shared, e: a2 }), "mouseup" === a2.type && l2.markerClick(a2, e2, i2), n2.globals.capturedSeriesIndex = e2, n2.globals.capturedDataPointIndex = i2, r2 = h2, o2 = c2 + n2.globals.translateY - 1.4 * l2.tooltipRect.ttHeight, l2.w.config.tooltip.followCursor) {
            var u5 = l2.getElGrid().getBoundingClientRect();
            o2 = l2.e.clientY + n2.globals.translateY - u5.top;
          }
          d2 < 0 && (o2 = c2), l2.marker.enlargeCurrentPoint(i2, s2.paths, r2, o2);
        }
        return { x: r2, y: o2 };
      } }, { key: "handleBarTooltip", value: function(t3) {
        var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, o2 = this.ttCtx, n2 = o2.getElTooltip(), l2 = 0, h2 = 0, c2 = 0, d2 = this.getBarTooltipXY({ e: a2, opt: s2 });
        e2 = d2.i;
        var g2 = d2.barHeight, u5 = d2.j;
        r2.globals.capturedSeriesIndex = e2, r2.globals.capturedDataPointIndex = u5, r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars() || !r2.config.tooltip.shared ? (h2 = d2.x, c2 = d2.y, i2 = Array.isArray(r2.config.stroke.width) ? r2.config.stroke.width[e2] : r2.config.stroke.width, l2 = h2) : r2.globals.comboCharts || r2.config.tooltip.shared || (l2 /= 2), isNaN(c2) && (c2 = r2.globals.svgHeight - o2.tooltipRect.ttHeight);
        var p2 = parseInt(s2.paths.parentNode.getAttribute("data:realIndex"), 10), f2 = r2.globals.isMultipleYAxis ? r2.config.yaxis[p2] && r2.config.yaxis[p2].reversed : r2.config.yaxis[0].reversed;
        if (h2 + o2.tooltipRect.ttWidth > r2.globals.gridWidth && !f2 ? h2 -= o2.tooltipRect.ttWidth : h2 < 0 && (h2 = 0), o2.w.config.tooltip.followCursor) {
          var x2 = o2.getElGrid().getBoundingClientRect();
          c2 = o2.e.clientY - x2.top;
        }
        null === o2.tooltip && (o2.tooltip = r2.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r2.config.tooltip.shared || (r2.globals.comboBarCount > 0 ? o2.tooltipPosition.moveXCrosshairs(l2 + i2 / 2) : o2.tooltipPosition.moveXCrosshairs(l2)), !o2.fixedTooltip && (!r2.config.tooltip.shared || r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars()) && (f2 && (h2 -= o2.tooltipRect.ttWidth) < 0 && (h2 = 0), !f2 || r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars() || (c2 = c2 + g2 - 2 * (r2.globals.series[e2][u5] < 0 ? g2 : 0)), c2 = c2 + r2.globals.translateY - o2.tooltipRect.ttHeight / 2, n2.style.left = h2 + r2.globals.translateX + "px", n2.style.top = c2 + "px");
      } }, { key: "getBarTooltipXY", value: function(t3) {
        var e2 = this, i2 = t3.e, a2 = t3.opt, s2 = this.w, r2 = null, o2 = this.ttCtx, n2 = 0, l2 = 0, h2 = 0, c2 = 0, d2 = 0, g2 = i2.target.classList;
        if (g2.contains("apexcharts-bar-area") || g2.contains("apexcharts-candlestick-area") || g2.contains("apexcharts-boxPlot-area") || g2.contains("apexcharts-rangebar-area")) {
          var u5 = i2.target, p2 = u5.getBoundingClientRect(), f2 = a2.elGrid.getBoundingClientRect(), x2 = p2.height;
          d2 = p2.height;
          var b2 = p2.width, v2 = parseInt(u5.getAttribute("cx"), 10), m2 = parseInt(u5.getAttribute("cy"), 10);
          c2 = parseFloat(u5.getAttribute("barWidth"));
          var y2 = "touchmove" === i2.type ? i2.touches[0].clientX : i2.clientX;
          r2 = parseInt(u5.getAttribute("j"), 10), n2 = parseInt(u5.parentNode.getAttribute("rel"), 10) - 1;
          var w2 = u5.getAttribute("data-range-y1"), k2 = u5.getAttribute("data-range-y2");
          s2.globals.comboCharts && (n2 = parseInt(u5.parentNode.getAttribute("data:realIndex"), 10));
          var A2 = function(t4) {
            return s2.globals.isXNumeric ? v2 - b2 / 2 : e2.isVerticalGroupedRangeBar ? v2 + b2 / 2 : v2 - o2.dataPointsDividedWidth + b2 / 2;
          }, S2 = function() {
            return m2 - o2.dataPointsDividedHeight + x2 / 2 - o2.tooltipRect.ttHeight / 2;
          };
          o2.tooltipLabels.drawSeriesTexts({ ttItems: a2.ttItems, i: n2, j: r2, y1: w2 ? parseInt(w2, 10) : null, y2: k2 ? parseInt(k2, 10) : null, shared: !o2.showOnIntersect && s2.config.tooltip.shared, e: i2 }), s2.config.tooltip.followCursor ? s2.globals.isBarHorizontal ? (l2 = y2 - f2.left + 15, h2 = S2()) : (l2 = A2(), h2 = i2.clientY - f2.top - o2.tooltipRect.ttHeight / 2 - 15) : s2.globals.isBarHorizontal ? ((l2 = v2) < o2.xyRatios.baseLineInvertedY && (l2 = v2 - o2.tooltipRect.ttWidth), h2 = S2()) : (l2 = A2(), h2 = m2);
        }
        return { x: l2, y: h2, barHeight: d2, barWidth: c2, i: n2, j: r2 };
      } }]), t2;
    }();
    var xt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.ttCtx = e2;
      }
      return r(t2, [{ key: "drawXaxisTooltip", value: function() {
        var t3 = this.w, e2 = this.ttCtx, i2 = "bottom" === t3.config.xaxis.position;
        e2.xaxisOffY = i2 ? t3.globals.gridHeight + 1 : -t3.globals.xAxisHeight - t3.config.xaxis.axisTicks.height + 3;
        var a2 = i2 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s2 = t3.globals.dom.elWrap;
        e2.isXAxisTooltipEnabled && (null === t3.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e2.xaxisTooltip = document.createElement("div"), e2.xaxisTooltip.setAttribute("class", a2 + " apexcharts-theme-" + t3.config.tooltip.theme), s2.appendChild(e2.xaxisTooltip), e2.xaxisTooltipText = document.createElement("div"), e2.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e2.xaxisTooltipText.style.fontFamily = t3.config.xaxis.tooltip.style.fontFamily || t3.config.chart.fontFamily, e2.xaxisTooltipText.style.fontSize = t3.config.xaxis.tooltip.style.fontSize, e2.xaxisTooltip.appendChild(e2.xaxisTooltipText)));
      } }, { key: "drawYaxisTooltip", value: function() {
        for (var t3 = this.w, e2 = this.ttCtx, i2 = function(i3) {
          var a3 = t3.config.yaxis[i3].opposite || t3.config.yaxis[i3].crosshairs.opposite;
          e2.yaxisOffX = a3 ? t3.globals.gridWidth + 1 : 1;
          var s2 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i3, a3 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
          t3.globals.yAxisSameScaleIndices.map(function(e3, a4) {
            e3.map(function(e4, a5) {
              a5 === i3 && (s2 += t3.config.yaxis[a5].show ? " " : " apexcharts-yaxistooltip-hidden");
            });
          });
          var r2 = t3.globals.dom.elWrap;
          null === t3.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i3)) && (e2.yaxisTooltip = document.createElement("div"), e2.yaxisTooltip.setAttribute("class", s2 + " apexcharts-theme-" + t3.config.tooltip.theme), r2.appendChild(e2.yaxisTooltip), 0 === i3 && (e2.yaxisTooltipText = []), e2.yaxisTooltipText[i3] = document.createElement("div"), e2.yaxisTooltipText[i3].classList.add("apexcharts-yaxistooltip-text"), e2.yaxisTooltip.appendChild(e2.yaxisTooltipText[i3]));
        }, a2 = 0; a2 < t3.config.yaxis.length; a2++)
          i2(a2);
      } }, { key: "setXCrosshairWidth", value: function() {
        var t3 = this.w, e2 = this.ttCtx, i2 = e2.getElXCrosshairs();
        if (e2.xcrosshairsWidth = parseInt(t3.config.xaxis.crosshairs.width, 10), t3.globals.comboCharts) {
          var a2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
          if (null !== a2 && "barWidth" === t3.config.xaxis.crosshairs.width) {
            var s2 = parseFloat(a2.getAttribute("barWidth"));
            e2.xcrosshairsWidth = s2;
          } else if ("tickWidth" === t3.config.xaxis.crosshairs.width) {
            var r2 = t3.globals.labels.length;
            e2.xcrosshairsWidth = t3.globals.gridWidth / r2;
          }
        } else if ("tickWidth" === t3.config.xaxis.crosshairs.width) {
          var o2 = t3.globals.labels.length;
          e2.xcrosshairsWidth = t3.globals.gridWidth / o2;
        } else if ("barWidth" === t3.config.xaxis.crosshairs.width) {
          var n2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
          if (null !== n2) {
            var l2 = parseFloat(n2.getAttribute("barWidth"));
            e2.xcrosshairsWidth = l2;
          } else
            e2.xcrosshairsWidth = 1;
        }
        t3.globals.isBarHorizontal && (e2.xcrosshairsWidth = 0), null !== i2 && e2.xcrosshairsWidth > 0 && i2.setAttribute("width", e2.xcrosshairsWidth);
      } }, { key: "handleYCrosshair", value: function() {
        var t3 = this.w, e2 = this.ttCtx;
        e2.ycrosshairs = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e2.ycrosshairsHidden = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
      } }, { key: "drawYaxisTooltipText", value: function(t3, e2, i2) {
        var a2 = this.ttCtx, s2 = this.w, r2 = s2.globals.yLabelFormatters[t3];
        if (a2.yaxisTooltips[t3]) {
          var o2 = a2.getElGrid().getBoundingClientRect(), n2 = (e2 - o2.top) * i2.yRatio[t3], l2 = s2.globals.maxYArr[t3] - s2.globals.minYArr[t3], h2 = s2.globals.minYArr[t3] + (l2 - n2);
          a2.tooltipPosition.moveYCrosshairs(e2 - o2.top), a2.yaxisTooltipText[t3].innerHTML = r2(h2), a2.tooltipPosition.moveYAxisTooltip(t3);
        }
      } }]), t2;
    }();
    var bt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var i2 = this.w;
        this.tConfig = i2.config.tooltip, this.tooltipUtil = new dt(this), this.tooltipLabels = new gt(this), this.tooltipPosition = new ut(this), this.marker = new pt(this), this.intersect = new ft(this), this.axesTooltip = new xt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i2.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
      }
      return r(t2, [{ key: "getElTooltip", value: function(t3) {
        return t3 || (t3 = this), t3.w.globals.dom.baseEl ? t3.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
      } }, { key: "getElXCrosshairs", value: function() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
      } }, { key: "getElGrid", value: function() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
      } }, { key: "drawTooltip", value: function(t3) {
        var e2 = this.w;
        this.xyRatios = t3, this.isXAxisTooltipEnabled = e2.config.xaxis.tooltip.enabled && e2.globals.axisCharts, this.yaxisTooltips = e2.config.yaxis.map(function(t4, i3) {
          return !!(t4.show && t4.tooltip.enabled && e2.globals.axisCharts);
        }), this.allTooltipSeriesGroups = [], e2.globals.axisCharts || (this.showTooltipTitle = false);
        var i2 = document.createElement("div");
        if (i2.classList.add("apexcharts-tooltip"), e2.config.tooltip.cssClass && i2.classList.add(e2.config.tooltip.cssClass), i2.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e2.globals.dom.elWrap.appendChild(i2), e2.globals.axisCharts) {
          this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
          var a2 = new V(this.ctx);
          this.xAxisTicksPositions = a2.getXAxisTicksPositions();
        }
        if (!e2.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e2.config.chart.type || this.tConfig.shared || (this.showOnIntersect = true), 0 !== e2.config.markers.size && 0 !== e2.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e2.globals.collapsedSeries.length !== e2.globals.series.length) {
          this.dataPointsDividedHeight = e2.globals.gridHeight / e2.globals.dataPoints, this.dataPointsDividedWidth = e2.globals.gridWidth / e2.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e2.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i2.appendChild(this.tooltipTitle));
          var s2 = e2.globals.series.length;
          (e2.globals.xyCharts || e2.globals.comboCharts) && this.tConfig.shared && (s2 = this.showOnIntersect ? 1 : e2.globals.series.length), this.legendLabels = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s2), this.addSVGEvents();
        }
      } }, { key: "createTTElements", value: function(t3) {
        for (var e2 = this, i2 = this.w, a2 = [], s2 = this.getElTooltip(), r2 = function(r3) {
          var o3 = document.createElement("div");
          o3.classList.add("apexcharts-tooltip-series-group"), o3.style.order = i2.config.tooltip.inverseOrder ? t3 - r3 : r3 + 1, e2.tConfig.shared && e2.tConfig.enabledOnSeries && Array.isArray(e2.tConfig.enabledOnSeries) && e2.tConfig.enabledOnSeries.indexOf(r3) < 0 && o3.classList.add("apexcharts-tooltip-series-group-hidden");
          var n2 = document.createElement("span");
          n2.classList.add("apexcharts-tooltip-marker"), n2.style.backgroundColor = i2.globals.colors[r3], o3.appendChild(n2);
          var l2 = document.createElement("div");
          l2.classList.add("apexcharts-tooltip-text"), l2.style.fontFamily = e2.tConfig.style.fontFamily || i2.config.chart.fontFamily, l2.style.fontSize = e2.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(t4) {
            var e3 = document.createElement("div");
            e3.classList.add("apexcharts-tooltip-".concat(t4, "-group"));
            var i3 = document.createElement("span");
            i3.classList.add("apexcharts-tooltip-text-".concat(t4, "-label")), e3.appendChild(i3);
            var a3 = document.createElement("span");
            a3.classList.add("apexcharts-tooltip-text-".concat(t4, "-value")), e3.appendChild(a3), l2.appendChild(e3);
          }), o3.appendChild(l2), s2.appendChild(o3), a2.push(o3);
        }, o2 = 0; o2 < t3; o2++)
          r2(o2);
        return a2;
      } }, { key: "addSVGEvents", value: function() {
        var t3 = this.w, e2 = t3.config.chart.type, i2 = this.getElTooltip(), a2 = !("bar" !== e2 && "candlestick" !== e2 && "boxPlot" !== e2 && "rangeBar" !== e2), s2 = "area" === e2 || "line" === e2 || "scatter" === e2 || "bubble" === e2 || "radar" === e2, r2 = t3.globals.dom.Paper.node, o2 = this.getElGrid();
        o2 && (this.seriesBound = o2.getBoundingClientRect());
        var n2, l2 = [], h2 = [], c2 = { hoverArea: r2, elGrid: o2, tooltipEl: i2, tooltipY: l2, tooltipX: h2, ttItems: this.ttItems };
        if (t3.globals.axisCharts && (s2 ? n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a2 ? n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e2 && "treemap" !== e2 || (n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), n2 && n2.length))
          for (var d2 = 0; d2 < n2.length; d2++)
            l2.push(n2[d2].getAttribute("cy")), h2.push(n2[d2].getAttribute("cx"));
        if (t3.globals.xyCharts && !this.showOnIntersect || t3.globals.comboCharts && !this.showOnIntersect || a2 && this.tooltipUtil.hasBars() && this.tConfig.shared)
          this.addPathsEventListeners([r2], c2);
        else if (a2 && !t3.globals.comboCharts || s2 && this.showOnIntersect)
          this.addDatapointEventsListeners(c2);
        else if (!t3.globals.axisCharts || "heatmap" === e2 || "treemap" === e2) {
          var g2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
          this.addPathsEventListeners(g2, c2);
        }
        if (this.showOnIntersect) {
          var u5 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
          u5.length > 0 && this.addPathsEventListeners(u5, c2), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c2);
        }
      } }, { key: "drawFixedTooltipRect", value: function() {
        var t3 = this.w, e2 = this.getElTooltip(), i2 = e2.getBoundingClientRect(), a2 = i2.width + 10, s2 = i2.height + 10, r2 = this.tConfig.fixed.offsetX, o2 = this.tConfig.fixed.offsetY, n2 = this.tConfig.fixed.position.toLowerCase();
        return n2.indexOf("right") > -1 && (r2 = r2 + t3.globals.svgWidth - a2 + 10), n2.indexOf("bottom") > -1 && (o2 = o2 + t3.globals.svgHeight - s2 - 10), e2.style.left = r2 + "px", e2.style.top = o2 + "px", { x: r2, y: o2, ttWidth: a2, ttHeight: s2 };
      } }, { key: "addDatapointEventsListeners", value: function(t3) {
        var e2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
        this.addPathsEventListeners(e2, t3);
      } }, { key: "addPathsEventListeners", value: function(t3, e2) {
        for (var i2 = this, a2 = function(a3) {
          var s3 = { paths: t3[a3], tooltipEl: e2.tooltipEl, tooltipY: e2.tooltipY, tooltipX: e2.tooltipX, elGrid: e2.elGrid, hoverArea: e2.hoverArea, ttItems: e2.ttItems };
          ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e3) {
            return t3[a3].addEventListener(e3, i2.onSeriesHover.bind(i2, s3), { capture: false, passive: true });
          });
        }, s2 = 0; s2 < t3.length; s2++)
          a2(s2);
      } }, { key: "onSeriesHover", value: function(t3, e2) {
        var i2 = this, a2 = Date.now() - this.lastHoverTime;
        a2 >= 100 ? this.seriesHover(t3, e2) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
          i2.seriesHover(t3, e2);
        }, 100 - a2));
      } }, { key: "seriesHover", value: function(t3, e2) {
        var i2 = this;
        this.lastHoverTime = Date.now();
        var a2 = [], s2 = this.w;
        s2.config.chart.group && (a2 = this.ctx.getGroupedCharts()), s2.globals.axisCharts && (s2.globals.minX === -1 / 0 && s2.globals.maxX === 1 / 0 || 0 === s2.globals.dataPoints) || (a2.length ? a2.forEach(function(a3) {
          var s3 = i2.getElTooltip(a3), r2 = { paths: t3.paths, tooltipEl: s3, tooltipY: t3.tooltipY, tooltipX: t3.tooltipX, elGrid: t3.elGrid, hoverArea: t3.hoverArea, ttItems: a3.w.globals.tooltip.ttItems };
          a3.w.globals.minX === i2.w.globals.minX && a3.w.globals.maxX === i2.w.globals.maxX && a3.w.globals.tooltip.seriesHoverByContext({ chartCtx: a3, ttCtx: a3.w.globals.tooltip, opt: r2, e: e2 });
        }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t3, e: e2 }));
      } }, { key: "seriesHoverByContext", value: function(t3) {
        var e2 = t3.chartCtx, i2 = t3.ttCtx, a2 = t3.opt, s2 = t3.e, r2 = e2.w, o2 = this.getElTooltip();
        if (o2) {
          if (i2.tooltipRect = { x: 0, y: 0, ttWidth: o2.getBoundingClientRect().width, ttHeight: o2.getBoundingClientRect().height }, i2.e = s2, i2.tooltipUtil.hasBars() && !r2.globals.comboCharts && !i2.isBarShared) {
            if (this.tConfig.onDatasetHover.highlightDataSeries)
              new N(e2).toggleSeriesOnHover(s2, s2.target.parentNode);
          }
          i2.fixedTooltip && i2.drawFixedTooltipRect(), r2.globals.axisCharts ? i2.axisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect }) : i2.nonAxisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect });
        }
      } }, { key: "axisChartsTooltips", value: function(t3) {
        var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, o2 = s2.elGrid.getBoundingClientRect(), n2 = "touchmove" === a2.type ? a2.touches[0].clientX : a2.clientX, l2 = "touchmove" === a2.type ? a2.touches[0].clientY : a2.clientY;
        if (this.clientY = l2, this.clientX = n2, r2.globals.capturedSeriesIndex = -1, r2.globals.capturedDataPointIndex = -1, l2 < o2.top || l2 > o2.top + o2.height)
          this.handleMouseOut(s2);
        else {
          if (Array.isArray(this.tConfig.enabledOnSeries) && !r2.config.tooltip.shared) {
            var h2 = parseInt(s2.paths.getAttribute("index"), 10);
            if (this.tConfig.enabledOnSeries.indexOf(h2) < 0)
              return void this.handleMouseOut(s2);
          }
          var c2 = this.getElTooltip(), d2 = this.getElXCrosshairs(), g2 = r2.globals.xyCharts || "bar" === r2.config.chart.type && !r2.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r2.globals.comboCharts && this.tooltipUtil.hasBars();
          if ("mousemove" === a2.type || "touchmove" === a2.type || "mouseup" === a2.type) {
            if (r2.globals.collapsedSeries.length + r2.globals.ancillaryCollapsedSeries.length === r2.globals.series.length)
              return;
            null !== d2 && d2.classList.add("apexcharts-active");
            var u5 = this.yaxisTooltips.filter(function(t4) {
              return true === t4;
            });
            if (null !== this.ycrosshairs && u5.length && this.ycrosshairs.classList.add("apexcharts-active"), g2 && !this.showOnIntersect)
              this.handleStickyTooltip(a2, n2, l2, s2);
            else if ("heatmap" === r2.config.chart.type || "treemap" === r2.config.chart.type) {
              var p2 = this.intersect.handleHeatTreeTooltip({ e: a2, opt: s2, x: e2, y: i2, type: r2.config.chart.type });
              e2 = p2.x, i2 = p2.y, c2.style.left = e2 + "px", c2.style.top = i2 + "px";
            } else
              this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a2, opt: s2 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a2, opt: s2, x: e2, y: i2 });
            if (this.yaxisTooltips.length)
              for (var f2 = 0; f2 < r2.config.yaxis.length; f2++)
                this.axesTooltip.drawYaxisTooltipText(f2, l2, this.xyRatios);
            s2.tooltipEl.classList.add("apexcharts-active");
          } else
            "mouseout" !== a2.type && "touchend" !== a2.type || this.handleMouseOut(s2);
        }
      } }, { key: "nonAxisChartsTooltips", value: function(t3) {
        var e2 = t3.e, i2 = t3.opt, a2 = t3.tooltipRect, s2 = this.w, r2 = i2.paths.getAttribute("rel"), o2 = this.getElTooltip(), n2 = s2.globals.dom.elWrap.getBoundingClientRect();
        if ("mousemove" === e2.type || "touchmove" === e2.type) {
          o2.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: parseInt(r2, 10) - 1, shared: false });
          var l2 = s2.globals.clientX - n2.left - a2.ttWidth / 2, h2 = s2.globals.clientY - n2.top - a2.ttHeight - 10;
          if (o2.style.left = l2 + "px", o2.style.top = h2 + "px", s2.config.legend.tooltipHoverFormatter) {
            var c2 = r2 - 1, d2 = (0, s2.config.legend.tooltipHoverFormatter)(this.legendLabels[c2].getAttribute("data:default-text"), { seriesIndex: c2, dataPointIndex: c2, w: s2 });
            this.legendLabels[c2].innerHTML = d2;
          }
        } else
          "mouseout" !== e2.type && "touchend" !== e2.type || (o2.classList.remove("apexcharts-active"), s2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
            var e3 = t4.getAttribute("data:default-text");
            t4.innerHTML = decodeURIComponent(e3);
          }));
      } }, { key: "handleStickyTooltip", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a2.hoverArea, elGrid: a2.elGrid, clientX: e2, clientY: i2 }), o2 = r2.j, n2 = r2.capturedSeries;
        s2.globals.collapsedSeriesIndices.includes(n2) && (n2 = null);
        var l2 = a2.elGrid.getBoundingClientRect();
        if (r2.hoverX < 0 || r2.hoverX > l2.width)
          this.handleMouseOut(a2);
        else if (null !== n2)
          this.handleStickyCapturedSeries(t3, n2, a2, o2);
        else if (this.tooltipUtil.isXoverlap(o2) || s2.globals.isBarHorizontal) {
          var h2 = s2.globals.series.findIndex(function(t4, e3) {
            return !s2.globals.collapsedSeriesIndices.includes(e3);
          });
          this.create(t3, this, h2, o2, a2.ttItems);
        }
      } }, { key: "handleStickyCapturedSeries", value: function(t3, e2, i2, a2) {
        var s2 = this.w;
        if (!this.tConfig.shared && null === s2.globals.series[e2][a2])
          return void this.handleMouseOut(i2);
        if (void 0 !== s2.globals.series[e2][a2])
          this.tConfig.shared && this.tooltipUtil.isXoverlap(a2) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t3, this, e2, a2, i2.ttItems) : this.create(t3, this, e2, a2, i2.ttItems, false);
        else if (this.tooltipUtil.isXoverlap(a2)) {
          var r2 = s2.globals.series.findIndex(function(t4, e3) {
            return !s2.globals.collapsedSeriesIndices.includes(e3);
          });
          this.create(t3, this, r2, a2, i2.ttItems);
        }
      } }, { key: "deactivateHoverFilter", value: function() {
        for (var t3 = this.w, e2 = new m(this.ctx), i2 = t3.globals.dom.Paper.select(".apexcharts-bar-area"), a2 = 0; a2 < i2.length; a2++)
          e2.pathMouseLeave(i2[a2]);
      } }, { key: "handleMouseOut", value: function(t3) {
        var e2 = this.w, i2 = this.getElXCrosshairs();
        if (t3.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e2.config.chart.type && this.marker.resetPointsSize(), null !== i2 && i2.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
          null === this.yaxisTTEls && (this.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
          for (var a2 = 0; a2 < this.yaxisTTEls.length; a2++)
            this.yaxisTTEls[a2].classList.remove("apexcharts-active");
        }
        e2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
          var e3 = t4.getAttribute("data:default-text");
          t4.innerHTML = decodeURIComponent(e3);
        });
      } }, { key: "markerClick", value: function(t3, e2, i2) {
        var a2 = this.w;
        "function" == typeof a2.config.chart.events.markerClick && a2.config.chart.events.markerClick(t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }), this.ctx.events.fireEvent("markerClick", [t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }]);
      } }, { key: "create", value: function(t3, i2, a2, s2, r2) {
        var o2, n2, l2, h2, c2, d2, g2, u5, p2, f2, x2, b2, v2, y2, w2, k2, A2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, S2 = this.w, C2 = i2;
        "mouseup" === t3.type && this.markerClick(t3, a2, s2), null === A2 && (A2 = this.tConfig.shared);
        var L2 = this.tooltipUtil.hasMarkers(a2), P2 = this.tooltipUtil.getElBars();
        if (S2.config.legend.tooltipHoverFormatter) {
          var I2 = S2.config.legend.tooltipHoverFormatter, T2 = Array.from(this.legendLabels);
          T2.forEach(function(t4) {
            var e2 = t4.getAttribute("data:default-text");
            t4.innerHTML = decodeURIComponent(e2);
          });
          for (var M2 = 0; M2 < T2.length; M2++) {
            var z2 = T2[M2], X2 = parseInt(z2.getAttribute("i"), 10), E2 = decodeURIComponent(z2.getAttribute("data:default-text")), Y2 = I2(E2, { seriesIndex: A2 ? X2 : a2, dataPointIndex: s2, w: S2 });
            if (A2)
              z2.innerHTML = S2.globals.collapsedSeriesIndices.indexOf(X2) < 0 ? Y2 : E2;
            else if (z2.innerHTML = X2 === a2 ? Y2 : E2, a2 === X2)
              break;
          }
        }
        var F2 = e(e({ ttItems: r2, i: a2, j: s2 }, void 0 !== (null === (o2 = S2.globals.seriesRange) || void 0 === o2 || null === (n2 = o2[a2]) || void 0 === n2 || null === (l2 = n2[s2]) || void 0 === l2 || null === (h2 = l2.y[0]) || void 0 === h2 ? void 0 : h2.y1) && { y1: null === (c2 = S2.globals.seriesRange) || void 0 === c2 || null === (d2 = c2[a2]) || void 0 === d2 || null === (g2 = d2[s2]) || void 0 === g2 || null === (u5 = g2.y[0]) || void 0 === u5 ? void 0 : u5.y1 }), void 0 !== (null === (p2 = S2.globals.seriesRange) || void 0 === p2 || null === (f2 = p2[a2]) || void 0 === f2 || null === (x2 = f2[s2]) || void 0 === x2 || null === (b2 = x2.y[0]) || void 0 === b2 ? void 0 : b2.y2) && { y2: null === (v2 = S2.globals.seriesRange) || void 0 === v2 || null === (y2 = v2[a2]) || void 0 === y2 || null === (w2 = y2[s2]) || void 0 === w2 || null === (k2 = w2.y[0]) || void 0 === k2 ? void 0 : k2.y2 });
        if (A2) {
          if (C2.tooltipLabels.drawSeriesTexts(e(e({}, F2), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), L2)
            S2.globals.markers.largestSize > 0 ? C2.marker.enlargePoints(s2) : C2.tooltipPosition.moveDynamicPointsOnHover(s2);
          else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(P2), this.barSeriesHeight > 0)) {
            var R2 = new m(this.ctx), H2 = S2.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s2, "']"));
            this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(s2, a2);
            for (var D2 = 0; D2 < H2.length; D2++)
              R2.pathMouseEnter(H2[D2]);
          }
        } else
          C2.tooltipLabels.drawSeriesTexts(e({ shared: false }, F2)), this.tooltipUtil.hasBars() && C2.tooltipPosition.moveStickyTooltipOverBars(s2, a2), L2 && C2.tooltipPosition.moveMarkers(a2, s2);
      } }]), t2;
    }();
    var vt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.barCtx = e2, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
      }
      return r(t2, [{ key: "handleBarDataLabels", value: function(t3) {
        var e2 = t3.x, i2 = t3.y, a2 = t3.y1, s2 = t3.y2, r2 = t3.i, o2 = t3.j, n2 = t3.realIndex, l2 = t3.groupIndex, h2 = t3.series, c2 = t3.barHeight, d2 = t3.barWidth, g2 = t3.barXPosition, u5 = t3.barYPosition, p2 = t3.visibleSeries, f2 = t3.renderedPath, x2 = this.w, b2 = new m(this.barCtx.ctx), v2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[n2] : this.barCtx.strokeWidth, y2 = e2 + parseFloat(d2 * p2), w2 = i2 + parseFloat(c2 * p2);
        x2.globals.isXNumeric && !x2.globals.isBarHorizontal && (y2 = e2 + parseFloat(d2 * (p2 + 1)), w2 = i2 + parseFloat(c2 * (p2 + 1)) - v2);
        var k2, A2 = null, S2 = e2, C2 = i2, L2 = {}, P2 = x2.config.dataLabels, I2 = this.barCtx.barOptions.dataLabels, T2 = this.barCtx.barOptions.dataLabels.total;
        void 0 !== u5 && this.barCtx.isRangeBar && (w2 = u5, C2 = u5), void 0 !== g2 && this.barCtx.isVerticalGroupedRangeBar && (y2 = g2, S2 = g2);
        var M2 = P2.offsetX, z2 = P2.offsetY, X2 = { width: 0, height: 0 };
        if (x2.config.dataLabels.enabled) {
          var E2 = this.barCtx.series[r2][o2];
          X2 = b2.getTextRects(x2.globals.yLabelFormatters[0](E2), parseFloat(P2.style.fontSize));
        }
        var Y2 = { x: e2, y: i2, i: r2, j: o2, realIndex: n2, groupIndex: l2 || -1, renderedPath: f2, bcx: y2, bcy: w2, barHeight: c2, barWidth: d2, textRects: X2, strokeWidth: v2, dataLabelsX: S2, dataLabelsY: C2, dataLabelsConfig: P2, barDataLabelsConfig: I2, barTotalDataLabelsConfig: T2, offX: M2, offY: z2 };
        return L2 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(Y2) : this.calculateColumnsDataLabelsPosition(Y2), f2.attr({ cy: L2.bcy, cx: L2.bcx, j: o2, val: h2[r2][o2], barHeight: c2, barWidth: d2 }), k2 = this.drawCalculatedDataLabels({ x: L2.dataLabelsX, y: L2.dataLabelsY, val: this.barCtx.isRangeBar ? [a2, s2] : h2[r2][o2], i: n2, j: o2, barWidth: d2, barHeight: c2, textRects: X2, dataLabelsConfig: P2 }), x2.config.chart.stacked && T2.enabled && (A2 = this.drawTotalDataLabels({ x: L2.totalDataLabelsX, y: L2.totalDataLabelsY, barWidth: d2, barHeight: c2, realIndex: n2, textAnchor: L2.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: n2, j: o2 }), dataLabelsConfig: P2, barTotalDataLabelsConfig: T2 })), { dataLabels: k2, totalDataLabels: A2 };
      } }, { key: "getStackedTotalDataLabel", value: function(t3) {
        var i2 = t3.realIndex, a2 = t3.j, s2 = this.w, r2 = this.barCtx.stackedSeriesTotals[a2];
        return this.totalFormatter && (r2 = this.totalFormatter(r2, e(e({}, s2), {}, { seriesIndex: i2, dataPointIndex: a2, w: s2 }))), r2;
      } }, { key: "calculateColumnsDataLabelsPosition", value: function(t3) {
        var e2, i2, a2 = this.w, s2 = t3.i, r2 = t3.j, o2 = t3.realIndex, n2 = t3.groupIndex, l2 = t3.y, h2 = t3.bcx, c2 = t3.barWidth, d2 = t3.barHeight, g2 = t3.textRects, u5 = t3.dataLabelsX, p2 = t3.dataLabelsY, f2 = t3.dataLabelsConfig, x2 = t3.barDataLabelsConfig, b2 = t3.barTotalDataLabelsConfig, v2 = t3.strokeWidth, y2 = t3.offX, w2 = t3.offY;
        d2 = Math.abs(d2);
        var k2 = "vertical" === a2.config.plotOptions.bar.dataLabels.orientation, A2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: s2, j: r2 }).zeroEncounters;
        h2 = h2 - v2 / 2 + (-1 !== n2 ? n2 * c2 : 0);
        var S2 = a2.globals.gridWidth / a2.globals.dataPoints;
        if (this.barCtx.isVerticalGroupedRangeBar ? u5 += c2 / 2 : (u5 = a2.globals.isXNumeric ? h2 - c2 / 2 + y2 : h2 - S2 + c2 / 2 + y2, A2 > 0 && a2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (u5 -= c2 * A2)), k2) {
          u5 = u5 + g2.height / 2 - v2 / 2 - 2;
        }
        var C2 = this.barCtx.series[s2][r2] < 0, L2 = l2;
        switch (this.barCtx.isReversed && (L2 = l2 - d2 + (C2 ? 2 * d2 : 0), l2 -= d2), x2.position) {
          case "center":
            p2 = k2 ? C2 ? L2 - d2 / 2 + w2 : L2 + d2 / 2 - w2 : C2 ? L2 - d2 / 2 + g2.height / 2 + w2 : L2 + d2 / 2 + g2.height / 2 - w2;
            break;
          case "bottom":
            p2 = k2 ? C2 ? L2 - d2 + w2 : L2 + d2 - w2 : C2 ? L2 - d2 + g2.height + v2 + w2 : L2 + d2 - g2.height / 2 + v2 - w2;
            break;
          case "top":
            p2 = k2 ? C2 ? L2 + w2 : L2 - w2 : C2 ? L2 - g2.height / 2 - w2 : L2 + g2.height + w2;
        }
        if (this.barCtx.lastActiveBarSerieIndex === o2 && b2.enabled) {
          var P2 = new m(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: o2, j: r2 }), f2.fontSize);
          e2 = C2 ? L2 - P2.height / 2 - w2 - b2.offsetY + 18 : L2 + P2.height + w2 + b2.offsetY - 18, i2 = u5 + b2.offsetX;
        }
        return a2.config.chart.stacked || (p2 < 0 ? p2 = 0 + v2 : p2 + g2.height / 3 > a2.globals.gridHeight && (p2 = a2.globals.gridHeight - v2)), { bcx: h2, bcy: l2, dataLabelsX: u5, dataLabelsY: p2, totalDataLabelsX: i2, totalDataLabelsY: e2, totalDataLabelsAnchor: "middle" };
      } }, { key: "calculateBarsDataLabelsPosition", value: function(t3) {
        var e2 = this.w, i2 = t3.x, a2 = t3.i, s2 = t3.j, r2 = t3.realIndex, o2 = t3.groupIndex, n2 = t3.bcy, l2 = t3.barHeight, h2 = t3.barWidth, c2 = t3.textRects, d2 = t3.dataLabelsX, g2 = t3.strokeWidth, u5 = t3.dataLabelsConfig, p2 = t3.barDataLabelsConfig, f2 = t3.barTotalDataLabelsConfig, x2 = t3.offX, b2 = t3.offY, v2 = e2.globals.gridHeight / e2.globals.dataPoints;
        h2 = Math.abs(h2);
        var y2, w2, k2 = (n2 += -1 !== o2 ? o2 * l2 : 0) - (this.barCtx.isRangeBar ? 0 : v2) + l2 / 2 + c2.height / 2 + b2 - 3, A2 = "start", S2 = this.barCtx.series[a2][s2] < 0, C2 = i2;
        switch (this.barCtx.isReversed && (C2 = i2 + h2 - (S2 ? 2 * h2 : 0), i2 = e2.globals.gridWidth - h2), p2.position) {
          case "center":
            d2 = S2 ? C2 + h2 / 2 - x2 : Math.max(c2.width / 2, C2 - h2 / 2) + x2;
            break;
          case "bottom":
            d2 = S2 ? C2 + h2 - g2 - Math.round(c2.width / 2) - x2 : C2 - h2 + g2 + Math.round(c2.width / 2) + x2;
            break;
          case "top":
            d2 = S2 ? C2 - g2 + Math.round(c2.width / 2) - x2 : C2 - g2 - Math.round(c2.width / 2) + x2;
        }
        if (this.barCtx.lastActiveBarSerieIndex === r2 && f2.enabled) {
          var L2 = new m(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r2, j: s2 }), u5.fontSize);
          S2 ? (y2 = C2 - g2 + Math.round(L2.width / 2) - x2 - f2.offsetX - 15, A2 = "end") : y2 = C2 - g2 - Math.round(L2.width / 2) + x2 + f2.offsetX + 15, w2 = k2 + f2.offsetY;
        }
        return e2.config.chart.stacked || (d2 < 0 ? d2 = d2 + c2.width + g2 : d2 + c2.width / 2 > e2.globals.gridWidth && (d2 = e2.globals.gridWidth - c2.width - g2)), { bcx: i2, bcy: n2, dataLabelsX: d2, dataLabelsY: k2, totalDataLabelsX: y2, totalDataLabelsY: w2, totalDataLabelsAnchor: A2 };
      } }, { key: "drawCalculatedDataLabels", value: function(t3) {
        var i2 = t3.x, a2 = t3.y, s2 = t3.val, r2 = t3.i, o2 = t3.j, n2 = t3.textRects, l2 = t3.barHeight, h2 = t3.barWidth, c2 = t3.dataLabelsConfig, d2 = this.w, g2 = "rotate(0)";
        "vertical" === d2.config.plotOptions.bar.dataLabels.orientation && (g2 = "rotate(-90, ".concat(i2, ", ").concat(a2, ")"));
        var u5 = new O(this.barCtx.ctx), p2 = new m(this.barCtx.ctx), f2 = c2.formatter, x2 = null, b2 = d2.globals.collapsedSeriesIndices.indexOf(r2) > -1;
        if (c2.enabled && !b2) {
          x2 = p2.group({ class: "apexcharts-data-labels", transform: g2 });
          var v2 = "";
          void 0 !== s2 && (v2 = f2(s2, e(e({}, d2), {}, { seriesIndex: r2, dataPointIndex: o2, w: d2 }))), !s2 && d2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (v2 = "");
          var y2 = d2.globals.series[r2][o2] < 0, w2 = d2.config.plotOptions.bar.dataLabels.position;
          if ("vertical" === d2.config.plotOptions.bar.dataLabels.orientation && ("top" === w2 && (c2.textAnchor = y2 ? "end" : "start"), "center" === w2 && (c2.textAnchor = "middle"), "bottom" === w2 && (c2.textAnchor = y2 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels)
            h2 < p2.getTextRects(v2, parseFloat(c2.style.fontSize)).width && (v2 = "");
          d2.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n2.width / 1.6 > Math.abs(h2) && (v2 = "") : n2.height / 1.6 > Math.abs(l2) && (v2 = ""));
          var k2 = e({}, c2);
          this.barCtx.isHorizontal && s2 < 0 && ("start" === c2.textAnchor ? k2.textAnchor = "end" : "end" === c2.textAnchor && (k2.textAnchor = "start")), u5.plotDataLabelsText({ x: i2, y: a2, text: v2, i: r2, j: o2, parent: x2, dataLabelsConfig: k2, alwaysDrawDataLabel: true, offsetCorrection: true });
        }
        return x2;
      } }, { key: "drawTotalDataLabels", value: function(t3) {
        var e2, i2 = t3.x, a2 = t3.y, s2 = t3.val, r2 = t3.barWidth, o2 = t3.barHeight, n2 = t3.realIndex, l2 = t3.textAnchor, h2 = t3.barTotalDataLabelsConfig, c2 = this.w, d2 = new m(this.barCtx.ctx);
        return h2.enabled && void 0 !== i2 && void 0 !== a2 && this.barCtx.lastActiveBarSerieIndex === n2 && (e2 = d2.drawText({ x: i2 - (!c2.globals.isBarHorizontal && c2.globals.seriesGroups.length ? r2 / c2.globals.seriesGroups.length : 0), y: a2 - (c2.globals.isBarHorizontal && c2.globals.seriesGroups.length ? o2 / c2.globals.seriesGroups.length : 0), foreColor: h2.style.color, text: s2, textAnchor: l2, fontFamily: h2.style.fontFamily, fontSize: h2.style.fontSize, fontWeight: h2.style.fontWeight })), e2;
      } }]), t2;
    }();
    var mt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.barCtx = e2;
      }
      return r(t2, [{ key: "initVariables", value: function(t3) {
        var e2 = this.w;
        this.barCtx.series = t3, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
        for (var i2 = 0; i2 < t3.length; i2++)
          if (t3[i2].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t3[i2].length), e2.globals.isXNumeric)
            for (var a2 = 0; a2 < t3[i2].length; a2++)
              e2.globals.seriesX[i2][a2] > e2.globals.minX && e2.globals.seriesX[i2][a2] < e2.globals.maxX && this.barCtx.visibleItems++;
          else
            this.barCtx.visibleItems = e2.globals.dataPoints;
        0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e2.globals.comboCharts || this.checkZeroSeries({ series: t3 });
      } }, { key: "initialPositions", value: function() {
        var t3, e2, i2, a2, s2, r2, o2, n2, l2 = this.w, h2 = l2.globals.dataPoints;
        this.barCtx.isRangeBar && (h2 = l2.globals.labels.length);
        var c2 = this.barCtx.seriesLen;
        if (l2.config.plotOptions.bar.rangeBarGroupRows && (c2 = 1), this.barCtx.isHorizontal)
          s2 = (i2 = l2.globals.gridHeight / h2) / c2, l2.globals.isXNumeric && (s2 = (i2 = l2.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s2 = s2 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (s2 = parseInt(this.barCtx.barOptions.barHeight, 10)), n2 = this.barCtx.baseLineInvertedY + l2.globals.padHorizontal + (this.barCtx.isReversed ? l2.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (n2 = l2.globals.gridWidth / 2), e2 = (i2 - s2 * this.barCtx.seriesLen) / 2;
        else {
          if (a2 = l2.globals.gridWidth / this.barCtx.visibleItems, l2.config.xaxis.convertedCatToNumeric && (a2 = l2.globals.gridWidth / l2.globals.dataPoints), r2 = a2 / c2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l2.globals.isXNumeric) {
            var d2 = this.barCtx.xRatio;
            l2.config.xaxis.convertedCatToNumeric && (d2 = this.barCtx.initialXRatio), l2.globals.minXDiff && 0.5 !== l2.globals.minXDiff && l2.globals.minXDiff / d2 > 0 && (a2 = l2.globals.minXDiff / d2), (r2 = a2 / c2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r2 = 1);
          }
          -1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (r2 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o2 = l2.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l2.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t3 = l2.globals.padHorizontal + (a2 - r2 * this.barCtx.seriesLen) / 2;
        }
        return l2.globals.barHeight = s2, l2.globals.barWidth = r2, { x: t3, y: e2, yDivision: i2, xDivision: a2, barHeight: s2, barWidth: r2, zeroH: o2, zeroW: n2 };
      } }, { key: "initializeStackedPrevVars", value: function(t3) {
        var e2 = t3.w;
        e2.globals.hasSeriesGroups ? e2.globals.seriesGroups.forEach(function(e3) {
          t3[e3] || (t3[e3] = {}), t3[e3].prevY = [], t3[e3].prevX = [], t3[e3].prevYF = [], t3[e3].prevXF = [], t3[e3].prevYVal = [], t3[e3].prevXVal = [];
        }) : (t3.prevY = [], t3.prevX = [], t3.prevYF = [], t3.prevXF = [], t3.prevYVal = [], t3.prevXVal = []);
      } }, { key: "initializeStackedXYVars", value: function(t3) {
        var e2 = t3.w;
        e2.globals.hasSeriesGroups ? e2.globals.seriesGroups.forEach(function(e3) {
          t3[e3] || (t3[e3] = {}), t3[e3].xArrj = [], t3[e3].xArrjF = [], t3[e3].xArrjVal = [], t3[e3].yArrj = [], t3[e3].yArrjF = [], t3[e3].yArrjVal = [];
        }) : (t3.xArrj = [], t3.xArrjF = [], t3.xArrjVal = [], t3.yArrj = [], t3.yArrjF = [], t3.yArrjVal = []);
      } }, { key: "getPathFillColor", value: function(t3, e2, i2, a2) {
        var s2, r2, o2, n2, l2 = this.w, h2 = new R(this.barCtx.ctx), c2 = null, d2 = this.barCtx.barOptions.distributed ? i2 : e2;
        this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(a3) {
          t3[e2][i2] >= a3.from && t3[e2][i2] <= a3.to && (c2 = a3.color);
        });
        return l2.config.series[e2].data[i2] && l2.config.series[e2].data[i2].fillColor && (c2 = l2.config.series[e2].data[i2].fillColor), h2.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? d2 : a2, dataPointIndex: i2, color: c2, value: t3[e2][i2], fillConfig: null === (s2 = l2.config.series[e2].data[i2]) || void 0 === s2 ? void 0 : s2.fill, fillType: null !== (r2 = l2.config.series[e2].data[i2]) && void 0 !== r2 && null !== (o2 = r2.fill) && void 0 !== o2 && o2.type ? null === (n2 = l2.config.series[e2].data[i2]) || void 0 === n2 ? void 0 : n2.fill.type : Array.isArray(l2.config.fill.type) ? l2.config.fill.type[e2] : l2.config.fill.type });
      } }, { key: "getStrokeWidth", value: function(t3, e2, i2) {
        var a2 = 0, s2 = this.w;
        return this.barCtx.series[t3][e2] ? this.barCtx.isNullValue = false : this.barCtx.isNullValue = true, s2.config.stroke.show && (this.barCtx.isNullValue || (a2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i2] : this.barCtx.strokeWidth)), a2;
      } }, { key: "shouldApplyRadius", value: function(t3) {
        var e2 = this.w, i2 = false;
        return e2.config.plotOptions.bar.borderRadius > 0 && (e2.config.chart.stacked && "last" === e2.config.plotOptions.bar.borderRadiusWhenStacked ? this.barCtx.lastActiveBarSerieIndex === t3 && (i2 = true) : i2 = true), i2;
      } }, { key: "barBackground", value: function(t3) {
        var e2 = t3.j, i2 = t3.i, a2 = t3.x1, s2 = t3.x2, r2 = t3.y1, o2 = t3.y2, n2 = t3.elSeries, l2 = this.w, h2 = new m(this.barCtx.ctx), c2 = new N(this.barCtx.ctx).getActiveConfigSeriesIndex();
        if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c2 === i2) {
          e2 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e2 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
          var d2 = this.barCtx.barOptions.colors.backgroundBarColors[e2], g2 = h2.drawRect(void 0 !== a2 ? a2 : 0, void 0 !== r2 ? r2 : 0, void 0 !== s2 ? s2 : l2.globals.gridWidth, void 0 !== o2 ? o2 : l2.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d2, this.barCtx.barOptions.colors.backgroundBarOpacity);
          n2.add(g2), g2.node.classList.add("apexcharts-backgroundBar");
        }
      } }, { key: "getColumnPaths", value: function(t3) {
        var e2, i2 = t3.barWidth, a2 = t3.barXPosition, s2 = t3.y1, r2 = t3.y2, o2 = t3.strokeWidth, n2 = t3.seriesGroup, l2 = t3.realIndex, h2 = t3.i, c2 = t3.j, d2 = t3.w, g2 = new m(this.barCtx.ctx);
        (o2 = Array.isArray(o2) ? o2[l2] : o2) || (o2 = 0);
        var u5 = i2, p2 = a2;
        null !== (e2 = d2.config.series[l2].data[c2]) && void 0 !== e2 && e2.columnWidthOffset && (p2 = a2 - d2.config.series[l2].data[c2].columnWidthOffset / 2, u5 = i2 + d2.config.series[l2].data[c2].columnWidthOffset);
        var f2 = p2, x2 = p2 + u5;
        s2 += 1e-3, r2 += 1e-3;
        var b2 = g2.move(f2, s2), v2 = g2.move(f2, s2), y2 = g2.line(x2 - o2, s2);
        if (d2.globals.previousPaths.length > 0 && (v2 = this.barCtx.getPreviousPath(l2, c2, false)), b2 = b2 + g2.line(f2, r2) + g2.line(x2 - o2, r2) + g2.line(x2 - o2, s2) + ("around" === d2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), v2 = v2 + g2.line(f2, s2) + y2 + y2 + y2 + y2 + y2 + g2.line(f2, s2) + ("around" === d2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(l2) && (b2 = g2.roundPathCorners(b2, d2.config.plotOptions.bar.borderRadius)), d2.config.chart.stacked) {
          var w2 = this.barCtx;
          d2.globals.hasSeriesGroups && n2 && (w2 = this.barCtx[n2]), w2.yArrj.push(r2), w2.yArrjF.push(Math.abs(s2 - r2)), w2.yArrjVal.push(this.barCtx.series[h2][c2]);
        }
        return { pathTo: b2, pathFrom: v2 };
      } }, { key: "getBarpaths", value: function(t3) {
        var e2, i2 = t3.barYPosition, a2 = t3.barHeight, s2 = t3.x1, r2 = t3.x2, o2 = t3.strokeWidth, n2 = t3.seriesGroup, l2 = t3.realIndex, h2 = t3.i, c2 = t3.j, d2 = t3.w, g2 = new m(this.barCtx.ctx);
        (o2 = Array.isArray(o2) ? o2[l2] : o2) || (o2 = 0);
        var u5 = i2, p2 = a2;
        null !== (e2 = d2.config.series[l2].data[c2]) && void 0 !== e2 && e2.barHeightOffset && (u5 = i2 - d2.config.series[l2].data[c2].barHeightOffset / 2, p2 = a2 + d2.config.series[l2].data[c2].barHeightOffset);
        var f2 = u5, x2 = u5 + p2;
        s2 += 1e-3, r2 += 1e-3;
        var b2 = g2.move(s2, f2), v2 = g2.move(s2, f2);
        d2.globals.previousPaths.length > 0 && (v2 = this.barCtx.getPreviousPath(l2, c2, false));
        var y2 = g2.line(s2, x2 - o2);
        if (b2 = b2 + g2.line(r2, f2) + g2.line(r2, x2 - o2) + y2 + ("around" === d2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), v2 = v2 + g2.line(s2, f2) + y2 + y2 + y2 + y2 + y2 + g2.line(s2, f2) + ("around" === d2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(l2) && (b2 = g2.roundPathCorners(b2, d2.config.plotOptions.bar.borderRadius)), d2.config.chart.stacked) {
          var w2 = this.barCtx;
          d2.globals.hasSeriesGroups && n2 && (w2 = this.barCtx[n2]), w2.xArrj.push(r2), w2.xArrjF.push(Math.abs(s2 - r2)), w2.xArrjVal.push(this.barCtx.series[h2][c2]);
        }
        return { pathTo: b2, pathFrom: v2 };
      } }, { key: "checkZeroSeries", value: function(t3) {
        for (var e2 = t3.series, i2 = this.w, a2 = 0; a2 < e2.length; a2++) {
          for (var s2 = 0, r2 = 0; r2 < e2[i2.globals.maxValsInArrayIndex].length; r2++)
            s2 += e2[a2][r2];
          0 === s2 && this.barCtx.zeroSerieses.push(a2);
        }
      } }, { key: "getXForValue", value: function(t3, e2) {
        var i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e2 : null;
        return null != t3 && (i2 = e2 + t3 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t3 / this.barCtx.invertedYRatio : 0)), i2;
      } }, { key: "getYForValue", value: function(t3, e2) {
        var i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e2 : null;
        return null != t3 && (i2 = e2 - t3 / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t3 / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), i2;
      } }, { key: "getGoalValues", value: function(t3, i2, a2, s2, r2) {
        var n2 = this, l2 = this.w, h2 = [], c2 = function(e2, s3) {
          var r3;
          h2.push((o(r3 = {}, t3, "x" === t3 ? n2.getXForValue(e2, i2, false) : n2.getYForValue(e2, a2, false)), o(r3, "attrs", s3), r3));
        };
        if (l2.globals.seriesGoals[s2] && l2.globals.seriesGoals[s2][r2] && Array.isArray(l2.globals.seriesGoals[s2][r2]) && l2.globals.seriesGoals[s2][r2].forEach(function(t4) {
          c2(t4.value, t4);
        }), this.barCtx.barOptions.isDumbbell && l2.globals.seriesRange.length) {
          var d2 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l2.globals.colors, g2 = { strokeHeight: "x" === t3 ? 0 : l2.globals.markers.size[s2], strokeWidth: "x" === t3 ? l2.globals.markers.size[s2] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(d2[s2]) ? d2[s2][0] : d2[s2] };
          c2(l2.globals.seriesRangeStart[s2][r2], g2), c2(l2.globals.seriesRangeEnd[s2][r2], e(e({}, g2), {}, { strokeColor: Array.isArray(d2[s2]) ? d2[s2][1] : d2[s2] }));
        }
        return h2;
      } }, { key: "drawGoalLine", value: function(t3) {
        var e2 = t3.barXPosition, i2 = t3.barYPosition, a2 = t3.goalX, s2 = t3.goalY, r2 = t3.barWidth, o2 = t3.barHeight, n2 = new m(this.barCtx.ctx), l2 = n2.group({ className: "apexcharts-bar-goals-groups" });
        l2.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l2.node }), l2.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
        var h2 = null;
        return this.barCtx.isHorizontal ? Array.isArray(a2) && a2.forEach(function(t4) {
          var e3 = void 0 !== t4.attrs.strokeHeight ? t4.attrs.strokeHeight : o2 / 2, a3 = i2 + e3 + o2 / 2;
          h2 = n2.drawLine(t4.x, a3 - 2 * e3, t4.x, a3, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeWidth ? t4.attrs.strokeWidth : 2, t4.attrs.strokeLineCap), l2.add(h2);
        }) : Array.isArray(s2) && s2.forEach(function(t4) {
          var i3 = void 0 !== t4.attrs.strokeWidth ? t4.attrs.strokeWidth : r2 / 2, a3 = e2 + i3 + r2 / 2;
          h2 = n2.drawLine(a3 - 2 * i3, t4.y, a3, t4.y, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeHeight ? t4.attrs.strokeHeight : 2, t4.attrs.strokeLineCap), l2.add(h2);
        }), l2;
      } }, { key: "drawBarShadow", value: function(t3) {
        var e2 = t3.prevPaths, i2 = t3.currPaths, a2 = t3.color, s2 = this.w, r2 = e2.x, o2 = e2.x1, n2 = e2.barYPosition, l2 = i2.x, h2 = i2.x1, c2 = i2.barYPosition, d2 = n2 + i2.barHeight, g2 = new m(this.barCtx.ctx), u5 = new x(), p2 = g2.move(o2, d2) + g2.line(r2, d2) + g2.line(l2, c2) + g2.line(h2, c2) + g2.line(o2, d2) + ("around" === s2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
        return g2.drawPath({ d: p2, fill: u5.shadeColor(0.5, x.rgb2hex(a2)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
      } }, { key: "getZeroValueEncounters", value: function(t3) {
        var e2 = t3.i, i2 = t3.j, a2 = this.w, s2 = 0, r2 = 0;
        return a2.globals.seriesPercent.forEach(function(t4, a3) {
          t4[i2] && s2++, a3 < e2 && 0 === t4[i2] && r2++;
        }), { nonZeroColumns: s2, zeroEncounters: r2 };
      } }]), t2;
    }();
    var yt = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var s2 = this.w;
        this.barOptions = s2.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s2.config.stroke.width, this.isNullValue = false, this.isRangeBar = s2.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s2.globals.isBarHorizontal && s2.globals.seriesRange.length && s2.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = i2, null !== this.xyRatios && (this.xRatio = i2.xRatio, this.initialXRatio = i2.initialXRatio, this.yRatio = i2.yRatio, this.invertedXRatio = i2.invertedXRatio, this.invertedYRatio = i2.invertedYRatio, this.baseLineY = i2.baseLineY, this.baseLineInvertedY = i2.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.pathArr = [];
        var r2 = new N(this.ctx);
        this.lastActiveBarSerieIndex = r2.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
        var o2 = r2.getBarSeriesIndices(), n2 = new y(this.ctx);
        this.stackedSeriesTotals = n2.getStackedSeriesTotals(this.w.config.series.map(function(t3, e3) {
          return -1 === o2.indexOf(e3) ? e3 : -1;
        }).filter(function(t3) {
          return -1 !== t3;
        })), this.barHelpers = new mt(this);
      }
      return r(t2, [{ key: "draw", value: function(t3, i2) {
        var a2 = this.w, s2 = new m(this.ctx), r2 = new y(this.ctx, a2);
        t3 = r2.getLogSeries(t3), this.series = t3, this.yRatio = r2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
        var o2 = s2.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
        a2.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
        for (var n2 = 0, l2 = 0; n2 < t3.length; n2++, l2++) {
          var h2, c2, d2, g2, u5 = void 0, p2 = void 0, f2 = [], b2 = [], v2 = a2.globals.comboCharts ? i2[n2] : n2, w2 = s2.group({ class: "apexcharts-series", rel: n2 + 1, seriesName: x.escapeString(a2.globals.seriesNames[v2]), "data:realIndex": v2 });
          this.ctx.series.addCollapsedClassToSeries(w2, v2), t3[n2].length > 0 && (this.visibleI = this.visibleI + 1);
          var k2 = 0, A2 = 0;
          this.yRatio.length > 1 && (this.yaxisIndex = v2), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed;
          var S2 = this.barHelpers.initialPositions();
          p2 = S2.y, k2 = S2.barHeight, c2 = S2.yDivision, g2 = S2.zeroW, u5 = S2.x, A2 = S2.barWidth, h2 = S2.xDivision, d2 = S2.zeroH, this.horizontal || b2.push(u5 + A2 / 2);
          var C2 = s2.group({ class: "apexcharts-datalabels", "data:realIndex": v2 });
          a2.globals.delayedElements.push({ el: C2.node }), C2.node.classList.add("apexcharts-element-hidden");
          var L2 = s2.group({ class: "apexcharts-bar-goals-markers" }), P2 = s2.group({ class: "apexcharts-bar-shadows" });
          a2.globals.delayedElements.push({ el: P2.node }), P2.node.classList.add("apexcharts-element-hidden");
          for (var I2 = 0; I2 < a2.globals.dataPoints; I2++) {
            var T2 = this.barHelpers.getStrokeWidth(n2, I2, v2), M2 = null, z2 = { indexes: { i: n2, j: I2, realIndex: v2, bc: l2 }, x: u5, y: p2, strokeWidth: T2, elSeries: w2 };
            this.isHorizontal ? (M2 = this.drawBarPaths(e(e({}, z2), {}, { barHeight: k2, zeroW: g2, yDivision: c2 })), A2 = this.series[n2][I2] / this.invertedYRatio) : (M2 = this.drawColumnPaths(e(e({}, z2), {}, { xDivision: h2, barWidth: A2, zeroH: d2 })), k2 = this.series[n2][I2] / this.yRatio[this.yaxisIndex]);
            var X2 = this.barHelpers.getPathFillColor(t3, n2, I2, v2);
            if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && I2 > 0) {
              var E2 = this.barHelpers.drawBarShadow({ color: "string" == typeof X2 && -1 === (null == X2 ? void 0 : X2.indexOf("url")) ? X2 : x.hexToRgba(a2.globals.colors[n2]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: M2 });
              E2 && P2.add(E2);
            }
            this.pathArr.push(M2);
            var Y2 = this.barHelpers.drawGoalLine({ barXPosition: M2.barXPosition, barYPosition: M2.barYPosition, goalX: M2.goalX, goalY: M2.goalY, barHeight: k2, barWidth: A2 });
            Y2 && L2.add(Y2), p2 = M2.y, u5 = M2.x, I2 > 0 && b2.push(u5 + A2 / 2), f2.push(p2), this.renderSeries({ realIndex: v2, pathFill: X2, j: I2, i: n2, pathFrom: M2.pathFrom, pathTo: M2.pathTo, strokeWidth: T2, elSeries: w2, x: u5, y: p2, series: t3, barHeight: M2.barHeight ? M2.barHeight : k2, barWidth: M2.barWidth ? M2.barWidth : A2, elDataLabelsWrap: C2, elGoalsMarkers: L2, elBarShadows: P2, visibleSeries: this.visibleI, type: "bar" });
          }
          a2.globals.seriesXvalues[v2] = b2, a2.globals.seriesYvalues[v2] = f2, o2.add(w2);
        }
        return o2;
      } }, { key: "renderSeries", value: function(t3) {
        var e2 = t3.realIndex, i2 = t3.pathFill, a2 = t3.lineFill, s2 = t3.j, r2 = t3.i, o2 = t3.groupIndex, n2 = t3.pathFrom, l2 = t3.pathTo, h2 = t3.strokeWidth, c2 = t3.elSeries, d2 = t3.x, g2 = t3.y, u5 = t3.y1, p2 = t3.y2, f2 = t3.series, x2 = t3.barHeight, b2 = t3.barWidth, y2 = t3.barXPosition, w2 = t3.barYPosition, k2 = t3.elDataLabelsWrap, A2 = t3.elGoalsMarkers, S2 = t3.elBarShadows, C2 = t3.visibleSeries, L2 = t3.type, P2 = this.w, I2 = new m(this.ctx);
        a2 || (a2 = this.barOptions.distributed ? P2.globals.stroke.colors[s2] : P2.globals.stroke.colors[e2]), P2.config.series[r2].data[s2] && P2.config.series[r2].data[s2].strokeColor && (a2 = P2.config.series[r2].data[s2].strokeColor), this.isNullValue && (i2 = "none");
        var T2 = s2 / P2.config.chart.animations.animateGradually.delay * (P2.config.chart.animations.speed / P2.globals.dataPoints) / 2.4, M2 = I2.renderPaths({ i: r2, j: s2, realIndex: e2, pathFrom: n2, pathTo: l2, stroke: a2, strokeWidth: h2, strokeLineCap: P2.config.stroke.lineCap, fill: i2, animationDelay: T2, initialSpeed: P2.config.chart.animations.speed, dataChangeSpeed: P2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(L2, "-area") });
        M2.attr("clip-path", "url(#gridRectMask".concat(P2.globals.cuid, ")"));
        var z2 = P2.config.forecastDataPoints;
        z2.count > 0 && s2 >= P2.globals.dataPoints - z2.count && (M2.node.setAttribute("stroke-dasharray", z2.dashArray), M2.node.setAttribute("stroke-width", z2.strokeWidth), M2.node.setAttribute("fill-opacity", z2.fillOpacity)), void 0 !== u5 && void 0 !== p2 && (M2.attr("data-range-y1", u5), M2.attr("data-range-y2", p2)), new v(this.ctx).setSelectionFilter(M2, e2, s2), c2.add(M2);
        var X2 = new vt(this).handleBarDataLabels({ x: d2, y: g2, y1: u5, y2: p2, i: r2, j: s2, series: f2, realIndex: e2, groupIndex: o2, barHeight: x2, barWidth: b2, barXPosition: y2, barYPosition: w2, renderedPath: M2, visibleSeries: C2 });
        return null !== X2.dataLabels && k2.add(X2.dataLabels), X2.totalDataLabels && k2.add(X2.totalDataLabels), c2.add(k2), A2 && c2.add(A2), S2 && c2.add(S2), c2;
      } }, { key: "drawBarPaths", value: function(t3) {
        var e2, i2 = t3.indexes, a2 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, o2 = t3.x, n2 = t3.y, l2 = t3.yDivision, h2 = t3.elSeries, c2 = this.w, d2 = i2.i, g2 = i2.j;
        if (c2.globals.isXNumeric)
          e2 = (n2 = (c2.globals.seriesX[d2][g2] - c2.globals.minX) / this.invertedXRatio - a2) + a2 * this.visibleI;
        else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
          var u5 = 0, p2 = 0;
          c2.globals.seriesPercent.forEach(function(t4, e3) {
            t4[g2] && u5++, e3 < d2 && 0 === t4[g2] && p2++;
          }), u5 > 0 && (a2 = this.seriesLen * a2 / u5), e2 = n2 + a2 * this.visibleI, e2 -= a2 * p2;
        } else
          e2 = n2 + a2 * this.visibleI;
        this.isFunnel && (r2 -= (this.barHelpers.getXForValue(this.series[d2][g2], r2) - r2) / 2), o2 = this.barHelpers.getXForValue(this.series[d2][g2], r2);
        var f2 = this.barHelpers.getBarpaths({ barYPosition: e2, barHeight: a2, x1: r2, x2: o2, strokeWidth: s2, series: this.series, realIndex: i2.realIndex, i: d2, j: g2, w: c2 });
        return c2.globals.isXNumeric || (n2 += l2), this.barHelpers.barBackground({ j: g2, i: d2, y1: e2 - a2 * this.visibleI, y2: a2 * this.seriesLen, elSeries: h2 }), { pathTo: f2.pathTo, pathFrom: f2.pathFrom, x1: r2, x: o2, y: n2, goalX: this.barHelpers.getGoalValues("x", r2, null, d2, g2), barYPosition: e2, barHeight: a2 };
      } }, { key: "drawColumnPaths", value: function(t3) {
        var e2, i2 = t3.indexes, a2 = t3.x, s2 = t3.y, r2 = t3.xDivision, o2 = t3.barWidth, n2 = t3.zeroH, l2 = t3.strokeWidth, h2 = t3.elSeries, c2 = this.w, d2 = i2.realIndex, g2 = i2.i, u5 = i2.j, p2 = i2.bc;
        if (c2.globals.isXNumeric) {
          var f2 = this.getBarXForNumericXAxis({ x: a2, j: u5, realIndex: d2, barWidth: o2 });
          a2 = f2.x, e2 = f2.barXPosition;
        } else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
          var x2 = this.barHelpers.getZeroValueEncounters({ i: g2, j: u5 }), b2 = x2.nonZeroColumns, v2 = x2.zeroEncounters;
          b2 > 0 && (o2 = this.seriesLen * o2 / b2), e2 = a2 + o2 * this.visibleI, e2 -= o2 * v2;
        } else
          e2 = a2 + o2 * this.visibleI;
        s2 = this.barHelpers.getYForValue(this.series[g2][u5], n2);
        var m2 = this.barHelpers.getColumnPaths({ barXPosition: e2, barWidth: o2, y1: n2, y2: s2, strokeWidth: l2, series: this.series, realIndex: i2.realIndex, i: g2, j: u5, w: c2 });
        return c2.globals.isXNumeric || (a2 += r2), this.barHelpers.barBackground({ bc: p2, j: u5, i: g2, x1: e2 - l2 / 2 - o2 * this.visibleI, x2: o2 * this.seriesLen + l2 / 2, elSeries: h2 }), { pathTo: m2.pathTo, pathFrom: m2.pathFrom, x: a2, y: s2, goalY: this.barHelpers.getGoalValues("y", null, n2, g2, u5), barXPosition: e2, barWidth: o2 };
      } }, { key: "getBarXForNumericXAxis", value: function(t3) {
        var e2 = t3.x, i2 = t3.barWidth, a2 = t3.realIndex, s2 = t3.j, r2 = this.w, o2 = a2;
        return r2.globals.seriesX[a2].length || (o2 = r2.globals.maxValsInArrayIndex), r2.globals.seriesX[o2][s2] && (e2 = (r2.globals.seriesX[o2][s2] - r2.globals.minX) / this.xRatio - i2 * this.seriesLen / 2), { barXPosition: e2 + i2 * this.visibleI, x: e2 };
      } }, { key: "getPreviousPath", value: function(t3, e2) {
        for (var i2, a2 = this.w, s2 = 0; s2 < a2.globals.previousPaths.length; s2++) {
          var r2 = a2.globals.previousPaths[s2];
          r2.paths && r2.paths.length > 0 && parseInt(r2.realIndex, 10) === parseInt(t3, 10) && void 0 !== a2.globals.previousPaths[s2].paths[e2] && (i2 = a2.globals.previousPaths[s2].paths[e2].d);
        }
        return i2;
      } }]), t2;
    }();
    var wt = function(t2) {
      n(s2, yt);
      var i2 = d(s2);
      function s2() {
        return a(this, s2), i2.apply(this, arguments);
      }
      return r(s2, [{ key: "draw", value: function(t3, i3) {
        var a2 = this, s3 = this.w;
        this.graphics = new m(this.ctx), this.bar = new yt(this.ctx, this.xyRatios);
        var r2 = new y(this.ctx, s3);
        t3 = r2.getLogSeries(t3), this.yRatio = r2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3), "100%" === s3.config.chart.stackType && (t3 = s3.globals.seriesPercent.slice()), this.series = t3, this.barHelpers.initializeStackedPrevVars(this);
        for (var o2 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n2 = 0, l2 = 0, h2 = function(r3, h3) {
          var c3 = void 0, d3 = void 0, g2 = void 0, u5 = void 0, p2 = -1;
          a2.groupCtx = a2, s3.globals.seriesGroups.forEach(function(t4, e2) {
            t4.indexOf(s3.config.series[r3].name) > -1 && (p2 = e2);
          }), -1 !== p2 && (a2.groupCtx = a2[s3.globals.seriesGroups[p2]]);
          var f2 = [], b2 = [], v2 = s3.globals.comboCharts ? i3[r3] : r3;
          a2.yRatio.length > 1 && (a2.yaxisIndex = v2), a2.isReversed = s3.config.yaxis[a2.yaxisIndex] && s3.config.yaxis[a2.yaxisIndex].reversed;
          var m2 = a2.graphics.group({ class: "apexcharts-series", seriesName: x.escapeString(s3.globals.seriesNames[v2]), rel: r3 + 1, "data:realIndex": v2 });
          a2.ctx.series.addCollapsedClassToSeries(m2, v2);
          var y2 = a2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": v2 }), w2 = a2.graphics.group({ class: "apexcharts-bar-goals-markers" }), k2 = 0, A2 = 0, S2 = a2.initialPositions(n2, l2, c3, d3, g2, u5);
          l2 = S2.y, k2 = S2.barHeight, d3 = S2.yDivision, u5 = S2.zeroW, n2 = S2.x, A2 = S2.barWidth, c3 = S2.xDivision, g2 = S2.zeroH, s3.globals.barHeight = k2, s3.globals.barWidth = A2, a2.barHelpers.initializeStackedXYVars(a2), 1 === a2.groupCtx.prevY.length && a2.groupCtx.prevY[0].every(function(t4) {
            return isNaN(t4);
          }) && (a2.groupCtx.prevY[0] = a2.groupCtx.prevY[0].map(function(t4) {
            return g2;
          }), a2.groupCtx.prevYF[0] = a2.groupCtx.prevYF[0].map(function(t4) {
            return 0;
          }));
          for (var C2 = 0; C2 < s3.globals.dataPoints; C2++) {
            var L2 = a2.barHelpers.getStrokeWidth(r3, C2, v2), P2 = { indexes: { i: r3, j: C2, realIndex: v2, bc: h3 }, strokeWidth: L2, x: n2, y: l2, elSeries: m2, groupIndex: p2, seriesGroup: s3.globals.seriesGroups[p2] }, I2 = null;
            a2.isHorizontal ? (I2 = a2.drawStackedBarPaths(e(e({}, P2), {}, { zeroW: u5, barHeight: k2, yDivision: d3 })), A2 = a2.series[r3][C2] / a2.invertedYRatio) : (I2 = a2.drawStackedColumnPaths(e(e({}, P2), {}, { xDivision: c3, barWidth: A2, zeroH: g2 })), k2 = a2.series[r3][C2] / a2.yRatio[a2.yaxisIndex]);
            var T2 = a2.barHelpers.drawGoalLine({ barXPosition: I2.barXPosition, barYPosition: I2.barYPosition, goalX: I2.goalX, goalY: I2.goalY, barHeight: k2, barWidth: A2 });
            T2 && w2.add(T2), l2 = I2.y, n2 = I2.x, f2.push(n2), b2.push(l2);
            var M2 = a2.barHelpers.getPathFillColor(t3, r3, C2, v2);
            m2 = a2.renderSeries({ realIndex: v2, pathFill: M2, j: C2, i: r3, groupIndex: p2, pathFrom: I2.pathFrom, pathTo: I2.pathTo, strokeWidth: L2, elSeries: m2, x: n2, y: l2, series: t3, barHeight: k2, barWidth: A2, elDataLabelsWrap: y2, elGoalsMarkers: w2, type: "bar", visibleSeries: 0 });
          }
          s3.globals.seriesXvalues[v2] = f2, s3.globals.seriesYvalues[v2] = b2, a2.groupCtx.prevY.push(a2.groupCtx.yArrj), a2.groupCtx.prevYF.push(a2.groupCtx.yArrjF), a2.groupCtx.prevYVal.push(a2.groupCtx.yArrjVal), a2.groupCtx.prevX.push(a2.groupCtx.xArrj), a2.groupCtx.prevXF.push(a2.groupCtx.xArrjF), a2.groupCtx.prevXVal.push(a2.groupCtx.xArrjVal), o2.add(m2);
        }, c2 = 0, d2 = 0; c2 < t3.length; c2++, d2++)
          h2(c2, d2);
        return o2;
      } }, { key: "initialPositions", value: function(t3, e2, i3, a2, s3, r2) {
        var o2, n2, l2, h2, c2 = this.w;
        return this.isHorizontal ? (l2 = (l2 = a2 = c2.globals.gridHeight / c2.globals.dataPoints) * parseInt(c2.config.plotOptions.bar.barHeight, 10) / 100, -1 === String(c2.config.plotOptions.bar.barHeight).indexOf("%") && (l2 = parseInt(c2.config.plotOptions.bar.barHeight, 10)), r2 = this.baseLineInvertedY + c2.globals.padHorizontal + (this.isReversed ? c2.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e2 = (a2 - l2) / 2) : (h2 = i3 = c2.globals.gridWidth / c2.globals.dataPoints, h2 = c2.globals.isXNumeric && c2.globals.dataPoints > 1 ? (i3 = c2.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : h2 * parseInt(c2.config.plotOptions.bar.columnWidth, 10) / 100, -1 === String(c2.config.plotOptions.bar.columnWidth).indexOf("%") && (h2 = parseInt(c2.config.plotOptions.bar.columnWidth, 10)), s3 = c2.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? c2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t3 = c2.globals.padHorizontal + (i3 - h2) / 2), { x: t3, y: e2, yDivision: a2, xDivision: i3, barHeight: null !== (o2 = c2.globals.seriesGroups) && void 0 !== o2 && o2.length ? l2 / c2.globals.seriesGroups.length : l2, barWidth: null !== (n2 = c2.globals.seriesGroups) && void 0 !== n2 && n2.length ? h2 / c2.globals.seriesGroups.length : h2, zeroH: s3, zeroW: r2 };
      } }, { key: "drawStackedBarPaths", value: function(t3) {
        for (var e2, i3 = t3.indexes, a2 = t3.barHeight, s3 = t3.strokeWidth, r2 = t3.zeroW, o2 = t3.x, n2 = t3.y, l2 = t3.groupIndex, h2 = t3.seriesGroup, c2 = t3.yDivision, d2 = t3.elSeries, g2 = this.w, u5 = n2 + (-1 !== l2 ? l2 * a2 : 0), p2 = i3.i, f2 = i3.j, x2 = 0, b2 = 0; b2 < this.groupCtx.prevXF.length; b2++)
          x2 += this.groupCtx.prevXF[b2][f2];
        var v2 = p2;
        if (h2 && (v2 = h2.indexOf(g2.config.series[p2].name)), v2 > 0) {
          var m2 = r2;
          this.groupCtx.prevXVal[v2 - 1][f2] < 0 ? m2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[v2 - 1][f2] + x2 - 2 * (this.isReversed ? x2 : 0) : this.groupCtx.prevX[v2 - 1][f2] : this.groupCtx.prevXVal[v2 - 1][f2] >= 0 && (m2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[v2 - 1][f2] : this.groupCtx.prevX[v2 - 1][f2] - x2 + 2 * (this.isReversed ? x2 : 0)), e2 = m2;
        } else
          e2 = r2;
        o2 = null === this.series[p2][f2] ? e2 : e2 + this.series[p2][f2] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p2][f2] / this.invertedYRatio : 0);
        var y2 = this.barHelpers.getBarpaths({ barYPosition: u5, barHeight: a2, x1: e2, x2: o2, strokeWidth: s3, series: this.series, realIndex: i3.realIndex, seriesGroup: h2, i: p2, j: f2, w: g2 });
        return this.barHelpers.barBackground({ j: f2, i: p2, y1: u5, y2: a2, elSeries: d2 }), n2 += c2, { pathTo: y2.pathTo, pathFrom: y2.pathFrom, goalX: this.barHelpers.getGoalValues("x", r2, null, p2, f2), barYPosition: u5, x: o2, y: n2 };
      } }, { key: "drawStackedColumnPaths", value: function(t3) {
        var e2 = t3.indexes, i3 = t3.x, a2 = t3.y, s3 = t3.xDivision, r2 = t3.barWidth, o2 = t3.zeroH, n2 = t3.groupIndex, l2 = t3.seriesGroup, h2 = t3.elSeries, c2 = this.w, d2 = e2.i, g2 = e2.j, u5 = e2.bc;
        if (c2.globals.isXNumeric) {
          var p2 = c2.globals.seriesX[d2][g2];
          p2 || (p2 = 0), i3 = (p2 - c2.globals.minX) / this.xRatio - r2 / 2, c2.globals.seriesGroups.length && (i3 = (p2 - c2.globals.minX) / this.xRatio - r2 / 2 * c2.globals.seriesGroups.length);
        }
        for (var f2, x2 = i3 + (-1 !== n2 ? n2 * r2 : 0), b2 = 0, v2 = 0; v2 < this.groupCtx.prevYF.length; v2++)
          b2 += isNaN(this.groupCtx.prevYF[v2][g2]) ? 0 : this.groupCtx.prevYF[v2][g2];
        var m2 = d2;
        if (l2 && (m2 = l2.indexOf(c2.config.series[d2].name)), m2 > 0 && !c2.globals.isXNumeric || m2 > 0 && c2.globals.isXNumeric && c2.globals.seriesX[d2 - 1][g2] === c2.globals.seriesX[d2][g2]) {
          var y2, w2, k2, A2 = Math.min(this.yRatio.length + 1, d2 + 1);
          if (void 0 !== this.groupCtx.prevY[m2 - 1] && this.groupCtx.prevY[m2 - 1].length)
            for (var S2 = 1; S2 < A2; S2++) {
              var C2;
              if (!isNaN(null === (C2 = this.groupCtx.prevY[m2 - S2]) || void 0 === C2 ? void 0 : C2[g2])) {
                k2 = this.groupCtx.prevY[m2 - S2][g2];
                break;
              }
            }
          for (var L2 = 1; L2 < A2; L2++) {
            var P2, I2;
            if ((null === (P2 = this.groupCtx.prevYVal[m2 - L2]) || void 0 === P2 ? void 0 : P2[g2]) < 0) {
              w2 = this.series[d2][g2] >= 0 ? k2 - b2 + 2 * (this.isReversed ? b2 : 0) : k2;
              break;
            }
            if ((null === (I2 = this.groupCtx.prevYVal[m2 - L2]) || void 0 === I2 ? void 0 : I2[g2]) >= 0) {
              w2 = this.series[d2][g2] >= 0 ? k2 : k2 + b2 - 2 * (this.isReversed ? b2 : 0);
              break;
            }
          }
          void 0 === w2 && (w2 = c2.globals.gridHeight), f2 = null !== (y2 = this.groupCtx.prevYF[0]) && void 0 !== y2 && y2.every(function(t4) {
            return 0 === t4;
          }) && this.groupCtx.prevYF.slice(1, m2).every(function(t4) {
            return t4.every(function(t5) {
              return isNaN(t5);
            });
          }) ? o2 : w2;
        } else
          f2 = o2;
        a2 = this.series[d2][g2] ? f2 - this.series[d2][g2] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[d2][g2] / this.yRatio[this.yaxisIndex] : 0) : f2;
        var T2 = this.barHelpers.getColumnPaths({ barXPosition: x2, barWidth: r2, y1: f2, y2: a2, yRatio: this.yRatio[this.yaxisIndex], strokeWidth: this.strokeWidth, series: this.series, seriesGroup: l2, realIndex: e2.realIndex, i: d2, j: g2, w: c2 });
        return this.barHelpers.barBackground({ bc: u5, j: g2, i: d2, x1: x2, x2: r2, elSeries: h2 }), i3 += s3, { pathTo: T2.pathTo, pathFrom: T2.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, o2, d2, g2), barXPosition: x2, x: c2.globals.isXNumeric ? i3 - s3 : i3, y: a2 };
      } }]), s2;
    }();
    var kt = function(t2) {
      n(s2, yt);
      var i2 = d(s2);
      function s2() {
        return a(this, s2), i2.apply(this, arguments);
      }
      return r(s2, [{ key: "draw", value: function(t3, i3, a2) {
        var s3 = this, r2 = this.w, o2 = new m(this.ctx), n2 = r2.globals.comboCharts ? i3 : r2.config.chart.type, l2 = new R(this.ctx);
        this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = r2.config.plotOptions.bar.horizontal;
        var h2 = new y(this.ctx, r2);
        t3 = h2.getLogSeries(t3), this.series = t3, this.yRatio = h2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
        for (var c2 = o2.group({ class: "apexcharts-".concat(n2, "-series apexcharts-plot-series") }), d2 = function(i4) {
          s3.isBoxPlot = "boxPlot" === r2.config.chart.type || "boxPlot" === r2.config.series[i4].type;
          var n3, h3, d3, g3, u5 = void 0, p2 = void 0, f2 = [], b2 = [], v2 = r2.globals.comboCharts ? a2[i4] : i4, m2 = o2.group({ class: "apexcharts-series", seriesName: x.escapeString(r2.globals.seriesNames[v2]), rel: i4 + 1, "data:realIndex": v2 });
          s3.ctx.series.addCollapsedClassToSeries(m2, v2), t3[i4].length > 0 && (s3.visibleI = s3.visibleI + 1);
          var y2, w2;
          s3.yRatio.length > 1 && (s3.yaxisIndex = v2);
          var k2 = s3.barHelpers.initialPositions();
          p2 = k2.y, y2 = k2.barHeight, h3 = k2.yDivision, g3 = k2.zeroW, u5 = k2.x, w2 = k2.barWidth, n3 = k2.xDivision, d3 = k2.zeroH, b2.push(u5 + w2 / 2);
          for (var A2 = o2.group({ class: "apexcharts-datalabels", "data:realIndex": v2 }), S2 = function(a3) {
            var o3 = s3.barHelpers.getStrokeWidth(i4, a3, v2), c3 = null, x2 = { indexes: { i: i4, j: a3, realIndex: v2 }, x: u5, y: p2, strokeWidth: o3, elSeries: m2 };
            c3 = s3.isHorizontal ? s3.drawHorizontalBoxPaths(e(e({}, x2), {}, { yDivision: h3, barHeight: y2, zeroW: g3 })) : s3.drawVerticalBoxPaths(e(e({}, x2), {}, { xDivision: n3, barWidth: w2, zeroH: d3 })), p2 = c3.y, u5 = c3.x, a3 > 0 && b2.push(u5 + w2 / 2), f2.push(p2), c3.pathTo.forEach(function(e2, n4) {
              var h4 = !s3.isBoxPlot && s3.candlestickOptions.wick.useFillColor ? c3.color[n4] : r2.globals.stroke.colors[i4], d4 = l2.fillPath({ seriesNumber: v2, dataPointIndex: a3, color: c3.color[n4], value: t3[i4][a3] });
              s3.renderSeries({ realIndex: v2, pathFill: d4, lineFill: h4, j: a3, i: i4, pathFrom: c3.pathFrom, pathTo: e2, strokeWidth: o3, elSeries: m2, x: u5, y: p2, series: t3, barHeight: y2, barWidth: w2, elDataLabelsWrap: A2, visibleSeries: s3.visibleI, type: r2.config.chart.type });
            });
          }, C2 = 0; C2 < r2.globals.dataPoints; C2++)
            S2(C2);
          r2.globals.seriesXvalues[v2] = b2, r2.globals.seriesYvalues[v2] = f2, c2.add(m2);
        }, g2 = 0; g2 < t3.length; g2++)
          d2(g2);
        return c2;
      } }, { key: "drawVerticalBoxPaths", value: function(t3) {
        var e2 = t3.indexes, i3 = t3.x;
        t3.y;
        var a2 = t3.xDivision, s3 = t3.barWidth, r2 = t3.zeroH, o2 = t3.strokeWidth, n2 = this.w, l2 = new m(this.ctx), h2 = e2.i, c2 = e2.j, d2 = true, g2 = n2.config.plotOptions.candlestick.colors.upward, u5 = n2.config.plotOptions.candlestick.colors.downward, p2 = "";
        this.isBoxPlot && (p2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
        var f2 = this.yRatio[this.yaxisIndex], x2 = e2.realIndex, b2 = this.getOHLCValue(x2, c2), v2 = r2, y2 = r2;
        b2.o > b2.c && (d2 = false);
        var w2 = Math.min(b2.o, b2.c), k2 = Math.max(b2.o, b2.c), A2 = b2.m;
        n2.globals.isXNumeric && (i3 = (n2.globals.seriesX[x2][c2] - n2.globals.minX) / this.xRatio - s3 / 2);
        var S2 = i3 + s3 * this.visibleI;
        void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (w2 = r2, k2 = r2) : (w2 = r2 - w2 / f2, k2 = r2 - k2 / f2, v2 = r2 - b2.h / f2, y2 = r2 - b2.l / f2, A2 = r2 - b2.m / f2);
        var C2 = l2.move(S2, r2), L2 = l2.move(S2 + s3 / 2, w2);
        return n2.globals.previousPaths.length > 0 && (L2 = this.getPreviousPath(x2, c2, true)), C2 = this.isBoxPlot ? [l2.move(S2, w2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 4, v2) + l2.line(S2 + s3 - s3 / 4, v2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3, w2) + l2.line(S2 + s3, A2) + l2.line(S2, A2) + l2.line(S2, w2 + o2 / 2), l2.move(S2, A2) + l2.line(S2 + s3, A2) + l2.line(S2 + s3, k2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 - s3 / 4, y2) + l2.line(S2 + s3 / 4, y2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2, k2) + l2.line(S2, A2) + "z"] : [l2.move(S2, k2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3, k2) + l2.line(S2 + s3, w2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2, w2) + l2.line(S2, k2 - o2 / 2)], L2 += l2.move(S2, w2), n2.globals.isXNumeric || (i3 += a2), { pathTo: C2, pathFrom: L2, x: i3, y: k2, barXPosition: S2, color: this.isBoxPlot ? p2 : d2 ? [g2] : [u5] };
      } }, { key: "drawHorizontalBoxPaths", value: function(t3) {
        var e2 = t3.indexes;
        t3.x;
        var i3 = t3.y, a2 = t3.yDivision, s3 = t3.barHeight, r2 = t3.zeroW, o2 = t3.strokeWidth, n2 = this.w, l2 = new m(this.ctx), h2 = e2.i, c2 = e2.j, d2 = this.boxOptions.colors.lower;
        this.isBoxPlot && (d2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
        var g2 = this.invertedYRatio, u5 = e2.realIndex, p2 = this.getOHLCValue(u5, c2), f2 = r2, x2 = r2, b2 = Math.min(p2.o, p2.c), v2 = Math.max(p2.o, p2.c), y2 = p2.m;
        n2.globals.isXNumeric && (i3 = (n2.globals.seriesX[u5][c2] - n2.globals.minX) / this.invertedXRatio - s3 / 2);
        var w2 = i3 + s3 * this.visibleI;
        void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (b2 = r2, v2 = r2) : (b2 = r2 + b2 / g2, v2 = r2 + v2 / g2, f2 = r2 + p2.h / g2, x2 = r2 + p2.l / g2, y2 = r2 + p2.m / g2);
        var k2 = l2.move(r2, w2), A2 = l2.move(b2, w2 + s3 / 2);
        return n2.globals.previousPaths.length > 0 && (A2 = this.getPreviousPath(u5, c2, true)), k2 = [l2.move(b2, w2) + l2.line(b2, w2 + s3 / 2) + l2.line(f2, w2 + s3 / 2) + l2.line(f2, w2 + s3 / 2 - s3 / 4) + l2.line(f2, w2 + s3 / 2 + s3 / 4) + l2.line(f2, w2 + s3 / 2) + l2.line(b2, w2 + s3 / 2) + l2.line(b2, w2 + s3) + l2.line(y2, w2 + s3) + l2.line(y2, w2) + l2.line(b2 + o2 / 2, w2), l2.move(y2, w2) + l2.line(y2, w2 + s3) + l2.line(v2, w2 + s3) + l2.line(v2, w2 + s3 / 2) + l2.line(x2, w2 + s3 / 2) + l2.line(x2, w2 + s3 - s3 / 4) + l2.line(x2, w2 + s3 / 4) + l2.line(x2, w2 + s3 / 2) + l2.line(v2, w2 + s3 / 2) + l2.line(v2, w2) + l2.line(y2, w2) + "z"], A2 += l2.move(b2, w2), n2.globals.isXNumeric || (i3 += a2), { pathTo: k2, pathFrom: A2, x: v2, y: i3, barYPosition: w2, color: d2 };
      } }, { key: "getOHLCValue", value: function(t3, e2) {
        var i3 = this.w;
        return { o: this.isBoxPlot ? i3.globals.seriesCandleH[t3][e2] : i3.globals.seriesCandleO[t3][e2], h: this.isBoxPlot ? i3.globals.seriesCandleO[t3][e2] : i3.globals.seriesCandleH[t3][e2], m: i3.globals.seriesCandleM[t3][e2], l: this.isBoxPlot ? i3.globals.seriesCandleC[t3][e2] : i3.globals.seriesCandleL[t3][e2], c: this.isBoxPlot ? i3.globals.seriesCandleL[t3][e2] : i3.globals.seriesCandleC[t3][e2] };
      } }]), s2;
    }();
    var At = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "checkColorRange", value: function() {
        var t3 = this.w, e2 = false, i2 = t3.config.plotOptions[t3.config.chart.type];
        return i2.colorScale.ranges.length > 0 && i2.colorScale.ranges.map(function(t4, i3) {
          t4.from <= 0 && (e2 = true);
        }), e2;
      } }, { key: "getShadeColor", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = 1, o2 = s2.config.plotOptions[t3].shadeIntensity, n2 = this.determineColor(t3, e2, i2);
        s2.globals.hasNegs || a2 ? r2 = s2.config.plotOptions[t3].reverseNegativeShade ? n2.percent < 0 ? n2.percent / 100 * (1.25 * o2) : (1 - n2.percent / 100) * (1.25 * o2) : n2.percent <= 0 ? 1 - (1 + n2.percent / 100) * o2 : (1 - n2.percent / 100) * o2 : (r2 = 1 - n2.percent / 100, "treemap" === t3 && (r2 = (1 - n2.percent / 100) * (1.25 * o2)));
        var l2 = n2.color, h2 = new x();
        return s2.config.plotOptions[t3].enableShades && (l2 = "dark" === this.w.config.theme.mode ? x.hexToRgba(h2.shadeColor(-1 * r2, n2.color), s2.config.fill.opacity) : x.hexToRgba(h2.shadeColor(r2, n2.color), s2.config.fill.opacity)), { color: l2, colorProps: n2 };
      } }, { key: "determineColor", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = a2.globals.series[e2][i2], r2 = a2.config.plotOptions[t3], o2 = r2.colorScale.inverse ? i2 : e2;
        r2.distributed && "treemap" === a2.config.chart.type && (o2 = i2);
        var n2 = a2.globals.colors[o2], l2 = null, h2 = Math.min.apply(Math, u4(a2.globals.series[e2])), c2 = Math.max.apply(Math, u4(a2.globals.series[e2]));
        r2.distributed || "heatmap" !== t3 || (h2 = a2.globals.minY, c2 = a2.globals.maxY), void 0 !== r2.colorScale.min && (h2 = r2.colorScale.min < a2.globals.minY ? r2.colorScale.min : a2.globals.minY, c2 = r2.colorScale.max > a2.globals.maxY ? r2.colorScale.max : a2.globals.maxY);
        var d2 = Math.abs(c2) + Math.abs(h2), g2 = 100 * s2 / (0 === d2 ? d2 - 1e-6 : d2);
        r2.colorScale.ranges.length > 0 && r2.colorScale.ranges.map(function(t4, e3) {
          if (s2 >= t4.from && s2 <= t4.to) {
            n2 = t4.color, l2 = t4.foreColor ? t4.foreColor : null, h2 = t4.from, c2 = t4.to;
            var i3 = Math.abs(c2) + Math.abs(h2);
            g2 = 100 * s2 / (0 === i3 ? i3 - 1e-6 : i3);
          }
        });
        return { color: n2, foreColor: l2, percent: g2 };
      } }, { key: "calculateDataLabels", value: function(t3) {
        var e2 = t3.text, i2 = t3.x, a2 = t3.y, s2 = t3.i, r2 = t3.j, o2 = t3.colorProps, n2 = t3.fontSize, l2 = this.w.config.dataLabels, h2 = new m(this.ctx), c2 = new O(this.ctx), d2 = null;
        if (l2.enabled) {
          d2 = h2.group({ class: "apexcharts-data-labels" });
          var g2 = l2.offsetX, u5 = l2.offsetY, p2 = i2 + g2, f2 = a2 + parseFloat(l2.style.fontSize) / 3 + u5;
          c2.plotDataLabelsText({ x: p2, y: f2, text: e2, i: s2, j: r2, color: o2.foreColor, parent: d2, fontSize: n2, dataLabelsConfig: l2 });
        }
        return d2;
      } }, { key: "addListeners", value: function(t3) {
        var e2 = new m(this.ctx);
        t3.node.addEventListener("mouseenter", e2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", e2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mousedown", e2.pathMouseDown.bind(this, t3));
      } }]), t2;
    }();
    var St = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.xRatio = i2.xRatio, this.yRatio = i2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new At(e2), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
      }
      return r(t2, [{ key: "draw", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx), a2 = i2.group({ class: "apexcharts-heatmap" });
        a2.attr("clip-path", "url(#gridRectMask".concat(e2.globals.cuid, ")"));
        var s2 = e2.globals.gridWidth / e2.globals.dataPoints, r2 = e2.globals.gridHeight / e2.globals.series.length, o2 = 0, n2 = false;
        this.negRange = this.helpers.checkColorRange();
        var l2 = t3.slice();
        e2.config.yaxis[0].reversed && (n2 = true, l2.reverse());
        for (var h2 = n2 ? 0 : l2.length - 1; n2 ? h2 < l2.length : h2 >= 0; n2 ? h2++ : h2--) {
          var c2 = i2.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: x.escapeString(e2.globals.seriesNames[h2]), rel: h2 + 1, "data:realIndex": h2 });
          if (this.ctx.series.addCollapsedClassToSeries(c2, h2), e2.config.chart.dropShadow.enabled) {
            var d2 = e2.config.chart.dropShadow;
            new v(this.ctx).dropShadow(c2, d2, h2);
          }
          for (var g2 = 0, u5 = e2.config.plotOptions.heatmap.shadeIntensity, p2 = 0; p2 < l2[h2].length; p2++) {
            var f2 = this.helpers.getShadeColor(e2.config.chart.type, h2, p2, this.negRange), b2 = f2.color, y2 = f2.colorProps;
            if ("image" === e2.config.fill.type)
              b2 = new R(this.ctx).fillPath({ seriesNumber: h2, dataPointIndex: p2, opacity: e2.globals.hasNegs ? y2.percent < 0 ? 1 - (1 + y2.percent / 100) : u5 + y2.percent / 100 : y2.percent / 100, patternID: x.randomId(), width: e2.config.fill.image.width ? e2.config.fill.image.width : s2, height: e2.config.fill.image.height ? e2.config.fill.image.height : r2 });
            var w2 = this.rectRadius, k2 = i2.drawRect(g2, o2, s2, r2, w2);
            if (k2.attr({ cx: g2, cy: o2 }), k2.node.classList.add("apexcharts-heatmap-rect"), c2.add(k2), k2.attr({ fill: b2, i: h2, index: h2, j: p2, val: t3[h2][p2], "stroke-width": this.strokeWidth, stroke: e2.config.plotOptions.heatmap.useFillColorAsStroke ? b2 : e2.globals.stroke.colors[0], color: b2 }), this.helpers.addListeners(k2), e2.config.chart.animations.enabled && !e2.globals.dataChanged) {
              var A2 = 1;
              e2.globals.resized || (A2 = e2.config.chart.animations.speed), this.animateHeatMap(k2, g2, o2, s2, r2, A2);
            }
            if (e2.globals.dataChanged) {
              var S2 = 1;
              if (this.dynamicAnim.enabled && e2.globals.shouldAnimate) {
                S2 = this.dynamicAnim.speed;
                var C2 = e2.globals.previousPaths[h2] && e2.globals.previousPaths[h2][p2] && e2.globals.previousPaths[h2][p2].color;
                C2 || (C2 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(k2, x.isColorHex(C2) ? C2 : x.rgb2hex(C2), x.isColorHex(b2) ? b2 : x.rgb2hex(b2), S2);
              }
            }
            var L2 = (0, e2.config.dataLabels.formatter)(e2.globals.series[h2][p2], { value: e2.globals.series[h2][p2], seriesIndex: h2, dataPointIndex: p2, w: e2 }), P2 = this.helpers.calculateDataLabels({ text: L2, x: g2 + s2 / 2, y: o2 + r2 / 2, i: h2, j: p2, colorProps: y2, series: l2 });
            null !== P2 && c2.add(P2), g2 += s2;
          }
          o2 += r2, a2.add(c2);
        }
        var I2 = e2.globals.yAxisScale[0].result.slice();
        return e2.config.yaxis[0].reversed ? I2.unshift("") : I2.push(""), e2.globals.yAxisScale[0].result = I2, a2;
      } }, { key: "animateHeatMap", value: function(t3, e2, i2, a2, s2, r2) {
        var o2 = new b(this.ctx);
        o2.animateRect(t3, { x: e2 + a2 / 2, y: i2 + s2 / 2, width: 0, height: 0 }, { x: e2, y: i2, width: a2, height: s2 }, r2, function() {
          o2.animationCompleted(t3);
        });
      } }, { key: "animateHeatColor", value: function(t3, e2, i2, a2) {
        t3.attr({ fill: e2 }).animate(a2).attr({ fill: i2 });
      } }]), t2;
    }();
    var Ct = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "drawYAxisTexts", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = s2.config.yaxis[0], o2 = s2.globals.yLabelFormatters[0];
        return new m(this.ctx).drawText({ x: t3 + r2.labels.offsetX, y: e2 + r2.labels.offsetY, text: o2(a2, i2), textAnchor: "middle", fontSize: r2.labels.style.fontSize, fontFamily: r2.labels.style.fontFamily, foreColor: Array.isArray(r2.labels.style.colors) ? r2.labels.style.colors[i2] : r2.labels.style.colors });
      } }]), t2;
    }();
    var Lt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var i2 = this.w;
        this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== i2.globals.stroke.colors ? i2.globals.stroke.colors : i2.globals.colors, this.defaultSize = Math.min(i2.globals.gridWidth, i2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = i2.globals.gridWidth / 2, "radialBar" === i2.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(i2.config.plotOptions.pie.endAngle - i2.config.plotOptions.pie.startAngle), this.initialAngle = i2.config.plotOptions.pie.startAngle % this.fullAngle, i2.globals.radialSize = this.defaultSize / 2.05 - i2.config.stroke.width - (i2.config.chart.sparkline.enabled ? 0 : i2.config.chart.dropShadow.blur), this.donutSize = i2.globals.radialSize * parseInt(i2.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
      }
      return r(t2, [{ key: "draw", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = new m(this.ctx);
        if (this.ret = a2.group({ class: "apexcharts-pie" }), i2.globals.noData)
          return this.ret;
        for (var s2 = 0, r2 = 0; r2 < t3.length; r2++)
          s2 += x.negToZero(t3[r2]);
        var o2 = [], n2 = a2.group();
        0 === s2 && (s2 = 1e-5), t3.forEach(function(t4) {
          e2.maxY = Math.max(e2.maxY, t4);
        }), i2.config.yaxis[0].max && (this.maxY = i2.config.yaxis[0].max), "back" === i2.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
        for (var l2 = 0; l2 < t3.length; l2++) {
          var h2 = this.fullAngle * x.negToZero(t3[l2]) / s2;
          o2.push(h2), "polarArea" === this.chartType ? (o2[l2] = this.fullAngle / t3.length, this.sliceSizes.push(i2.globals.radialSize * t3[l2] / this.maxY)) : this.sliceSizes.push(i2.globals.radialSize);
        }
        if (i2.globals.dataChanged) {
          for (var c2, d2 = 0, g2 = 0; g2 < i2.globals.previousPaths.length; g2++)
            d2 += x.negToZero(i2.globals.previousPaths[g2]);
          for (var u5 = 0; u5 < i2.globals.previousPaths.length; u5++)
            c2 = this.fullAngle * x.negToZero(i2.globals.previousPaths[u5]) / d2, this.prevSectorAngleArr.push(c2);
        }
        this.donutSize < 0 && (this.donutSize = 0);
        var p2 = i2.config.plotOptions.pie.customScale, f2 = i2.globals.gridWidth / 2, b2 = i2.globals.gridHeight / 2, v2 = f2 - i2.globals.gridWidth / 2 * p2, y2 = b2 - i2.globals.gridHeight / 2 * p2;
        if ("donut" === this.chartType) {
          var w2 = a2.drawCircle(this.donutSize);
          w2.attr({ cx: this.centerX, cy: this.centerY, fill: i2.config.plotOptions.pie.donut.background ? i2.config.plotOptions.pie.donut.background : "transparent" }), n2.add(w2);
        }
        var k2 = this.drawArcs(o2, t3);
        if (this.sliceLabels.forEach(function(t4) {
          k2.add(t4);
        }), n2.attr({ transform: "translate(".concat(v2, ", ").concat(y2, ") scale(").concat(p2, ")") }), n2.add(k2), this.ret.add(n2), this.donutDataLabels.show) {
          var A2 = this.renderInnerDataLabels(this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: v2, translateY: y2 });
          this.ret.add(A2);
        }
        return "front" === i2.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret), this.ret;
      } }, { key: "drawArcs", value: function(t3, e2) {
        var i2 = this.w, a2 = new v(this.ctx), s2 = new m(this.ctx), r2 = new R(this.ctx), o2 = s2.group({ class: "apexcharts-slices" }), n2 = this.initialAngle, l2 = this.initialAngle, h2 = this.initialAngle, c2 = this.initialAngle;
        this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0;
        for (var d2 = 0; d2 < t3.length; d2++) {
          var g2 = s2.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: x.escapeString(i2.globals.seriesNames[d2]), rel: d2 + 1, "data:realIndex": d2 });
          o2.add(g2), l2 = c2, h2 = (n2 = h2) + t3[d2], c2 = l2 + this.prevSectorAngleArr[d2];
          var u5 = h2 < n2 ? this.fullAngle + h2 - n2 : h2 - n2, p2 = r2.fillPath({ seriesNumber: d2, size: this.sliceSizes[d2], value: e2[d2] }), f2 = this.getChangedPath(l2, c2), b2 = s2.drawPath({ d: f2, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d2] : this.lineColorArr, strokeWidth: 0, fill: p2, fillOpacity: i2.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d2) });
          if (b2.attr({ index: 0, j: d2 }), a2.setSelectionFilter(b2, 0, d2), i2.config.chart.dropShadow.enabled) {
            var y2 = i2.config.chart.dropShadow;
            a2.dropShadow(b2, y2, d2);
          }
          this.addListeners(b2, this.donutDataLabels), m.setAttrs(b2.node, { "data:angle": u5, "data:startAngle": n2, "data:strokeWidth": this.strokeWidth, "data:value": e2[d2] });
          var w2 = { x: 0, y: 0 };
          "pie" === this.chartType || "polarArea" === this.chartType ? w2 = x.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize / 1.25 + i2.config.plotOptions.pie.dataLabels.offset, (n2 + u5 / 2) % this.fullAngle) : "donut" === this.chartType && (w2 = x.polarToCartesian(this.centerX, this.centerY, (i2.globals.radialSize + this.donutSize) / 2 + i2.config.plotOptions.pie.dataLabels.offset, (n2 + u5 / 2) % this.fullAngle)), g2.add(b2);
          var k2 = 0;
          if (!this.initialAnim || i2.globals.resized || i2.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (k2 = u5 / this.fullAngle * i2.config.chart.animations.speed) && (k2 = 1), this.animDur = k2 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i2.globals.dataChanged ? this.animatePaths(b2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: n2, prevStartAngle: l2, prevEndAngle: c2, animateStartingPos: true, i: d2, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i2.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(b2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: n2, i: d2, totalItems: t3.length - 1, animBeginArr: this.animBeginArr, dur: k2 }), i2.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && b2.click(this.pieClicked.bind(this, d2)), void 0 !== i2.globals.selectedDataPoints[0] && i2.globals.selectedDataPoints[0].indexOf(d2) > -1 && this.pieClicked(d2), i2.config.dataLabels.enabled) {
            var A2 = w2.x, S2 = w2.y, C2 = 100 * u5 / this.fullAngle + "%";
            if (0 !== u5 && i2.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t3[d2]) {
              var L2 = i2.config.dataLabels.formatter;
              void 0 !== L2 && (C2 = L2(i2.globals.seriesPercent[d2][0], { seriesIndex: d2, w: i2 }));
              var P2 = i2.globals.dataLabels.style.colors[d2], I2 = s2.group({ class: "apexcharts-datalabels" }), T2 = s2.drawText({ x: A2, y: S2, text: C2, textAnchor: "middle", fontSize: i2.config.dataLabels.style.fontSize, fontFamily: i2.config.dataLabels.style.fontFamily, fontWeight: i2.config.dataLabels.style.fontWeight, foreColor: P2 });
              if (I2.add(T2), i2.config.dataLabels.dropShadow.enabled) {
                var M2 = i2.config.dataLabels.dropShadow;
                a2.dropShadow(T2, M2);
              }
              T2.node.classList.add("apexcharts-pie-label"), i2.config.chart.animations.animate && false === i2.globals.resized && (T2.node.classList.add("apexcharts-pie-label-delay"), T2.node.style.animationDelay = i2.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(I2);
            }
          }
        }
        return o2;
      } }, { key: "addListeners", value: function(t3, e2) {
        var i2 = new m(this.ctx);
        t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this, t3)), this.donutDataLabels.total.showAlways || (t3.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t3.node, e2)));
      } }, { key: "animatePaths", value: function(t3, e2) {
        var i2 = this.w, a2 = e2.endAngle < e2.startAngle ? this.fullAngle + e2.endAngle - e2.startAngle : e2.endAngle - e2.startAngle, s2 = a2, r2 = e2.startAngle, o2 = e2.startAngle;
        void 0 !== e2.prevStartAngle && void 0 !== e2.prevEndAngle && (r2 = e2.prevEndAngle, s2 = e2.prevEndAngle < e2.prevStartAngle ? this.fullAngle + e2.prevEndAngle - e2.prevStartAngle : e2.prevEndAngle - e2.prevStartAngle), e2.i === i2.config.series.length - 1 && (a2 + o2 > this.fullAngle ? e2.endAngle = e2.endAngle - (a2 + o2) : a2 + o2 < this.fullAngle && (e2.endAngle = e2.endAngle + (this.fullAngle - (a2 + o2)))), a2 === this.fullAngle && (a2 = this.fullAngle - 0.01), this.animateArc(t3, r2, o2, a2, s2, e2);
      } }, { key: "animateArc", value: function(t3, e2, i2, a2, s2, r2) {
        var o2, n2 = this, l2 = this.w, h2 = new b(this.ctx), c2 = r2.size;
        (isNaN(e2) || isNaN(s2)) && (e2 = i2, s2 = a2, r2.dur = 0);
        var d2 = a2, g2 = i2, u5 = e2 < i2 ? this.fullAngle + e2 - i2 : e2 - i2;
        l2.globals.dataChanged && r2.shouldSetPrevPaths && r2.prevEndAngle && (o2 = n2.getPiePath({ me: n2, startAngle: r2.prevStartAngle, angle: r2.prevEndAngle < r2.prevStartAngle ? this.fullAngle + r2.prevEndAngle - r2.prevStartAngle : r2.prevEndAngle - r2.prevStartAngle, size: c2 }), t3.attr({ d: o2 })), 0 !== r2.dur ? t3.animate(r2.dur, l2.globals.easing, r2.animBeginArr[r2.i]).afterAll(function() {
          "pie" !== n2.chartType && "donut" !== n2.chartType && "polarArea" !== n2.chartType || this.animate(l2.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": n2.strokeWidth }), r2.i === l2.config.series.length - 1 && h2.animationCompleted(t3);
        }).during(function(l3) {
          d2 = u5 + (a2 - u5) * l3, r2.animateStartingPos && (d2 = s2 + (a2 - s2) * l3, g2 = e2 - s2 + (i2 - (e2 - s2)) * l3), o2 = n2.getPiePath({ me: n2, startAngle: g2, angle: d2, size: c2 }), t3.node.setAttribute("data:pathOrig", o2), t3.attr({ d: o2 });
        }) : (o2 = n2.getPiePath({ me: n2, startAngle: g2, angle: a2, size: c2 }), r2.isTrack || (l2.globals.animationEnded = true), t3.node.setAttribute("data:pathOrig", o2), t3.attr({ d: o2, "stroke-width": n2.strokeWidth }));
      } }, { key: "pieClicked", value: function(t3) {
        var e2, i2 = this.w, a2 = this, s2 = a2.sliceSizes[t3] + (i2.config.plotOptions.pie.expandOnClick ? 4 : 0), r2 = i2.globals.dom.Paper.select(".apexcharts-".concat(a2.chartType.toLowerCase(), "-slice-").concat(t3)).members[0];
        if ("true" !== r2.attr("data:pieClicked")) {
          var o2 = i2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
          Array.prototype.forEach.call(o2, function(t4) {
            t4.setAttribute("data:pieClicked", "false");
            var e3 = t4.getAttribute("data:pathOrig");
            e3 && t4.setAttribute("d", e3);
          }), r2.attr("data:pieClicked", "true");
          var n2 = parseInt(r2.attr("data:startAngle"), 10), l2 = parseInt(r2.attr("data:angle"), 10);
          e2 = a2.getPiePath({ me: a2, startAngle: n2, angle: l2, size: s2 }), 360 !== l2 && r2.plot(e2);
        } else {
          r2.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r2.node, this.donutDataLabels);
          var h2 = r2.attr("data:pathOrig");
          r2.attr({ d: h2 });
        }
      } }, { key: "getChangedPath", value: function(t3, e2) {
        var i2 = "";
        return this.dynamicAnim && this.w.globals.dataChanged && (i2 = this.getPiePath({ me: this, startAngle: t3, angle: e2 - t3, size: this.size })), i2;
      } }, { key: "getPiePath", value: function(t3) {
        var e2, i2 = t3.me, a2 = t3.startAngle, s2 = t3.angle, r2 = t3.size, o2 = new m(this.ctx), n2 = a2, l2 = Math.PI * (n2 - 90) / 180, h2 = s2 + a2;
        Math.ceil(h2) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h2 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h2) > this.fullAngle && (h2 -= this.fullAngle);
        var c2 = Math.PI * (h2 - 90) / 180, d2 = i2.centerX + r2 * Math.cos(l2), g2 = i2.centerY + r2 * Math.sin(l2), u5 = i2.centerX + r2 * Math.cos(c2), p2 = i2.centerY + r2 * Math.sin(c2), f2 = x.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, h2), b2 = x.polarToCartesian(i2.centerX, i2.centerY, i2.donutSize, n2), v2 = s2 > 180 ? 1 : 0, y2 = ["M", d2, g2, "A", r2, r2, 0, v2, 1, u5, p2];
        return e2 = "donut" === i2.chartType ? [].concat(y2, ["L", f2.x, f2.y, "A", i2.donutSize, i2.donutSize, 0, v2, 0, b2.x, b2.y, "L", d2, g2, "z"]).join(" ") : "pie" === i2.chartType || "polarArea" === i2.chartType ? [].concat(y2, ["L", i2.centerX, i2.centerY, "L", d2, g2]).join(" ") : [].concat(y2).join(" "), o2.roundPathCorners(e2, 2 * this.strokeWidth);
      } }, { key: "drawPolarElements", value: function(t3) {
        var e2 = this.w, i2 = new _(this.ctx), a2 = new m(this.ctx), s2 = new Ct(this.ctx), r2 = a2.group(), o2 = a2.group(), n2 = i2.niceScale(0, Math.ceil(this.maxY), e2.config.yaxis[0].tickAmount, 0, true), l2 = n2.result.reverse(), h2 = n2.result.length;
        this.maxY = n2.niceMax;
        for (var c2 = e2.globals.radialSize, d2 = c2 / (h2 - 1), g2 = 0; g2 < h2 - 1; g2++) {
          var u5 = a2.drawCircle(c2);
          if (u5.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e2.config.plotOptions.polarArea.rings.strokeWidth, stroke: e2.config.plotOptions.polarArea.rings.strokeColor }), e2.config.yaxis[0].show) {
            var p2 = s2.drawYAxisTexts(this.centerX, this.centerY - c2 + parseInt(e2.config.yaxis[0].labels.style.fontSize, 10) / 2, g2, l2[g2]);
            o2.add(p2);
          }
          r2.add(u5), c2 -= d2;
        }
        this.drawSpokes(t3), t3.add(r2), t3.add(o2);
      } }, { key: "renderInnerDataLabels", value: function(t3, e2) {
        var i2 = this.w, a2 = new m(this.ctx), s2 = a2.group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(e2.translateX ? e2.translateX : 0, ", ").concat(e2.translateY ? e2.translateY : 0, ") scale(").concat(i2.config.plotOptions.pie.customScale, ")") }), r2 = t3.total.show;
        s2.node.style.opacity = e2.opacity;
        var o2, n2, l2 = e2.centerX, h2 = e2.centerY;
        o2 = void 0 === t3.name.color ? i2.globals.colors[0] : t3.name.color;
        var c2 = t3.name.fontSize, d2 = t3.name.fontFamily, g2 = t3.name.fontWeight;
        n2 = void 0 === t3.value.color ? i2.config.chart.foreColor : t3.value.color;
        var u5 = t3.value.formatter, p2 = "", f2 = "";
        if (r2 ? (o2 = t3.total.color, c2 = t3.total.fontSize, d2 = t3.total.fontFamily, g2 = t3.total.fontWeight, f2 = t3.total.label, p2 = t3.total.formatter(i2)) : 1 === i2.globals.series.length && (p2 = u5(i2.globals.series[0], i2), f2 = i2.globals.seriesNames[0]), f2 && (f2 = t3.name.formatter(f2, t3.total.show, i2)), t3.name.show) {
          var x2 = a2.drawText({ x: l2, y: h2 + parseFloat(t3.name.offsetY), text: f2, textAnchor: "middle", foreColor: o2, fontSize: c2, fontWeight: g2, fontFamily: d2 });
          x2.node.classList.add("apexcharts-datalabel-label"), s2.add(x2);
        }
        if (t3.value.show) {
          var b2 = t3.name.show ? parseFloat(t3.value.offsetY) + 16 : t3.value.offsetY, v2 = a2.drawText({ x: l2, y: h2 + b2, text: p2, textAnchor: "middle", foreColor: n2, fontWeight: t3.value.fontWeight, fontSize: t3.value.fontSize, fontFamily: t3.value.fontFamily });
          v2.node.classList.add("apexcharts-datalabel-value"), s2.add(v2);
        }
        return s2;
      } }, { key: "printInnerLabels", value: function(t3, e2, i2, a2) {
        var s2, r2 = this.w;
        a2 ? s2 = void 0 === t3.name.color ? r2.globals.colors[parseInt(a2.parentNode.getAttribute("rel"), 10) - 1] : t3.name.color : r2.globals.series.length > 1 && t3.total.show && (s2 = t3.total.color);
        var o2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), n2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
        i2 = (0, t3.value.formatter)(i2, r2), a2 || "function" != typeof t3.total.formatter || (i2 = t3.total.formatter(r2));
        var l2 = e2 === t3.total.label;
        e2 = t3.name.formatter(e2, l2, r2), null !== o2 && (o2.textContent = e2), null !== n2 && (n2.textContent = i2), null !== o2 && (o2.style.fill = s2);
      } }, { key: "printDataLabelsInner", value: function(t3, e2) {
        var i2 = this.w, a2 = t3.getAttribute("data:value"), s2 = i2.globals.seriesNames[parseInt(t3.parentNode.getAttribute("rel"), 10) - 1];
        i2.globals.series.length > 1 && this.printInnerLabels(e2, s2, a2, t3);
        var r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
        null !== r2 && (r2.style.opacity = 1);
      } }, { key: "drawSpokes", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = i2.config.plotOptions.polarArea.spokes;
        if (0 !== s2.strokeWidth) {
          for (var r2 = [], o2 = 360 / i2.globals.series.length, n2 = 0; n2 < i2.globals.series.length; n2++)
            r2.push(x.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize, i2.config.plotOptions.pie.startAngle + o2 * n2));
          r2.forEach(function(i3, r3) {
            var o3 = a2.drawLine(i3.x, i3.y, e2.centerX, e2.centerY, Array.isArray(s2.connectorColors) ? s2.connectorColors[r3] : s2.connectorColors);
            t3.add(o3);
          });
        }
      } }, { key: "revertDataLabelsInner", value: function(t3, e2, i2) {
        var a2 = this, s2 = this.w, r2 = s2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"), o2 = false, n2 = s2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), l2 = function(t4) {
          var i3 = t4.makeSliceOut, s3 = t4.printLabel;
          Array.prototype.forEach.call(n2, function(t5) {
            "true" === t5.getAttribute("data:pieClicked") && (i3 && (o2 = true), s3 && a2.printDataLabelsInner(t5, e2));
          });
        };
        if (l2({ makeSliceOut: true, printLabel: false }), e2.total.show && s2.globals.series.length > 1)
          o2 && !e2.total.showAlways ? l2({ makeSliceOut: false, printLabel: true }) : this.printInnerLabels(e2, e2.total.label, e2.total.formatter(s2));
        else if (l2({ makeSliceOut: false, printLabel: true }), !o2)
          if (s2.globals.selectedDataPoints.length && s2.globals.series.length > 1)
            if (s2.globals.selectedDataPoints[0].length > 0) {
              var h2 = s2.globals.selectedDataPoints[0], c2 = s2.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(h2));
              this.printDataLabelsInner(c2, e2);
            } else
              r2 && s2.globals.selectedDataPoints.length && 0 === s2.globals.selectedDataPoints[0].length && (r2.style.opacity = 0);
          else
            r2 && s2.globals.series.length > 1 && (r2.style.opacity = 0);
      } }]), t2;
    }();
    var Pt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
        var i2 = this.w;
        this.graphics = new m(this.ctx), this.lineColorArr = void 0 !== i2.globals.stroke.colors ? i2.globals.stroke.colors : i2.globals.colors, this.defaultSize = i2.globals.svgHeight < i2.globals.svgWidth ? i2.globals.gridHeight + 1.5 * i2.globals.goldenPadding : i2.globals.gridWidth, this.isLog = i2.config.yaxis[0].logarithmic, this.coreUtils = new y(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(i2.globals.maxY, 0) : i2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : i2.globals.minY, this.polygons = i2.config.plotOptions.radar.polygons, this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - i2.config.chart.dropShadow.blur, i2.config.xaxis.labels.show && (this.size = this.size - i2.globals.xAxisLabelsWidth / 1.75), void 0 !== i2.config.plotOptions.radar.size && (this.size = i2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
      }
      return r(t2, [{ key: "draw", value: function(t3) {
        var i2 = this, a2 = this.w, s2 = new R(this.ctx), r2 = [], o2 = new O(this.ctx);
        t3.length && (this.dataPointsLen = t3[a2.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
        var n2 = a2.globals.gridWidth / 2, l2 = a2.globals.gridHeight / 2, h2 = n2 + a2.config.plotOptions.radar.offsetX, c2 = l2 + a2.config.plotOptions.radar.offsetY, d2 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(h2 || 0, ", ").concat(c2 || 0, ")") }), g2 = [], u5 = null, p2 = null;
        if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t3.forEach(function(t4, n3) {
          var l3 = t4.length === a2.globals.dataPoints, h3 = i2.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": l3, seriesName: x.escapeString(a2.globals.seriesNames[n3]), rel: n3 + 1, "data:realIndex": n3 });
          i2.dataRadiusOfPercent[n3] = [], i2.dataRadius[n3] = [], i2.angleArr[n3] = [], t4.forEach(function(t5, e2) {
            var a3 = Math.abs(i2.maxValue - i2.minValue);
            t5 += Math.abs(i2.minValue), i2.isLog && (t5 = i2.coreUtils.getLogVal(t5, 0)), i2.dataRadiusOfPercent[n3][e2] = t5 / a3, i2.dataRadius[n3][e2] = i2.dataRadiusOfPercent[n3][e2] * i2.size, i2.angleArr[n3][e2] = e2 * i2.disAngle;
          }), g2 = i2.getDataPointsPos(i2.dataRadius[n3], i2.angleArr[n3]);
          var c3 = i2.createPaths(g2, { x: 0, y: 0 });
          u5 = i2.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p2 = i2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": n3 }), a2.globals.delayedElements.push({ el: u5.node, index: n3 });
          var d3 = { i: n3, realIndex: n3, animationDelay: n3, initialSpeed: a2.config.chart.animations.speed, dataChangeSpeed: a2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: a2.globals.stroke.colors[n3], strokeLineCap: a2.config.stroke.lineCap }, f3 = null;
          a2.globals.previousPaths.length > 0 && (f3 = i2.getPreviousPath(n3));
          for (var b2 = 0; b2 < c3.linePathsTo.length; b2++) {
            var m2 = i2.graphics.renderPaths(e(e({}, d3), {}, { pathFrom: null === f3 ? c3.linePathsFrom[b2] : f3, pathTo: c3.linePathsTo[b2], strokeWidth: Array.isArray(i2.strokeWidth) ? i2.strokeWidth[n3] : i2.strokeWidth, fill: "none", drawShadow: false }));
            h3.add(m2);
            var y2 = s2.fillPath({ seriesNumber: n3 }), w2 = i2.graphics.renderPaths(e(e({}, d3), {}, { pathFrom: null === f3 ? c3.areaPathsFrom[b2] : f3, pathTo: c3.areaPathsTo[b2], strokeWidth: 0, fill: y2, drawShadow: false }));
            if (a2.config.chart.dropShadow.enabled) {
              var k2 = new v(i2.ctx), A2 = a2.config.chart.dropShadow;
              k2.dropShadow(w2, Object.assign({}, A2, { noUserSpaceOnUse: true }), n3);
            }
            h3.add(w2);
          }
          t4.forEach(function(t5, s3) {
            var r3 = new H(i2.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n3, dataPointIndex: s3 }), l4 = i2.graphics.drawMarker(g2[s3].x, g2[s3].y, r3);
            l4.attr("rel", s3), l4.attr("j", s3), l4.attr("index", n3), l4.node.setAttribute("default-marker-size", r3.pSize);
            var c4 = i2.graphics.group({ class: "apexcharts-series-markers" });
            c4 && c4.add(l4), u5.add(c4), h3.add(u5);
            var d4 = a2.config.dataLabels;
            if (d4.enabled) {
              var f4 = d4.formatter(a2.globals.series[n3][s3], { seriesIndex: n3, dataPointIndex: s3, w: a2 });
              o2.plotDataLabelsText({ x: g2[s3].x, y: g2[s3].y, text: f4, textAnchor: "middle", i: n3, j: n3, parent: p2, offsetCorrection: false, dataLabelsConfig: e({}, d4) });
            }
            h3.add(p2);
          }), r2.push(h3);
        }), this.drawPolygons({ parent: d2 }), a2.config.xaxis.labels.show) {
          var f2 = this.drawXAxisTexts();
          d2.add(f2);
        }
        return r2.forEach(function(t4) {
          d2.add(t4);
        }), d2.add(this.yaxisLabels), d2;
      } }, { key: "drawPolygons", value: function(t3) {
        for (var e2 = this, i2 = this.w, a2 = t3.parent, s2 = new Ct(this.ctx), r2 = i2.globals.yAxisScale[0].result.reverse(), o2 = r2.length, n2 = [], l2 = this.size / (o2 - 1), h2 = 0; h2 < o2; h2++)
          n2[h2] = l2 * h2;
        n2.reverse();
        var c2 = [], d2 = [];
        n2.forEach(function(t4, i3) {
          var a3 = x.getPolygonPos(t4, e2.dataPointsLen), s3 = "";
          a3.forEach(function(t5, a4) {
            if (0 === i3) {
              var r3 = e2.graphics.drawLine(t5.x, t5.y, 0, 0, Array.isArray(e2.polygons.connectorColors) ? e2.polygons.connectorColors[a4] : e2.polygons.connectorColors);
              d2.push(r3);
            }
            0 === a4 && e2.yaxisLabelsTextsPos.push({ x: t5.x, y: t5.y }), s3 += t5.x + "," + t5.y + " ";
          }), c2.push(s3);
        }), c2.forEach(function(t4, s3) {
          var r3 = e2.polygons.strokeColors, o3 = e2.polygons.strokeWidth, n3 = e2.graphics.drawPolygon(t4, Array.isArray(r3) ? r3[s3] : r3, Array.isArray(o3) ? o3[s3] : o3, i2.globals.radarPolygons.fill.colors[s3]);
          a2.add(n3);
        }), d2.forEach(function(t4) {
          a2.add(t4);
        }), i2.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t4, i3) {
          var a3 = s2.drawYAxisTexts(t4.x, t4.y, i3, r2[i3]);
          e2.yaxisLabels.add(a3);
        });
      } }, { key: "drawXAxisTexts", value: function() {
        var t3 = this, i2 = this.w, a2 = i2.config.xaxis.labels, s2 = this.graphics.group({ class: "apexcharts-xaxis" }), r2 = x.getPolygonPos(this.size, this.dataPointsLen);
        return i2.globals.labels.forEach(function(o2, n2) {
          var l2 = i2.config.xaxis.labels.formatter, h2 = new O(t3.ctx);
          if (r2[n2]) {
            var c2 = t3.getTextPos(r2[n2], t3.size), d2 = l2(o2, { seriesIndex: -1, dataPointIndex: n2, w: i2 });
            h2.plotDataLabelsText({ x: c2.newX, y: c2.newY, text: d2, textAnchor: c2.textAnchor, i: n2, j: n2, parent: s2, color: Array.isArray(a2.style.colors) && a2.style.colors[n2] ? a2.style.colors[n2] : "#a8a8a8", dataLabelsConfig: e({ textAnchor: c2.textAnchor, dropShadow: { enabled: false } }, a2), offsetCorrection: false });
          }
        }), s2;
      } }, { key: "createPaths", value: function(t3, e2) {
        var i2 = this, a2 = [], s2 = [], r2 = [], o2 = [];
        if (t3.length) {
          s2 = [this.graphics.move(e2.x, e2.y)], o2 = [this.graphics.move(e2.x, e2.y)];
          var n2 = this.graphics.move(t3[0].x, t3[0].y), l2 = this.graphics.move(t3[0].x, t3[0].y);
          t3.forEach(function(e3, a3) {
            n2 += i2.graphics.line(e3.x, e3.y), l2 += i2.graphics.line(e3.x, e3.y), a3 === t3.length - 1 && (n2 += "Z", l2 += "Z");
          }), a2.push(n2), r2.push(l2);
        }
        return { linePathsFrom: s2, linePathsTo: a2, areaPathsFrom: o2, areaPathsTo: r2 };
      } }, { key: "getTextPos", value: function(t3, e2) {
        var i2 = "middle", a2 = t3.x, s2 = t3.y;
        return Math.abs(t3.x) >= 10 ? t3.x > 0 ? (i2 = "start", a2 += 10) : t3.x < 0 && (i2 = "end", a2 -= 10) : i2 = "middle", Math.abs(t3.y) >= e2 - 10 && (t3.y < 0 ? s2 -= 10 : t3.y > 0 && (s2 += 10)), { textAnchor: i2, newX: a2, newY: s2 };
      } }, { key: "getPreviousPath", value: function(t3) {
        for (var e2 = this.w, i2 = null, a2 = 0; a2 < e2.globals.previousPaths.length; a2++) {
          var s2 = e2.globals.previousPaths[a2];
          s2.paths.length > 0 && parseInt(s2.realIndex, 10) === parseInt(t3, 10) && void 0 !== e2.globals.previousPaths[a2].paths[0] && (i2 = e2.globals.previousPaths[a2].paths[0].d);
        }
        return i2;
      } }, { key: "getDataPointsPos", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
        t3 = t3 || [], e2 = e2 || [];
        for (var a2 = [], s2 = 0; s2 < i2; s2++) {
          var r2 = {};
          r2.x = t3[s2] * Math.sin(e2[s2]), r2.y = -t3[s2] * Math.cos(e2[s2]), a2.push(r2);
        }
        return a2;
      } }]), t2;
    }();
    var It = function(t2) {
      n(i2, Lt);
      var e2 = d(i2);
      function i2(t3) {
        var s2;
        a(this, i2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.animBeginArr = [0], s2.animDur = 0;
        var r2 = s2.w;
        return s2.startAngle = r2.config.plotOptions.radialBar.startAngle, s2.endAngle = r2.config.plotOptions.radialBar.endAngle, s2.totalAngle = Math.abs(r2.config.plotOptions.radialBar.endAngle - r2.config.plotOptions.radialBar.startAngle), s2.trackStartAngle = r2.config.plotOptions.radialBar.track.startAngle, s2.trackEndAngle = r2.config.plotOptions.radialBar.track.endAngle, s2.barLabels = s2.w.config.plotOptions.radialBar.barLabels, s2.donutDataLabels = s2.w.config.plotOptions.radialBar.dataLabels, s2.radialDataLabels = s2.donutDataLabels, s2.trackStartAngle || (s2.trackStartAngle = s2.startAngle), s2.trackEndAngle || (s2.trackEndAngle = s2.endAngle), 360 === s2.endAngle && (s2.endAngle = 359.99), s2.margin = parseInt(r2.config.plotOptions.radialBar.track.margin, 10), s2.onBarLabelClick = s2.onBarLabelClick.bind(c(s2)), s2;
      }
      return r(i2, [{ key: "draw", value: function(t3) {
        var e3 = this.w, i3 = new m(this.ctx), a2 = i3.group({ class: "apexcharts-radialbar" });
        if (e3.globals.noData)
          return a2;
        var s2 = i3.group(), r2 = this.defaultSize / 2, o2 = e3.globals.gridWidth / 2, n2 = this.defaultSize / 2.05;
        e3.config.chart.sparkline.enabled || (n2 = n2 - e3.config.stroke.width - e3.config.chart.dropShadow.blur);
        var l2 = e3.globals.fill.colors;
        if (e3.config.plotOptions.radialBar.track.show) {
          var h2 = this.drawTracks({ size: n2, centerX: o2, centerY: r2, colorArr: l2, series: t3 });
          s2.add(h2);
        }
        var c2 = this.drawArcs({ size: n2, centerX: o2, centerY: r2, colorArr: l2, series: t3 }), d2 = 360;
        e3.config.plotOptions.radialBar.startAngle < 0 && (d2 = this.totalAngle);
        var g2 = (360 - d2) / 360;
        if (e3.globals.radialSize = n2 - n2 * g2, this.radialDataLabels.value.show) {
          var u5 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
          e3.globals.radialSize += u5 * g2;
        }
        return s2.add(c2.g), "front" === e3.config.plotOptions.radialBar.hollow.position && (c2.g.add(c2.elHollow), c2.dataLabels && c2.g.add(c2.dataLabels)), a2.add(s2), a2;
      } }, { key: "drawTracks", value: function(t3) {
        var e3 = this.w, i3 = new m(this.ctx), a2 = i3.group({ class: "apexcharts-tracks" }), s2 = new v(this.ctx), r2 = new R(this.ctx), o2 = this.getStrokeWidth(t3);
        t3.size = t3.size - o2 / 2;
        for (var n2 = 0; n2 < t3.series.length; n2++) {
          var l2 = i3.group({ class: "apexcharts-radialbar-track apexcharts-track" });
          a2.add(l2), l2.attr({ rel: n2 + 1 }), t3.size = t3.size - o2 - this.margin;
          var h2 = e3.config.plotOptions.radialBar.track, c2 = r2.fillPath({ seriesNumber: 0, size: t3.size, fillColors: Array.isArray(h2.background) ? h2.background[n2] : h2.background, solid: true }), d2 = this.trackStartAngle, g2 = this.trackEndAngle;
          Math.abs(g2) + Math.abs(d2) >= 360 && (g2 = 360 - Math.abs(this.startAngle) - 0.1);
          var u5 = i3.drawPath({ d: "", stroke: c2, strokeWidth: o2 * parseInt(h2.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h2.opacity, classes: "apexcharts-radialbar-area" });
          if (h2.dropShadow.enabled) {
            var p2 = h2.dropShadow;
            s2.dropShadow(u5, p2);
          }
          l2.add(u5), u5.attr("id", "apexcharts-radialbarTrack-" + n2), this.animatePaths(u5, { centerX: t3.centerX, centerY: t3.centerY, endAngle: g2, startAngle: d2, size: t3.size, i: n2, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true, easing: e3.globals.easing });
        }
        return a2;
      } }, { key: "drawArcs", value: function(t3) {
        var e3 = this.w, i3 = new m(this.ctx), a2 = new R(this.ctx), s2 = new v(this.ctx), r2 = i3.group(), o2 = this.getStrokeWidth(t3);
        t3.size = t3.size - o2 / 2;
        var n2 = e3.config.plotOptions.radialBar.hollow.background, l2 = t3.size - o2 * t3.series.length - this.margin * t3.series.length - o2 * parseInt(e3.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h2 = l2 - e3.config.plotOptions.radialBar.hollow.margin;
        void 0 !== e3.config.plotOptions.radialBar.hollow.image && (n2 = this.drawHollowImage(t3, r2, l2, n2));
        var c2 = this.drawHollow({ size: h2, centerX: t3.centerX, centerY: t3.centerY, fill: n2 || "transparent" });
        if (e3.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
          var d2 = e3.config.plotOptions.radialBar.hollow.dropShadow;
          s2.dropShadow(c2, d2);
        }
        var g2 = 1;
        !this.radialDataLabels.total.show && e3.globals.series.length > 1 && (g2 = 0);
        var u5 = null;
        this.radialDataLabels.show && (u5 = this.renderInnerDataLabels(this.radialDataLabels, { hollowSize: l2, centerX: t3.centerX, centerY: t3.centerY, opacity: g2 })), "back" === e3.config.plotOptions.radialBar.hollow.position && (r2.add(c2), u5 && r2.add(u5));
        var p2 = false;
        e3.config.plotOptions.radialBar.inverseOrder && (p2 = true);
        for (var f2 = p2 ? t3.series.length - 1 : 0; p2 ? f2 >= 0 : f2 < t3.series.length; p2 ? f2-- : f2++) {
          var b2 = i3.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: x.escapeString(e3.globals.seriesNames[f2]) });
          r2.add(b2), b2.attr({ rel: f2 + 1, "data:realIndex": f2 }), this.ctx.series.addCollapsedClassToSeries(b2, f2), t3.size = t3.size - o2 - this.margin;
          var y2 = a2.fillPath({ seriesNumber: f2, size: t3.size, value: t3.series[f2] }), w2 = this.startAngle, k2 = void 0, A2 = x.negToZero(t3.series[f2] > 100 ? 100 : t3.series[f2]) / 100, S2 = Math.round(this.totalAngle * A2) + this.startAngle, C2 = void 0;
          e3.globals.dataChanged && (k2 = this.startAngle, C2 = Math.round(this.totalAngle * x.negToZero(e3.globals.previousPaths[f2]) / 100) + k2), Math.abs(S2) + Math.abs(w2) >= 360 && (S2 -= 0.01), Math.abs(C2) + Math.abs(k2) >= 360 && (C2 -= 0.01);
          var L2 = S2 - w2, P2 = Array.isArray(e3.config.stroke.dashArray) ? e3.config.stroke.dashArray[f2] : e3.config.stroke.dashArray, I2 = i3.drawPath({ d: "", stroke: y2, strokeWidth: o2, fill: "none", fillOpacity: e3.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + f2, strokeDashArray: P2 });
          if (m.setAttrs(I2.node, { "data:angle": L2, "data:value": t3.series[f2] }), e3.config.chart.dropShadow.enabled) {
            var T2 = e3.config.chart.dropShadow;
            s2.dropShadow(I2, T2, f2);
          }
          if (s2.setSelectionFilter(I2, 0, f2), this.addListeners(I2, this.radialDataLabels), b2.add(I2), I2.attr({ index: 0, j: f2 }), this.barLabels.enabled) {
            var M2 = x.polarToCartesian(t3.centerX, t3.centerY, t3.size, w2), z2 = this.barLabels.formatter(e3.globals.seriesNames[f2], { seriesIndex: f2, w: e3 }), X2 = ["apexcharts-radialbar-label"];
            this.barLabels.onClick || X2.push("apexcharts-no-click");
            var E2 = this.barLabels.useSeriesColors ? e3.globals.colors[f2] : e3.config.chart.foreColor;
            E2 || (E2 = e3.config.chart.foreColor);
            var Y2 = M2.x - this.barLabels.margin, F2 = M2.y, H2 = i3.drawText({ x: Y2, y: F2, text: z2, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: E2, cssClass: X2.join(" ") });
            H2.on("click", this.onBarLabelClick), H2.attr({ rel: f2 + 1 }), 0 !== w2 && H2.attr({ "transform-origin": "".concat(Y2, " ").concat(F2), transform: "rotate(".concat(w2, " 0 0)") }), b2.add(H2);
          }
          var D2 = 0;
          !this.initialAnim || e3.globals.resized || e3.globals.dataChanged || (D2 = e3.config.chart.animations.speed), e3.globals.dataChanged && (D2 = e3.config.chart.animations.dynamicAnimation.speed), this.animDur = D2 / (1.2 * t3.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(I2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: S2, startAngle: w2, prevEndAngle: C2, prevStartAngle: k2, size: t3.size, i: f2, totalItems: 2, animBeginArr: this.animBeginArr, dur: D2, shouldSetPrevPaths: true, easing: e3.globals.easing });
        }
        return { g: r2, elHollow: c2, dataLabels: u5 };
      } }, { key: "drawHollow", value: function(t3) {
        var e3 = new m(this.ctx).drawCircle(2 * t3.size);
        return e3.attr({ class: "apexcharts-radialbar-hollow", cx: t3.centerX, cy: t3.centerY, r: t3.size, fill: t3.fill }), e3;
      } }, { key: "drawHollowImage", value: function(t3, e3, i3, a2) {
        var s2 = this.w, r2 = new R(this.ctx), o2 = x.randomId(), n2 = s2.config.plotOptions.radialBar.hollow.image;
        if (s2.config.plotOptions.radialBar.hollow.imageClipped)
          r2.clippedImgArea({ width: i3, height: i3, image: n2, patternID: "pattern".concat(s2.globals.cuid).concat(o2) }), a2 = "url(#pattern".concat(s2.globals.cuid).concat(o2, ")");
        else {
          var l2 = s2.config.plotOptions.radialBar.hollow.imageWidth, h2 = s2.config.plotOptions.radialBar.hollow.imageHeight;
          if (void 0 === l2 && void 0 === h2) {
            var c2 = s2.globals.dom.Paper.image(n2).loaded(function(e4) {
              this.move(t3.centerX - e4.width / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - e4.height / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY);
            });
            e3.add(c2);
          } else {
            var d2 = s2.globals.dom.Paper.image(n2).loaded(function(e4) {
              this.move(t3.centerX - l2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - h2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l2, h2);
            });
            e3.add(d2);
          }
        }
        return a2;
      } }, { key: "getStrokeWidth", value: function(t3) {
        var e3 = this.w;
        return t3.size * (100 - parseInt(e3.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t3.series.length + 1) - this.margin;
      } }, { key: "onBarLabelClick", value: function(t3) {
        var e3 = parseInt(t3.target.getAttribute("rel"), 10) - 1, i3 = this.barLabels.onClick, a2 = this.w;
        i3 && i3(a2.globals.seriesNames[e3], { w: a2, seriesIndex: e3 });
      } }]), i2;
    }();
    var Tt = function(t2) {
      n(s2, yt);
      var i2 = d(s2);
      function s2() {
        return a(this, s2), i2.apply(this, arguments);
      }
      return r(s2, [{ key: "draw", value: function(t3, i3) {
        var a2 = this.w, s3 = new m(this.ctx);
        this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t3, this.seriesRangeStart = a2.globals.seriesRangeStart, this.seriesRangeEnd = a2.globals.seriesRangeEnd, this.barHelpers.initVariables(t3);
        for (var r2 = s3.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), n2 = 0; n2 < t3.length; n2++) {
          var l2, h2, c2, d2, g2 = void 0, u5 = void 0, p2 = a2.globals.comboCharts ? i3[n2] : n2, f2 = s3.group({ class: "apexcharts-series", seriesName: x.escapeString(a2.globals.seriesNames[p2]), rel: n2 + 1, "data:realIndex": p2 });
          this.ctx.series.addCollapsedClassToSeries(f2, p2), t3[n2].length > 0 && (this.visibleI = this.visibleI + 1);
          var b2 = 0, v2 = 0;
          this.yRatio.length > 1 && (this.yaxisIndex = p2);
          var y2 = this.barHelpers.initialPositions();
          u5 = y2.y, d2 = y2.zeroW, g2 = y2.x, v2 = y2.barWidth, b2 = y2.barHeight, l2 = y2.xDivision, h2 = y2.yDivision, c2 = y2.zeroH;
          for (var w2 = s3.group({ class: "apexcharts-datalabels", "data:realIndex": p2 }), k2 = s3.group({ class: "apexcharts-rangebar-goals-markers" }), A2 = 0; A2 < a2.globals.dataPoints; A2++) {
            var S2, C2 = this.barHelpers.getStrokeWidth(n2, A2, p2), L2 = this.seriesRangeStart[n2][A2], P2 = this.seriesRangeEnd[n2][A2], I2 = null, T2 = null, M2 = null, z2 = { x: g2, y: u5, strokeWidth: C2, elSeries: f2 }, X2 = this.seriesLen;
            if (a2.config.plotOptions.bar.rangeBarGroupRows && (X2 = 1), void 0 === a2.config.series[n2].data[A2])
              break;
            if (this.isHorizontal) {
              M2 = u5 + b2 * this.visibleI;
              var E2 = (h2 - b2 * X2) / 2;
              if (a2.config.series[n2].data[A2].x) {
                var Y2 = this.detectOverlappingBars({ i: n2, j: A2, barYPosition: M2, srty: E2, barHeight: b2, yDivision: h2, initPositions: y2 });
                b2 = Y2.barHeight, M2 = Y2.barYPosition;
              }
              v2 = (I2 = this.drawRangeBarPaths(e({ indexes: { i: n2, j: A2, realIndex: p2 }, barHeight: b2, barYPosition: M2, zeroW: d2, yDivision: h2, y1: L2, y2: P2 }, z2))).barWidth;
            } else {
              a2.globals.isXNumeric && (g2 = (a2.globals.seriesX[n2][A2] - a2.globals.minX) / this.xRatio - v2 / 2), T2 = g2 + v2 * this.visibleI;
              var F2 = (l2 - v2 * X2) / 2;
              if (a2.config.series[n2].data[A2].x) {
                var R2 = this.detectOverlappingBars({ i: n2, j: A2, barXPosition: T2, srtx: F2, barWidth: v2, xDivision: l2, initPositions: y2 });
                v2 = R2.barWidth, T2 = R2.barXPosition;
              }
              b2 = (I2 = this.drawRangeColumnPaths(e({ indexes: { i: n2, j: A2, realIndex: p2 }, barWidth: v2, barXPosition: T2, zeroH: c2, xDivision: l2 }, z2))).barHeight;
            }
            var H2 = this.barHelpers.drawGoalLine({ barXPosition: I2.barXPosition, barYPosition: M2, goalX: I2.goalX, goalY: I2.goalY, barHeight: b2, barWidth: v2 });
            H2 && k2.add(H2), u5 = I2.y, g2 = I2.x;
            var D2 = this.barHelpers.getPathFillColor(t3, n2, A2, p2), O2 = a2.globals.stroke.colors[p2];
            this.renderSeries((o(S2 = { realIndex: p2, pathFill: D2, lineFill: O2, j: A2, i: n2, x: g2, y: u5, y1: L2, y2: P2, pathFrom: I2.pathFrom, pathTo: I2.pathTo, strokeWidth: C2, elSeries: f2, series: t3, barHeight: b2, barWidth: v2, barXPosition: T2, barYPosition: M2 }, "barWidth", v2), o(S2, "elDataLabelsWrap", w2), o(S2, "elGoalsMarkers", k2), o(S2, "visibleSeries", this.visibleI), o(S2, "type", "rangebar"), S2));
          }
          r2.add(f2);
        }
        return r2;
      } }, { key: "detectOverlappingBars", value: function(t3) {
        var e2 = t3.i, i3 = t3.j, a2 = t3.barYPosition, s3 = t3.barXPosition, r2 = t3.srty, o2 = t3.srtx, n2 = t3.barHeight, l2 = t3.barWidth, h2 = t3.yDivision, c2 = t3.xDivision, d2 = t3.initPositions, g2 = this.w, u5 = [], p2 = g2.config.series[e2].data[i3].rangeName, f2 = g2.config.series[e2].data[i3].x, x2 = Array.isArray(f2) ? f2.join(" ") : f2, b2 = g2.globals.labels.map(function(t4) {
          return Array.isArray(t4) ? t4.join(" ") : t4;
        }).indexOf(x2), v2 = g2.globals.seriesRange[e2].findIndex(function(t4) {
          return t4.x === x2 && t4.overlaps.length > 0;
        });
        return this.isHorizontal ? (a2 = g2.config.plotOptions.bar.rangeBarGroupRows ? r2 + h2 * b2 : r2 + n2 * this.visibleI + h2 * b2, v2 > -1 && !g2.config.plotOptions.bar.rangeBarOverlap && (u5 = g2.globals.seriesRange[e2][v2].overlaps).indexOf(p2) > -1 && (a2 = (n2 = d2.barHeight / u5.length) * this.visibleI + h2 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + n2 * (this.visibleI + u5.indexOf(p2)) + h2 * b2)) : (b2 > -1 && (s3 = g2.config.plotOptions.bar.rangeBarGroupRows ? o2 + c2 * b2 : o2 + l2 * this.visibleI + c2 * b2), v2 > -1 && !g2.config.plotOptions.bar.rangeBarOverlap && (u5 = g2.globals.seriesRange[e2][v2].overlaps).indexOf(p2) > -1 && (s3 = (l2 = d2.barWidth / u5.length) * this.visibleI + c2 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l2 * (this.visibleI + u5.indexOf(p2)) + c2 * b2)), { barYPosition: a2, barXPosition: s3, barHeight: n2, barWidth: l2 };
      } }, { key: "drawRangeColumnPaths", value: function(t3) {
        var e2 = t3.indexes, i3 = t3.x, a2 = t3.xDivision, s3 = t3.barWidth, r2 = t3.barXPosition, o2 = t3.zeroH, n2 = this.w, l2 = e2.i, h2 = e2.j, c2 = this.yRatio[this.yaxisIndex], d2 = e2.realIndex, g2 = this.getRangeValue(d2, h2), u5 = Math.min(g2.start, g2.end), p2 = Math.max(g2.start, g2.end);
        void 0 === this.series[l2][h2] || null === this.series[l2][h2] ? u5 = o2 : (u5 = o2 - u5 / c2, p2 = o2 - p2 / c2);
        var f2 = Math.abs(p2 - u5), x2 = this.barHelpers.getColumnPaths({ barXPosition: r2, barWidth: s3, y1: u5, y2: p2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: e2.realIndex, i: d2, j: h2, w: n2 });
        if (n2.globals.isXNumeric) {
          var b2 = this.getBarXForNumericXAxis({ x: i3, j: h2, realIndex: d2, barWidth: s3 });
          i3 = b2.x, r2 = b2.barXPosition;
        } else
          i3 += a2;
        return { pathTo: x2.pathTo, pathFrom: x2.pathFrom, barHeight: f2, x: i3, y: p2, goalY: this.barHelpers.getGoalValues("y", null, o2, l2, h2), barXPosition: r2 };
      } }, { key: "drawRangeBarPaths", value: function(t3) {
        var e2 = t3.indexes, i3 = t3.y, a2 = t3.y1, s3 = t3.y2, r2 = t3.yDivision, o2 = t3.barHeight, n2 = t3.barYPosition, l2 = t3.zeroW, h2 = this.w, c2 = l2 + a2 / this.invertedYRatio, d2 = l2 + s3 / this.invertedYRatio, g2 = Math.abs(d2 - c2), u5 = this.barHelpers.getBarpaths({ barYPosition: n2, barHeight: o2, x1: c2, x2: d2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: e2.realIndex, realIndex: e2.realIndex, j: e2.j, w: h2 });
        return h2.globals.isXNumeric || (i3 += r2), { pathTo: u5.pathTo, pathFrom: u5.pathFrom, barWidth: g2, x: d2, goalX: this.barHelpers.getGoalValues("x", l2, null, e2.realIndex, e2.j), y: i3 };
      } }, { key: "getRangeValue", value: function(t3, e2) {
        var i3 = this.w;
        return { start: i3.globals.seriesRangeStart[t3][e2], end: i3.globals.seriesRangeEnd[t3][e2] };
      } }]), s2;
    }();
    var Mt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.lineCtx = e2;
      }
      return r(t2, [{ key: "sameValueSeriesFix", value: function(t3, e2) {
        var i2 = this.w;
        if (("gradient" === i2.config.fill.type || "gradient" === i2.config.fill.type[t3]) && new y(this.lineCtx.ctx, i2).seriesHaveSameValues(t3)) {
          var a2 = e2[t3].slice();
          a2[a2.length - 1] = a2[a2.length - 1] + 1e-6, e2[t3] = a2;
        }
        return e2;
      } }, { key: "calculatePoints", value: function(t3) {
        var e2 = t3.series, i2 = t3.realIndex, a2 = t3.x, s2 = t3.y, r2 = t3.i, o2 = t3.j, n2 = t3.prevY, l2 = this.w, h2 = [], c2 = [];
        if (0 === o2) {
          var d2 = this.lineCtx.categoryAxisCorrection + l2.config.markers.offsetX;
          l2.globals.isXNumeric && (d2 = (l2.globals.seriesX[i2][0] - l2.globals.minX) / this.lineCtx.xRatio + l2.config.markers.offsetX), h2.push(d2), c2.push(x.isNumber(e2[r2][0]) ? n2 + l2.config.markers.offsetY : null), h2.push(a2 + l2.config.markers.offsetX), c2.push(x.isNumber(e2[r2][o2 + 1]) ? s2 + l2.config.markers.offsetY : null);
        } else
          h2.push(a2 + l2.config.markers.offsetX), c2.push(x.isNumber(e2[r2][o2 + 1]) ? s2 + l2.config.markers.offsetY : null);
        return { x: h2, y: c2 };
      } }, { key: "checkPreviousPaths", value: function(t3) {
        for (var e2 = t3.pathFromLine, i2 = t3.pathFromArea, a2 = t3.realIndex, s2 = this.w, r2 = 0; r2 < s2.globals.previousPaths.length; r2++) {
          var o2 = s2.globals.previousPaths[r2];
          ("line" === o2.type || "area" === o2.type) && o2.paths.length > 0 && parseInt(o2.realIndex, 10) === parseInt(a2, 10) && ("line" === o2.type ? (this.lineCtx.appendPathFrom = false, e2 = s2.globals.previousPaths[r2].paths[0].d) : "area" === o2.type && (this.lineCtx.appendPathFrom = false, i2 = s2.globals.previousPaths[r2].paths[0].d, s2.config.stroke.show && s2.globals.previousPaths[r2].paths[1] && (e2 = s2.globals.previousPaths[r2].paths[1].d)));
        }
        return { pathFromLine: e2, pathFromArea: i2 };
      } }, { key: "determineFirstPrevY", value: function(t3) {
        var e2, i2, a2 = t3.i, s2 = t3.series, r2 = t3.prevY, o2 = t3.lineYPosition, n2 = this.w, l2 = n2.config.chart.stacked && !n2.globals.comboCharts || n2.config.chart.stacked && n2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e2 = this.w.config.series[a2]) || void 0 === e2 ? void 0 : e2.type));
        if (void 0 !== (null === (i2 = s2[a2]) || void 0 === i2 ? void 0 : i2[0]))
          r2 = (o2 = l2 && a2 > 0 ? this.lineCtx.prevSeriesY[a2 - 1][0] : this.lineCtx.zeroY) - s2[a2][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? s2[a2][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
        else if (l2 && a2 > 0 && void 0 === s2[a2][0]) {
          for (var h2 = a2 - 1; h2 >= 0; h2--)
            if (null !== s2[h2][0] && void 0 !== s2[h2][0]) {
              r2 = o2 = this.lineCtx.prevSeriesY[h2][0];
              break;
            }
        }
        return { prevY: r2, lineYPosition: o2 };
      } }]), t2;
    }();
    var zt = function(t2) {
      for (var e2, i2, a2, s2, r2 = function(t3) {
        for (var e3 = [], i3 = t3[0], a3 = t3[1], s3 = e3[0] = Yt(i3, a3), r3 = 1, o3 = t3.length - 1; r3 < o3; r3++)
          i3 = a3, a3 = t3[r3 + 1], e3[r3] = 0.5 * (s3 + (s3 = Yt(i3, a3)));
        return e3[r3] = s3, e3;
      }(t2), o2 = t2.length - 1, n2 = [], l2 = 0; l2 < o2; l2++)
        a2 = Yt(t2[l2], t2[l2 + 1]), Math.abs(a2) < 1e-6 ? r2[l2] = r2[l2 + 1] = 0 : (s2 = (e2 = r2[l2] / a2) * e2 + (i2 = r2[l2 + 1] / a2) * i2) > 9 && (s2 = 3 * a2 / Math.sqrt(s2), r2[l2] = s2 * e2, r2[l2 + 1] = s2 * i2);
      for (var h2 = 0; h2 <= o2; h2++)
        s2 = (t2[Math.min(o2, h2 + 1)][0] - t2[Math.max(0, h2 - 1)][0]) / (6 * (1 + r2[h2] * r2[h2])), n2.push([s2 || 0, r2[h2] * s2 || 0]);
      return n2;
    };
    var Xt = function(t2, e2) {
      for (var i2 = "", a2 = 0; a2 < t2.length; a2++) {
        var s2 = t2[a2], r2 = t2[a2 - 1], o2 = s2.length, n2 = null == r2 ? void 0 : r2.length;
        a2 > 1 && Math.abs(s2[o2 - 2] - r2[n2 - 2]) < e2 / 25 ? i2 += "L".concat(s2[2], ", ").concat(s2[3]) : o2 > 4 ? (i2 += "C".concat(s2[0], ", ").concat(s2[1]), i2 += ", ".concat(s2[2], ", ").concat(s2[3]), i2 += ", ".concat(s2[4], ", ").concat(s2[5])) : o2 > 2 && (i2 += "S".concat(s2[0], ", ").concat(s2[1]), i2 += ", ".concat(s2[2], ", ").concat(s2[3]));
      }
      return i2;
    };
    var Et = function(t2) {
      var e2 = zt(t2), i2 = t2[1], a2 = t2[0], s2 = [], r2 = e2[1], o2 = e2[0];
      s2.push(a2, [a2[0] + o2[0], a2[1] + o2[1], i2[0] - r2[0], i2[1] - r2[1], i2[0], i2[1]]);
      for (var n2 = 2, l2 = e2.length; n2 < l2; n2++) {
        var h2 = t2[n2], c2 = e2[n2];
        s2.push([h2[0] - c2[0], h2[1] - c2[1], h2[0], h2[1]]);
      }
      return s2;
    };
    function Yt(t2, e2) {
      return (e2[1] - t2[1]) / (e2[0] - t2[0]);
    }
    var Ft = function() {
      function t2(e2, i2, s2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.xyRatios = i2, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s2, this.scatter = new D(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Mt(this), this.markers = new H(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
      }
      return r(t2, [{ key: "draw", value: function(t3, i2, a2, s2) {
        var r2, o2 = this.w, n2 = new m(this.ctx), l2 = o2.globals.comboCharts ? i2 : o2.config.chart.type, h2 = n2.group({ class: "apexcharts-".concat(l2, "-series apexcharts-plot-series") }), c2 = new y(this.ctx, o2);
        this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t3 = c2.getLogSeries(t3), this.yRatio = c2.getLogYRatios(this.yRatio);
        for (var d2 = [], g2 = 0; g2 < t3.length; g2++) {
          t3 = this.lineHelpers.sameValueSeriesFix(g2, t3);
          var u5 = o2.globals.comboCharts ? a2[g2] : g2;
          this._initSerieVariables(t3, g2, u5);
          var p2 = [], f2 = [], x2 = [], b2 = o2.globals.padHorizontal + this.categoryAxisCorrection;
          this.ctx.series.addCollapsedClassToSeries(this.elSeries, u5), o2.globals.isXNumeric && o2.globals.seriesX.length > 0 && (b2 = (o2.globals.seriesX[u5][0] - o2.globals.minX) / this.xRatio), x2.push(b2);
          var v2 = b2, w2 = this.zeroY, k2 = this.zeroY;
          w2 = this.lineHelpers.determineFirstPrevY({ i: g2, series: t3, prevY: w2, lineYPosition: 0 }).prevY, "smooth" === o2.config.stroke.curve && null === t3[g2][0] ? p2.push(null) : p2.push(w2);
          "rangeArea" === l2 && (k2 = this.lineHelpers.determineFirstPrevY({ i: g2, series: s2, prevY: k2, lineYPosition: 0 }).prevY, f2.push(k2));
          var A2 = { type: l2, series: t3, realIndex: u5, i: g2, x: b2, y: 1, pathsFrom: this._calculatePathsFrom({ type: l2, series: t3, i: g2, realIndex: u5, prevX: v2, prevY: w2, prevY2: k2 }), linePaths: [], areaPaths: [], seriesIndex: a2, lineYPosition: 0, xArrj: x2, yArrj: p2, y2Arrj: f2, seriesRangeEnd: s2 }, S2 = this._iterateOverDataPoints(e(e({}, A2), {}, { iterations: "rangeArea" === l2 ? t3[g2].length - 1 : void 0, isRangeStart: true }));
          if ("rangeArea" === l2) {
            var C2 = this._calculatePathsFrom({ series: s2, i: g2, realIndex: u5, prevX: v2, prevY: k2 }), L2 = this._iterateOverDataPoints(e(e({}, A2), {}, { series: s2, pathsFrom: C2, iterations: s2[g2].length - 1, isRangeStart: false }));
            S2.linePaths[0] = L2.linePath + S2.linePath, S2.pathFromLine = L2.pathFromLine + S2.pathFromLine;
          }
          this._handlePaths({ type: l2, realIndex: u5, i: g2, paths: S2 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), d2.push(this.elSeries);
        }
        if (void 0 !== (null === (r2 = o2.config.series[0]) || void 0 === r2 ? void 0 : r2.zIndex) && d2.sort(function(t4, e2) {
          return Number(t4.node.getAttribute("zIndex")) - Number(e2.node.getAttribute("zIndex"));
        }), o2.config.chart.stacked)
          for (var P2 = d2.length; P2 > 0; P2--)
            h2.add(d2[P2 - 1]);
        else
          for (var I2 = 0; I2 < d2.length; I2++)
            h2.add(d2[I2]);
        return h2;
      } }, { key: "_initSerieVariables", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = new m(this.ctx);
        this.xDivision = a2.globals.gridWidth / (a2.globals.dataPoints - ("on" === a2.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a2.config.stroke.width) ? a2.config.stroke.width[i2] : a2.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i2), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a2.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a2.globals.gridHeight || "end" === a2.config.plotOptions.area.fillTo) && (this.areaBottomY = a2.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s2.group({ class: "apexcharts-series", zIndex: void 0 !== a2.config.series[i2].zIndex ? a2.config.series[i2].zIndex : i2, seriesName: x.escapeString(a2.globals.seriesNames[i2]) }), this.elPointsMain = s2.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i2 }), this.elDataLabelsWrap = s2.group({ class: "apexcharts-datalabels", "data:realIndex": i2 });
        var r2 = t3[e2].length === a2.globals.dataPoints;
        this.elSeries.attr({ "data:longestSeries": r2, rel: e2 + 1, "data:realIndex": i2 }), this.appendPathFrom = true;
      } }, { key: "_calculatePathsFrom", value: function(t3) {
        var e2, i2, a2, s2, r2 = t3.type, o2 = t3.series, n2 = t3.i, l2 = t3.realIndex, h2 = t3.prevX, c2 = t3.prevY, d2 = t3.prevY2, g2 = this.w, u5 = new m(this.ctx);
        if (null === o2[n2][0]) {
          for (var p2 = 0; p2 < o2[n2].length; p2++)
            if (null !== o2[n2][p2]) {
              h2 = this.xDivision * p2, c2 = this.zeroY - o2[n2][p2] / this.yRatio[this.yaxisIndex], e2 = u5.move(h2, c2), i2 = u5.move(h2, this.areaBottomY);
              break;
            }
        } else
          e2 = u5.move(h2, c2), "rangeArea" === r2 && (e2 = u5.move(h2, d2) + u5.line(h2, c2)), i2 = u5.move(h2, this.areaBottomY) + u5.line(h2, c2);
        if (a2 = u5.move(-1, this.zeroY) + u5.line(-1, this.zeroY), s2 = u5.move(-1, this.zeroY) + u5.line(-1, this.zeroY), g2.globals.previousPaths.length > 0) {
          var f2 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a2, pathFromArea: s2, realIndex: l2 });
          a2 = f2.pathFromLine, s2 = f2.pathFromArea;
        }
        return { prevX: h2, prevY: c2, linePath: e2, areaPath: i2, pathFromLine: a2, pathFromArea: s2 };
      } }, { key: "_handlePaths", value: function(t3) {
        var i2 = t3.type, a2 = t3.realIndex, s2 = t3.i, r2 = t3.paths, o2 = this.w, n2 = new m(this.ctx), l2 = new R(this.ctx);
        this.prevSeriesY.push(r2.yArrj), o2.globals.seriesXvalues[a2] = r2.xArrj, o2.globals.seriesYvalues[a2] = r2.yArrj;
        var h2 = o2.config.forecastDataPoints;
        if (h2.count > 0 && "rangeArea" !== i2) {
          var c2 = o2.globals.seriesXvalues[a2][o2.globals.seriesXvalues[a2].length - h2.count - 1], d2 = n2.drawRect(c2, 0, o2.globals.gridWidth, o2.globals.gridHeight, 0);
          o2.globals.dom.elForecastMask.appendChild(d2.node);
          var g2 = n2.drawRect(0, 0, c2, o2.globals.gridHeight, 0);
          o2.globals.dom.elNonForecastMask.appendChild(g2.node);
        }
        this.pointsChart || o2.globals.delayedElements.push({ el: this.elPointsMain.node, index: a2 });
        var u5 = { i: s2, realIndex: a2, animationDelay: s2, initialSpeed: o2.config.chart.animations.speed, dataChangeSpeed: o2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(i2) };
        if ("area" === i2)
          for (var p2 = l2.fillPath({ seriesNumber: a2 }), f2 = 0; f2 < r2.areaPaths.length; f2++) {
            var x2 = n2.renderPaths(e(e({}, u5), {}, { pathFrom: r2.pathFromArea, pathTo: r2.areaPaths[f2], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p2 }));
            this.elSeries.add(x2);
          }
        if (o2.config.stroke.show && !this.pointsChart) {
          var b2 = null;
          if ("line" === i2)
            b2 = l2.fillPath({ seriesNumber: a2, i: s2 });
          else if ("solid" === o2.config.stroke.fill.type)
            b2 = o2.globals.stroke.colors[a2];
          else {
            var v2 = o2.config.fill;
            o2.config.fill = o2.config.stroke.fill, b2 = l2.fillPath({ seriesNumber: a2, i: s2 }), o2.config.fill = v2;
          }
          for (var y2 = 0; y2 < r2.linePaths.length; y2++) {
            var w2 = b2;
            "rangeArea" === i2 && (w2 = l2.fillPath({ seriesNumber: a2 }));
            var k2 = e(e({}, u5), {}, { pathFrom: r2.pathFromLine, pathTo: r2.linePaths[y2], stroke: b2, strokeWidth: this.strokeWidth, strokeLineCap: o2.config.stroke.lineCap, fill: "rangeArea" === i2 ? w2 : "none" }), A2 = n2.renderPaths(k2);
            if (this.elSeries.add(A2), A2.attr("fill-rule", "evenodd"), h2.count > 0 && "rangeArea" !== i2) {
              var S2 = n2.renderPaths(k2);
              S2.node.setAttribute("stroke-dasharray", h2.dashArray), h2.strokeWidth && S2.node.setAttribute("stroke-width", h2.strokeWidth), this.elSeries.add(S2), S2.attr("clip-path", "url(#forecastMask".concat(o2.globals.cuid, ")")), A2.attr("clip-path", "url(#nonForecastMask".concat(o2.globals.cuid, ")"));
            }
          }
        }
      } }, { key: "_iterateOverDataPoints", value: function(t3) {
        var e2, i2 = this, a2 = t3.type, s2 = t3.series, r2 = t3.iterations, o2 = t3.realIndex, n2 = t3.i, l2 = t3.x, h2 = t3.y, c2 = t3.pathsFrom, d2 = t3.linePaths, g2 = t3.areaPaths, u5 = t3.seriesIndex, p2 = t3.lineYPosition, f2 = t3.xArrj, b2 = t3.yArrj, v2 = t3.y2Arrj, y2 = t3.isRangeStart, w2 = t3.seriesRangeEnd, k2 = this.w, A2 = new m(this.ctx), S2 = this.yRatio, C2 = c2.prevY, L2 = c2.linePath, P2 = c2.areaPath, I2 = c2.pathFromLine, T2 = c2.pathFromArea, M2 = x.isNumber(k2.globals.minYArr[o2]) ? k2.globals.minYArr[o2] : k2.globals.minY;
        r2 || (r2 = k2.globals.dataPoints > 1 ? k2.globals.dataPoints - 1 : k2.globals.dataPoints);
        for (var z2 = function(t4, e3) {
          return e3 - t4 / S2[i2.yaxisIndex] + 2 * (i2.isReversed ? t4 / S2[i2.yaxisIndex] : 0);
        }, X2 = h2, E2 = k2.config.chart.stacked && !k2.globals.comboCharts || k2.config.chart.stacked && k2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e2 = this.w.config.series[o2]) || void 0 === e2 ? void 0 : e2.type)), Y2 = 0; Y2 < r2; Y2++) {
          var F2 = void 0 === s2[n2][Y2 + 1] || null === s2[n2][Y2 + 1];
          if (k2.globals.isXNumeric) {
            var R2 = k2.globals.seriesX[o2][Y2 + 1];
            void 0 === k2.globals.seriesX[o2][Y2 + 1] && (R2 = k2.globals.seriesX[o2][r2 - 1]), l2 = (R2 - k2.globals.minX) / this.xRatio;
          } else
            l2 += this.xDivision;
          if (E2)
            if (n2 > 0 && k2.globals.collapsedSeries.length < k2.config.series.length - 1) {
              p2 = this.prevSeriesY[function(t4) {
                for (var e3 = t4, i3 = 0; i3 < k2.globals.series.length; i3++)
                  if (k2.globals.collapsedSeriesIndices.indexOf(t4) > -1) {
                    e3--;
                    break;
                  }
                return e3 >= 0 ? e3 : 0;
              }(n2 - 1)][Y2 + 1];
            } else
              p2 = this.zeroY;
          else
            p2 = this.zeroY;
          F2 ? h2 = z2(M2, p2) : (h2 = z2(s2[n2][Y2 + 1], p2), "rangeArea" === a2 && (X2 = z2(w2[n2][Y2 + 1], p2))), f2.push(l2), F2 && "smooth" === k2.config.stroke.curve ? b2.push(null) : b2.push(h2), v2.push(X2);
          var H2 = this.lineHelpers.calculatePoints({ series: s2, x: l2, y: h2, realIndex: o2, i: n2, j: Y2, prevY: C2 }), D2 = this._createPaths({ type: a2, series: s2, i: n2, realIndex: o2, j: Y2, x: l2, y: h2, y2: X2, xArrj: f2, yArrj: b2, y2Arrj: v2, linePath: L2, areaPath: P2, linePaths: d2, areaPaths: g2, seriesIndex: u5, isRangeStart: y2 });
          g2 = D2.areaPaths, d2 = D2.linePaths, P2 = D2.areaPath, L2 = D2.linePath, !this.appendPathFrom || "smooth" === k2.config.stroke.curve && "rangeArea" === a2 || (I2 += A2.line(l2, this.zeroY), T2 += A2.line(l2, this.zeroY)), this.handleNullDataPoints(s2, H2, n2, Y2, o2), this._handleMarkersAndLabels({ type: a2, pointsPos: H2, i: n2, j: Y2, realIndex: o2, isRangeStart: y2 });
        }
        return { yArrj: b2, xArrj: f2, pathFromArea: T2, areaPaths: g2, pathFromLine: I2, linePaths: d2, linePath: L2, areaPath: P2 };
      } }, { key: "_handleMarkersAndLabels", value: function(t3) {
        var e2 = t3.type, i2 = t3.pointsPos, a2 = t3.isRangeStart, s2 = t3.i, r2 = t3.j, o2 = t3.realIndex, n2 = this.w, l2 = new O(this.ctx);
        if (this.pointsChart)
          this.scatter.draw(this.elSeries, r2, { realIndex: o2, pointsPos: i2, zRatio: this.zRatio, elParent: this.elPointsMain });
        else {
          n2.globals.series[s2].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
          var h2 = this.markers.plotChartMarkers(i2, o2, r2 + 1);
          null !== h2 && this.elPointsMain.add(h2);
        }
        var c2 = l2.drawDataLabel({ type: e2, isRangeStart: a2, pos: i2, i: o2, j: r2 + 1 });
        null !== c2 && this.elDataLabelsWrap.add(c2);
      } }, { key: "_createPaths", value: function(t3) {
        var e2 = t3.type, i2 = t3.series, a2 = t3.i, s2 = t3.realIndex, r2 = t3.j, o2 = t3.x, n2 = t3.y, l2 = t3.xArrj, h2 = t3.yArrj, c2 = t3.y2, d2 = t3.y2Arrj, g2 = t3.linePath, u5 = t3.areaPath, p2 = t3.linePaths, f2 = t3.areaPaths, x2 = t3.seriesIndex, b2 = t3.isRangeStart, v2 = this.w, y2 = new m(this.ctx), w2 = v2.config.stroke.curve, k2 = this.areaBottomY;
        if (Array.isArray(v2.config.stroke.curve) && (w2 = Array.isArray(x2) ? v2.config.stroke.curve[x2[a2]] : v2.config.stroke.curve[a2]), "rangeArea" === e2 && (v2.globals.hasNullValues || v2.config.forecastDataPoints.count > 0) && "smooth" === w2 && (w2 = "straight"), "smooth" === w2) {
          var A2 = "rangeArea" === e2 ? l2.length === v2.globals.dataPoints : r2 === i2[a2].length - 2, S2 = l2.map(function(t4, e3) {
            return [l2[e3], h2[e3]];
          }).filter(function(t4) {
            return null !== t4[1];
          });
          if (A2 && S2.length > 1) {
            var C2 = Et(S2);
            if (g2 += Xt(C2, v2.globals.gridWidth), null === i2[a2][0] ? u5 = g2 : u5 += Xt(C2, v2.globals.gridWidth), "rangeArea" === e2 && b2) {
              g2 += y2.line(l2[l2.length - 1], d2[d2.length - 1]);
              var L2 = l2.slice().reverse(), P2 = d2.slice().reverse(), I2 = L2.map(function(t4, e3) {
                return [L2[e3], P2[e3]];
              }), T2 = Et(I2);
              u5 = g2 += Xt(T2, v2.globals.gridWidth);
            } else
              u5 += y2.line(S2[S2.length - 1][0], k2) + y2.line(S2[0][0], k2) + y2.move(S2[0][0], S2[0][1]) + "z";
            p2.push(g2), f2.push(u5);
          }
        } else {
          if (null === i2[a2][r2 + 1]) {
            g2 += y2.move(o2, n2);
            var M2 = v2.globals.isXNumeric ? (v2.globals.seriesX[s2][r2] - v2.globals.minX) / this.xRatio : o2 - this.xDivision;
            u5 = u5 + y2.line(M2, k2) + y2.move(o2, n2) + "z";
          }
          null === i2[a2][r2] && (g2 += y2.move(o2, n2), u5 += y2.move(o2, k2)), "stepline" === w2 ? (g2 = g2 + y2.line(o2, null, "H") + y2.line(null, n2, "V"), u5 = u5 + y2.line(o2, null, "H") + y2.line(null, n2, "V")) : "straight" === w2 && (g2 += y2.line(o2, n2), u5 += y2.line(o2, n2)), r2 === i2[a2].length - 2 && (u5 = u5 + y2.line(o2, k2) + y2.move(o2, n2) + "z", "rangeArea" === e2 && b2 ? g2 = g2 + y2.line(o2, c2) + y2.move(o2, c2) + "z" : (p2.push(g2), f2.push(u5)));
        }
        return { linePaths: p2, areaPaths: f2, linePath: g2, areaPath: u5 };
      } }, { key: "handleNullDataPoints", value: function(t3, e2, i2, a2, s2) {
        var r2 = this.w;
        if (null === t3[i2][a2] && r2.config.markers.showNullDataPoints || 1 === t3[i2].length) {
          var o2 = this.markers.plotChartMarkers(e2, s2, a2 + 1, this.strokeWidth - r2.config.markers.strokeWidth / 2, true);
          null !== o2 && this.elPointsMain.add(o2);
        }
      } }]), t2;
    }();
    window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
      function t2(e3, i3, a3, s3) {
        this.xoffset = e3, this.yoffset = i3, this.height = s3, this.width = a3, this.shortestEdge = function() {
          return Math.min(this.height, this.width);
        }, this.getCoordinates = function(t3) {
          var e4, i4 = [], a4 = this.xoffset, s4 = this.yoffset, o3 = r2(t3) / this.height, n2 = r2(t3) / this.width;
          if (this.width >= this.height)
            for (e4 = 0; e4 < t3.length; e4++)
              i4.push([a4, s4, a4 + o3, s4 + t3[e4] / o3]), s4 += t3[e4] / o3;
          else
            for (e4 = 0; e4 < t3.length; e4++)
              i4.push([a4, s4, a4 + t3[e4] / n2, s4 + n2]), a4 += t3[e4] / n2;
          return i4;
        }, this.cutArea = function(e4) {
          var i4;
          if (this.width >= this.height) {
            var a4 = e4 / this.height, s4 = this.width - a4;
            i4 = new t2(this.xoffset + a4, this.yoffset, s4, this.height);
          } else {
            var r3 = e4 / this.width, o3 = this.height - r3;
            i4 = new t2(this.xoffset, this.yoffset + r3, this.width, o3);
          }
          return i4;
        };
      }
      function e2(e3, a3, s3, o3, n2) {
        o3 = void 0 === o3 ? 0 : o3, n2 = void 0 === n2 ? 0 : n2;
        var l2 = i2(function(t3, e4) {
          var i3, a4 = [], s4 = e4 / r2(t3);
          for (i3 = 0; i3 < t3.length; i3++)
            a4[i3] = t3[i3] * s4;
          return a4;
        }(e3, a3 * s3), [], new t2(o3, n2, a3, s3), []);
        return function(t3) {
          var e4, i3, a4 = [];
          for (e4 = 0; e4 < t3.length; e4++)
            for (i3 = 0; i3 < t3[e4].length; i3++)
              a4.push(t3[e4][i3]);
          return a4;
        }(l2);
      }
      function i2(t3, e3, s3, o3) {
        var n2, l2, h2;
        if (0 !== t3.length)
          return n2 = s3.shortestEdge(), function(t4, e4, i3) {
            var s4;
            if (0 === t4.length)
              return true;
            (s4 = t4.slice()).push(e4);
            var r3 = a2(t4, i3), o4 = a2(s4, i3);
            return r3 >= o4;
          }(e3, l2 = t3[0], n2) ? (e3.push(l2), i2(t3.slice(1), e3, s3, o3)) : (h2 = s3.cutArea(r2(e3), o3), o3.push(s3.getCoordinates(e3)), i2(t3, [], h2, o3)), o3;
        o3.push(s3.getCoordinates(e3));
      }
      function a2(t3, e3) {
        var i3 = Math.min.apply(Math, t3), a3 = Math.max.apply(Math, t3), s3 = r2(t3);
        return Math.max(Math.pow(e3, 2) * a3 / Math.pow(s3, 2), Math.pow(s3, 2) / (Math.pow(e3, 2) * i3));
      }
      function s2(t3) {
        return t3 && t3.constructor === Array;
      }
      function r2(t3) {
        var e3, i3 = 0;
        for (e3 = 0; e3 < t3.length; e3++)
          i3 += t3[e3];
        return i3;
      }
      function o2(t3) {
        var e3, i3 = 0;
        if (s2(t3[0]))
          for (e3 = 0; e3 < t3.length; e3++)
            i3 += o2(t3[e3]);
        else
          i3 = r2(t3);
        return i3;
      }
      return function t3(i3, a3, r3, n2, l2) {
        n2 = void 0 === n2 ? 0 : n2, l2 = void 0 === l2 ? 0 : l2;
        var h2, c2, d2 = [], g2 = [];
        if (s2(i3[0])) {
          for (c2 = 0; c2 < i3.length; c2++)
            d2[c2] = o2(i3[c2]);
          for (h2 = e2(d2, a3, r3, n2, l2), c2 = 0; c2 < i3.length; c2++)
            g2.push(t3(i3[c2], h2[c2][2] - h2[c2][0], h2[c2][3] - h2[c2][1], h2[c2][0], h2[c2][1]));
        } else
          g2 = e2(i3, a3, r3, n2, l2);
        return g2;
      };
    }();
    var Rt;
    var Ht;
    var Dt = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new At(e2), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
      }
      return r(t2, [{ key: "draw", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = new R(this.ctx), r2 = a2.group({ class: "apexcharts-treemap" });
        if (i2.globals.noData)
          return r2;
        var o2 = [];
        return t3.forEach(function(t4) {
          var e3 = t4.map(function(t5) {
            return Math.abs(t5);
          });
          o2.push(e3);
        }), this.negRange = this.helpers.checkColorRange(), i2.config.series.forEach(function(t4, i3) {
          t4.data.forEach(function(t5) {
            Array.isArray(e2.labels[i3]) || (e2.labels[i3] = []), e2.labels[i3].push(t5.x);
          });
        }), window.TreemapSquared.generate(o2, i2.globals.gridWidth, i2.globals.gridHeight).forEach(function(o3, n2) {
          var l2 = a2.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: x.escapeString(i2.globals.seriesNames[n2]), rel: n2 + 1, "data:realIndex": n2 });
          if (i2.config.chart.dropShadow.enabled) {
            var h2 = i2.config.chart.dropShadow;
            new v(e2.ctx).dropShadow(r2, h2, n2);
          }
          var c2 = a2.group({ class: "apexcharts-data-labels" });
          o3.forEach(function(r3, o4) {
            var h3 = r3[0], c3 = r3[1], d2 = r3[2], g2 = r3[3], u5 = a2.drawRect(h3, c3, d2 - h3, g2 - c3, 0, "#fff", 1, e2.strokeWidth, i2.config.plotOptions.treemap.useFillColorAsStroke ? f2 : i2.globals.stroke.colors[n2]);
            u5.attr({ cx: h3, cy: c3, index: n2, i: n2, j: o4, width: d2 - h3, height: g2 - c3 });
            var p2 = e2.helpers.getShadeColor(i2.config.chart.type, n2, o4, e2.negRange), f2 = p2.color;
            void 0 !== i2.config.series[n2].data[o4] && i2.config.series[n2].data[o4].fillColor && (f2 = i2.config.series[n2].data[o4].fillColor);
            var x2 = s2.fillPath({ color: f2, seriesNumber: n2, dataPointIndex: o4 });
            u5.node.classList.add("apexcharts-treemap-rect"), u5.attr({ fill: x2 }), e2.helpers.addListeners(u5);
            var b2 = { x: h3 + (d2 - h3) / 2, y: c3 + (g2 - c3) / 2, width: 0, height: 0 }, v2 = { x: h3, y: c3, width: d2 - h3, height: g2 - c3 };
            if (i2.config.chart.animations.enabled && !i2.globals.dataChanged) {
              var m2 = 1;
              i2.globals.resized || (m2 = i2.config.chart.animations.speed), e2.animateTreemap(u5, b2, v2, m2);
            }
            if (i2.globals.dataChanged) {
              var y2 = 1;
              e2.dynamicAnim.enabled && i2.globals.shouldAnimate && (y2 = e2.dynamicAnim.speed, i2.globals.previousPaths[n2] && i2.globals.previousPaths[n2][o4] && i2.globals.previousPaths[n2][o4].rect && (b2 = i2.globals.previousPaths[n2][o4].rect), e2.animateTreemap(u5, b2, v2, y2));
            }
            var w2 = e2.getFontSize(r3), k2 = i2.config.dataLabels.formatter(e2.labels[n2][o4], { value: i2.globals.series[n2][o4], seriesIndex: n2, dataPointIndex: o4, w: i2 });
            "truncate" === i2.config.plotOptions.treemap.dataLabels.format && (w2 = parseInt(i2.config.dataLabels.style.fontSize, 10), k2 = e2.truncateLabels(k2, w2, h3, c3, d2, g2));
            var A2 = e2.helpers.calculateDataLabels({ text: k2, x: (h3 + d2) / 2, y: (c3 + g2) / 2 + e2.strokeWidth / 2 + w2 / 3, i: n2, j: o4, colorProps: p2, fontSize: w2, series: t3 });
            i2.config.dataLabels.enabled && A2 && e2.rotateToFitLabel(A2, w2, k2, h3, c3, d2, g2), l2.add(u5), null !== A2 && l2.add(A2);
          }), l2.add(c2), r2.add(l2);
        }), r2;
      } }, { key: "getFontSize", value: function(t3) {
        var e2 = this.w;
        var i2, a2, s2, r2, o2 = function t4(e3) {
          var i3, a3 = 0;
          if (Array.isArray(e3[0]))
            for (i3 = 0; i3 < e3.length; i3++)
              a3 += t4(e3[i3]);
          else
            for (i3 = 0; i3 < e3.length; i3++)
              a3 += e3[i3].length;
          return a3;
        }(this.labels) / function t4(e3) {
          var i3, a3 = 0;
          if (Array.isArray(e3[0]))
            for (i3 = 0; i3 < e3.length; i3++)
              a3 += t4(e3[i3]);
          else
            for (i3 = 0; i3 < e3.length; i3++)
              a3 += 1;
          return a3;
        }(this.labels);
        return i2 = t3[2] - t3[0], a2 = t3[3] - t3[1], s2 = i2 * a2, r2 = Math.pow(s2, 0.5), Math.min(r2 / o2, parseInt(e2.config.dataLabels.style.fontSize, 10));
      } }, { key: "rotateToFitLabel", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = new m(this.ctx), l2 = n2.getTextRects(i2, e2);
        if (l2.width + this.w.config.stroke.width + 5 > r2 - a2 && l2.width <= o2 - s2) {
          var h2 = n2.rotateAroundCenter(t3.node);
          t3.node.setAttribute("transform", "rotate(-90 ".concat(h2.x, " ").concat(h2.y, ") translate(").concat(l2.height / 3, ")"));
        }
      } }, { key: "truncateLabels", value: function(t3, e2, i2, a2, s2, r2) {
        var o2 = new m(this.ctx), n2 = o2.getTextRects(t3, e2).width + this.w.config.stroke.width + 5 > s2 - i2 && r2 - a2 > s2 - i2 ? r2 - a2 : s2 - i2, l2 = o2.getTextBasedOnMaxWidth({ text: t3, maxWidth: n2, fontSize: e2 });
        return t3.length !== l2.length && n2 / e2 < 5 ? "" : l2;
      } }, { key: "animateTreemap", value: function(t3, e2, i2, a2) {
        var s2 = new b(this.ctx);
        s2.animateRect(t3, { x: e2.x, y: e2.y, width: e2.width, height: e2.height }, { x: i2.x, y: i2.y, width: i2.width, height: i2.height }, a2, function() {
          s2.animationCompleted(t3);
        });
      } }]), t2;
    }();
    var Ot = 86400;
    var Nt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
      }
      return r(t2, [{ key: "calculateTimeScaleTicks", value: function(t3, i2) {
        var a2 = this, s2 = this.w;
        if (s2.globals.allSeriesCollapsed)
          return s2.globals.labels = [], s2.globals.timescaleLabels = [], [];
        var r2 = new I(this.ctx), o2 = (i2 - t3) / 864e5;
        this.determineInterval(o2), s2.globals.disableZoomIn = false, s2.globals.disableZoomOut = false, o2 < 11574074074074075e-20 ? s2.globals.disableZoomIn = true : o2 > 5e4 && (s2.globals.disableZoomOut = true);
        var n2 = r2.getTimeUnitsfromTimestamp(t3, i2, this.utc), l2 = s2.globals.gridWidth / o2, h2 = l2 / 24, c2 = h2 / 60, d2 = c2 / 60, g2 = Math.floor(24 * o2), u5 = Math.floor(1440 * o2), p2 = Math.floor(o2 * Ot), f2 = Math.floor(o2), x2 = Math.floor(o2 / 30), b2 = Math.floor(o2 / 365), v2 = { minMillisecond: n2.minMillisecond, minSecond: n2.minSecond, minMinute: n2.minMinute, minHour: n2.minHour, minDate: n2.minDate, minMonth: n2.minMonth, minYear: n2.minYear }, m2 = { firstVal: v2, currentMillisecond: v2.minMillisecond, currentSecond: v2.minSecond, currentMinute: v2.minMinute, currentHour: v2.minHour, currentMonthDate: v2.minDate, currentDate: v2.minDate, currentMonth: v2.minMonth, currentYear: v2.minYear, daysWidthOnXAxis: l2, hoursWidthOnXAxis: h2, minutesWidthOnXAxis: c2, secondsWidthOnXAxis: d2, numberOfSeconds: p2, numberOfMinutes: u5, numberOfHours: g2, numberOfDays: f2, numberOfMonths: x2, numberOfYears: b2 };
        switch (this.tickInterval) {
          case "years":
            this.generateYearScale(m2);
            break;
          case "months":
          case "half_year":
            this.generateMonthScale(m2);
            break;
          case "months_days":
          case "months_fortnight":
          case "days":
          case "week_days":
            this.generateDayScale(m2);
            break;
          case "hours":
            this.generateHourScale(m2);
            break;
          case "minutes_fives":
          case "minutes":
            this.generateMinuteScale(m2);
            break;
          case "seconds_tens":
          case "seconds_fives":
          case "seconds":
            this.generateSecondScale(m2);
        }
        var y2 = this.timeScaleArray.map(function(t4) {
          var i3 = { position: t4.position, unit: t4.unit, year: t4.year, day: t4.day ? t4.day : 1, hour: t4.hour ? t4.hour : 0, month: t4.month + 1 };
          return "month" === t4.unit ? e(e({}, i3), {}, { day: 1, value: t4.value + 1 }) : "day" === t4.unit || "hour" === t4.unit ? e(e({}, i3), {}, { value: t4.value }) : "minute" === t4.unit ? e(e({}, i3), {}, { value: t4.value, minute: t4.value }) : "second" === t4.unit ? e(e({}, i3), {}, { value: t4.value, minute: t4.minute, second: t4.second }) : t4;
        });
        return y2.filter(function(t4) {
          var e2 = 1, i3 = Math.ceil(s2.globals.gridWidth / 120), r3 = t4.value;
          void 0 !== s2.config.xaxis.tickAmount && (i3 = s2.config.xaxis.tickAmount), y2.length > i3 && (e2 = Math.floor(y2.length / i3));
          var o3 = false, n3 = false;
          switch (a2.tickInterval) {
            case "years":
              "year" === t4.unit && (o3 = true);
              break;
            case "half_year":
              e2 = 7, "year" === t4.unit && (o3 = true);
              break;
            case "months":
              e2 = 1, "year" === t4.unit && (o3 = true);
              break;
            case "months_fortnight":
              e2 = 15, "year" !== t4.unit && "month" !== t4.unit || (o3 = true), 30 === r3 && (n3 = true);
              break;
            case "months_days":
              e2 = 10, "month" === t4.unit && (o3 = true), 30 === r3 && (n3 = true);
              break;
            case "week_days":
              e2 = 8, "month" === t4.unit && (o3 = true);
              break;
            case "days":
              e2 = 1, "month" === t4.unit && (o3 = true);
              break;
            case "hours":
              "day" === t4.unit && (o3 = true);
              break;
            case "minutes_fives":
            case "seconds_fives":
              r3 % 5 != 0 && (n3 = true);
              break;
            case "seconds_tens":
              r3 % 10 != 0 && (n3 = true);
          }
          if ("hours" === a2.tickInterval || "minutes_fives" === a2.tickInterval || "seconds_tens" === a2.tickInterval || "seconds_fives" === a2.tickInterval) {
            if (!n3)
              return true;
          } else if ((r3 % e2 == 0 || o3) && !n3)
            return true;
        });
      } }, { key: "recalcDimensionsBasedOnFormat", value: function(t3, e2) {
        var i2 = this.w, a2 = this.formatDates(t3), s2 = this.removeOverlappingTS(a2);
        i2.globals.timescaleLabels = s2.slice(), new ot(this.ctx).plotCoords();
      } }, { key: "determineInterval", value: function(t3) {
        var e2 = 24 * t3, i2 = 60 * e2;
        switch (true) {
          case t3 / 365 > 5:
            this.tickInterval = "years";
            break;
          case t3 > 800:
            this.tickInterval = "half_year";
            break;
          case t3 > 180:
            this.tickInterval = "months";
            break;
          case t3 > 90:
            this.tickInterval = "months_fortnight";
            break;
          case t3 > 60:
            this.tickInterval = "months_days";
            break;
          case t3 > 30:
            this.tickInterval = "week_days";
            break;
          case t3 > 2:
            this.tickInterval = "days";
            break;
          case e2 > 2.4:
            this.tickInterval = "hours";
            break;
          case i2 > 15:
            this.tickInterval = "minutes_fives";
            break;
          case i2 > 5:
            this.tickInterval = "minutes";
            break;
          case i2 > 1:
            this.tickInterval = "seconds_tens";
            break;
          case 60 * i2 > 20:
            this.tickInterval = "seconds_fives";
            break;
          default:
            this.tickInterval = "seconds";
        }
      } }, { key: "generateYearScale", value: function(t3) {
        var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.daysWidthOnXAxis, r2 = t3.numberOfYears, o2 = e2.minYear, n2 = 0, l2 = new I(this.ctx), h2 = "year";
        if (e2.minDate > 1 || e2.minMonth > 0) {
          var c2 = l2.determineRemainingDaysOfYear(e2.minYear, e2.minMonth, e2.minDate);
          n2 = (l2.determineDaysOfYear(e2.minYear) - c2 + 1) * s2, o2 = e2.minYear + 1, this.timeScaleArray.push({ position: n2, value: o2, unit: h2, year: o2, month: x.monthMod(i2 + 1) });
        } else
          1 === e2.minDate && 0 === e2.minMonth && this.timeScaleArray.push({ position: n2, value: o2, unit: h2, year: a2, month: x.monthMod(i2 + 1) });
        for (var d2 = o2, g2 = n2, u5 = 0; u5 < r2; u5++)
          d2++, g2 = l2.determineDaysOfYear(d2 - 1) * s2 + g2, this.timeScaleArray.push({ position: g2, value: d2, unit: h2, year: d2, month: 1 });
      } }, { key: "generateMonthScale", value: function(t3) {
        var e2 = t3.firstVal, i2 = t3.currentMonthDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.daysWidthOnXAxis, o2 = t3.numberOfMonths, n2 = a2, l2 = 0, h2 = new I(this.ctx), c2 = "month", d2 = 0;
        if (e2.minDate > 1) {
          l2 = (h2.determineDaysOfMonths(a2 + 1, e2.minYear) - i2 + 1) * r2, n2 = x.monthMod(a2 + 1);
          var g2 = s2 + d2, u5 = x.monthMod(n2), p2 = n2;
          0 === n2 && (c2 = "year", p2 = g2, u5 = 1, g2 += d2 += 1), this.timeScaleArray.push({ position: l2, value: p2, unit: c2, year: g2, month: u5 });
        } else
          this.timeScaleArray.push({ position: l2, value: n2, unit: c2, year: s2, month: x.monthMod(a2) });
        for (var f2 = n2 + 1, b2 = l2, v2 = 0, m2 = 1; v2 < o2; v2++, m2++) {
          0 === (f2 = x.monthMod(f2)) ? (c2 = "year", d2 += 1) : c2 = "month";
          var y2 = this._getYear(s2, f2, d2);
          b2 = h2.determineDaysOfMonths(f2, y2) * r2 + b2;
          var w2 = 0 === f2 ? y2 : f2;
          this.timeScaleArray.push({ position: b2, value: w2, unit: c2, year: y2, month: 0 === f2 ? 1 : f2 }), f2++;
        }
      } }, { key: "generateDayScale", value: function(t3) {
        var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.hoursWidthOnXAxis, r2 = t3.numberOfDays, o2 = new I(this.ctx), n2 = "day", l2 = e2.minDate + 1, h2 = l2, c2 = function(t4, e3, i3) {
          return t4 > o2.determineDaysOfMonths(e3 + 1, i3) ? (h2 = 1, n2 = "month", g2 = e3 += 1, e3) : e3;
        }, d2 = (24 - e2.minHour) * s2, g2 = l2, u5 = c2(h2, i2, a2);
        0 === e2.minHour && 1 === e2.minDate ? (d2 = 0, g2 = x.monthMod(e2.minMonth), n2 = "month", h2 = e2.minDate) : 1 !== e2.minDate && 0 === e2.minHour && 0 === e2.minMinute && (d2 = 0, l2 = e2.minDate, g2 = l2, u5 = c2(h2 = l2, i2, a2)), this.timeScaleArray.push({ position: d2, value: g2, unit: n2, year: this._getYear(a2, u5, 0), month: x.monthMod(u5), day: h2 });
        for (var p2 = d2, f2 = 0; f2 < r2; f2++) {
          n2 = "day", u5 = c2(h2 += 1, u5, this._getYear(a2, u5, 0));
          var b2 = this._getYear(a2, u5, 0);
          p2 = 24 * s2 + p2;
          var v2 = 1 === h2 ? x.monthMod(u5) : h2;
          this.timeScaleArray.push({ position: p2, value: v2, unit: n2, year: b2, month: x.monthMod(u5), day: v2 });
        }
      } }, { key: "generateHourScale", value: function(t3) {
        var e2 = t3.firstVal, i2 = t3.currentDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.minutesWidthOnXAxis, o2 = t3.numberOfHours, n2 = new I(this.ctx), l2 = "hour", h2 = function(t4, e3) {
          return t4 > n2.determineDaysOfMonths(e3 + 1, s2) && (f2 = 1, e3 += 1), { month: e3, date: f2 };
        }, c2 = function(t4, e3) {
          return t4 > n2.determineDaysOfMonths(e3 + 1, s2) ? e3 += 1 : e3;
        }, d2 = 60 - (e2.minMinute + e2.minSecond / 60), g2 = d2 * r2, u5 = e2.minHour + 1, p2 = u5;
        60 === d2 && (g2 = 0, p2 = u5 = e2.minHour);
        var f2 = i2;
        p2 >= 24 && (p2 = 0, f2 += 1, l2 = "day");
        var b2 = h2(f2, a2).month;
        b2 = c2(f2, b2), this.timeScaleArray.push({ position: g2, value: u5, unit: l2, day: f2, hour: p2, year: s2, month: x.monthMod(b2) }), p2++;
        for (var v2 = g2, m2 = 0; m2 < o2; m2++) {
          if (l2 = "hour", p2 >= 24)
            p2 = 0, l2 = "day", b2 = h2(f2 += 1, b2).month, b2 = c2(f2, b2);
          var y2 = this._getYear(s2, b2, 0);
          v2 = 60 * r2 + v2;
          var w2 = 0 === p2 ? f2 : p2;
          this.timeScaleArray.push({ position: v2, value: w2, unit: l2, hour: p2, day: f2, year: y2, month: x.monthMod(b2) }), p2++;
        }
      } }, { key: "generateMinuteScale", value: function(t3) {
        for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, o2 = t3.currentMonth, n2 = t3.currentYear, l2 = t3.minutesWidthOnXAxis, h2 = t3.secondsWidthOnXAxis, c2 = t3.numberOfMinutes, d2 = a2 + 1, g2 = r2, u5 = o2, p2 = n2, f2 = s2, b2 = (60 - i2 - e2 / 1e3) * h2, v2 = 0; v2 < c2; v2++)
          d2 >= 60 && (d2 = 0, 24 === (f2 += 1) && (f2 = 0)), this.timeScaleArray.push({ position: b2, value: d2, unit: "minute", hour: f2, minute: d2, day: g2, year: this._getYear(p2, u5, 0), month: x.monthMod(u5) }), b2 += l2, d2++;
      } }, { key: "generateSecondScale", value: function(t3) {
        for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, o2 = t3.currentMonth, n2 = t3.currentYear, l2 = t3.secondsWidthOnXAxis, h2 = t3.numberOfSeconds, c2 = i2 + 1, d2 = a2, g2 = r2, u5 = o2, p2 = n2, f2 = s2, b2 = (1e3 - e2) / 1e3 * l2, v2 = 0; v2 < h2; v2++)
          c2 >= 60 && (c2 = 0, ++d2 >= 60 && (d2 = 0, 24 === ++f2 && (f2 = 0))), this.timeScaleArray.push({ position: b2, value: c2, unit: "second", hour: f2, minute: d2, second: c2, day: g2, year: this._getYear(p2, u5, 0), month: x.monthMod(u5) }), b2 += l2, c2++;
      } }, { key: "createRawDateString", value: function(t3, e2) {
        var i2 = t3.year;
        return 0 === t3.month && (t3.month = 1), i2 += "-" + ("0" + t3.month.toString()).slice(-2), "day" === t3.unit ? i2 += "day" === t3.unit ? "-" + ("0" + e2).slice(-2) : "-01" : i2 += "-" + ("0" + (t3.day ? t3.day : "1")).slice(-2), "hour" === t3.unit ? i2 += "hour" === t3.unit ? "T" + ("0" + e2).slice(-2) : "T00" : i2 += "T" + ("0" + (t3.hour ? t3.hour : "0")).slice(-2), "minute" === t3.unit ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":" + (t3.minute ? ("0" + t3.minute).slice(-2) : "00"), "second" === t3.unit ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":00", this.utc && (i2 += ".000Z"), i2;
      } }, { key: "formatDates", value: function(t3) {
        var e2 = this, i2 = this.w;
        return t3.map(function(t4) {
          var a2 = t4.value.toString(), s2 = new I(e2.ctx), r2 = e2.createRawDateString(t4, a2), o2 = s2.getDate(s2.parseDate(r2));
          if (e2.utc || (o2 = s2.getDate(s2.parseDateWithTimezone(r2))), void 0 === i2.config.xaxis.labels.format) {
            var n2 = "dd MMM", l2 = i2.config.xaxis.labels.datetimeFormatter;
            "year" === t4.unit && (n2 = l2.year), "month" === t4.unit && (n2 = l2.month), "day" === t4.unit && (n2 = l2.day), "hour" === t4.unit && (n2 = l2.hour), "minute" === t4.unit && (n2 = l2.minute), "second" === t4.unit && (n2 = l2.second), a2 = s2.formatDate(o2, n2);
          } else
            a2 = s2.formatDate(o2, i2.config.xaxis.labels.format);
          return { dateString: r2, position: t4.position, value: a2, unit: t4.unit, year: t4.year, month: t4.month };
        });
      } }, { key: "removeOverlappingTS", value: function(t3) {
        var e2, i2 = this, a2 = new m(this.ctx), s2 = false;
        t3.length > 0 && t3[0].value && t3.every(function(e3) {
          return e3.value.length === t3[0].value.length;
        }) && (s2 = true, e2 = a2.getTextRects(t3[0].value).width);
        var r2 = 0, o2 = t3.map(function(o3, n2) {
          if (n2 > 0 && i2.w.config.xaxis.labels.hideOverlappingLabels) {
            var l2 = s2 ? e2 : a2.getTextRects(t3[r2].value).width, h2 = t3[r2].position;
            return o3.position > h2 + l2 + 10 ? (r2 = n2, o3) : null;
          }
          return o3;
        });
        return o2 = o2.filter(function(t4) {
          return null !== t4;
        });
      } }, { key: "_getYear", value: function(t3, e2, i2) {
        return t3 + Math.floor(e2 / 12) + i2;
      } }]), t2;
    }();
    var Wt = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = i2, this.w = i2.w, this.el = e2;
      }
      return r(t2, [{ key: "setupElements", value: function() {
        var t3 = this.w.globals, e2 = this.w.config, i2 = e2.chart.type;
        t3.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i2) > -1, t3.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i2) > -1, t3.isBarHorizontal = ("bar" === e2.chart.type || "rangeBar" === e2.chart.type || "boxPlot" === e2.chart.type) && e2.plotOptions.bar.horizontal, t3.chartClass = ".apexcharts" + t3.chartID, t3.dom.baseEl = this.el, t3.dom.elWrap = document.createElement("div"), m.setAttrs(t3.dom.elWrap, { id: t3.chartClass.substring(1), class: "apexcharts-canvas " + t3.chartClass.substring(1) }), this.el.appendChild(t3.dom.elWrap), t3.dom.Paper = new window.SVG.Doc(t3.dom.elWrap), t3.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(e2.chart.offsetX, ", ").concat(e2.chart.offsetY, ")") }), t3.dom.Paper.node.style.background = "dark" !== e2.theme.mode || e2.chart.background ? e2.chart.background : "rgba(0, 0, 0, 0.8)", this.setSVGDimensions(), t3.dom.elLegendForeign = document.createElementNS(t3.SVGNS, "foreignObject"), m.setAttrs(t3.dom.elLegendForeign, { x: 0, y: 0, width: t3.svgWidth, height: t3.svgHeight }), t3.dom.elLegendWrap = document.createElement("div"), t3.dom.elLegendWrap.classList.add("apexcharts-legend"), t3.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), t3.dom.elLegendForeign.appendChild(t3.dom.elLegendWrap), t3.dom.Paper.node.appendChild(t3.dom.elLegendForeign), t3.dom.elGraphical = t3.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t3.dom.elDefs = t3.dom.Paper.defs(), t3.dom.Paper.add(t3.dom.elGraphical), t3.dom.elGraphical.add(t3.dom.elDefs);
      } }, { key: "plotChartType", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.config, s2 = i2.globals, r2 = { series: [], i: [] }, o2 = { series: [], i: [] }, n2 = { series: [], i: [] }, l2 = { series: [], i: [] }, h2 = { series: [], i: [] }, c2 = { series: [], i: [] }, d2 = { series: [], i: [] }, g2 = { series: [], i: [] }, u5 = { series: [], seriesRangeEnd: [], i: [] };
        s2.series.map(function(e3, p3) {
          var f3 = 0;
          void 0 !== t3[p3].type ? ("column" === t3[p3].type || "bar" === t3[p3].type ? (s2.series.length > 1 && a2.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), h2.series.push(e3), h2.i.push(p3), f3++, i2.globals.columnSeries = h2.series) : "area" === t3[p3].type ? (o2.series.push(e3), o2.i.push(p3), f3++) : "line" === t3[p3].type ? (r2.series.push(e3), r2.i.push(p3), f3++) : "scatter" === t3[p3].type ? (n2.series.push(e3), n2.i.push(p3)) : "bubble" === t3[p3].type ? (l2.series.push(e3), l2.i.push(p3), f3++) : "candlestick" === t3[p3].type ? (c2.series.push(e3), c2.i.push(p3), f3++) : "boxPlot" === t3[p3].type ? (d2.series.push(e3), d2.i.push(p3), f3++) : "rangeBar" === t3[p3].type ? (g2.series.push(e3), g2.i.push(p3), f3++) : "rangeArea" === t3[p3].type ? (u5.series.push(s2.seriesRangeStart[p3]), u5.seriesRangeEnd.push(s2.seriesRangeEnd[p3]), u5.i.push(p3), f3++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"), f3 > 1 && (s2.comboCharts = true)) : (r2.series.push(e3), r2.i.push(p3));
        });
        var p2 = new Ft(this.ctx, e2), f2 = new kt(this.ctx, e2);
        this.ctx.pie = new Lt(this.ctx);
        var x2 = new It(this.ctx);
        this.ctx.rangeBar = new Tt(this.ctx, e2);
        var b2 = new Pt(this.ctx), v2 = [];
        if (s2.comboCharts) {
          if (o2.series.length > 0 && v2.push(p2.draw(o2.series, "area", o2.i)), h2.series.length > 0)
            if (i2.config.chart.stacked) {
              var m2 = new wt(this.ctx, e2);
              v2.push(m2.draw(h2.series, h2.i));
            } else
              this.ctx.bar = new yt(this.ctx, e2), v2.push(this.ctx.bar.draw(h2.series, h2.i));
          if (u5.series.length > 0 && v2.push(p2.draw(u5.series, "rangeArea", u5.i, u5.seriesRangeEnd)), r2.series.length > 0 && v2.push(p2.draw(r2.series, "line", r2.i)), c2.series.length > 0 && v2.push(f2.draw(c2.series, "candlestick", c2.i)), d2.series.length > 0 && v2.push(f2.draw(d2.series, "boxPlot", d2.i)), g2.series.length > 0 && v2.push(this.ctx.rangeBar.draw(g2.series, g2.i)), n2.series.length > 0) {
            var y2 = new Ft(this.ctx, e2, true);
            v2.push(y2.draw(n2.series, "scatter", n2.i));
          }
          if (l2.series.length > 0) {
            var w2 = new Ft(this.ctx, e2, true);
            v2.push(w2.draw(l2.series, "bubble", l2.i));
          }
        } else
          switch (a2.chart.type) {
            case "line":
              v2 = p2.draw(s2.series, "line");
              break;
            case "area":
              v2 = p2.draw(s2.series, "area");
              break;
            case "bar":
              if (a2.chart.stacked)
                v2 = new wt(this.ctx, e2).draw(s2.series);
              else
                this.ctx.bar = new yt(this.ctx, e2), v2 = this.ctx.bar.draw(s2.series);
              break;
            case "candlestick":
              v2 = new kt(this.ctx, e2).draw(s2.series, "candlestick");
              break;
            case "boxPlot":
              v2 = new kt(this.ctx, e2).draw(s2.series, a2.chart.type);
              break;
            case "rangeBar":
              v2 = this.ctx.rangeBar.draw(s2.series);
              break;
            case "rangeArea":
              v2 = p2.draw(s2.seriesRangeStart, "rangeArea", void 0, s2.seriesRangeEnd);
              break;
            case "heatmap":
              v2 = new St(this.ctx, e2).draw(s2.series);
              break;
            case "treemap":
              v2 = new Dt(this.ctx, e2).draw(s2.series);
              break;
            case "pie":
            case "donut":
            case "polarArea":
              v2 = this.ctx.pie.draw(s2.series);
              break;
            case "radialBar":
              v2 = x2.draw(s2.series);
              break;
            case "radar":
              v2 = b2.draw(s2.series);
              break;
            default:
              v2 = p2.draw(s2.series);
          }
        return v2;
      } }, { key: "setSVGDimensions", value: function() {
        var t3 = this.w.globals, e2 = this.w.config;
        t3.svgWidth = e2.chart.width, t3.svgHeight = e2.chart.height;
        var i2 = x.getDimensions(this.el), a2 = e2.chart.width.toString().split(/[0-9]+/g).pop();
        "%" === a2 ? x.isNumber(i2[0]) && (0 === i2[0].width && (i2 = x.getDimensions(this.el.parentNode)), t3.svgWidth = i2[0] * parseInt(e2.chart.width, 10) / 100) : "px" !== a2 && "" !== a2 || (t3.svgWidth = parseInt(e2.chart.width, 10));
        var s2 = e2.chart.height.toString().split(/[0-9]+/g).pop();
        if ("auto" !== t3.svgHeight && "" !== t3.svgHeight)
          if ("%" === s2) {
            var r2 = x.getDimensions(this.el.parentNode);
            t3.svgHeight = r2[1] * parseInt(e2.chart.height, 10) / 100;
          } else
            t3.svgHeight = parseInt(e2.chart.height, 10);
        else
          t3.axisCharts ? t3.svgHeight = t3.svgWidth / 1.61 : t3.svgHeight = t3.svgWidth / 1.2;
        if (t3.svgWidth < 0 && (t3.svgWidth = 0), t3.svgHeight < 0 && (t3.svgHeight = 0), m.setAttrs(t3.dom.Paper.node, { width: t3.svgWidth, height: t3.svgHeight }), "%" !== s2) {
          var o2 = e2.chart.sparkline.enabled ? 0 : t3.axisCharts ? e2.chart.parentHeightOffset : 0;
          t3.dom.Paper.node.parentNode.parentNode.style.minHeight = t3.svgHeight + o2 + "px";
        }
        t3.dom.elWrap.style.width = t3.svgWidth + "px", t3.dom.elWrap.style.height = t3.svgHeight + "px";
      } }, { key: "shiftGraphPosition", value: function() {
        var t3 = this.w.globals, e2 = t3.translateY, i2 = { transform: "translate(" + t3.translateX + ", " + e2 + ")" };
        m.setAttrs(t3.dom.elGraphical.node, i2);
      } }, { key: "resizeNonAxisCharts", value: function() {
        var t3 = this.w, e2 = t3.globals, i2 = 0, a2 = t3.config.chart.sparkline.enabled ? 1 : 15;
        a2 += t3.config.grid.padding.bottom, "top" !== t3.config.legend.position && "bottom" !== t3.config.legend.position || !t3.config.legend.show || t3.config.legend.floating || (i2 = new lt(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
        var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r2 = 2.05 * t3.globals.radialSize;
        if (s2 && !t3.config.chart.sparkline.enabled && 0 !== t3.config.plotOptions.radialBar.startAngle) {
          var o2 = x.getBoundingClientRect(s2);
          r2 = o2.bottom;
          var n2 = o2.bottom - o2.top;
          r2 = Math.max(2.05 * t3.globals.radialSize, n2);
        }
        var l2 = r2 + e2.translateY + i2 + a2;
        e2.dom.elLegendForeign && e2.dom.elLegendForeign.setAttribute("height", l2), t3.config.chart.height && String(t3.config.chart.height).indexOf("%") > 0 || (e2.dom.elWrap.style.height = l2 + "px", m.setAttrs(e2.dom.Paper.node, { height: l2 }), e2.dom.Paper.node.parentNode.parentNode.style.minHeight = l2 + "px");
      } }, { key: "coreCalculations", value: function() {
        new U(this.ctx).init();
      } }, { key: "resetGlobals", value: function() {
        var t3 = this, e2 = function() {
          return t3.w.config.series.map(function(t4) {
            return [];
          });
        }, i2 = new Y(), a2 = this.w.globals;
        i2.initGlobalVars(a2), a2.seriesXvalues = e2(), a2.seriesYvalues = e2();
      } }, { key: "isMultipleY", value: function() {
        if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
          return this.w.globals.isMultipleYAxis = true, true;
      } }, { key: "xySettings", value: function() {
        var t3 = null, e2 = this.w;
        if (e2.globals.axisCharts) {
          if ("back" === e2.config.xaxis.crosshairs.position)
            new Q(this.ctx).drawXCrosshairs();
          if ("back" === e2.config.yaxis[0].crosshairs.position)
            new Q(this.ctx).drawYCrosshairs();
          if ("datetime" === e2.config.xaxis.type && void 0 === e2.config.xaxis.labels.formatter) {
            this.ctx.timeScale = new Nt(this.ctx);
            var i2 = [];
            isFinite(e2.globals.minX) && isFinite(e2.globals.maxX) && !e2.globals.isBarHorizontal ? i2 = this.ctx.timeScale.calculateTimeScaleTicks(e2.globals.minX, e2.globals.maxX) : e2.globals.isBarHorizontal && (i2 = this.ctx.timeScale.calculateTimeScaleTicks(e2.globals.minY, e2.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i2);
          }
          t3 = new y(this.ctx).getCalculatedRatios();
        }
        return t3;
      } }, { key: "updateSourceChart", value: function(t3) {
        this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t3.w.globals.minX, max: t3.w.globals.maxX } } } }, false, false);
      } }, { key: "setupBrushHandler", value: function() {
        var t3 = this, i2 = this.w;
        if (i2.config.chart.brush.enabled && "function" != typeof i2.config.chart.events.selection) {
          var a2 = Array.isArray(i2.config.chart.brush.targets) || [i2.config.chart.brush.target];
          a2.forEach(function(e2) {
            var i3 = ApexCharts.getChartByID(e2);
            i3.w.globals.brushSource = t3.ctx, "function" != typeof i3.w.config.chart.events.zoomed && (i3.w.config.chart.events.zoomed = function() {
              t3.updateSourceChart(i3);
            }), "function" != typeof i3.w.config.chart.events.scrolled && (i3.w.config.chart.events.scrolled = function() {
              t3.updateSourceChart(i3);
            });
          }), i2.config.chart.events.selection = function(t4, s2) {
            a2.forEach(function(t5) {
              var a3 = ApexCharts.getChartByID(t5), r2 = x.clone(i2.config.yaxis);
              if (i2.config.chart.brush.autoScaleYaxis && 1 === a3.w.globals.series.length) {
                var o2 = new _(a3);
                r2 = o2.autoScaleY(a3, r2, s2);
              }
              var n2 = a3.w.config.yaxis.reduce(function(t6, i3, s3) {
                return [].concat(u4(t6), [e(e({}, a3.w.config.yaxis[s3]), {}, { min: r2[0].min, max: r2[0].max })]);
              }, []);
              a3.ctx.updateHelpers._updateOptions({ xaxis: { min: s2.xaxis.min, max: s2.xaxis.max }, yaxis: n2 }, false, false, false, false);
            });
          };
        }
      } }]), t2;
    }();
    var Bt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "_updateOptions", value: function(t3) {
        var e2 = this, a2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], s2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], o2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        return new Promise(function(n2) {
          var l2 = [e2.ctx];
          r2 && (l2 = e2.ctx.getSyncedCharts()), e2.ctx.w.globals.isExecCalled && (l2 = [e2.ctx], e2.ctx.w.globals.isExecCalled = false), l2.forEach(function(r3, h2) {
            var c2 = r3.w;
            if (c2.globals.shouldAnimate = s2, a2 || (c2.globals.resized = true, c2.globals.dataChanged = true, s2 && r3.series.getPreviousPaths()), t3 && "object" === i(t3) && (r3.config = new E(t3), t3 = y.extendArrayProps(r3.config, t3, c2), r3.w.globals.chartID !== e2.ctx.w.globals.chartID && delete t3.series, c2.config = x.extend(c2.config, t3), o2 && (c2.globals.lastXAxis = t3.xaxis ? x.clone(t3.xaxis) : [], c2.globals.lastYAxis = t3.yaxis ? x.clone(t3.yaxis) : [], c2.globals.initialConfig = x.extend({}, c2.config), c2.globals.initialSeries = x.clone(c2.config.series), t3.series))) {
              for (var d2 = 0; d2 < c2.globals.collapsedSeriesIndices.length; d2++) {
                var g2 = c2.config.series[c2.globals.collapsedSeriesIndices[d2]];
                c2.globals.collapsedSeries[d2].data = c2.globals.axisCharts ? g2.data.slice() : g2;
              }
              for (var u5 = 0; u5 < c2.globals.ancillaryCollapsedSeriesIndices.length; u5++) {
                var p2 = c2.config.series[c2.globals.ancillaryCollapsedSeriesIndices[u5]];
                c2.globals.ancillaryCollapsedSeries[u5].data = c2.globals.axisCharts ? p2.data.slice() : p2;
              }
              r3.series.emptyCollapsedSeries(c2.config.series);
            }
            return r3.update(t3).then(function() {
              h2 === l2.length - 1 && n2(r3);
            });
          });
        });
      } }, { key: "_updateSeries", value: function(t3, e2) {
        var i2 = this, a2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return new Promise(function(s2) {
          var r2, o2 = i2.w;
          return o2.globals.shouldAnimate = e2, o2.globals.dataChanged = true, e2 && i2.ctx.series.getPreviousPaths(), o2.globals.axisCharts ? (0 === (r2 = t3.map(function(t4, e3) {
            return i2._extendSeries(t4, e3);
          })).length && (r2 = [{ data: [] }]), o2.config.series = r2) : o2.config.series = t3.slice(), a2 && (o2.globals.initialConfig.series = x.clone(o2.config.series), o2.globals.initialSeries = x.clone(o2.config.series)), i2.ctx.update().then(function() {
            s2(i2.ctx);
          });
        });
      } }, { key: "_extendSeries", value: function(t3, i2) {
        var a2 = this.w, s2 = a2.config.series[i2];
        return e(e({}, a2.config.series[i2]), {}, { name: t3.name ? t3.name : null == s2 ? void 0 : s2.name, color: t3.color ? t3.color : null == s2 ? void 0 : s2.color, type: t3.type ? t3.type : null == s2 ? void 0 : s2.type, group: t3.group ? t3.group : null == s2 ? void 0 : s2.group, data: t3.data ? t3.data : null == s2 ? void 0 : s2.data, zIndex: void 0 !== t3.zIndex ? t3.zIndex : i2 });
      } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
        var i2 = this.w, a2 = null, s2 = ".apexcharts-series[data\\:realIndex='".concat(t3, "']");
        return i2.globals.axisCharts ? a2 = i2.globals.dom.Paper.select("".concat(s2, " path[j='").concat(e2, "'], ").concat(s2, " circle[j='").concat(e2, "'], ").concat(s2, " rect[j='").concat(e2, "']")).members[0] : void 0 === e2 && (a2 = i2.globals.dom.Paper.select("".concat(s2, " path[j='").concat(t3, "']")).members[0], "pie" !== i2.config.chart.type && "polarArea" !== i2.config.chart.type && "donut" !== i2.config.chart.type || this.ctx.pie.pieClicked(t3)), a2 ? (new m(this.ctx).pathMouseDown(a2, null), a2.node ? a2.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
      } }, { key: "forceXAxisUpdate", value: function(t3) {
        var e2 = this.w;
        if (["min", "max"].forEach(function(i3) {
          void 0 !== t3.xaxis[i3] && (e2.config.xaxis[i3] = t3.xaxis[i3], e2.globals.lastXAxis[i3] = t3.xaxis[i3]);
        }), t3.xaxis.categories && t3.xaxis.categories.length && (e2.config.xaxis.categories = t3.xaxis.categories), e2.config.xaxis.convertedCatToNumeric) {
          var i2 = new X(t3);
          t3 = i2.convertCatToNumericXaxis(t3, this.ctx);
        }
        return t3;
      } }, { key: "forceYAxisUpdate", value: function(t3) {
        return t3.chart && t3.chart.stacked && "100%" === t3.chart.stackType && (Array.isArray(t3.yaxis) ? t3.yaxis.forEach(function(e2, i2) {
          t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
        }) : (t3.yaxis.min = 0, t3.yaxis.max = 100)), t3;
      } }, { key: "revertDefaultAxisMinMax", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = i2.globals.lastXAxis, s2 = i2.globals.lastYAxis;
        t3 && t3.xaxis && (a2 = t3.xaxis), t3 && t3.yaxis && (s2 = t3.yaxis), i2.config.xaxis.min = a2.min, i2.config.xaxis.max = a2.max;
        var r2 = function(t4) {
          void 0 !== s2[t4] && (i2.config.yaxis[t4].min = s2[t4].min, i2.config.yaxis[t4].max = s2[t4].max);
        };
        i2.config.yaxis.map(function(t4, a3) {
          i2.globals.zoomed || void 0 !== s2[a3] ? r2(a3) : void 0 !== e2.ctx.opts.yaxis[a3] && (t4.min = e2.ctx.opts.yaxis[a3].min, t4.max = e2.ctx.opts.yaxis[a3].max);
        });
      } }]), t2;
    }();
    Rt = "undefined" != typeof window ? window : void 0, Ht = function(t2, e2) {
      var a2 = (void 0 !== this ? this : t2).SVG = function(t3) {
        if (a2.supported)
          return t3 = new a2.Doc(t3), a2.parser.draw || a2.prepare(), t3;
      };
      if (a2.ns = "http://www.w3.org/2000/svg", a2.xmlns = "http://www.w3.org/2000/xmlns/", a2.xlink = "http://www.w3.org/1999/xlink", a2.svgjs = "http://svgjs.dev", a2.supported = true, !a2.supported)
        return false;
      a2.did = 1e3, a2.eid = function(t3) {
        return "Svgjs" + d2(t3) + a2.did++;
      }, a2.create = function(t3) {
        var i2 = e2.createElementNS(this.ns, t3);
        return i2.setAttribute("id", this.eid(t3)), i2;
      }, a2.extend = function() {
        var t3, e3;
        e3 = (t3 = [].slice.call(arguments)).pop();
        for (var i2 = t3.length - 1; i2 >= 0; i2--)
          if (t3[i2])
            for (var s3 in e3)
              t3[i2].prototype[s3] = e3[s3];
        a2.Set && a2.Set.inherit && a2.Set.inherit();
      }, a2.invent = function(t3) {
        var e3 = "function" == typeof t3.create ? t3.create : function() {
          this.constructor.call(this, a2.create(t3.create));
        };
        return t3.inherit && (e3.prototype = new t3.inherit()), t3.extend && a2.extend(e3, t3.extend), t3.construct && a2.extend(t3.parent || a2.Container, t3.construct), e3;
      }, a2.adopt = function(e3) {
        return e3 ? e3.instance ? e3.instance : ((i2 = "svg" == e3.nodeName ? e3.parentNode instanceof t2.SVGElement ? new a2.Nested() : new a2.Doc() : "linearGradient" == e3.nodeName ? new a2.Gradient("linear") : "radialGradient" == e3.nodeName ? new a2.Gradient("radial") : a2[d2(e3.nodeName)] ? new a2[d2(e3.nodeName)]() : new a2.Element(e3)).type = e3.nodeName, i2.node = e3, e3.instance = i2, i2 instanceof a2.Doc && i2.namespace().defs(), i2.setData(JSON.parse(e3.getAttribute("svgjs:data")) || {}), i2) : null;
        var i2;
      }, a2.prepare = function() {
        var t3 = e2.getElementsByTagName("body")[0], i2 = (t3 ? new a2.Doc(t3) : a2.adopt(e2.documentElement).nested()).size(2, 0);
        a2.parser = { body: t3 || e2.documentElement, draw: i2.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: i2.polyline().node, path: i2.path().node, native: a2.create("svg") };
      }, a2.parser = { native: a2.create("svg") }, e2.addEventListener("DOMContentLoaded", function() {
        a2.parser.draw || a2.prepare();
      }, false), a2.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, a2.utils = { map: function(t3, e3) {
        for (var i2 = t3.length, a3 = [], s3 = 0; s3 < i2; s3++)
          a3.push(e3(t3[s3]));
        return a3;
      }, filter: function(t3, e3) {
        for (var i2 = t3.length, a3 = [], s3 = 0; s3 < i2; s3++)
          e3(t3[s3]) && a3.push(t3[s3]);
        return a3;
      }, filterSVGElements: function(e3) {
        return this.filter(e3, function(e4) {
          return e4 instanceof t2.SVGElement;
        });
      } }, a2.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, a2.Color = function(t3) {
        var e3, s3;
        this.r = 0, this.g = 0, this.b = 0, t3 && ("string" == typeof t3 ? a2.regex.isRgb.test(t3) ? (e3 = a2.regex.rgb.exec(t3.replace(a2.regex.whitespace, "")), this.r = parseInt(e3[1]), this.g = parseInt(e3[2]), this.b = parseInt(e3[3])) : a2.regex.isHex.test(t3) && (e3 = a2.regex.hex.exec(4 == (s3 = t3).length ? ["#", s3.substring(1, 2), s3.substring(1, 2), s3.substring(2, 3), s3.substring(2, 3), s3.substring(3, 4), s3.substring(3, 4)].join("") : s3), this.r = parseInt(e3[1], 16), this.g = parseInt(e3[2], 16), this.b = parseInt(e3[3], 16)) : "object" === i(t3) && (this.r = t3.r, this.g = t3.g, this.b = t3.b));
      }, a2.extend(a2.Color, { toString: function() {
        return this.toHex();
      }, toHex: function() {
        return "#" + g2(this.r) + g2(this.g) + g2(this.b);
      }, toRgb: function() {
        return "rgb(" + [this.r, this.g, this.b].join() + ")";
      }, brightness: function() {
        return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
      }, morph: function(t3) {
        return this.destination = new a2.Color(t3), this;
      }, at: function(t3) {
        return this.destination ? (t3 = t3 < 0 ? 0 : t3 > 1 ? 1 : t3, new a2.Color({ r: ~~(this.r + (this.destination.r - this.r) * t3), g: ~~(this.g + (this.destination.g - this.g) * t3), b: ~~(this.b + (this.destination.b - this.b) * t3) })) : this;
      } }), a2.Color.test = function(t3) {
        return t3 += "", a2.regex.isHex.test(t3) || a2.regex.isRgb.test(t3);
      }, a2.Color.isRgb = function(t3) {
        return t3 && "number" == typeof t3.r && "number" == typeof t3.g && "number" == typeof t3.b;
      }, a2.Color.isColor = function(t3) {
        return a2.Color.isRgb(t3) || a2.Color.test(t3);
      }, a2.Array = function(t3, e3) {
        0 == (t3 = (t3 || []).valueOf()).length && e3 && (t3 = e3.valueOf()), this.value = this.parse(t3);
      }, a2.extend(a2.Array, { toString: function() {
        return this.value.join(" ");
      }, valueOf: function() {
        return this.value;
      }, parse: function(t3) {
        return t3 = t3.valueOf(), Array.isArray(t3) ? t3 : this.split(t3);
      } }), a2.PointArray = function(t3, e3) {
        a2.Array.call(this, t3, e3 || [[0, 0]]);
      }, a2.PointArray.prototype = new a2.Array(), a2.PointArray.prototype.constructor = a2.PointArray;
      for (var s2 = { M: function(t3, e3, i2) {
        return e3.x = i2.x = t3[0], e3.y = i2.y = t3[1], ["M", e3.x, e3.y];
      }, L: function(t3, e3) {
        return e3.x = t3[0], e3.y = t3[1], ["L", t3[0], t3[1]];
      }, H: function(t3, e3) {
        return e3.x = t3[0], ["H", t3[0]];
      }, V: function(t3, e3) {
        return e3.y = t3[0], ["V", t3[0]];
      }, C: function(t3, e3) {
        return e3.x = t3[4], e3.y = t3[5], ["C", t3[0], t3[1], t3[2], t3[3], t3[4], t3[5]];
      }, Q: function(t3, e3) {
        return e3.x = t3[2], e3.y = t3[3], ["Q", t3[0], t3[1], t3[2], t3[3]];
      }, S: function(t3, e3) {
        return e3.x = t3[2], e3.y = t3[3], ["S", t3[0], t3[1], t3[2], t3[3]];
      }, Z: function(t3, e3, i2) {
        return e3.x = i2.x, e3.y = i2.y, ["Z"];
      } }, r2 = "mlhvqtcsaz".split(""), o2 = 0, n2 = r2.length; o2 < n2; ++o2)
        s2[r2[o2]] = function(t3) {
          return function(e3, i2, a3) {
            if ("H" == t3)
              e3[0] = e3[0] + i2.x;
            else if ("V" == t3)
              e3[0] = e3[0] + i2.y;
            else if ("A" == t3)
              e3[5] = e3[5] + i2.x, e3[6] = e3[6] + i2.y;
            else
              for (var r3 = 0, o3 = e3.length; r3 < o3; ++r3)
                e3[r3] = e3[r3] + (r3 % 2 ? i2.y : i2.x);
            if (s2 && "function" == typeof s2[t3])
              return s2[t3](e3, i2, a3);
          };
        }(r2[o2].toUpperCase());
      a2.PathArray = function(t3, e3) {
        a2.Array.call(this, t3, e3 || [["M", 0, 0]]);
      }, a2.PathArray.prototype = new a2.Array(), a2.PathArray.prototype.constructor = a2.PathArray, a2.extend(a2.PathArray, { toString: function() {
        return function(t3) {
          for (var e3 = 0, i2 = t3.length, a3 = ""; e3 < i2; e3++)
            a3 += t3[e3][0], null != t3[e3][1] && (a3 += t3[e3][1], null != t3[e3][2] && (a3 += " ", a3 += t3[e3][2], null != t3[e3][3] && (a3 += " ", a3 += t3[e3][3], a3 += " ", a3 += t3[e3][4], null != t3[e3][5] && (a3 += " ", a3 += t3[e3][5], a3 += " ", a3 += t3[e3][6], null != t3[e3][7] && (a3 += " ", a3 += t3[e3][7])))));
          return a3 + " ";
        }(this.value);
      }, move: function(t3, e3) {
        var i2 = this.bbox();
        return i2.x, i2.y, this;
      }, at: function(t3) {
        if (!this.destination)
          return this;
        for (var e3 = this.value, i2 = this.destination.value, s3 = [], r3 = new a2.PathArray(), o3 = 0, n3 = e3.length; o3 < n3; o3++) {
          s3[o3] = [e3[o3][0]];
          for (var l3 = 1, h3 = e3[o3].length; l3 < h3; l3++)
            s3[o3][l3] = e3[o3][l3] + (i2[o3][l3] - e3[o3][l3]) * t3;
          "A" === s3[o3][0] && (s3[o3][4] = +(0 != s3[o3][4]), s3[o3][5] = +(0 != s3[o3][5]));
        }
        return r3.value = s3, r3;
      }, parse: function(t3) {
        if (t3 instanceof a2.PathArray)
          return t3.valueOf();
        var e3, i2 = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
        t3 = "string" == typeof t3 ? t3.replace(a2.regex.numbersWithDots, h2).replace(a2.regex.pathLetters, " $& ").replace(a2.regex.hyphen, "$1 -").trim().split(a2.regex.delimiter) : t3.reduce(function(t4, e4) {
          return [].concat.call(t4, e4);
        }, []);
        var r3 = [], o3 = new a2.Point(), n3 = new a2.Point(), l3 = 0, c3 = t3.length;
        do {
          a2.regex.isPathLetter.test(t3[l3]) ? (e3 = t3[l3], ++l3) : "M" == e3 ? e3 = "L" : "m" == e3 && (e3 = "l"), r3.push(s2[e3].call(null, t3.slice(l3, l3 += i2[e3.toUpperCase()]).map(parseFloat), o3, n3));
        } while (c3 > l3);
        return r3;
      }, bbox: function() {
        return a2.parser.draw || a2.prepare(), a2.parser.path.setAttribute("d", this.toString()), a2.parser.path.getBBox();
      } }), a2.Number = a2.invent({ create: function(t3, e3) {
        this.value = 0, this.unit = e3 || "", "number" == typeof t3 ? this.value = isNaN(t3) ? 0 : isFinite(t3) ? t3 : t3 < 0 ? -34e37 : 34e37 : "string" == typeof t3 ? (e3 = t3.match(a2.regex.numberAndUnit)) && (this.value = parseFloat(e3[1]), "%" == e3[5] ? this.value /= 100 : "s" == e3[5] && (this.value *= 1e3), this.unit = e3[5]) : t3 instanceof a2.Number && (this.value = t3.valueOf(), this.unit = t3.unit);
      }, extend: { toString: function() {
        return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
      }, toJSON: function() {
        return this.toString();
      }, valueOf: function() {
        return this.value;
      }, plus: function(t3) {
        return t3 = new a2.Number(t3), new a2.Number(this + t3, this.unit || t3.unit);
      }, minus: function(t3) {
        return t3 = new a2.Number(t3), new a2.Number(this - t3, this.unit || t3.unit);
      }, times: function(t3) {
        return t3 = new a2.Number(t3), new a2.Number(this * t3, this.unit || t3.unit);
      }, divide: function(t3) {
        return t3 = new a2.Number(t3), new a2.Number(this / t3, this.unit || t3.unit);
      }, to: function(t3) {
        var e3 = new a2.Number(this);
        return "string" == typeof t3 && (e3.unit = t3), e3;
      }, morph: function(t3) {
        return this.destination = new a2.Number(t3), t3.relative && (this.destination.value += this.value), this;
      }, at: function(t3) {
        return this.destination ? new a2.Number(this.destination).minus(this).times(t3).plus(this) : this;
      } } }), a2.Element = a2.invent({ create: function(t3) {
        this._stroke = a2.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t3) && (this.type = t3.nodeName, this.node.instance = this, this._stroke = t3.getAttribute("stroke") || this._stroke);
      }, extend: { x: function(t3) {
        return this.attr("x", t3);
      }, y: function(t3) {
        return this.attr("y", t3);
      }, cx: function(t3) {
        return null == t3 ? this.x() + this.width() / 2 : this.x(t3 - this.width() / 2);
      }, cy: function(t3) {
        return null == t3 ? this.y() + this.height() / 2 : this.y(t3 - this.height() / 2);
      }, move: function(t3, e3) {
        return this.x(t3).y(e3);
      }, center: function(t3, e3) {
        return this.cx(t3).cy(e3);
      }, width: function(t3) {
        return this.attr("width", t3);
      }, height: function(t3) {
        return this.attr("height", t3);
      }, size: function(t3, e3) {
        var i2 = u5(this, t3, e3);
        return this.width(new a2.Number(i2.width)).height(new a2.Number(i2.height));
      }, clone: function(t3) {
        this.writeDataToDom();
        var e3 = x2(this.node.cloneNode(true));
        return t3 ? t3.add(e3) : this.after(e3), e3;
      }, remove: function() {
        return this.parent() && this.parent().removeElement(this), this;
      }, replace: function(t3) {
        return this.after(t3).remove(), t3;
      }, addTo: function(t3) {
        return t3.put(this);
      }, putIn: function(t3) {
        return t3.add(this);
      }, id: function(t3) {
        return this.attr("id", t3);
      }, show: function() {
        return this.style("display", "");
      }, hide: function() {
        return this.style("display", "none");
      }, visible: function() {
        return "none" != this.style("display");
      }, toString: function() {
        return this.attr("id");
      }, classes: function() {
        var t3 = this.attr("class");
        return null == t3 ? [] : t3.trim().split(a2.regex.delimiter);
      }, hasClass: function(t3) {
        return -1 != this.classes().indexOf(t3);
      }, addClass: function(t3) {
        if (!this.hasClass(t3)) {
          var e3 = this.classes();
          e3.push(t3), this.attr("class", e3.join(" "));
        }
        return this;
      }, removeClass: function(t3) {
        return this.hasClass(t3) && this.attr("class", this.classes().filter(function(e3) {
          return e3 != t3;
        }).join(" ")), this;
      }, toggleClass: function(t3) {
        return this.hasClass(t3) ? this.removeClass(t3) : this.addClass(t3);
      }, reference: function(t3) {
        return a2.get(this.attr(t3));
      }, parent: function(e3) {
        var i2 = this;
        if (!i2.node.parentNode)
          return null;
        if (i2 = a2.adopt(i2.node.parentNode), !e3)
          return i2;
        for (; i2 && i2.node instanceof t2.SVGElement; ) {
          if ("string" == typeof e3 ? i2.matches(e3) : i2 instanceof e3)
            return i2;
          if (!i2.node.parentNode || "#document" == i2.node.parentNode.nodeName)
            return null;
          i2 = a2.adopt(i2.node.parentNode);
        }
      }, doc: function() {
        return this instanceof a2.Doc ? this : this.parent(a2.Doc);
      }, parents: function(t3) {
        var e3 = [], i2 = this;
        do {
          if (!(i2 = i2.parent(t3)) || !i2.node)
            break;
          e3.push(i2);
        } while (i2.parent);
        return e3;
      }, matches: function(t3) {
        return function(t4, e3) {
          return (t4.matches || t4.matchesSelector || t4.msMatchesSelector || t4.mozMatchesSelector || t4.webkitMatchesSelector || t4.oMatchesSelector).call(t4, e3);
        }(this.node, t3);
      }, native: function() {
        return this.node;
      }, svg: function(t3) {
        var i2 = e2.createElement("svg");
        if (!(t3 && this instanceof a2.Parent))
          return i2.appendChild(t3 = e2.createElement("svg")), this.writeDataToDom(), t3.appendChild(this.node.cloneNode(true)), i2.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
        i2.innerHTML = "<svg>" + t3.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
        for (var s3 = 0, r3 = i2.firstChild.childNodes.length; s3 < r3; s3++)
          this.node.appendChild(i2.firstChild.firstChild);
        return this;
      }, writeDataToDom: function() {
        return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
          this.writeDataToDom();
        }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
      }, setData: function(t3) {
        return this.dom = t3, this;
      }, is: function(t3) {
        return function(t4, e3) {
          return t4 instanceof e3;
        }(this, t3);
      } } }), a2.easing = { "-": function(t3) {
        return t3;
      }, "<>": function(t3) {
        return -Math.cos(t3 * Math.PI) / 2 + 0.5;
      }, ">": function(t3) {
        return Math.sin(t3 * Math.PI / 2);
      }, "<": function(t3) {
        return 1 - Math.cos(t3 * Math.PI / 2);
      } }, a2.morph = function(t3) {
        return function(e3, i2) {
          return new a2.MorphObj(e3, i2).at(t3);
        };
      }, a2.Situation = a2.invent({ create: function(t3) {
        this.init = false, this.reversed = false, this.reversing = false, this.duration = new a2.Number(t3.duration).valueOf(), this.delay = new a2.Number(t3.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t3.ease, this.loop = 0, this.loops = false, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
      } }), a2.FX = a2.invent({ create: function(t3) {
        this._target = t3, this.situations = [], this.active = false, this.situation = null, this.paused = false, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
      }, extend: { animate: function(t3, e3, s3) {
        "object" === i(t3) && (e3 = t3.ease, s3 = t3.delay, t3 = t3.duration);
        var r3 = new a2.Situation({ duration: t3 || 1e3, delay: s3 || 0, ease: a2.easing[e3 || "-"] || e3 });
        return this.queue(r3), this;
      }, target: function(t3) {
        return t3 && t3 instanceof a2.Element ? (this._target = t3, this) : this._target;
      }, timeToAbsPos: function(t3) {
        return (t3 - this.situation.start) / (this.situation.duration / this._speed);
      }, absPosToTime: function(t3) {
        return this.situation.duration / this._speed * t3 + this.situation.start;
      }, startAnimFrame: function() {
        this.stopAnimFrame(), this.animationFrame = t2.requestAnimationFrame((function() {
          this.step();
        }).bind(this));
      }, stopAnimFrame: function() {
        t2.cancelAnimationFrame(this.animationFrame);
      }, start: function() {
        return !this.active && this.situation && (this.active = true, this.startCurrent()), this;
      }, startCurrent: function() {
        return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
      }, queue: function(t3) {
        return ("function" == typeof t3 || t3 instanceof a2.Situation) && this.situations.push(t3), this.situation || (this.situation = this.situations.shift()), this;
      }, dequeue: function() {
        return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a2.Situation ? this.start() : this.situation.call(this)), this;
      }, initAnimations: function() {
        var t3, e3 = this.situation;
        if (e3.init)
          return this;
        for (var i2 in e3.animations) {
          t3 = this.target()[i2](), Array.isArray(t3) || (t3 = [t3]), Array.isArray(e3.animations[i2]) || (e3.animations[i2] = [e3.animations[i2]]);
          for (var s3 = t3.length; s3--; )
            e3.animations[i2][s3] instanceof a2.Number && (t3[s3] = new a2.Number(t3[s3])), e3.animations[i2][s3] = t3[s3].morph(e3.animations[i2][s3]);
        }
        for (var i2 in e3.attrs)
          e3.attrs[i2] = new a2.MorphObj(this.target().attr(i2), e3.attrs[i2]);
        for (var i2 in e3.styles)
          e3.styles[i2] = new a2.MorphObj(this.target().style(i2), e3.styles[i2]);
        return e3.initialTransformation = this.target().matrixify(), e3.init = true, this;
      }, clearQueue: function() {
        return this.situations = [], this;
      }, clearCurrent: function() {
        return this.situation = null, this;
      }, stop: function(t3, e3) {
        var i2 = this.active;
        return this.active = false, e3 && this.clearQueue(), t3 && this.situation && (!i2 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
      }, after: function(t3) {
        var e3 = this.last();
        return this.target().on("finished.fx", function i2(a3) {
          a3.detail.situation == e3 && (t3.call(this, e3), this.off("finished.fx", i2));
        }), this._callStart();
      }, during: function(t3) {
        var e3 = this.last(), i2 = function(i3) {
          i3.detail.situation == e3 && t3.call(this, i3.detail.pos, a2.morph(i3.detail.pos), i3.detail.eased, e3);
        };
        return this.target().off("during.fx", i2).on("during.fx", i2), this.after(function() {
          this.off("during.fx", i2);
        }), this._callStart();
      }, afterAll: function(t3) {
        var e3 = function e4(i2) {
          t3.call(this), this.off("allfinished.fx", e4);
        };
        return this.target().off("allfinished.fx", e3).on("allfinished.fx", e3), this._callStart();
      }, last: function() {
        return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
      }, add: function(t3, e3, i2) {
        return this.last()[i2 || "animations"][t3] = e3, this._callStart();
      }, step: function(t3) {
        var e3, i2, a3;
        t3 || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), false !== this.situation.loops ? (e3 = Math.max(this.absPos, 0), i2 = Math.floor(e3), true === this.situation.loops || i2 < this.situation.loops ? (this.pos = e3 - i2, a3 = this.situation.loop, this.situation.loop = i2) : (this.absPos = this.situation.loops, this.pos = 1, a3 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a3) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
        var s3 = this.situation.ease(this.pos);
        for (var r3 in this.situation.once)
          r3 > this.lastPos && r3 <= s3 && (this.situation.once[r3].call(this.target(), this.pos, s3), delete this.situation.once[r3]);
        return this.active && this.target().fire("during", { pos: this.pos, eased: s3, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = false)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s3, this) : this;
      }, eachAt: function() {
        var t3, e3 = this, i2 = this.target(), s3 = this.situation;
        for (var r3 in s3.animations)
          t3 = [].concat(s3.animations[r3]).map(function(t4) {
            return "string" != typeof t4 && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
          }), i2[r3].apply(i2, t3);
        for (var r3 in s3.attrs)
          t3 = [r3].concat(s3.attrs[r3]).map(function(t4) {
            return "string" != typeof t4 && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
          }), i2.attr.apply(i2, t3);
        for (var r3 in s3.styles)
          t3 = [r3].concat(s3.styles[r3]).map(function(t4) {
            return "string" != typeof t4 && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
          }), i2.style.apply(i2, t3);
        if (s3.transforms.length) {
          t3 = s3.initialTransformation, r3 = 0;
          for (var o3 = s3.transforms.length; r3 < o3; r3++) {
            var n3 = s3.transforms[r3];
            n3 instanceof a2.Matrix ? t3 = n3.relative ? t3.multiply(new a2.Matrix().morph(n3).at(s3.ease(this.pos))) : t3.morph(n3).at(s3.ease(this.pos)) : (n3.relative || n3.undo(t3.extract()), t3 = t3.multiply(n3.at(s3.ease(this.pos))));
          }
          i2.matrix(t3);
        }
        return this;
      }, once: function(t3, e3, i2) {
        var a3 = this.last();
        return i2 || (t3 = a3.ease(t3)), a3.once[t3] = e3, this;
      }, _callStart: function() {
        return setTimeout((function() {
          this.start();
        }).bind(this), 0), this;
      } }, parent: a2.Element, construct: { animate: function(t3, e3, i2) {
        return (this.fx || (this.fx = new a2.FX(this))).animate(t3, e3, i2);
      }, delay: function(t3) {
        return (this.fx || (this.fx = new a2.FX(this))).delay(t3);
      }, stop: function(t3, e3) {
        return this.fx && this.fx.stop(t3, e3), this;
      }, finish: function() {
        return this.fx && this.fx.finish(), this;
      } } }), a2.MorphObj = a2.invent({ create: function(t3, e3) {
        return a2.Color.isColor(e3) ? new a2.Color(t3).morph(e3) : a2.regex.delimiter.test(t3) ? a2.regex.pathLetters.test(t3) ? new a2.PathArray(t3).morph(e3) : new a2.Array(t3).morph(e3) : a2.regex.numberAndUnit.test(e3) ? new a2.Number(t3).morph(e3) : (this.value = t3, void (this.destination = e3));
      }, extend: { at: function(t3, e3) {
        return e3 < 1 ? this.value : this.destination;
      }, valueOf: function() {
        return this.value;
      } } }), a2.extend(a2.FX, { attr: function(t3, e3, a3) {
        if ("object" === i(t3))
          for (var s3 in t3)
            this.attr(s3, t3[s3]);
        else
          this.add(t3, e3, "attrs");
        return this;
      }, plot: function(t3, e3, i2, a3) {
        return 4 == arguments.length ? this.plot([t3, e3, i2, a3]) : this.add("plot", new (this.target()).morphArray(t3));
      } }), a2.Box = a2.invent({ create: function(t3, e3, s3, r3) {
        if (!("object" !== i(t3) || t3 instanceof a2.Element))
          return a2.Box.call(this, null != t3.left ? t3.left : t3.x, null != t3.top ? t3.top : t3.y, t3.width, t3.height);
        var o3;
        4 == arguments.length && (this.x = t3, this.y = e3, this.width = s3, this.height = r3), null == (o3 = this).x && (o3.x = 0, o3.y = 0, o3.width = 0, o3.height = 0), o3.w = o3.width, o3.h = o3.height, o3.x2 = o3.x + o3.width, o3.y2 = o3.y + o3.height, o3.cx = o3.x + o3.width / 2, o3.cy = o3.y + o3.height / 2;
      } }), a2.BBox = a2.invent({ create: function(t3) {
        if (a2.Box.apply(this, [].slice.call(arguments)), t3 instanceof a2.Element) {
          var i2;
          try {
            if (!e2.documentElement.contains) {
              for (var s3 = t3.node; s3.parentNode; )
                s3 = s3.parentNode;
              if (s3 != e2)
                throw new Error("Element not in the dom");
            }
            i2 = t3.node.getBBox();
          } catch (e3) {
            if (t3 instanceof a2.Shape) {
              a2.parser.draw || a2.prepare();
              var r3 = t3.clone(a2.parser.draw.instance).show();
              r3 && r3.node && "function" == typeof r3.node.getBBox && (i2 = r3.node.getBBox()), r3 && "function" == typeof r3.remove && r3.remove();
            } else
              i2 = { x: t3.node.clientLeft, y: t3.node.clientTop, width: t3.node.clientWidth, height: t3.node.clientHeight };
          }
          a2.Box.call(this, i2);
        }
      }, inherit: a2.Box, parent: a2.Element, construct: { bbox: function() {
        return new a2.BBox(this);
      } } }), a2.BBox.prototype.constructor = a2.BBox, a2.Matrix = a2.invent({ create: function(t3) {
        var e3 = f2([1, 0, 0, 1, 0, 0]);
        t3 = null === t3 ? e3 : t3 instanceof a2.Element ? t3.matrixify() : "string" == typeof t3 ? f2(t3.split(a2.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? f2([].slice.call(arguments)) : Array.isArray(t3) ? f2(t3) : t3 && "object" === i(t3) ? t3 : e3;
        for (var s3 = v2.length - 1; s3 >= 0; --s3)
          this[v2[s3]] = null != t3[v2[s3]] ? t3[v2[s3]] : e3[v2[s3]];
      }, extend: { extract: function() {
        var t3 = p2(this, 0, 1);
        p2(this, 1, 0);
        var e3 = 180 / Math.PI * Math.atan2(t3.y, t3.x) - 90;
        return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(e3 * Math.PI / 180) + this.f * Math.sin(e3 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(e3 * Math.PI / 180) + this.e * Math.sin(-e3 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: e3, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new a2.Matrix(this) };
      }, clone: function() {
        return new a2.Matrix(this);
      }, morph: function(t3) {
        return this.destination = new a2.Matrix(t3), this;
      }, multiply: function(t3) {
        return new a2.Matrix(this.native().multiply(function(t4) {
          return t4 instanceof a2.Matrix || (t4 = new a2.Matrix(t4)), t4;
        }(t3).native()));
      }, inverse: function() {
        return new a2.Matrix(this.native().inverse());
      }, translate: function(t3, e3) {
        return new a2.Matrix(this.native().translate(t3 || 0, e3 || 0));
      }, native: function() {
        for (var t3 = a2.parser.native.createSVGMatrix(), e3 = v2.length - 1; e3 >= 0; e3--)
          t3[v2[e3]] = this[v2[e3]];
        return t3;
      }, toString: function() {
        return "matrix(" + b2(this.a) + "," + b2(this.b) + "," + b2(this.c) + "," + b2(this.d) + "," + b2(this.e) + "," + b2(this.f) + ")";
      } }, parent: a2.Element, construct: { ctm: function() {
        return new a2.Matrix(this.node.getCTM());
      }, screenCTM: function() {
        if (this instanceof a2.Nested) {
          var t3 = this.rect(1, 1), e3 = t3.node.getScreenCTM();
          return t3.remove(), new a2.Matrix(e3);
        }
        return new a2.Matrix(this.node.getScreenCTM());
      } } }), a2.Point = a2.invent({ create: function(t3, e3) {
        var a3;
        a3 = Array.isArray(t3) ? { x: t3[0], y: t3[1] } : "object" === i(t3) ? { x: t3.x, y: t3.y } : null != t3 ? { x: t3, y: null != e3 ? e3 : t3 } : { x: 0, y: 0 }, this.x = a3.x, this.y = a3.y;
      }, extend: { clone: function() {
        return new a2.Point(this);
      }, morph: function(t3, e3) {
        return this.destination = new a2.Point(t3, e3), this;
      } } }), a2.extend(a2.Element, { point: function(t3, e3) {
        return new a2.Point(t3, e3).transform(this.screenCTM().inverse());
      } }), a2.extend(a2.Element, { attr: function(t3, e3, s3) {
        if (null == t3) {
          for (t3 = {}, s3 = (e3 = this.node.attributes).length - 1; s3 >= 0; s3--)
            t3[e3[s3].nodeName] = a2.regex.isNumber.test(e3[s3].nodeValue) ? parseFloat(e3[s3].nodeValue) : e3[s3].nodeValue;
          return t3;
        }
        if ("object" === i(t3))
          for (var r3 in t3)
            this.attr(r3, t3[r3]);
        else if (null === e3)
          this.node.removeAttribute(t3);
        else {
          if (null == e3)
            return null == (e3 = this.node.getAttribute(t3)) ? a2.defaults.attrs[t3] : a2.regex.isNumber.test(e3) ? parseFloat(e3) : e3;
          "stroke-width" == t3 ? this.attr("stroke", parseFloat(e3) > 0 ? this._stroke : null) : "stroke" == t3 && (this._stroke = e3), "fill" != t3 && "stroke" != t3 || (a2.regex.isImage.test(e3) && (e3 = this.doc().defs().image(e3, 0, 0)), e3 instanceof a2.Image && (e3 = this.doc().defs().pattern(0, 0, function() {
            this.add(e3);
          }))), "number" == typeof e3 ? e3 = new a2.Number(e3) : a2.Color.isColor(e3) ? e3 = new a2.Color(e3) : Array.isArray(e3) && (e3 = new a2.Array(e3)), "leading" == t3 ? this.leading && this.leading(e3) : "string" == typeof s3 ? this.node.setAttributeNS(s3, t3, e3.toString()) : this.node.setAttribute(t3, e3.toString()), !this.rebuild || "font-size" != t3 && "x" != t3 || this.rebuild(t3, e3);
        }
        return this;
      } }), a2.extend(a2.Element, { transform: function(t3, e3) {
        var s3;
        return "object" !== i(t3) ? (s3 = new a2.Matrix(this).extract(), "string" == typeof t3 ? s3[t3] : s3) : (s3 = new a2.Matrix(this), e3 = !!e3 || !!t3.relative, null != t3.a && (s3 = e3 ? s3.multiply(new a2.Matrix(t3)) : new a2.Matrix(t3)), this.attr("transform", s3));
      } }), a2.extend(a2.Element, { untransform: function() {
        return this.attr("transform", null);
      }, matrixify: function() {
        return (this.attr("transform") || "").split(a2.regex.transforms).slice(0, -1).map(function(t3) {
          var e3 = t3.trim().split("(");
          return [e3[0], e3[1].split(a2.regex.delimiter).map(function(t4) {
            return parseFloat(t4);
          })];
        }).reduce(function(t3, e3) {
          return "matrix" == e3[0] ? t3.multiply(f2(e3[1])) : t3[e3[0]].apply(t3, e3[1]);
        }, new a2.Matrix());
      }, toParent: function(t3) {
        if (this == t3)
          return this;
        var e3 = this.screenCTM(), i2 = t3.screenCTM().inverse();
        return this.addTo(t3).untransform().transform(i2.multiply(e3)), this;
      }, toDoc: function() {
        return this.toParent(this.doc());
      } }), a2.Transformation = a2.invent({ create: function(t3, e3) {
        if (arguments.length > 1 && "boolean" != typeof e3)
          return this.constructor.call(this, [].slice.call(arguments));
        if (Array.isArray(t3))
          for (var a3 = 0, s3 = this.arguments.length; a3 < s3; ++a3)
            this[this.arguments[a3]] = t3[a3];
        else if (t3 && "object" === i(t3))
          for (a3 = 0, s3 = this.arguments.length; a3 < s3; ++a3)
            this[this.arguments[a3]] = t3[this.arguments[a3]];
        this.inversed = false, true === e3 && (this.inversed = true);
      } }), a2.Translate = a2.invent({ parent: a2.Matrix, inherit: a2.Transformation, create: function(t3, e3) {
        this.constructor.apply(this, [].slice.call(arguments));
      }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), a2.extend(a2.Element, { style: function(t3, e3) {
        if (0 == arguments.length)
          return this.node.style.cssText || "";
        if (arguments.length < 2)
          if ("object" === i(t3))
            for (var s3 in t3)
              this.style(s3, t3[s3]);
          else {
            if (!a2.regex.isCss.test(t3))
              return this.node.style[c2(t3)];
            for (t3 = t3.split(/\s*;\s*/).filter(function(t4) {
              return !!t4;
            }).map(function(t4) {
              return t4.split(/\s*:\s*/);
            }); e3 = t3.pop(); )
              this.style(e3[0], e3[1]);
          }
        else
          this.node.style[c2(t3)] = null === e3 || a2.regex.isBlank.test(e3) ? "" : e3;
        return this;
      } }), a2.Parent = a2.invent({ create: function(t3) {
        this.constructor.call(this, t3);
      }, inherit: a2.Element, extend: { children: function() {
        return a2.utils.map(a2.utils.filterSVGElements(this.node.childNodes), function(t3) {
          return a2.adopt(t3);
        });
      }, add: function(t3, e3) {
        return null == e3 ? this.node.appendChild(t3.node) : t3.node != this.node.childNodes[e3] && this.node.insertBefore(t3.node, this.node.childNodes[e3]), this;
      }, put: function(t3, e3) {
        return this.add(t3, e3), t3;
      }, has: function(t3) {
        return this.index(t3) >= 0;
      }, index: function(t3) {
        return [].slice.call(this.node.childNodes).indexOf(t3.node);
      }, get: function(t3) {
        return a2.adopt(this.node.childNodes[t3]);
      }, first: function() {
        return this.get(0);
      }, last: function() {
        return this.get(this.node.childNodes.length - 1);
      }, each: function(t3, e3) {
        for (var i2 = this.children(), s3 = 0, r3 = i2.length; s3 < r3; s3++)
          i2[s3] instanceof a2.Element && t3.apply(i2[s3], [s3, i2]), e3 && i2[s3] instanceof a2.Container && i2[s3].each(t3, e3);
        return this;
      }, removeElement: function(t3) {
        return this.node.removeChild(t3.node), this;
      }, clear: function() {
        for (; this.node.hasChildNodes(); )
          this.node.removeChild(this.node.lastChild);
        return delete this._defs, this;
      }, defs: function() {
        return this.doc().defs();
      } } }), a2.extend(a2.Parent, { ungroup: function(t3, e3) {
        return 0 === e3 || this instanceof a2.Defs || this.node == a2.parser.draw || (t3 = t3 || (this instanceof a2.Doc ? this : this.parent(a2.Parent)), e3 = e3 || 1 / 0, this.each(function() {
          return this instanceof a2.Defs ? this : this instanceof a2.Parent ? this.ungroup(t3, e3 - 1) : this.toParent(t3);
        }), this.node.firstChild || this.remove()), this;
      }, flatten: function(t3, e3) {
        return this.ungroup(t3, e3);
      } }), a2.Container = a2.invent({ create: function(t3) {
        this.constructor.call(this, t3);
      }, inherit: a2.Parent }), a2.ViewBox = a2.invent({ parent: a2.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(t3) {
        a2.Element.prototype[t3] = function(e3) {
          return a2.on(this.node, t3, e3), this;
        };
      }), a2.listeners = [], a2.handlerMap = [], a2.listenerId = 0, a2.on = function(t3, e3, i2, s3, r3) {
        var o3 = i2.bind(s3 || t3.instance || t3), n3 = (a2.handlerMap.indexOf(t3) + 1 || a2.handlerMap.push(t3)) - 1, l3 = e3.split(".")[0], h3 = e3.split(".")[1] || "*";
        a2.listeners[n3] = a2.listeners[n3] || {}, a2.listeners[n3][l3] = a2.listeners[n3][l3] || {}, a2.listeners[n3][l3][h3] = a2.listeners[n3][l3][h3] || {}, i2._svgjsListenerId || (i2._svgjsListenerId = ++a2.listenerId), a2.listeners[n3][l3][h3][i2._svgjsListenerId] = o3, t3.addEventListener(l3, o3, r3 || { passive: true });
      }, a2.off = function(t3, e3, i2) {
        var s3 = a2.handlerMap.indexOf(t3), r3 = e3 && e3.split(".")[0], o3 = e3 && e3.split(".")[1], n3 = "";
        if (-1 != s3)
          if (i2) {
            if ("function" == typeof i2 && (i2 = i2._svgjsListenerId), !i2)
              return;
            a2.listeners[s3][r3] && a2.listeners[s3][r3][o3 || "*"] && (t3.removeEventListener(r3, a2.listeners[s3][r3][o3 || "*"][i2], false), delete a2.listeners[s3][r3][o3 || "*"][i2]);
          } else if (o3 && r3) {
            if (a2.listeners[s3][r3] && a2.listeners[s3][r3][o3]) {
              for (var l3 in a2.listeners[s3][r3][o3])
                a2.off(t3, [r3, o3].join("."), l3);
              delete a2.listeners[s3][r3][o3];
            }
          } else if (o3)
            for (var h3 in a2.listeners[s3])
              for (var n3 in a2.listeners[s3][h3])
                o3 === n3 && a2.off(t3, [h3, o3].join("."));
          else if (r3) {
            if (a2.listeners[s3][r3]) {
              for (var n3 in a2.listeners[s3][r3])
                a2.off(t3, [r3, n3].join("."));
              delete a2.listeners[s3][r3];
            }
          } else {
            for (var h3 in a2.listeners[s3])
              a2.off(t3, h3);
            delete a2.listeners[s3], delete a2.handlerMap[s3];
          }
      }, a2.extend(a2.Element, { on: function(t3, e3, i2, s3) {
        return a2.on(this.node, t3, e3, i2, s3), this;
      }, off: function(t3, e3) {
        return a2.off(this.node, t3, e3), this;
      }, fire: function(e3, i2) {
        return e3 instanceof t2.Event ? this.node.dispatchEvent(e3) : this.node.dispatchEvent(e3 = new a2.CustomEvent(e3, { detail: i2, cancelable: true })), this._event = e3, this;
      }, event: function() {
        return this._event;
      } }), a2.Defs = a2.invent({ create: "defs", inherit: a2.Container }), a2.G = a2.invent({ create: "g", inherit: a2.Container, extend: { x: function(t3) {
        return null == t3 ? this.transform("x") : this.transform({ x: t3 - this.x() }, true);
      } }, construct: { group: function() {
        return this.put(new a2.G());
      } } }), a2.Doc = a2.invent({ create: function(t3) {
        t3 && ("svg" == (t3 = "string" == typeof t3 ? e2.getElementById(t3) : t3).nodeName ? this.constructor.call(this, t3) : (this.constructor.call(this, a2.create("svg")), t3.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
      }, inherit: a2.Container, extend: { namespace: function() {
        return this.attr({ xmlns: a2.ns, version: "1.1" }).attr("xmlns:xlink", a2.xlink, a2.xmlns).attr("xmlns:svgjs", a2.svgjs, a2.xmlns);
      }, defs: function() {
        var t3;
        return this._defs || ((t3 = this.node.getElementsByTagName("defs")[0]) ? this._defs = a2.adopt(t3) : this._defs = new a2.Defs(), this.node.appendChild(this._defs.node)), this._defs;
      }, parent: function() {
        return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
      }, remove: function() {
        return this.parent() && this.parent().removeChild(this.node), this;
      }, clear: function() {
        for (; this.node.hasChildNodes(); )
          this.node.removeChild(this.node.lastChild);
        return delete this._defs, a2.parser.draw && !a2.parser.draw.parentNode && this.node.appendChild(a2.parser.draw), this;
      }, clone: function(t3) {
        this.writeDataToDom();
        var e3 = this.node, i2 = x2(e3.cloneNode(true));
        return t3 ? (t3.node || t3).appendChild(i2.node) : e3.parentNode.insertBefore(i2.node, e3.nextSibling), i2;
      } } }), a2.extend(a2.Element, {}), a2.Gradient = a2.invent({ create: function(t3) {
        this.constructor.call(this, a2.create(t3 + "Gradient")), this.type = t3;
      }, inherit: a2.Container, extend: { at: function(t3, e3, i2) {
        return this.put(new a2.Stop()).update(t3, e3, i2);
      }, update: function(t3) {
        return this.clear(), "function" == typeof t3 && t3.call(this, this), this;
      }, fill: function() {
        return "url(#" + this.id() + ")";
      }, toString: function() {
        return this.fill();
      }, attr: function(t3, e3, i2) {
        return "transform" == t3 && (t3 = "gradientTransform"), a2.Container.prototype.attr.call(this, t3, e3, i2);
      } }, construct: { gradient: function(t3, e3) {
        return this.defs().gradient(t3, e3);
      } } }), a2.extend(a2.Gradient, a2.FX, { from: function(t3, e3) {
        return "radial" == (this._target || this).type ? this.attr({ fx: new a2.Number(t3), fy: new a2.Number(e3) }) : this.attr({ x1: new a2.Number(t3), y1: new a2.Number(e3) });
      }, to: function(t3, e3) {
        return "radial" == (this._target || this).type ? this.attr({ cx: new a2.Number(t3), cy: new a2.Number(e3) }) : this.attr({ x2: new a2.Number(t3), y2: new a2.Number(e3) });
      } }), a2.extend(a2.Defs, { gradient: function(t3, e3) {
        return this.put(new a2.Gradient(t3)).update(e3);
      } }), a2.Stop = a2.invent({ create: "stop", inherit: a2.Element, extend: { update: function(t3) {
        return ("number" == typeof t3 || t3 instanceof a2.Number) && (t3 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t3.opacity && this.attr("stop-opacity", t3.opacity), null != t3.color && this.attr("stop-color", t3.color), null != t3.offset && this.attr("offset", new a2.Number(t3.offset)), this;
      } } }), a2.Pattern = a2.invent({ create: "pattern", inherit: a2.Container, extend: { fill: function() {
        return "url(#" + this.id() + ")";
      }, update: function(t3) {
        return this.clear(), "function" == typeof t3 && t3.call(this, this), this;
      }, toString: function() {
        return this.fill();
      }, attr: function(t3, e3, i2) {
        return "transform" == t3 && (t3 = "patternTransform"), a2.Container.prototype.attr.call(this, t3, e3, i2);
      } }, construct: { pattern: function(t3, e3, i2) {
        return this.defs().pattern(t3, e3, i2);
      } } }), a2.extend(a2.Defs, { pattern: function(t3, e3, i2) {
        return this.put(new a2.Pattern()).update(i2).attr({ x: 0, y: 0, width: t3, height: e3, patternUnits: "userSpaceOnUse" });
      } }), a2.Shape = a2.invent({ create: function(t3) {
        this.constructor.call(this, t3);
      }, inherit: a2.Element }), a2.Symbol = a2.invent({ create: "symbol", inherit: a2.Container, construct: { symbol: function() {
        return this.put(new a2.Symbol());
      } } }), a2.Use = a2.invent({ create: "use", inherit: a2.Shape, extend: { element: function(t3, e3) {
        return this.attr("href", (e3 || "") + "#" + t3, a2.xlink);
      } }, construct: { use: function(t3, e3) {
        return this.put(new a2.Use()).element(t3, e3);
      } } }), a2.Rect = a2.invent({ create: "rect", inherit: a2.Shape, construct: { rect: function(t3, e3) {
        return this.put(new a2.Rect()).size(t3, e3);
      } } }), a2.Circle = a2.invent({ create: "circle", inherit: a2.Shape, construct: { circle: function(t3) {
        return this.put(new a2.Circle()).rx(new a2.Number(t3).divide(2)).move(0, 0);
      } } }), a2.extend(a2.Circle, a2.FX, { rx: function(t3) {
        return this.attr("r", t3);
      }, ry: function(t3) {
        return this.rx(t3);
      } }), a2.Ellipse = a2.invent({ create: "ellipse", inherit: a2.Shape, construct: { ellipse: function(t3, e3) {
        return this.put(new a2.Ellipse()).size(t3, e3).move(0, 0);
      } } }), a2.extend(a2.Ellipse, a2.Rect, a2.FX, { rx: function(t3) {
        return this.attr("rx", t3);
      }, ry: function(t3) {
        return this.attr("ry", t3);
      } }), a2.extend(a2.Circle, a2.Ellipse, { x: function(t3) {
        return null == t3 ? this.cx() - this.rx() : this.cx(t3 + this.rx());
      }, y: function(t3) {
        return null == t3 ? this.cy() - this.ry() : this.cy(t3 + this.ry());
      }, cx: function(t3) {
        return null == t3 ? this.attr("cx") : this.attr("cx", t3);
      }, cy: function(t3) {
        return null == t3 ? this.attr("cy") : this.attr("cy", t3);
      }, width: function(t3) {
        return null == t3 ? 2 * this.rx() : this.rx(new a2.Number(t3).divide(2));
      }, height: function(t3) {
        return null == t3 ? 2 * this.ry() : this.ry(new a2.Number(t3).divide(2));
      }, size: function(t3, e3) {
        var i2 = u5(this, t3, e3);
        return this.rx(new a2.Number(i2.width).divide(2)).ry(new a2.Number(i2.height).divide(2));
      } }), a2.Line = a2.invent({ create: "line", inherit: a2.Shape, extend: { array: function() {
        return new a2.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
      }, plot: function(t3, e3, i2, s3) {
        return null == t3 ? this.array() : (t3 = void 0 !== e3 ? { x1: t3, y1: e3, x2: i2, y2: s3 } : new a2.PointArray(t3).toLine(), this.attr(t3));
      }, move: function(t3, e3) {
        return this.attr(this.array().move(t3, e3).toLine());
      }, size: function(t3, e3) {
        var i2 = u5(this, t3, e3);
        return this.attr(this.array().size(i2.width, i2.height).toLine());
      } }, construct: { line: function(t3, e3, i2, s3) {
        return a2.Line.prototype.plot.apply(this.put(new a2.Line()), null != t3 ? [t3, e3, i2, s3] : [0, 0, 0, 0]);
      } } }), a2.Polyline = a2.invent({ create: "polyline", inherit: a2.Shape, construct: { polyline: function(t3) {
        return this.put(new a2.Polyline()).plot(t3 || new a2.PointArray());
      } } }), a2.Polygon = a2.invent({ create: "polygon", inherit: a2.Shape, construct: { polygon: function(t3) {
        return this.put(new a2.Polygon()).plot(t3 || new a2.PointArray());
      } } }), a2.extend(a2.Polyline, a2.Polygon, { array: function() {
        return this._array || (this._array = new a2.PointArray(this.attr("points")));
      }, plot: function(t3) {
        return null == t3 ? this.array() : this.clear().attr("points", "string" == typeof t3 ? t3 : this._array = new a2.PointArray(t3));
      }, clear: function() {
        return delete this._array, this;
      }, move: function(t3, e3) {
        return this.attr("points", this.array().move(t3, e3));
      }, size: function(t3, e3) {
        var i2 = u5(this, t3, e3);
        return this.attr("points", this.array().size(i2.width, i2.height));
      } }), a2.extend(a2.Line, a2.Polyline, a2.Polygon, { morphArray: a2.PointArray, x: function(t3) {
        return null == t3 ? this.bbox().x : this.move(t3, this.bbox().y);
      }, y: function(t3) {
        return null == t3 ? this.bbox().y : this.move(this.bbox().x, t3);
      }, width: function(t3) {
        var e3 = this.bbox();
        return null == t3 ? e3.width : this.size(t3, e3.height);
      }, height: function(t3) {
        var e3 = this.bbox();
        return null == t3 ? e3.height : this.size(e3.width, t3);
      } }), a2.Path = a2.invent({ create: "path", inherit: a2.Shape, extend: { morphArray: a2.PathArray, array: function() {
        return this._array || (this._array = new a2.PathArray(this.attr("d")));
      }, plot: function(t3) {
        return null == t3 ? this.array() : this.clear().attr("d", "string" == typeof t3 ? t3 : this._array = new a2.PathArray(t3));
      }, clear: function() {
        return delete this._array, this;
      } }, construct: { path: function(t3) {
        return this.put(new a2.Path()).plot(t3 || new a2.PathArray());
      } } }), a2.Image = a2.invent({ create: "image", inherit: a2.Shape, extend: { load: function(e3) {
        if (!e3)
          return this;
        var i2 = this, s3 = new t2.Image();
        return a2.on(s3, "load", function() {
          a2.off(s3);
          var t3 = i2.parent(a2.Pattern);
          null !== t3 && (0 == i2.width() && 0 == i2.height() && i2.size(s3.width, s3.height), t3 && 0 == t3.width() && 0 == t3.height() && t3.size(i2.width(), i2.height()), "function" == typeof i2._loaded && i2._loaded.call(i2, { width: s3.width, height: s3.height, ratio: s3.width / s3.height, url: e3 }));
        }), a2.on(s3, "error", function(t3) {
          a2.off(s3), "function" == typeof i2._error && i2._error.call(i2, t3);
        }), this.attr("href", s3.src = this.src = e3, a2.xlink);
      }, loaded: function(t3) {
        return this._loaded = t3, this;
      }, error: function(t3) {
        return this._error = t3, this;
      } }, construct: { image: function(t3, e3, i2) {
        return this.put(new a2.Image()).load(t3).size(e3 || 0, i2 || e3 || 0);
      } } }), a2.Text = a2.invent({ create: function() {
        this.constructor.call(this, a2.create("text")), this.dom.leading = new a2.Number(1.3), this._rebuild = true, this._build = false, this.attr("font-family", a2.defaults.attrs["font-family"]);
      }, inherit: a2.Shape, extend: { x: function(t3) {
        return null == t3 ? this.attr("x") : this.attr("x", t3);
      }, text: function(t3) {
        if (void 0 === t3) {
          t3 = "";
          for (var e3 = this.node.childNodes, i2 = 0, s3 = e3.length; i2 < s3; ++i2)
            0 != i2 && 3 != e3[i2].nodeType && 1 == a2.adopt(e3[i2]).dom.newLined && (t3 += "\n"), t3 += e3[i2].textContent;
          return t3;
        }
        if (this.clear().build(true), "function" == typeof t3)
          t3.call(this, this);
        else {
          i2 = 0;
          for (var r3 = (t3 = t3.split("\n")).length; i2 < r3; i2++)
            this.tspan(t3[i2]).newLine();
        }
        return this.build(false).rebuild();
      }, size: function(t3) {
        return this.attr("font-size", t3).rebuild();
      }, leading: function(t3) {
        return null == t3 ? this.dom.leading : (this.dom.leading = new a2.Number(t3), this.rebuild());
      }, lines: function() {
        var t3 = (this.textPath && this.textPath() || this).node, e3 = a2.utils.map(a2.utils.filterSVGElements(t3.childNodes), function(t4) {
          return a2.adopt(t4);
        });
        return new a2.Set(e3);
      }, rebuild: function(t3) {
        if ("boolean" == typeof t3 && (this._rebuild = t3), this._rebuild) {
          var e3 = this, i2 = 0, s3 = this.dom.leading * new a2.Number(this.attr("font-size"));
          this.lines().each(function() {
            this.dom.newLined && (e3.textPath() || this.attr("x", e3.attr("x")), "\n" == this.text() ? i2 += s3 : (this.attr("dy", s3 + i2), i2 = 0));
          }), this.fire("rebuild");
        }
        return this;
      }, build: function(t3) {
        return this._build = !!t3, this;
      }, setData: function(t3) {
        return this.dom = t3, this.dom.leading = new a2.Number(t3.leading || 1.3), this;
      } }, construct: { text: function(t3) {
        return this.put(new a2.Text()).text(t3);
      }, plain: function(t3) {
        return this.put(new a2.Text()).plain(t3);
      } } }), a2.Tspan = a2.invent({ create: "tspan", inherit: a2.Shape, extend: { text: function(t3) {
        return null == t3 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t3 ? t3.call(this, this) : this.plain(t3), this);
      }, dx: function(t3) {
        return this.attr("dx", t3);
      }, dy: function(t3) {
        return this.attr("dy", t3);
      }, newLine: function() {
        var t3 = this.parent(a2.Text);
        return this.dom.newLined = true, this.dy(t3.dom.leading * t3.attr("font-size")).attr("x", t3.x());
      } } }), a2.extend(a2.Text, a2.Tspan, { plain: function(t3) {
        return false === this._build && this.clear(), this.node.appendChild(e2.createTextNode(t3)), this;
      }, tspan: function(t3) {
        var e3 = (this.textPath && this.textPath() || this).node, i2 = new a2.Tspan();
        return false === this._build && this.clear(), e3.appendChild(i2.node), i2.text(t3);
      }, clear: function() {
        for (var t3 = (this.textPath && this.textPath() || this).node; t3.hasChildNodes(); )
          t3.removeChild(t3.lastChild);
        return this;
      }, length: function() {
        return this.node.getComputedTextLength();
      } }), a2.TextPath = a2.invent({ create: "textPath", inherit: a2.Parent, parent: a2.Text, construct: { morphArray: a2.PathArray, array: function() {
        var t3 = this.track();
        return t3 ? t3.array() : null;
      }, plot: function(t3) {
        var e3 = this.track(), i2 = null;
        return e3 && (i2 = e3.plot(t3)), null == t3 ? i2 : this;
      }, track: function() {
        var t3 = this.textPath();
        if (t3)
          return t3.reference("href");
      }, textPath: function() {
        if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName)
          return a2.adopt(this.node.firstChild);
      } } }), a2.Nested = a2.invent({ create: function() {
        this.constructor.call(this, a2.create("svg")), this.style("overflow", "visible");
      }, inherit: a2.Container, construct: { nested: function() {
        return this.put(new a2.Nested());
      } } });
      var l2 = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t3, e3) {
        return "color" == e3 ? t3 : t3 + "-" + e3;
      } };
      function h2(t3, e3, i2, s3) {
        return i2 + s3.replace(a2.regex.dots, " .");
      }
      function c2(t3) {
        return t3.toLowerCase().replace(/-(.)/g, function(t4, e3) {
          return e3.toUpperCase();
        });
      }
      function d2(t3) {
        return t3.charAt(0).toUpperCase() + t3.slice(1);
      }
      function g2(t3) {
        var e3 = t3.toString(16);
        return 1 == e3.length ? "0" + e3 : e3;
      }
      function u5(t3, e3, i2) {
        if (null == e3 || null == i2) {
          var a3 = t3.bbox();
          null == e3 ? e3 = a3.width / a3.height * i2 : null == i2 && (i2 = a3.height / a3.width * e3);
        }
        return { width: e3, height: i2 };
      }
      function p2(t3, e3, i2) {
        return { x: e3 * t3.a + i2 * t3.c + 0, y: e3 * t3.b + i2 * t3.d + 0 };
      }
      function f2(t3) {
        return { a: t3[0], b: t3[1], c: t3[2], d: t3[3], e: t3[4], f: t3[5] };
      }
      function x2(e3) {
        for (var i2 = e3.childNodes.length - 1; i2 >= 0; i2--)
          e3.childNodes[i2] instanceof t2.SVGElement && x2(e3.childNodes[i2]);
        return a2.adopt(e3).id(a2.eid(e3.nodeName));
      }
      function b2(t3) {
        return Math.abs(t3) > 1e-37 ? t3 : 0;
      }
      ["fill", "stroke"].forEach(function(t3) {
        var e3 = {};
        e3[t3] = function(e4) {
          if (void 0 === e4)
            return this;
          if ("string" == typeof e4 || a2.Color.isRgb(e4) || e4 && "function" == typeof e4.fill)
            this.attr(t3, e4);
          else
            for (var i2 = l2[t3].length - 1; i2 >= 0; i2--)
              null != e4[l2[t3][i2]] && this.attr(l2.prefix(t3, l2[t3][i2]), e4[l2[t3][i2]]);
          return this;
        }, a2.extend(a2.Element, a2.FX, e3);
      }), a2.extend(a2.Element, a2.FX, { translate: function(t3, e3) {
        return this.transform({ x: t3, y: e3 });
      }, matrix: function(t3) {
        return this.attr("transform", new a2.Matrix(6 == arguments.length ? [].slice.call(arguments) : t3));
      }, opacity: function(t3) {
        return this.attr("opacity", t3);
      }, dx: function(t3) {
        return this.x(new a2.Number(t3).plus(this instanceof a2.FX ? 0 : this.x()), true);
      }, dy: function(t3) {
        return this.y(new a2.Number(t3).plus(this instanceof a2.FX ? 0 : this.y()), true);
      } }), a2.extend(a2.Path, { length: function() {
        return this.node.getTotalLength();
      }, pointAt: function(t3) {
        return this.node.getPointAtLength(t3);
      } }), a2.Set = a2.invent({ create: function(t3) {
        Array.isArray(t3) ? this.members = t3 : this.clear();
      }, extend: { add: function() {
        for (var t3 = [].slice.call(arguments), e3 = 0, i2 = t3.length; e3 < i2; e3++)
          this.members.push(t3[e3]);
        return this;
      }, remove: function(t3) {
        var e3 = this.index(t3);
        return e3 > -1 && this.members.splice(e3, 1), this;
      }, each: function(t3) {
        for (var e3 = 0, i2 = this.members.length; e3 < i2; e3++)
          t3.apply(this.members[e3], [e3, this.members]);
        return this;
      }, clear: function() {
        return this.members = [], this;
      }, length: function() {
        return this.members.length;
      }, has: function(t3) {
        return this.index(t3) >= 0;
      }, index: function(t3) {
        return this.members.indexOf(t3);
      }, get: function(t3) {
        return this.members[t3];
      }, first: function() {
        return this.get(0);
      }, last: function() {
        return this.get(this.members.length - 1);
      }, valueOf: function() {
        return this.members;
      } }, construct: { set: function(t3) {
        return new a2.Set(t3);
      } } }), a2.FX.Set = a2.invent({ create: function(t3) {
        this.set = t3;
      } }), a2.Set.inherit = function() {
        var t3 = [];
        for (var e3 in a2.Shape.prototype)
          "function" == typeof a2.Shape.prototype[e3] && "function" != typeof a2.Set.prototype[e3] && t3.push(e3);
        for (var e3 in t3.forEach(function(t4) {
          a2.Set.prototype[t4] = function() {
            for (var e4 = 0, i2 = this.members.length; e4 < i2; e4++)
              this.members[e4] && "function" == typeof this.members[e4][t4] && this.members[e4][t4].apply(this.members[e4], arguments);
            return "animate" == t4 ? this.fx || (this.fx = new a2.FX.Set(this)) : this;
          };
        }), t3 = [], a2.FX.prototype)
          "function" == typeof a2.FX.prototype[e3] && "function" != typeof a2.FX.Set.prototype[e3] && t3.push(e3);
        t3.forEach(function(t4) {
          a2.FX.Set.prototype[t4] = function() {
            for (var e4 = 0, i2 = this.set.members.length; e4 < i2; e4++)
              this.set.members[e4].fx[t4].apply(this.set.members[e4].fx, arguments);
            return this;
          };
        });
      }, a2.extend(a2.Element, {}), a2.extend(a2.Element, { remember: function(t3, e3) {
        if ("object" === i(arguments[0]))
          for (var a3 in t3)
            this.remember(a3, t3[a3]);
        else {
          if (1 == arguments.length)
            return this.memory()[t3];
          this.memory()[t3] = e3;
        }
        return this;
      }, forget: function() {
        if (0 == arguments.length)
          this._memory = {};
        else
          for (var t3 = arguments.length - 1; t3 >= 0; t3--)
            delete this.memory()[arguments[t3]];
        return this;
      }, memory: function() {
        return this._memory || (this._memory = {});
      } }), a2.get = function(t3) {
        var i2 = e2.getElementById(function(t4) {
          var e3 = (t4 || "").toString().match(a2.regex.reference);
          if (e3)
            return e3[1];
        }(t3) || t3);
        return a2.adopt(i2);
      }, a2.select = function(t3, i2) {
        return new a2.Set(a2.utils.map((i2 || e2).querySelectorAll(t3), function(t4) {
          return a2.adopt(t4);
        }));
      }, a2.extend(a2.Parent, { select: function(t3) {
        return a2.select(t3, this.node);
      } });
      var v2 = "abcdef".split("");
      if ("function" != typeof t2.CustomEvent) {
        var m2 = function(t3, i2) {
          i2 = i2 || { bubbles: false, cancelable: false, detail: void 0 };
          var a3 = e2.createEvent("CustomEvent");
          return a3.initCustomEvent(t3, i2.bubbles, i2.cancelable, i2.detail), a3;
        };
        m2.prototype = t2.Event.prototype, a2.CustomEvent = m2;
      } else
        a2.CustomEvent = t2.CustomEvent;
      return a2;
    }, "function" == typeof define && define.amd ? define(function() {
      return Ht(Rt, Rt.document);
    }) : "object" === ("undefined" == typeof exports ? "undefined" : i(exports)) && "undefined" != typeof module ? module.exports = Rt.document ? Ht(Rt, Rt.document) : function(t2) {
      return Ht(t2, t2.document);
    } : Rt.SVG = Ht(Rt, Rt.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
    * https://github.com/wout/svg.filter.js
    * Copyright (c) 2016 Wout Fierens; Licensed MIT */
    (function() {
      SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: true, put: function(t3, e3) {
        return this.add(t3, e3), !t3.attr("in") && this.autoSetIn && t3.attr("in", this.source), t3.attr("result") || t3.attr("result", t3), t3;
      }, blend: function(t3, e3, i3) {
        return this.put(new SVG.BlendEffect(t3, e3, i3));
      }, colorMatrix: function(t3, e3) {
        return this.put(new SVG.ColorMatrixEffect(t3, e3));
      }, convolveMatrix: function(t3) {
        return this.put(new SVG.ConvolveMatrixEffect(t3));
      }, componentTransfer: function(t3) {
        return this.put(new SVG.ComponentTransferEffect(t3));
      }, composite: function(t3, e3, i3) {
        return this.put(new SVG.CompositeEffect(t3, e3, i3));
      }, flood: function(t3, e3) {
        return this.put(new SVG.FloodEffect(t3, e3));
      }, offset: function(t3, e3) {
        return this.put(new SVG.OffsetEffect(t3, e3));
      }, image: function(t3) {
        return this.put(new SVG.ImageEffect(t3));
      }, merge: function() {
        var t3 = [void 0];
        for (var e3 in arguments)
          t3.push(arguments[e3]);
        return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t3))());
      }, gaussianBlur: function(t3, e3) {
        return this.put(new SVG.GaussianBlurEffect(t3, e3));
      }, morphology: function(t3, e3) {
        return this.put(new SVG.MorphologyEffect(t3, e3));
      }, diffuseLighting: function(t3, e3, i3) {
        return this.put(new SVG.DiffuseLightingEffect(t3, e3, i3));
      }, displacementMap: function(t3, e3, i3, a3, s3) {
        return this.put(new SVG.DisplacementMapEffect(t3, e3, i3, a3, s3));
      }, specularLighting: function(t3, e3, i3, a3) {
        return this.put(new SVG.SpecularLightingEffect(t3, e3, i3, a3));
      }, tile: function() {
        return this.put(new SVG.TileEffect());
      }, turbulence: function(t3, e3, i3, a3, s3) {
        return this.put(new SVG.TurbulenceEffect(t3, e3, i3, a3, s3));
      }, toString: function() {
        return "url(#" + this.attr("id") + ")";
      } } }), SVG.extend(SVG.Defs, { filter: function(t3) {
        var e3 = this.put(new SVG.Filter());
        return "function" == typeof t3 && t3.call(e3, e3), e3;
      } }), SVG.extend(SVG.Container, { filter: function(t3) {
        return this.defs().filter(t3);
      } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(t3) {
        return this.filterer = t3 instanceof SVG.Element ? t3 : this.doc().filter(t3), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
      }, unfilter: function(t3) {
        return this.filterer && true === t3 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
      } }), SVG.Effect = SVG.invent({ create: function() {
        this.constructor.call(this);
      }, inherit: SVG.Element, extend: { in: function(t3) {
        return null == t3 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t3);
      }, result: function(t3) {
        return null == t3 ? this.attr("result") : this.attr("result", t3);
      }, toString: function() {
        return this.result();
      } } }), SVG.ParentEffect = SVG.invent({ create: function() {
        this.constructor.call(this);
      }, inherit: SVG.Parent, extend: { in: function(t3) {
        return null == t3 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t3);
      }, result: function(t3) {
        return null == t3 ? this.attr("result") : this.attr("result", t3);
      }, toString: function() {
        return this.result();
      } } });
      var t2 = { blend: function(t3, e3) {
        return this.parent() && this.parent().blend(this, t3, e3);
      }, colorMatrix: function(t3, e3) {
        return this.parent() && this.parent().colorMatrix(t3, e3).in(this);
      }, convolveMatrix: function(t3) {
        return this.parent() && this.parent().convolveMatrix(t3).in(this);
      }, componentTransfer: function(t3) {
        return this.parent() && this.parent().componentTransfer(t3).in(this);
      }, composite: function(t3, e3) {
        return this.parent() && this.parent().composite(this, t3, e3);
      }, flood: function(t3, e3) {
        return this.parent() && this.parent().flood(t3, e3);
      }, offset: function(t3, e3) {
        return this.parent() && this.parent().offset(t3, e3).in(this);
      }, image: function(t3) {
        return this.parent() && this.parent().image(t3);
      }, merge: function() {
        return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
      }, gaussianBlur: function(t3, e3) {
        return this.parent() && this.parent().gaussianBlur(t3, e3).in(this);
      }, morphology: function(t3, e3) {
        return this.parent() && this.parent().morphology(t3, e3).in(this);
      }, diffuseLighting: function(t3, e3, i3) {
        return this.parent() && this.parent().diffuseLighting(t3, e3, i3).in(this);
      }, displacementMap: function(t3, e3, i3, a3) {
        return this.parent() && this.parent().displacementMap(this, t3, e3, i3, a3);
      }, specularLighting: function(t3, e3, i3, a3) {
        return this.parent() && this.parent().specularLighting(t3, e3, i3, a3).in(this);
      }, tile: function() {
        return this.parent() && this.parent().tile().in(this);
      }, turbulence: function(t3, e3, i3, a3, s3) {
        return this.parent() && this.parent().turbulence(t3, e3, i3, a3, s3).in(this);
      } };
      SVG.extend(SVG.Effect, t2), SVG.extend(SVG.ParentEffect, t2), SVG.ChildEffect = SVG.invent({ create: function() {
        this.constructor.call(this);
      }, inherit: SVG.Element, extend: { in: function(t3) {
        this.attr("in", t3);
      } } });
      var e2 = { blend: function(t3, e3, i3) {
        this.attr({ in: t3, in2: e3, mode: i3 || "normal" });
      }, colorMatrix: function(t3, e3) {
        "matrix" == t3 && (e3 = s2(e3)), this.attr({ type: t3, values: void 0 === e3 ? null : e3 });
      }, convolveMatrix: function(t3) {
        t3 = s2(t3), this.attr({ order: Math.sqrt(t3.split(" ").length), kernelMatrix: t3 });
      }, composite: function(t3, e3, i3) {
        this.attr({ in: t3, in2: e3, operator: i3 });
      }, flood: function(t3, e3) {
        this.attr("flood-color", t3), null != e3 && this.attr("flood-opacity", e3);
      }, offset: function(t3, e3) {
        this.attr({ dx: t3, dy: e3 });
      }, image: function(t3) {
        this.attr("href", t3, SVG.xlink);
      }, displacementMap: function(t3, e3, i3, a3, s3) {
        this.attr({ in: t3, in2: e3, scale: i3, xChannelSelector: a3, yChannelSelector: s3 });
      }, gaussianBlur: function(t3, e3) {
        null != t3 || null != e3 ? this.attr("stdDeviation", function(t4) {
          if (!Array.isArray(t4))
            return t4;
          for (var e4 = 0, i3 = t4.length, a3 = []; e4 < i3; e4++)
            a3.push(t4[e4]);
          return a3.join(" ");
        }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
      }, morphology: function(t3, e3) {
        this.attr({ operator: t3, radius: e3 });
      }, tile: function() {
      }, turbulence: function(t3, e3, i3, a3, s3) {
        this.attr({ numOctaves: e3, seed: i3, stitchTiles: a3, baseFrequency: t3, type: s3 });
      } }, i2 = { merge: function() {
        var t3;
        if (arguments[0] instanceof SVG.Set) {
          var e3 = this;
          arguments[0].each(function(t4) {
            this instanceof SVG.MergeNode ? e3.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e3.put(new SVG.MergeNode(this));
          });
        } else {
          t3 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
          for (var i3 = 0; i3 < t3.length; i3++)
            t3[i3] instanceof SVG.MergeNode ? this.put(t3[i3]) : this.put(new SVG.MergeNode(t3[i3]));
        }
      }, componentTransfer: function(t3) {
        if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(t4) {
          this[t4] = new SVG["Func" + t4.toUpperCase()]("identity"), this.rgb.add(this[t4]), this.node.appendChild(this[t4].node);
        }).bind(this)), t3)
          for (var e3 in t3.rgb && (["r", "g", "b"].forEach((function(e4) {
            this[e4].attr(t3.rgb);
          }).bind(this)), delete t3.rgb), t3)
            this[e3].attr(t3[e3]);
      }, diffuseLighting: function(t3, e3, i3) {
        this.attr({ surfaceScale: t3, diffuseConstant: e3, kernelUnitLength: i3 });
      }, specularLighting: function(t3, e3, i3, a3) {
        this.attr({ surfaceScale: t3, diffuseConstant: e3, specularExponent: i3, kernelUnitLength: a3 });
      } }, a2 = { distantLight: function(t3, e3) {
        this.attr({ azimuth: t3, elevation: e3 });
      }, pointLight: function(t3, e3, i3) {
        this.attr({ x: t3, y: e3, z: i3 });
      }, spotLight: function(t3, e3, i3, a3, s3, r3) {
        this.attr({ x: t3, y: e3, z: i3, pointsAtX: a3, pointsAtY: s3, pointsAtZ: r3 });
      }, mergeNode: function(t3) {
        this.attr("in", t3);
      } };
      function s2(t3) {
        return Array.isArray(t3) && (t3 = new SVG.Array(t3)), t3.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
      }
      function r2() {
        var t3 = function() {
        };
        for (var e3 in "function" == typeof arguments[arguments.length - 1] && (t3 = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
          for (var i3 in arguments[e3])
            t3(arguments[e3][i3], i3, arguments[e3]);
      }
      ["r", "g", "b", "a"].forEach(function(t3) {
        a2["Func" + t3.toUpperCase()] = function(t4) {
          switch (this.attr("type", t4), t4) {
            case "table":
              this.attr("tableValues", arguments[1]);
              break;
            case "linear":
              this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
              break;
            case "gamma":
              this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
          }
        };
      }), r2(e2, function(t3, e3) {
        var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
        SVG[i3 + "Effect"] = SVG.invent({ create: function() {
          this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments), this.result(this.attr("id") + "Out");
        }, inherit: SVG.Effect, extend: {} });
      }), r2(i2, function(t3, e3) {
        var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
        SVG[i3 + "Effect"] = SVG.invent({ create: function() {
          this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments), this.result(this.attr("id") + "Out");
        }, inherit: SVG.ParentEffect, extend: {} });
      }), r2(a2, function(t3, e3) {
        var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
        SVG[i3] = SVG.invent({ create: function() {
          this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments);
        }, inherit: SVG.ChildEffect, extend: {} });
      }), SVG.extend(SVG.MergeEffect, { in: function(t3) {
        return t3 instanceof SVG.MergeNode ? this.add(t3, 0) : this.add(new SVG.MergeNode(t3), 0), this;
      } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(t3) {
        return null == t3 ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t3);
      } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
    }).call(void 0), function() {
      function t2(t3, s3, r2, o2, n2, l2, h2) {
        for (var c2 = t3.slice(s3, r2 || h2), d2 = o2.slice(n2, l2 || h2), g2 = 0, u5 = { pos: [0, 0], start: [0, 0] }, p2 = { pos: [0, 0], start: [0, 0] }; ; ) {
          if (c2[g2] = e2.call(u5, c2[g2]), d2[g2] = e2.call(p2, d2[g2]), c2[g2][0] != d2[g2][0] || "M" == c2[g2][0] || "A" == c2[g2][0] && (c2[g2][4] != d2[g2][4] || c2[g2][5] != d2[g2][5]) ? (Array.prototype.splice.apply(c2, [g2, 1].concat(a2.call(u5, c2[g2]))), Array.prototype.splice.apply(d2, [g2, 1].concat(a2.call(p2, d2[g2])))) : (c2[g2] = i2.call(u5, c2[g2]), d2[g2] = i2.call(p2, d2[g2])), ++g2 == c2.length && g2 == d2.length)
            break;
          g2 == c2.length && c2.push(["C", u5.pos[0], u5.pos[1], u5.pos[0], u5.pos[1], u5.pos[0], u5.pos[1]]), g2 == d2.length && d2.push(["C", p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1]]);
        }
        return { start: c2, dest: d2 };
      }
      function e2(t3) {
        switch (t3[0]) {
          case "z":
          case "Z":
            t3[0] = "L", t3[1] = this.start[0], t3[2] = this.start[1];
            break;
          case "H":
            t3[0] = "L", t3[2] = this.pos[1];
            break;
          case "V":
            t3[0] = "L", t3[2] = t3[1], t3[1] = this.pos[0];
            break;
          case "T":
            t3[0] = "Q", t3[3] = t3[1], t3[4] = t3[2], t3[1] = this.reflection[1], t3[2] = this.reflection[0];
            break;
          case "S":
            t3[0] = "C", t3[6] = t3[4], t3[5] = t3[3], t3[4] = t3[2], t3[3] = t3[1], t3[2] = this.reflection[1], t3[1] = this.reflection[0];
        }
        return t3;
      }
      function i2(t3) {
        var e3 = t3.length;
        return this.pos = [t3[e3 - 2], t3[e3 - 1]], -1 != "SCQT".indexOf(t3[0]) && (this.reflection = [2 * this.pos[0] - t3[e3 - 4], 2 * this.pos[1] - t3[e3 - 3]]), t3;
      }
      function a2(t3) {
        var e3 = [t3];
        switch (t3[0]) {
          case "M":
            return this.pos = this.start = [t3[1], t3[2]], e3;
          case "L":
            t3[5] = t3[3] = t3[1], t3[6] = t3[4] = t3[2], t3[1] = this.pos[0], t3[2] = this.pos[1];
            break;
          case "Q":
            t3[6] = t3[4], t3[5] = t3[3], t3[4] = 1 * t3[4] / 3 + 2 * t3[2] / 3, t3[3] = 1 * t3[3] / 3 + 2 * t3[1] / 3, t3[2] = 1 * this.pos[1] / 3 + 2 * t3[2] / 3, t3[1] = 1 * this.pos[0] / 3 + 2 * t3[1] / 3;
            break;
          case "A":
            e3 = function(t4, e4) {
              var i3, a3, s3, r2, o2, n2, l2, h2, c2, d2, g2, u5, p2, f2, x2, b2, v2, m2, y2, w2, k2, A2, S2, C2, L2, P2, I2 = Math.abs(e4[1]), T2 = Math.abs(e4[2]), M2 = e4[3] % 360, z2 = e4[4], X2 = e4[5], E2 = e4[6], Y2 = e4[7], F2 = new SVG.Point(t4), R2 = new SVG.Point(E2, Y2), H2 = [];
              if (0 === I2 || 0 === T2 || F2.x === R2.x && F2.y === R2.y)
                return [["C", F2.x, F2.y, R2.x, R2.y, R2.x, R2.y]];
              i3 = new SVG.Point((F2.x - R2.x) / 2, (F2.y - R2.y) / 2).transform(new SVG.Matrix().rotate(M2)), (a3 = i3.x * i3.x / (I2 * I2) + i3.y * i3.y / (T2 * T2)) > 1 && (I2 *= a3 = Math.sqrt(a3), T2 *= a3);
              s3 = new SVG.Matrix().rotate(M2).scale(1 / I2, 1 / T2).rotate(-M2), F2 = F2.transform(s3), R2 = R2.transform(s3), r2 = [R2.x - F2.x, R2.y - F2.y], n2 = r2[0] * r2[0] + r2[1] * r2[1], o2 = Math.sqrt(n2), r2[0] /= o2, r2[1] /= o2, l2 = n2 < 4 ? Math.sqrt(1 - n2 / 4) : 0, z2 === X2 && (l2 *= -1);
              h2 = new SVG.Point((R2.x + F2.x) / 2 + l2 * -r2[1], (R2.y + F2.y) / 2 + l2 * r2[0]), c2 = new SVG.Point(F2.x - h2.x, F2.y - h2.y), d2 = new SVG.Point(R2.x - h2.x, R2.y - h2.y), g2 = Math.acos(c2.x / Math.sqrt(c2.x * c2.x + c2.y * c2.y)), c2.y < 0 && (g2 *= -1);
              u5 = Math.acos(d2.x / Math.sqrt(d2.x * d2.x + d2.y * d2.y)), d2.y < 0 && (u5 *= -1);
              X2 && g2 > u5 && (u5 += 2 * Math.PI);
              !X2 && g2 < u5 && (u5 -= 2 * Math.PI);
              for (f2 = Math.ceil(2 * Math.abs(g2 - u5) / Math.PI), b2 = [], v2 = g2, p2 = (u5 - g2) / f2, x2 = 4 * Math.tan(p2 / 4) / 3, k2 = 0; k2 <= f2; k2++)
                y2 = Math.cos(v2), m2 = Math.sin(v2), w2 = new SVG.Point(h2.x + y2, h2.y + m2), b2[k2] = [new SVG.Point(w2.x + x2 * m2, w2.y - x2 * y2), w2, new SVG.Point(w2.x - x2 * m2, w2.y + x2 * y2)], v2 += p2;
              for (b2[0][0] = b2[0][1].clone(), b2[b2.length - 1][2] = b2[b2.length - 1][1].clone(), s3 = new SVG.Matrix().rotate(M2).scale(I2, T2).rotate(-M2), k2 = 0, A2 = b2.length; k2 < A2; k2++)
                b2[k2][0] = b2[k2][0].transform(s3), b2[k2][1] = b2[k2][1].transform(s3), b2[k2][2] = b2[k2][2].transform(s3);
              for (k2 = 1, A2 = b2.length; k2 < A2; k2++)
                S2 = (w2 = b2[k2 - 1][2]).x, C2 = w2.y, L2 = (w2 = b2[k2][0]).x, P2 = w2.y, E2 = (w2 = b2[k2][1]).x, Y2 = w2.y, H2.push(["C", S2, C2, L2, P2, E2, Y2]);
              return H2;
            }(this.pos, t3), t3 = e3[0];
        }
        return t3[0] = "C", this.pos = [t3[5], t3[6]], this.reflection = [2 * t3[5] - t3[3], 2 * t3[6] - t3[4]], e3;
      }
      function s2(t3, e3) {
        if (false === e3)
          return false;
        for (var i3 = e3, a3 = t3.length; i3 < a3; ++i3)
          if ("M" == t3[i3][0])
            return i3;
        return false;
      }
      SVG.extend(SVG.PathArray, { morph: function(e3) {
        for (var i3 = this.value, a3 = this.parse(e3), r2 = 0, o2 = 0, n2 = false, l2 = false; false !== r2 || false !== o2; ) {
          var h2;
          n2 = s2(i3, false !== r2 && r2 + 1), l2 = s2(a3, false !== o2 && o2 + 1), false === r2 && (r2 = 0 == (h2 = new SVG.PathArray(c2.start).bbox()).height || 0 == h2.width ? i3.push(i3[0]) - 1 : i3.push(["M", h2.x + h2.width / 2, h2.y + h2.height / 2]) - 1), false === o2 && (o2 = 0 == (h2 = new SVG.PathArray(c2.dest).bbox()).height || 0 == h2.width ? a3.push(a3[0]) - 1 : a3.push(["M", h2.x + h2.width / 2, h2.y + h2.height / 2]) - 1);
          var c2 = t2(i3, r2, n2, a3, o2, l2);
          i3 = i3.slice(0, r2).concat(c2.start, false === n2 ? [] : i3.slice(n2)), a3 = a3.slice(0, o2).concat(c2.dest, false === l2 ? [] : a3.slice(l2)), r2 = false !== n2 && r2 + c2.start.length, o2 = false !== l2 && o2 + c2.dest.length;
        }
        return this.value = i3, this.destination = new SVG.PathArray(), this.destination.value = a3, this;
      } });
    }(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
    * https://github.com/svgdotjs/svg.draggable.js
    * Copyright (c) 2019 Wout Fierens; Licensed MIT */
    (function() {
      function t2(t3) {
        t3.remember("_draggable", this), this.el = t3;
      }
      t2.prototype.init = function(t3, e2) {
        var i2 = this;
        this.constraint = t3, this.value = e2, this.el.on("mousedown.drag", function(t4) {
          i2.start(t4);
        }), this.el.on("touchstart.drag", function(t4) {
          i2.start(t4);
        });
      }, t2.prototype.transformPoint = function(t3, e2) {
        var i2 = (t3 = t3 || window.event).changedTouches && t3.changedTouches[0] || t3;
        return this.p.x = i2.clientX - (e2 || 0), this.p.y = i2.clientY, this.p.matrixTransform(this.m);
      }, t2.prototype.getBBox = function() {
        var t3 = this.el.bbox();
        return this.el instanceof SVG.Nested && (t3 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t3.x = this.el.x(), t3.y = this.el.y()), t3;
      }, t2.prototype.start = function(t3) {
        if ("click" != t3.type && "mousedown" != t3.type && "mousemove" != t3.type || 1 == (t3.which || t3.buttons)) {
          var e2 = this;
          if (this.el.fire("beforedrag", { event: t3, handler: this }), !this.el.event().defaultPrevented) {
            t3.preventDefault(), t3.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
            var i2, a2 = this.getBBox();
            if (this.el instanceof SVG.Text)
              switch (i2 = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
                case "middle":
                  i2 /= 2;
                  break;
                case "start":
                  i2 = 0;
              }
            this.startPoints = { point: this.transformPoint(t3, i2), box: a2, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(t4) {
              e2.drag(t4);
            }), SVG.on(window, "touchmove.drag", function(t4) {
              e2.drag(t4);
            }), SVG.on(window, "mouseup.drag", function(t4) {
              e2.end(t4);
            }), SVG.on(window, "touchend.drag", function(t4) {
              e2.end(t4);
            }), this.el.fire("dragstart", { event: t3, p: this.startPoints.point, m: this.m, handler: this });
          }
        }
      }, t2.prototype.drag = function(t3) {
        var e2 = this.getBBox(), i2 = this.transformPoint(t3), a2 = this.startPoints.box.x + i2.x - this.startPoints.point.x, s2 = this.startPoints.box.y + i2.y - this.startPoints.point.y, r2 = this.constraint, o2 = i2.x - this.startPoints.point.x, n2 = i2.y - this.startPoints.point.y;
        if (this.el.fire("dragmove", { event: t3, p: i2, m: this.m, handler: this }), this.el.event().defaultPrevented)
          return i2;
        if ("function" == typeof r2) {
          var l2 = r2.call(this.el, a2, s2, this.m);
          "boolean" == typeof l2 && (l2 = { x: l2, y: l2 }), true === l2.x ? this.el.x(a2) : false !== l2.x && this.el.x(l2.x), true === l2.y ? this.el.y(s2) : false !== l2.y && this.el.y(l2.y);
        } else
          "object" == typeof r2 && (null != r2.minX && a2 < r2.minX ? o2 = (a2 = r2.minX) - this.startPoints.box.x : null != r2.maxX && a2 > r2.maxX - e2.width && (o2 = (a2 = r2.maxX - e2.width) - this.startPoints.box.x), null != r2.minY && s2 < r2.minY ? n2 = (s2 = r2.minY) - this.startPoints.box.y : null != r2.maxY && s2 > r2.maxY - e2.height && (n2 = (s2 = r2.maxY - e2.height) - this.startPoints.box.y), null != r2.snapToGrid && (a2 -= a2 % r2.snapToGrid, s2 -= s2 % r2.snapToGrid, o2 -= o2 % r2.snapToGrid, n2 -= n2 % r2.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: o2, y: n2 }, true) : this.el.move(a2, s2));
        return i2;
      }, t2.prototype.end = function(t3) {
        var e2 = this.drag(t3);
        this.el.fire("dragend", { event: t3, p: e2, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
      }, SVG.extend(SVG.Element, { draggable: function(e2, i2) {
        "function" != typeof e2 && "object" != typeof e2 || (i2 = e2, e2 = true);
        var a2 = this.remember("_draggable") || new t2(this);
        return (e2 = void 0 === e2 || e2) ? a2.init(i2 || {}, e2) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
      } });
    }).call(void 0), function() {
      function t2(t3) {
        this.el = t3, t3.remember("_selectHandler", this), this.pointSelection = { isSelected: false }, this.rectSelection = { isSelected: false }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(t4, e2, i2) {
          var a2 = "string" != typeof t4 ? t4 : e2[t4];
          return i2 ? a2 / 2 : a2;
        }, this.pointCoords = function(t4, e2) {
          var i2 = this.pointsList[t4];
          return { x: this.pointCoord(i2[0], e2, "t" === t4 || "b" === t4), y: this.pointCoord(i2[1], e2, "r" === t4 || "l" === t4) };
        };
      }
      t2.prototype.init = function(t3, e2) {
        var i2 = this.el.bbox();
        this.options = {};
        var a2 = this.el.selectize.defaults.points;
        for (var s2 in this.el.selectize.defaults)
          this.options[s2] = this.el.selectize.defaults[s2], void 0 !== e2[s2] && (this.options[s2] = e2[s2]);
        var r2 = ["points", "pointsExclude"];
        for (var s2 in r2) {
          var o2 = this.options[r2[s2]];
          "string" == typeof o2 ? o2 = o2.length > 0 ? o2.split(/\s*,\s*/i) : [] : "boolean" == typeof o2 && "points" === r2[s2] && (o2 = o2 ? a2 : []), this.options[r2[s2]] = o2;
        }
        this.options.points = [a2, this.options.points].reduce(function(t4, e3) {
          return t4.filter(function(t5) {
            return e3.indexOf(t5) > -1;
          });
        }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(t4, e3) {
          return t4.filter(function(t5) {
            return e3.indexOf(t5) < 0;
          });
        }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i2.x, i2.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t3) : this.selectRect(t3), this.observe(), this.cleanup();
      }, t2.prototype.selectPoints = function(t3) {
        return this.pointSelection.isSelected = t3, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
      }, t2.prototype.getPointArray = function() {
        var t3 = this.el.bbox();
        return this.el.array().valueOf().map(function(e2) {
          return [e2[0] - t3.x, e2[1] - t3.y];
        });
      }, t2.prototype.drawPoints = function() {
        for (var t3 = this, e2 = this.getPointArray(), i2 = 0, a2 = e2.length; i2 < a2; ++i2) {
          var s2 = function(e3) {
            return function(i3) {
              (i3 = i3 || window.event).preventDefault ? i3.preventDefault() : i3.returnValue = false, i3.stopPropagation();
              var a3 = i3.pageX || i3.touches[0].pageX, s3 = i3.pageY || i3.touches[0].pageY;
              t3.el.fire("point", { x: a3, y: s3, i: e3, event: i3 });
            };
          }(i2), r2 = this.drawPoint(e2[i2][0], e2[i2][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s2).on("mousedown", s2);
          this.pointSelection.set.add(r2);
        }
      }, t2.prototype.drawPoint = function(t3, e2) {
        var i2 = this.options.pointType;
        switch (i2) {
          case "circle":
            return this.drawCircle(t3, e2);
          case "rect":
            return this.drawRect(t3, e2);
          default:
            if ("function" == typeof i2)
              return i2.call(this, t3, e2);
            throw new Error("Unknown " + i2 + " point type!");
        }
      }, t2.prototype.drawCircle = function(t3, e2) {
        return this.nested.circle(this.options.pointSize).center(t3, e2);
      }, t2.prototype.drawRect = function(t3, e2) {
        return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t3, e2);
      }, t2.prototype.updatePointSelection = function() {
        var t3 = this.getPointArray();
        this.pointSelection.set.each(function(e2) {
          this.cx() === t3[e2][0] && this.cy() === t3[e2][1] || this.center(t3[e2][0], t3[e2][1]);
        });
      }, t2.prototype.updateRectSelection = function() {
        var t3 = this, e2 = this.el.bbox();
        if (this.rectSelection.set.get(0).attr({ width: e2.width, height: e2.height }), this.options.points.length && this.options.points.map(function(i3, a2) {
          var s2 = t3.pointCoords(i3, e2);
          t3.rectSelection.set.get(a2 + 1).center(s2.x, s2.y);
        }), this.options.rotationPoint) {
          var i2 = this.rectSelection.set.length();
          this.rectSelection.set.get(i2 - 1).center(e2.width / 2, 20);
        }
      }, t2.prototype.selectRect = function(t3) {
        var e2 = this, i2 = this.el.bbox();
        function a2(t4) {
          return function(i3) {
            (i3 = i3 || window.event).preventDefault ? i3.preventDefault() : i3.returnValue = false, i3.stopPropagation();
            var a3 = i3.pageX || i3.touches[0].pageX, s3 = i3.pageY || i3.touches[0].pageY;
            e2.el.fire(t4, { x: a3, y: s3, event: i3 });
          };
        }
        if (this.rectSelection.isSelected = t3, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i2.width, i2.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
          this.options.points.map(function(t4, s3) {
            var r3 = e2.pointCoords(t4, i2), o2 = e2.drawPoint(r3.x, r3.y).attr("class", e2.options.classPoints + "_" + t4).on("mousedown", a2(t4)).on("touchstart", a2(t4));
            e2.rectSelection.set.add(o2);
          }), this.rectSelection.set.each(function() {
            this.addClass(e2.options.classPoints);
          });
        }
        if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
          var s2 = function(t4) {
            (t4 = t4 || window.event).preventDefault ? t4.preventDefault() : t4.returnValue = false, t4.stopPropagation();
            var i3 = t4.pageX || t4.touches[0].pageX, a3 = t4.pageY || t4.touches[0].pageY;
            e2.el.fire("rot", { x: i3, y: a3, event: t4 });
          }, r2 = this.drawPoint(i2.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s2).on("mousedown", s2);
          this.rectSelection.set.add(r2);
        }
      }, t2.prototype.handler = function() {
        var t3 = this.el.bbox();
        this.nested.matrix(new SVG.Matrix(this.el).translate(t3.x, t3.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
      }, t2.prototype.observe = function() {
        var t3 = this;
        if (MutationObserver)
          if (this.rectSelection.isSelected || this.pointSelection.isSelected)
            this.observerInst = this.observerInst || new MutationObserver(function() {
              t3.handler();
            }), this.observerInst.observe(this.el.node, { attributes: true });
          else
            try {
              this.observerInst.disconnect(), delete this.observerInst;
            } catch (t4) {
            }
        else
          this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
            t3.handler();
          });
      }, t2.prototype.cleanup = function() {
        !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
          this.remove();
        }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
          this.remove();
        }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
      }, SVG.extend(SVG.Element, { selectize: function(e2, i2) {
        return "object" == typeof e2 && (i2 = e2, e2 = true), (this.remember("_selectHandler") || new t2(this)).init(void 0 === e2 || e2, i2 || {}), this;
      } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: true, deepSelect: false, pointType: "circle" };
    }(), function() {
      (function() {
        function t2(t3) {
          t3.remember("_resizeHandler", this), this.el = t3, this.parameters = {}, this.lastUpdateCall = null, this.p = t3.doc().node.createSVGPoint();
        }
        t2.prototype.transformPoint = function(t3, e2, i2) {
          return this.p.x = t3 - (this.offset.x - window.pageXOffset), this.p.y = e2 - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i2 || this.m);
        }, t2.prototype._extractPosition = function(t3) {
          return { x: null != t3.clientX ? t3.clientX : t3.touches[0].clientX, y: null != t3.clientY ? t3.clientY : t3.touches[0].clientY };
        }, t2.prototype.init = function(t3) {
          var e2 = this;
          if (this.stop(), "stop" !== t3) {
            for (var i2 in this.options = {}, this.el.resize.defaults)
              this.options[i2] = this.el.resize.defaults[i2], void 0 !== t3[i2] && (this.options[i2] = t3[i2]);
            this.el.on("lt.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("rt.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("rb.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("lb.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("t.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("r.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("b.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("l.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("rot.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("point.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.update();
          }
        }, t2.prototype.stop = function() {
          return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
        }, t2.prototype.resize = function(t3) {
          var e2 = this;
          this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
          var i2 = this._extractPosition(t3.detail.event);
          if (this.parameters = { type: this.el.type, p: this.transformPoint(i2.x, i2.y), x: t3.detail.x, y: t3.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t3.detail.i) {
            var a2 = this.el.array().valueOf();
            this.parameters.i = t3.detail.i, this.parameters.pointCoords = [a2[t3.detail.i][0], a2[t3.detail.i][1]];
          }
          switch (t3.type) {
            case "lt":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3);
                if (this.parameters.box.width - i3[0] > 0 && this.parameters.box.height - i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i3[0]);
                  i3 = this.checkAspectRatio(i3), this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y + i3[1]).size(this.parameters.box.width - i3[0], this.parameters.box.height - i3[1]);
                }
              };
              break;
            case "rt":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 2);
                if (this.parameters.box.width + i3[0] > 0 && this.parameters.box.height - i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return this.el.move(this.parameters.box.x - i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i3[0]);
                  i3 = this.checkAspectRatio(i3, true), this.el.move(this.parameters.box.x, this.parameters.box.y + i3[1]).size(this.parameters.box.width + i3[0], this.parameters.box.height - i3[1]);
                }
              };
              break;
            case "rb":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 0);
                if (this.parameters.box.width + i3[0] > 0 && this.parameters.box.height + i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return this.el.move(this.parameters.box.x - i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i3[0]);
                  i3 = this.checkAspectRatio(i3), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i3[0], this.parameters.box.height + i3[1]);
                }
              };
              break;
            case "lb":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 1);
                if (this.parameters.box.width - i3[0] > 0 && this.parameters.box.height + i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i3[0]);
                  i3 = this.checkAspectRatio(i3, true), this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y).size(this.parameters.box.width - i3[0], this.parameters.box.height + i3[1]);
                }
              };
              break;
            case "t":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 2);
                if (this.parameters.box.height - i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y + i3[1]).height(this.parameters.box.height - i3[1]);
                }
              };
              break;
            case "r":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 0);
                if (this.parameters.box.width + i3[0] > 0) {
                  if ("text" === this.parameters.type)
                    return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i3[0]);
                }
              };
              break;
            case "b":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 0);
                if (this.parameters.box.height + i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i3[1]);
                }
              };
              break;
            case "l":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 1);
                if (this.parameters.box.width - i3[0] > 0) {
                  if ("text" === this.parameters.type)
                    return;
                  this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y).width(this.parameters.box.width - i3[0]);
                }
              };
              break;
            case "rot":
              this.calc = function(t4, e3) {
                var i3 = t4 + this.parameters.p.x, a3 = e3 + this.parameters.p.y, s2 = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), r2 = Math.atan2(a3 - this.parameters.box.y - this.parameters.box.height / 2, i3 - this.parameters.box.x - this.parameters.box.width / 2), o2 = this.parameters.rotation + 180 * (r2 - s2) / Math.PI + this.options.snapToAngle / 2;
                this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o2 - o2 % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
              };
              break;
            case "point":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), a3 = this.el.array().valueOf();
                a3[this.parameters.i][0] = this.parameters.pointCoords[0] + i3[0], a3[this.parameters.i][1] = this.parameters.pointCoords[1] + i3[1], this.el.plot(a3);
              };
          }
          this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t3 }), SVG.on(window, "touchmove.resize", function(t4) {
            e2.update(t4 || window.event);
          }), SVG.on(window, "touchend.resize", function() {
            e2.done();
          }), SVG.on(window, "mousemove.resize", function(t4) {
            e2.update(t4 || window.event);
          }), SVG.on(window, "mouseup.resize", function() {
            e2.done();
          });
        }, t2.prototype.update = function(t3) {
          if (t3) {
            var e2 = this._extractPosition(t3), i2 = this.transformPoint(e2.x, e2.y), a2 = i2.x - this.parameters.p.x, s2 = i2.y - this.parameters.p.y;
            this.lastUpdateCall = [a2, s2], this.calc(a2, s2), this.el.fire("resizing", { dx: a2, dy: s2, event: t3 });
          } else
            this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
        }, t2.prototype.done = function() {
          this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
        }, t2.prototype.snapToGrid = function(t3, e2, i2, a2) {
          var s2;
          return void 0 !== a2 ? s2 = [(i2 + t3) % this.options.snapToGrid, (a2 + e2) % this.options.snapToGrid] : (i2 = null == i2 ? 3 : i2, s2 = [(this.parameters.box.x + t3 + (1 & i2 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e2 + (2 & i2 ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t3 < 0 && (s2[0] -= this.options.snapToGrid), e2 < 0 && (s2[1] -= this.options.snapToGrid), t3 -= Math.abs(s2[0]) < this.options.snapToGrid / 2 ? s2[0] : s2[0] - (t3 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e2 -= Math.abs(s2[1]) < this.options.snapToGrid / 2 ? s2[1] : s2[1] - (e2 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t3, e2, i2, a2);
        }, t2.prototype.constraintToBox = function(t3, e2, i2, a2) {
          var s2, r2, o2 = this.options.constraint || {};
          return void 0 !== a2 ? (s2 = i2, r2 = a2) : (s2 = this.parameters.box.x + (1 & i2 ? 0 : this.parameters.box.width), r2 = this.parameters.box.y + (2 & i2 ? 0 : this.parameters.box.height)), void 0 !== o2.minX && s2 + t3 < o2.minX && (t3 = o2.minX - s2), void 0 !== o2.maxX && s2 + t3 > o2.maxX && (t3 = o2.maxX - s2), void 0 !== o2.minY && r2 + e2 < o2.minY && (e2 = o2.minY - r2), void 0 !== o2.maxY && r2 + e2 > o2.maxY && (e2 = o2.maxY - r2), [t3, e2];
        }, t2.prototype.checkAspectRatio = function(t3, e2) {
          if (!this.options.saveAspectRatio)
            return t3;
          var i2 = t3.slice(), a2 = this.parameters.box.width / this.parameters.box.height, s2 = this.parameters.box.width + t3[0], r2 = this.parameters.box.height - t3[1], o2 = s2 / r2;
          return o2 < a2 ? (i2[1] = s2 / a2 - this.parameters.box.height, e2 && (i2[1] = -i2[1])) : o2 > a2 && (i2[0] = this.parameters.box.width - r2 * a2, e2 && (i2[0] = -i2[0])), i2;
        }, SVG.extend(SVG.Element, { resize: function(e2) {
          return (this.remember("_resizeHandler") || new t2(this)).init(e2 || {}), this;
        } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: false };
      }).call(this);
    }(), void 0 === window.Apex && (window.Apex = {});
    var Gt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "initModules", value: function() {
        this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new b(this.ctx), this.ctx.axes = new J(this.ctx), this.ctx.core = new Wt(this.ctx.el, this.ctx), this.ctx.config = new E({}), this.ctx.data = new W(this.ctx), this.ctx.grid = new j(this.ctx), this.ctx.graphics = new m(this.ctx), this.ctx.coreUtils = new y(this.ctx), this.ctx.crosshairs = new Q(this.ctx), this.ctx.events = new Z(this.ctx), this.ctx.exports = new G(this.ctx), this.ctx.localization = new $(this.ctx), this.ctx.options = new L(), this.ctx.responsive = new K(this.ctx), this.ctx.series = new N(this.ctx), this.ctx.theme = new tt(this.ctx), this.ctx.formatters = new T(this.ctx), this.ctx.titleSubtitle = new et(this.ctx), this.ctx.legend = new lt(this.ctx), this.ctx.toolbar = new ht(this.ctx), this.ctx.tooltip = new bt(this.ctx), this.ctx.dimensions = new ot(this.ctx), this.ctx.updateHelpers = new Bt(this.ctx), this.ctx.zoomPanSelection = new ct(this.ctx), this.ctx.w.globals.tooltip = new bt(this.ctx);
      } }]), t2;
    }();
    var Vt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "clear", value: function(t3) {
        var e2 = t3.isUpdating;
        this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e2 });
      } }, { key: "killSVG", value: function(t3) {
        t3.each(function(t4, e2) {
          this.removeClass("*"), this.off(), this.stop();
        }, true), t3.ungroup(), t3.clear();
      } }, { key: "clearDomElements", value: function(t3) {
        var e2 = this, i2 = t3.isUpdating, a2 = this.w.globals.dom.Paper.node;
        a2.parentNode && a2.parentNode.parentNode && !i2 && (a2.parentNode.parentNode.style.minHeight = "unset");
        var s2 = this.w.globals.dom.baseEl;
        s2 && this.ctx.eventList.forEach(function(t4) {
          s2.removeEventListener(t4, e2.ctx.events.documentEvent);
        });
        var r2 = this.w.globals.dom;
        if (null !== this.ctx.el)
          for (; this.ctx.el.firstChild; )
            this.ctx.el.removeChild(this.ctx.el.firstChild);
        this.killSVG(r2.Paper), r2.Paper.remove(), r2.elWrap = null, r2.elGraphical = null, r2.elLegendWrap = null, r2.elLegendForeign = null, r2.baseEl = null, r2.elGridRect = null, r2.elGridRectMask = null, r2.elGridRectMarkerMask = null, r2.elForecastMask = null, r2.elNonForecastMask = null, r2.elDefs = null;
      } }]), t2;
    }();
    var jt = /* @__PURE__ */ new WeakMap();
    var _t = function() {
      function t2(e2, i2) {
        a(this, t2), this.opts = i2, this.ctx = this, this.w = new F(i2).init(), this.el = e2, this.w.globals.cuid = x.randomId(), this.w.globals.chartID = this.w.config.chart.id ? x.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Gt(this).initModules(), this.create = x.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
      }
      return r(t2, [{ key: "render", value: function() {
        var t3 = this;
        return new Promise(function(e2, i2) {
          if (null !== t3.el) {
            void 0 === Apex._chartInstances && (Apex._chartInstances = []), t3.w.config.chart.id && Apex._chartInstances.push({ id: t3.w.globals.chartID, group: t3.w.config.chart.group, chart: t3 }), t3.setLocale(t3.w.config.chart.defaultLocale);
            var a2 = t3.w.config.chart.events.beforeMount;
            if ("function" == typeof a2 && a2(t3, t3.w), t3.events.fireEvent("beforeMount", [t3, t3.w]), window.addEventListener("resize", t3.windowResizeHandler), function(t4, e3) {
              var i3 = false;
              if (t4.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                var a3 = t4.getBoundingClientRect();
                "none" !== t4.style.display && 0 !== a3.width || (i3 = true);
              }
              var s3 = new ResizeObserver(function(a4) {
                i3 && e3.call(t4, a4), i3 = true;
              });
              t4.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t4.children).forEach(function(t5) {
                return s3.observe(t5);
              }) : s3.observe(t4), jt.set(e3, s3);
            }(t3.el.parentNode, t3.parentResizeHandler), !t3.css) {
              var s2 = t3.el.getRootNode && t3.el.getRootNode(), r2 = x.is("ShadowRoot", s2), o2 = t3.el.ownerDocument, n2 = o2.getElementById("apexcharts-css");
              if (r2 || !n2) {
                var l2;
                t3.css = document.createElement("style"), t3.css.id = "apexcharts-css", t3.css.textContent = '@keyframes opaque {\n  0% {\n      opacity: 0\n  }\n\n  to {\n      opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n  0%,to {\n      opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\n.legend-mouseover-inactive {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255,255,255,.96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30,.8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0,0,0,.7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0!important\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0,0,0,.7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n      opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {\n  opacity: 0\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,.resize-triggers,.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers{\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows{\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers{\n  pointer-events: none\n}';
                var h2 = (null === (l2 = t3.opts.chart) || void 0 === l2 ? void 0 : l2.nonce) || t3.w.config.chart.nonce;
                h2 && t3.css.setAttribute("nonce", h2), r2 ? s2.prepend(t3.css) : o2.head.appendChild(t3.css);
              }
            }
            var c2 = t3.create(t3.w.config.series, {});
            if (!c2)
              return e2(t3);
            t3.mount(c2).then(function() {
              "function" == typeof t3.w.config.chart.events.mounted && t3.w.config.chart.events.mounted(t3, t3.w), t3.events.fireEvent("mounted", [t3, t3.w]), e2(c2);
            }).catch(function(t4) {
              i2(t4);
            });
          } else
            i2(new Error("Element not found"));
        });
      } }, { key: "create", value: function(t3, e2) {
        var i2 = this.w;
        new Gt(this).initModules();
        var a2 = this.w.globals;
        (a2.noData = false, a2.animationEnded = false, this.responsive.checkResponsiveConfig(e2), i2.config.xaxis.convertedCatToNumeric) && new X(i2.config).convertCatToNumericXaxis(i2.config, this.ctx);
        if (null === this.el)
          return a2.animationEnded = true, null;
        if (this.core.setupElements(), "treemap" === i2.config.chart.type && (i2.config.grid.show = false, i2.config.yaxis[0].show = false), 0 === a2.svgWidth)
          return a2.animationEnded = true, null;
        var s2 = y.checkComboSeries(t3);
        a2.comboCharts = s2.comboCharts, a2.comboBarCount = s2.comboBarCount;
        var r2 = t3.every(function(t4) {
          return t4.data && 0 === t4.data.length;
        });
        (0 === t3.length || r2) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t3), this.theme.init(), new H(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a2.noData && a2.collapsedSeries.length !== a2.series.length && !i2.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a2.axisCharts && (this.core.coreCalculations(), "category" !== i2.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i2.globals.minX, this.ctx.toolbar.maxX = i2.globals.maxX), this.formatters.heatmapLabelFormatters(), new y(this).getLargestMarkerSize(), this.dimensions.plotCoords();
        var o2 = this.core.xySettings();
        this.grid.createGridMask();
        var n2 = this.core.plotChartType(t3, o2), l2 = new O(this);
        return l2.bringForward(), i2.config.dataLabels.background.enabled && l2.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: n2, xyRatios: o2, dimensions: { plot: { left: i2.globals.translateX, top: i2.globals.translateY, width: i2.globals.gridWidth, height: i2.globals.gridHeight } } };
      } }, { key: "mount", value: function() {
        var t3 = this, e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i2 = this, a2 = i2.w;
        return new Promise(function(s2, r2) {
          if (null === i2.el)
            return r2(new Error("Not enough data to display or target element not found"));
          (null === e2 || a2.globals.allSeriesCollapsed) && i2.series.handleNoData(), i2.grid = new j(i2);
          var o2, n2, l2 = i2.grid.drawGrid();
          (i2.annotations = new P(i2), i2.annotations.drawImageAnnos(), i2.annotations.drawTextAnnos(), "back" === a2.config.grid.position) && (l2 && a2.globals.dom.elGraphical.add(l2.el), null != l2 && null !== (o2 = l2.elGridBorders) && void 0 !== o2 && o2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
          if (Array.isArray(e2.elGraph))
            for (var h2 = 0; h2 < e2.elGraph.length; h2++)
              a2.globals.dom.elGraphical.add(e2.elGraph[h2]);
          else
            a2.globals.dom.elGraphical.add(e2.elGraph);
          "front" === a2.config.grid.position && (l2 && a2.globals.dom.elGraphical.add(l2.el), null != l2 && null !== (n2 = l2.elGridBorders) && void 0 !== n2 && n2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
          "front" === a2.config.xaxis.crosshairs.position && i2.crosshairs.drawXCrosshairs(), "front" === a2.config.yaxis[0].crosshairs.position && i2.crosshairs.drawYCrosshairs(), "treemap" !== a2.config.chart.type && i2.axes.drawAxis(a2.config.chart.type, l2);
          var c2 = new V(t3.ctx, l2), d2 = new q(t3.ctx, l2);
          if (null !== l2 && (c2.xAxisLabelCorrections(l2.xAxisTickWidth), d2.setYAxisTextAlignments(), a2.config.yaxis.map(function(t4, e3) {
            -1 === a2.globals.ignoreYAxisIndexes.indexOf(e3) && d2.yAxisTitleRotate(e3, t4.opposite);
          })), i2.annotations.drawAxesAnnotations(), !a2.globals.noData) {
            if (a2.config.tooltip.enabled && !a2.globals.noData && i2.w.globals.tooltip.drawTooltip(e2.xyRatios), a2.globals.axisCharts && (a2.globals.isXNumeric || a2.config.xaxis.convertedCatToNumeric || a2.globals.isRangeBar))
              (a2.config.chart.zoom.enabled || a2.config.chart.selection && a2.config.chart.selection.enabled || a2.config.chart.pan && a2.config.chart.pan.enabled) && i2.zoomPanSelection.init({ xyRatios: e2.xyRatios });
            else {
              var g2 = a2.config.chart.toolbar.tools;
              ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(t4) {
                g2[t4] = false;
              });
            }
            a2.config.chart.toolbar.show && !a2.globals.allSeriesCollapsed && i2.toolbar.createToolbar();
          }
          a2.globals.memory.methodsToExec.length > 0 && a2.globals.memory.methodsToExec.forEach(function(t4) {
            t4.method(t4.params, false, t4.context);
          }), a2.globals.axisCharts || a2.globals.noData || i2.core.resizeNonAxisCharts(), s2(i2);
        });
      } }, { key: "destroy", value: function() {
        var t3, e2;
        window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t3 = this.parentResizeHandler, (e2 = jt.get(t3)) && (e2.disconnect(), jt.delete(t3));
        var i2 = this.w.config.chart.id;
        i2 && Apex._chartInstances.forEach(function(t4, e3) {
          t4.id === x.escapeString(i2) && Apex._chartInstances.splice(e3, 1);
        }), new Vt(this.ctx).clear({ isUpdating: false });
      } }, { key: "updateOptions", value: function(t3) {
        var e2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], o2 = this.w;
        return o2.globals.selection = void 0, t3.series && (this.series.resetSeries(false, true, false), t3.series.length && t3.series[0].data && (t3.series = t3.series.map(function(t4, i3) {
          return e2.updateHelpers._extendSeries(t4, i3);
        })), this.updateHelpers.revertDefaultAxisMinMax()), t3.xaxis && (t3 = this.updateHelpers.forceXAxisUpdate(t3)), t3.yaxis && (t3 = this.updateHelpers.forceYAxisUpdate(t3)), o2.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t3.theme && (t3 = this.theme.updateThemeOptions(t3)), this.updateHelpers._updateOptions(t3, i2, a2, s2, r2);
      } }, { key: "updateSeries", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t3, e2, i2);
      } }, { key: "appendSeries", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = this.w.config.series.slice();
        return a2.push(t3), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a2, e2, i2);
      } }, { key: "appendData", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this;
        i2.w.globals.dataChanged = true, i2.series.getPreviousPaths();
        for (var a2 = i2.w.config.series.slice(), s2 = 0; s2 < a2.length; s2++)
          if (null !== t3[s2] && void 0 !== t3[s2])
            for (var r2 = 0; r2 < t3[s2].data.length; r2++)
              a2[s2].data.push(t3[s2].data[r2]);
        return i2.w.config.series = a2, e2 && (i2.w.globals.initialSeries = x.clone(i2.w.config.series)), this.update();
      } }, { key: "update", value: function(t3) {
        var e2 = this;
        return new Promise(function(i2, a2) {
          new Vt(e2.ctx).clear({ isUpdating: true });
          var s2 = e2.create(e2.w.config.series, t3);
          if (!s2)
            return i2(e2);
          e2.mount(s2).then(function() {
            "function" == typeof e2.w.config.chart.events.updated && e2.w.config.chart.events.updated(e2, e2.w), e2.events.fireEvent("updated", [e2, e2.w]), e2.w.globals.isDirty = true, i2(e2);
          }).catch(function(t4) {
            a2(t4);
          });
        });
      } }, { key: "getSyncedCharts", value: function() {
        var t3 = this.getGroupedCharts(), e2 = [this];
        return t3.length && (e2 = [], t3.forEach(function(t4) {
          e2.push(t4);
        })), e2;
      } }, { key: "getGroupedCharts", value: function() {
        var t3 = this;
        return Apex._chartInstances.filter(function(t4) {
          if (t4.group)
            return true;
        }).map(function(e2) {
          return t3.w.config.chart.group === e2.group ? e2.chart : t3;
        });
      } }, { key: "toggleSeries", value: function(t3) {
        return this.series.toggleSeries(t3);
      } }, { key: "highlightSeriesOnLegendHover", value: function(t3, e2) {
        return this.series.toggleSeriesOnHover(t3, e2);
      } }, { key: "showSeries", value: function(t3) {
        this.series.showSeries(t3);
      } }, { key: "hideSeries", value: function(t3) {
        this.series.hideSeries(t3);
      } }, { key: "isSeriesHidden", value: function(t3) {
        this.series.isSeriesHidden(t3);
      } }, { key: "resetSeries", value: function() {
        var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        this.series.resetSeries(t3, e2);
      } }, { key: "addEventListener", value: function(t3, e2) {
        this.events.addEventListener(t3, e2);
      } }, { key: "removeEventListener", value: function(t3, e2) {
        this.events.removeEventListener(t3, e2);
      } }, { key: "addXaxisAnnotation", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
        i2 && (a2 = i2), a2.annotations.addXaxisAnnotationExternal(t3, e2, a2);
      } }, { key: "addYaxisAnnotation", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
        i2 && (a2 = i2), a2.annotations.addYaxisAnnotationExternal(t3, e2, a2);
      } }, { key: "addPointAnnotation", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
        i2 && (a2 = i2), a2.annotations.addPointAnnotationExternal(t3, e2, a2);
      } }, { key: "clearAnnotations", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e2 = this;
        t3 && (e2 = t3), e2.annotations.clearAnnotations(e2);
      } }, { key: "removeAnnotation", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i2 = this;
        e2 && (i2 = e2), i2.annotations.removeAnnotation(i2, t3);
      } }, { key: "getChartArea", value: function() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
      } }, { key: "getSeriesTotalXRange", value: function(t3, e2) {
        return this.coreUtils.getSeriesTotalsXRange(t3, e2);
      } }, { key: "getHighestValueInSeries", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        return new U(this.ctx).getMinYMaxY(t3).highestY;
      } }, { key: "getLowestValueInSeries", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        return new U(this.ctx).getMinYMaxY(t3).lowestY;
      } }, { key: "getSeriesTotal", value: function() {
        return this.w.globals.seriesTotals;
      } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
        return this.updateHelpers.toggleDataPointSelection(t3, e2);
      } }, { key: "zoomX", value: function(t3, e2) {
        this.ctx.toolbar.zoomUpdateOptions(t3, e2);
      } }, { key: "setLocale", value: function(t3) {
        this.localization.setCurrentLocaleValues(t3);
      } }, { key: "dataURI", value: function(t3) {
        return new G(this.ctx).dataURI(t3);
      } }, { key: "exportToCSV", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return new G(this.ctx).exportToCSV(t3);
      } }, { key: "paper", value: function() {
        return this.w.globals.dom.Paper;
      } }, { key: "_parentResizeCallback", value: function() {
        this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
      } }, { key: "_windowResize", value: function() {
        var t3 = this;
        clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
          t3.w.globals.resized = true, t3.w.globals.dataChanged = false, t3.ctx.update();
        }, 150);
      } }, { key: "_windowResizeHandler", value: function() {
        var t3 = this.w.config.chart.redrawOnWindowResize;
        "function" == typeof t3 && (t3 = t3()), t3 && this._windowResize();
      } }], [{ key: "getChartByID", value: function(t3) {
        var e2 = x.escapeString(t3);
        if (Apex._chartInstances) {
          var i2 = Apex._chartInstances.filter(function(t4) {
            return t4.id === e2;
          })[0];
          return i2 && i2.chart;
        }
      } }, { key: "initOnLoad", value: function() {
        for (var e2 = document.querySelectorAll("[data-apexcharts]"), i2 = 0; i2 < e2.length; i2++) {
          new t2(e2[i2], JSON.parse(e2[i2].getAttribute("data-options"))).render();
        }
      } }, { key: "exec", value: function(t3, e2) {
        var i2 = this.getChartByID(t3);
        if (i2) {
          i2.w.globals.isExecCalled = true;
          var a2 = null;
          if (-1 !== i2.publicMethods.indexOf(e2)) {
            for (var s2 = arguments.length, r2 = new Array(s2 > 2 ? s2 - 2 : 0), o2 = 2; o2 < s2; o2++)
              r2[o2 - 2] = arguments[o2];
            a2 = i2[e2].apply(i2, r2);
          }
          return a2;
        }
      } }, { key: "merge", value: function(t3, e2) {
        return x.extend(t3, e2);
      } }]), t2;
    }();
    module.exports = _t;
  }
});

// _mock/index.ts
var mock_exports = {};
__export(mock_exports, {
  USERS: () => USERS
});

// _mock/_user.ts
var list = [];
var total = 50;
for (let i = 0; i < total; i += 1) {
  list.push({
    id: i + 1,
    disabled: i % 6 === 0,
    href: "https://ant.design",
    avatar: [
      "https://gw.alipayobjects.com/zos/rmsportal/eeHMaZBwmTvLdIwMfBpg.png",
      "https://gw.alipayobjects.com/zos/rmsportal/udxAbMEhpwthVVcjLXik.png"
    ][i % 2],
    no: `TradeCode ${i}`,
    title: `\u4E00\u4E2A\u4EFB\u52A1\u540D\u79F0 ${i}`,
    owner: "\u66F2\u4E3D\u4E3D",
    description: "\u8FD9\u662F\u4E00\u6BB5\u63CF\u8FF0",
    callNo: Math.floor(Math.random() * 1e3),
    status: Math.floor(Math.random() * 10) % 4,
    updatedAt: /* @__PURE__ */ new Date(`2017-07-${Math.floor(i / 2) + 1}`),
    createdAt: /* @__PURE__ */ new Date(`2017-07-${Math.floor(i / 2) + 1}`),
    progress: Math.ceil(Math.random() * 100)
  });
}
function genData(params) {
  let ret = [...list];
  const pi = +params.pi;
  const ps = +params.ps;
  const start = (pi - 1) * ps;
  if (params.no) {
    ret = ret.filter((data) => data.no.indexOf(params.no) > -1);
  }
  return { total: ret.length, list: ret.slice(start, ps * pi) };
}
function saveData(id, value) {
  const item = list.find((w) => w.id === id);
  if (!item) {
    return { msg: "\u65E0\u6548\u7528\u6237\u4FE1\u606F" };
  }
  Object.assign(item, value);
  return { msg: "ok" };
}
var USERS = {
  "/user": (req) => genData(req.queryString),
  "/user/:id": (req) => list.find((w) => w.id === +req.params.id),
  "POST /user/:id": (req) => saveData(+req.params.id, req.body),
  "/user/current": {
    name: "Cipchk",
    avatar: "https://gw.alipayobjects.com/zos/rmsportal/BiazfanxmamNRoxxVxka.png",
    userid: "00000001",
    email: "cipchk@qq.com",
    signature: "\u6D77\u7EB3\u767E\u5DDD\uFF0C\u6709\u5BB9\u4E43\u5927",
    title: "\u4EA4\u4E92\u4E13\u5BB6",
    group: "\u8682\u8681\u91D1\u670D\uFF0D\u67D0\u67D0\u67D0\u4E8B\u4E1A\u7FA4\uFF0D\u67D0\u67D0\u5E73\u53F0\u90E8\uFF0D\u67D0\u67D0\u6280\u672F\u90E8\uFF0DUED",
    tags: [
      {
        key: "0",
        label: "\u5F88\u6709\u60F3\u6CD5\u7684"
      },
      {
        key: "1",
        label: "\u4E13\u6CE8\u64A9\u59B9"
      },
      {
        key: "2",
        label: "\u5E05~"
      },
      {
        key: "3",
        label: "\u901A\u5403"
      },
      {
        key: "4",
        label: "\u4E13\u804C\u540E\u7AEF"
      },
      {
        key: "5",
        label: "\u6D77\u7EB3\u767E\u5DDD"
      }
    ],
    notifyCount: 12,
    country: "China",
    geographic: {
      province: {
        label: "\u4E0A\u6D77",
        key: "330000"
      },
      city: {
        label: "\u5E02\u8F96\u533A",
        key: "330100"
      }
    },
    address: "XX\u533AXXX\u8DEF XX \u53F7",
    phone: "\u4F60\u731C-\u4F60\u731C\u4F60\u731C\u731C\u731C"
  },
  "POST /user/avatar": "ok",
  "POST /login/account": (req) => {
    const data = req.body;
    if (!(data.userName === "admin" || data.userName === "user") || data.password !== "ng-alain.com") {
      return { msg: `Invalid username or password\uFF08admin/ng-alain.com\uFF09` };
    }
    return {
      msg: "ok",
      user: {
        token: "123456789",
        name: data.userName,
        email: `${data.userName}@qq.com`,
        id: 1e4,
        time: +/* @__PURE__ */ new Date()
      }
    };
  },
  "POST /register": {
    msg: "ok"
  }
};

// node_modules/@delon/mock/fesm2022/mock.mjs
var MockStatusError = class {
  constructor(status, error) {
    this.status = status;
    this.error = error;
  }
};
var MOCK_DEFULAT_CONFIG = {
  delay: 300,
  force: false,
  log: true
};
var DELON_MOCK_CONFIG = new InjectionToken("alain-mock-config");
function provideMockConfig(config) {
  return makeEnvironmentProviders([{
    provide: DELON_MOCK_CONFIG,
    useValue: config
  }]);
}
var _MockService = class _MockService {
  constructor(cogSrv, options) {
    this.cached = [];
    this.config = cogSrv.merge("mock", MOCK_DEFULAT_CONFIG);
    this.setData(options?.data);
  }
  /**
   * Reset request data
   *
   * 重新设置请求数据
   */
  setData(data) {
    this.applyMock(data);
  }
  // #region parse rule
  applyMock(data) {
    this.cached = [];
    try {
      this.realApplyMock(data);
    } catch (e) {
      this.outputError(e);
    }
  }
  realApplyMock(data) {
    if (!data)
      return;
    Object.keys(data).forEach((key) => {
      const rules = data[key];
      if (!rules)
        return;
      Object.keys(rules).forEach((ruleKey) => {
        const value = rules[ruleKey];
        if (!(typeof value === "function" || typeof value === "object" || typeof value === "string")) {
          throw Error(`mock value of [${key}-${ruleKey}] should be function or object or string, but got ${typeof value}`);
        }
        const rule = this.genRule(ruleKey, value);
        if (["GET", "POST", "PUT", "HEAD", "DELETE", "PATCH", "OPTIONS"].indexOf(rule.method) === -1) {
          throw Error(`method of ${key}-${ruleKey} is not valid`);
        }
        const item = this.cached.find((w) => w.url === rule.url && w.method === rule.method);
        if (item) {
          item.callback = rule.callback;
        } else {
          this.cached.push(rule);
        }
      });
    });
    this.cached.sort((a, b) => (b.martcher || "").toString().length - (a.martcher || "").toString().length);
  }
  genRule(key, callback) {
    let method = "GET";
    let url = key;
    if (key.indexOf(" ") > -1) {
      const splited = key.split(" ");
      method = splited[0].toLowerCase();
      url = splited[1];
    }
    let martcher = null;
    let segments = [];
    if (~url.indexOf(":")) {
      segments = url.split("/").filter((segment) => segment.startsWith(":")).map((v) => v.substring(1));
      const reStr = url.split("/").map((segment) => segment.startsWith(":") ? `([^/]+)` : segment).join("/");
      martcher = new RegExp(`^${reStr}`, "i");
    } else if (/(\([^)]+\))/i.test(url)) {
      martcher = new RegExp(url, "i");
    }
    return {
      url,
      martcher,
      segments,
      callback,
      method: method.toUpperCase()
    };
  }
  outputError(error) {
    const filePath = error.message.split(": ")[0];
    const errors = error.stack.split("\n").filter((line) => line.trim().indexOf("at ") !== 0).map((line) => line.replace(`${filePath}: `, ""));
    errors.splice(1, 0, "");
    console.group();
    console.warn(`==========Failed to parse mock config.==========`);
    console.log(errors.join("\n"));
    console.groupEnd();
    throw error;
  }
  // #endregion
  getRule(method, url) {
    method = (method || "GET").toUpperCase();
    const params = {};
    const list2 = this.cached.filter((w) => w.method === method && (w.martcher ? w.martcher.test(url) : w.url === url));
    if (list2.length === 0)
      return null;
    const ret = list2.find((w) => w.url === url) || list2[0];
    if (ret.martcher) {
      const execArr = ret.martcher.exec(url);
      execArr.slice(1).map((value, index) => {
        params[ret.segments[index]] = value;
      });
    }
    return {
      url,
      method: ret.method,
      params,
      callback: ret.callback
    };
  }
  clearCache() {
    this.cached = [];
  }
  get rules() {
    return this.cached;
  }
  ngOnDestroy() {
    this.clearCache();
  }
};
_MockService.\u0275fac = function MockService_Factory(t) {
  return new (t || _MockService)(\u0275\u0275inject(AlainConfigService), \u0275\u0275inject(DELON_MOCK_CONFIG, 8));
};
_MockService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _MockService,
  factory: _MockService.\u0275fac,
  providedIn: "root"
});
var MockService = _MockService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MockService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AlainConfigService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DELON_MOCK_CONFIG]
    }]
  }], null);
})();
var mockInterceptor = (req, next) => {
  const src = inject(MockService);
  const config = src.config;
  const rule = src.getRule(req.method, req.url.split("?")[0]);
  if (!rule && !config.force) {
    return next(req);
  }
  let res$;
  switch (typeof rule.callback) {
    case "function":
      const mockRequest = {
        original: req,
        body: req.body,
        queryString: {},
        headers: {},
        params: rule.params
      };
      const urlParams = req.url.split("?");
      if (urlParams.length > 1) {
        urlParams[1].split("&").forEach((item) => {
          const itemArr = item.split("=");
          const key = itemArr[0];
          const value = itemArr[1];
          if (Object.keys(mockRequest.queryString).includes(key)) {
            if (!Array.isArray(mockRequest.queryString[key])) {
              mockRequest.queryString[key] = [mockRequest.queryString[key]];
            }
            mockRequest.queryString[key].push(value);
          } else {
            mockRequest.queryString[key] = value;
          }
        });
      }
      req.params.keys().forEach((key) => mockRequest.queryString[key] = req.params.get(key));
      req.headers.keys().forEach((key) => mockRequest.headers[key] = req.headers.get(key));
      try {
        const fnRes = rule.callback.call(void 0, mockRequest);
        res$ = isObservable(fnRes) ? fnRes : from(Promise.resolve(fnRes));
      } catch (e) {
        res$ = of(new HttpErrorResponse({
          url: req.url,
          headers: req.headers,
          status: e instanceof MockStatusError ? e.status : 400,
          statusText: e.statusText || "Unknown Error",
          error: e.error
        }));
      }
      break;
    default:
      res$ = of(rule.callback);
      break;
  }
  res$ = res$.pipe(map((res) => res instanceof HttpResponseBase ? res : new HttpResponse({
    status: 200,
    url: req.url,
    body: deepCopy(res)
  })), map((res) => {
    const anyRes = res;
    if (anyRes.body) {
      anyRes.body = deepCopy(anyRes.body);
    }
    if (config.log) {
      console.log(`%c\u{1F47D}${req.method}->${req.urlWithParams}->request`, "background:#000;color:#bada55", req);
      console.log(`%c\u{1F47D}${req.method}->${req.urlWithParams}->response`, "background:#000;color:#bada55", res);
    }
    return res;
  }), switchMap((res) => res instanceof HttpErrorResponse ? throwError(() => res) : of(res)));
  return res$.pipe(delay(config.delay));
};

// src/environments/environment.ts
var environment2 = {
  production: false,
  useHash: true,
  api: {
    baseUrl: "./",
    refreshTokenEnabled: true,
    refreshTokenType: "auth-refresh"
  },
  providers: [provideMockConfig({ data: mock_exports })],
  interceptorFns: [mockInterceptor]
};

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-version.mjs
var VERSION2 = new Version("17.1.0");

// src/app/app.component.ts
var _AppComponent = class _AppComponent {
  constructor(el, renderer, router, titleSrv, modalSrv) {
    this.router = router;
    this.titleSrv = titleSrv;
    this.modalSrv = modalSrv;
    this.donePreloader = stepPreloader();
    renderer.setAttribute(el.nativeElement, "ng-alain-version", VERSION.full);
    renderer.setAttribute(el.nativeElement, "ng-zorro-version", VERSION2.full);
  }
  ngOnInit() {
    let configLoad = false;
    this.router.events.subscribe((ev) => {
      if (ev instanceof RouteConfigLoadStart) {
        configLoad = true;
      }
      if (configLoad && ev instanceof NavigationError) {
        this.modalSrv.confirm({
          nzTitle: `\u63D0\u9192`,
          nzContent: environment2.production ? `\u5E94\u7528\u53EF\u80FD\u5DF2\u53D1\u5E03\u65B0\u7248\u672C\uFF0C\u8BF7\u70B9\u51FB\u5237\u65B0\u624D\u80FD\u751F\u6548\u3002` : `\u65E0\u6CD5\u52A0\u8F7D\u8DEF\u7531\uFF1A${ev.url}`,
          nzCancelDisabled: false,
          nzOkText: "\u5237\u65B0",
          nzCancelText: "\u5FFD\u7565",
          nzOnOk: () => location.reload()
        });
      }
      if (ev instanceof NavigationEnd) {
        this.donePreloader();
        this.titleSrv.setTitle();
        this.modalSrv.closeAll();
      }
    });
  }
};
_AppComponent.\u0275fac = function AppComponent_Factory(t) {
  return new (t || _AppComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(TitleService), \u0275\u0275directiveInject(NzModalService));
};
_AppComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppComponent, selectors: [["app-root"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 0, template: function AppComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "router-outlet");
  }
}, dependencies: [RouterOutlet], encapsulation: 2 });
var AppComponent = _AppComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppComponent, { className: "AppComponent", filePath: "src\\app\\app.component.ts", lineNumber: 14 });
})();

// node_modules/@angular/common/locales/en.mjs
var u = void 0;
function plural(val) {
  const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i === 1 && v === 0)
    return 1;
  return 5;
}
var en_default = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-core-animation.mjs
var _AnimationDuration = class _AnimationDuration {
  // Tooltip
};
_AnimationDuration.SLOW = "0.3s";
_AnimationDuration.BASE = "0.2s";
_AnimationDuration.FAST = "0.1s";
var AnimationDuration = _AnimationDuration;
var _AnimationCurves = class _AnimationCurves {
};
_AnimationCurves.EASE_BASE_OUT = "cubic-bezier(0.7, 0.3, 0.1, 1)";
_AnimationCurves.EASE_BASE_IN = "cubic-bezier(0.9, 0, 0.3, 0.7)";
_AnimationCurves.EASE_OUT = "cubic-bezier(0.215, 0.61, 0.355, 1)";
_AnimationCurves.EASE_IN = "cubic-bezier(0.55, 0.055, 0.675, 0.19)";
_AnimationCurves.EASE_IN_OUT = "cubic-bezier(0.645, 0.045, 0.355, 1)";
_AnimationCurves.EASE_OUT_BACK = "cubic-bezier(0.12, 0.4, 0.29, 1.46)";
_AnimationCurves.EASE_IN_BACK = "cubic-bezier(0.71, -0.46, 0.88, 0.6)";
_AnimationCurves.EASE_IN_OUT_BACK = "cubic-bezier(0.71, -0.46, 0.29, 1.46)";
_AnimationCurves.EASE_OUT_CIRC = "cubic-bezier(0.08, 0.82, 0.17, 1)";
_AnimationCurves.EASE_IN_CIRC = "cubic-bezier(0.6, 0.04, 0.98, 0.34)";
_AnimationCurves.EASE_IN_OUT_CIRC = "cubic-bezier(0.78, 0.14, 0.15, 0.86)";
_AnimationCurves.EASE_OUT_QUINT = "cubic-bezier(0.23, 1, 0.32, 1)";
_AnimationCurves.EASE_IN_QUINT = "cubic-bezier(0.755, 0.05, 0.855, 0.06)";
_AnimationCurves.EASE_IN_OUT_QUINT = "cubic-bezier(0.86, 0, 0.07, 1)";
var AnimationCurves = _AnimationCurves;
var collapseMotion = trigger("collapseMotion", [
  state("expanded", style({ height: "*" })),
  state("collapsed", style({ height: 0, overflow: "hidden" })),
  state("hidden", style({ height: 0, overflow: "hidden", borderTopWidth: "0" })),
  transition("expanded => collapsed", animate(`150ms ${AnimationCurves.EASE_IN_OUT}`)),
  transition("expanded => hidden", animate(`150ms ${AnimationCurves.EASE_IN_OUT}`)),
  transition("collapsed => expanded", animate(`150ms ${AnimationCurves.EASE_IN_OUT}`)),
  transition("hidden => expanded", animate(`150ms ${AnimationCurves.EASE_IN_OUT}`))
]);
var treeCollapseMotion = trigger("treeCollapseMotion", [
  transition("* => *", [
    query("nz-tree-node:leave,nz-tree-builtin-node:leave", [
      style({ overflow: "hidden" }),
      stagger(0, [
        animate(`150ms ${AnimationCurves.EASE_IN_OUT}`, style({ height: 0, opacity: 0, "padding-bottom": 0 }))
      ])
    ], {
      optional: true
    }),
    query("nz-tree-node:enter,nz-tree-builtin-node:enter", [
      style({ overflow: "hidden", height: 0, opacity: 0, "padding-bottom": 0 }),
      stagger(0, [
        animate(`150ms ${AnimationCurves.EASE_IN_OUT}`, style({ overflow: "hidden", height: "*", opacity: "*", "padding-bottom": "*" }))
      ])
    ], {
      optional: true
    })
  ])
]);
var fadeMotion = trigger("fadeMotion", [
  transition(":enter", [style({ opacity: 0 }), animate(`${AnimationDuration.BASE}`, style({ opacity: 1 }))]),
  transition(":leave", [style({ opacity: 1 }), animate(`${AnimationDuration.BASE}`, style({ opacity: 0 }))])
]);
var helpMotion = trigger("helpMotion", [
  transition(":enter", [
    style({
      opacity: 0,
      transform: "translateY(-5px)"
    }),
    animate(`${AnimationDuration.SLOW} ${AnimationCurves.EASE_IN_OUT}`, style({
      opacity: 1,
      transform: "translateY(0)"
    }))
  ]),
  transition(":leave", [
    style({
      opacity: 1,
      transform: "translateY(0)"
    }),
    animate(`${AnimationDuration.SLOW} ${AnimationCurves.EASE_IN_OUT}`, style({
      opacity: 0,
      transform: "translateY(-5px)"
    }))
  ])
]);
var moveUpMotion = trigger("moveUpMotion", [
  transition("* => enter", [
    style({
      transformOrigin: "0 0",
      transform: "translateY(-100%)",
      opacity: 0
    }),
    animate(`${AnimationDuration.BASE}`, style({
      transformOrigin: "0 0",
      transform: "translateY(0%)",
      opacity: 1
    }))
  ]),
  transition("* => leave", [
    style({
      transformOrigin: "0 0",
      transform: "translateY(0%)",
      opacity: 1
    }),
    animate(`${AnimationDuration.BASE}`, style({
      transformOrigin: "0 0",
      transform: "translateY(-100%)",
      opacity: 0
    }))
  ])
]);
var notificationMotion = trigger("notificationMotion", [
  state("enterRight", style({ opacity: 1, transform: "translateX(0)" })),
  transition("* => enterRight", [style({ opacity: 0, transform: "translateX(5%)" }), animate("100ms linear")]),
  state("enterLeft", style({ opacity: 1, transform: "translateX(0)" })),
  transition("* => enterLeft", [style({ opacity: 0, transform: "translateX(-5%)" }), animate("100ms linear")]),
  state("enterTop", style({ opacity: 1, transform: "translateY(0)" })),
  transition("* => enterTop", [style({ opacity: 0, transform: "translateY(-5%)" }), animate("100ms linear")]),
  state("enterBottom", style({ opacity: 1, transform: "translateY(0)" })),
  transition("* => enterBottom", [style({ opacity: 0, transform: "translateY(5%)" }), animate("100ms linear")]),
  state("leave", style({
    opacity: 0,
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%"
  })),
  transition("* => leave", [
    style({
      opacity: 1,
      transform: "scaleY(1)",
      transformOrigin: "0% 0%"
    }),
    animate("100ms linear")
  ])
]);
var ANIMATION_TRANSITION_IN = `${AnimationDuration.BASE} ${AnimationCurves.EASE_OUT_QUINT}`;
var ANIMATION_TRANSITION_OUT = `${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_QUINT}`;
var slideMotion = trigger("slideMotion", [
  state("void", style({
    opacity: 0,
    transform: "scaleY(0.8)"
  })),
  state("enter", style({
    opacity: 1,
    transform: "scaleY(1)"
  })),
  transition("void => *", [animate(ANIMATION_TRANSITION_IN)]),
  transition("* => void", [animate(ANIMATION_TRANSITION_OUT)])
]);
var slideAlertMotion = trigger("slideAlertMotion", [
  transition(":leave", [
    style({ opacity: 1, transform: "scaleY(1)", transformOrigin: "0% 0%" }),
    animate(`${AnimationDuration.SLOW} ${AnimationCurves.EASE_IN_OUT_CIRC}`, style({
      opacity: 0,
      transform: "scaleY(0)",
      transformOrigin: "0% 0%"
    }))
  ])
]);
var zoomBigMotion = trigger("zoomBigMotion", [
  transition("void => active", [
    style({ opacity: 0, transform: "scale(0.8)" }),
    animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_OUT_CIRC}`, style({
      opacity: 1,
      transform: "scale(1)"
    }))
  ]),
  transition("active => void", [
    style({ opacity: 1, transform: "scale(1)" }),
    animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_CIRC}`, style({
      opacity: 0,
      transform: "scale(0.8)"
    }))
  ])
]);
var zoomBadgeMotion = trigger("zoomBadgeMotion", [
  transition(":enter", [
    style({ opacity: 0, transform: "scale(0) translate(50%, -50%)" }),
    animate(`${AnimationDuration.SLOW} ${AnimationCurves.EASE_OUT_BACK}`, style({
      opacity: 1,
      transform: "scale(1) translate(50%, -50%)"
    }))
  ]),
  transition(":leave", [
    style({ opacity: 1, transform: "scale(1) translate(50%, -50%)" }),
    animate(`${AnimationDuration.SLOW} ${AnimationCurves.EASE_IN_BACK}`, style({
      opacity: 0,
      transform: "scale(0) translate(50%, -50%)"
    }))
  ])
]);
var thumbMotion = trigger("thumbMotion", [
  state("from", style({ transform: "translateX({{ transform }}px)", width: "{{ width }}px" }), {
    params: { transform: 0, width: 0 }
  }),
  state("to", style({ transform: "translateX({{ transform }}px)", width: "{{ width }}px" }), {
    params: { transform: 100, width: 0 }
  }),
  transition("from => to", animate(`300ms ${AnimationCurves.EASE_IN_OUT}`))
]);

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-core-services.mjs
var NOOP = () => {
};
var _NzResizeService = class _NzResizeService {
  constructor(ngZone, rendererFactory2) {
    this.ngZone = ngZone;
    this.rendererFactory2 = rendererFactory2;
    this.resizeSource$ = new Subject();
    this.listeners = 0;
    this.disposeHandle = NOOP;
    this.handler = () => {
      this.ngZone.run(() => {
        this.resizeSource$.next();
      });
    };
    this.renderer = this.rendererFactory2.createRenderer(null, null);
  }
  ngOnDestroy() {
    this.handler = NOOP;
  }
  subscribe() {
    this.registerListener();
    return this.resizeSource$.pipe(auditTime(16), finalize(() => this.unregisterListener()));
  }
  unsubscribe() {
    this.unregisterListener();
  }
  registerListener() {
    if (this.listeners === 0) {
      this.ngZone.runOutsideAngular(() => {
        this.disposeHandle = this.renderer.listen("window", "resize", this.handler);
      });
    }
    this.listeners += 1;
  }
  unregisterListener() {
    this.listeners -= 1;
    if (this.listeners === 0) {
      this.disposeHandle();
      this.disposeHandle = NOOP;
    }
  }
};
_NzResizeService.\u0275fac = function NzResizeService_Factory(t) {
  return new (t || _NzResizeService)(\u0275\u0275inject(NgZone), \u0275\u0275inject(RendererFactory2));
};
_NzResizeService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzResizeService,
  factory: _NzResizeService.\u0275fac,
  providedIn: "root"
});
var NzResizeService = _NzResizeService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizeService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: RendererFactory2
  }], null);
})();
var testSingleRegistry = /* @__PURE__ */ new Map();
var _NzSingletonService = class _NzSingletonService {
  constructor() {
    this._singletonRegistry = /* @__PURE__ */ new Map();
  }
  get singletonRegistry() {
    return environment.isTestMode ? testSingleRegistry : this._singletonRegistry;
  }
  registerSingletonWithKey(key, target) {
    const alreadyHave = this.singletonRegistry.has(key);
    const item = alreadyHave ? this.singletonRegistry.get(key) : this.withNewTarget(target);
    if (!alreadyHave) {
      this.singletonRegistry.set(key, item);
    }
  }
  unregisterSingletonWithKey(key) {
    if (this.singletonRegistry.has(key)) {
      this.singletonRegistry.delete(key);
    }
  }
  getSingletonWithKey(key) {
    return this.singletonRegistry.has(key) ? this.singletonRegistry.get(key).target : null;
  }
  withNewTarget(target) {
    return {
      target
    };
  }
};
_NzSingletonService.\u0275fac = function NzSingletonService_Factory(t) {
  return new (t || _NzSingletonService)();
};
_NzSingletonService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzSingletonService,
  factory: _NzSingletonService.\u0275fac,
  providedIn: "root"
});
var NzSingletonService = _NzSingletonService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSingletonService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function getPagePosition(event) {
  const e = getEventPosition(event);
  return {
    x: e.pageX,
    y: e.pageY
  };
}
var _NzDragService = class _NzDragService {
  constructor(rendererFactory2) {
    this.draggingThreshold = 5;
    this.currentDraggingSequence = null;
    this.currentStartingPoint = null;
    this.handleRegistry = /* @__PURE__ */ new Set();
    this.renderer = rendererFactory2.createRenderer(null, null);
  }
  requestDraggingSequence(event) {
    if (!this.handleRegistry.size) {
      this.registerDraggingHandler(isTouchEvent(event));
    }
    if (this.currentDraggingSequence) {
      this.currentDraggingSequence.complete();
    }
    this.currentStartingPoint = getPagePosition(event);
    this.currentDraggingSequence = new Subject();
    return this.currentDraggingSequence.pipe(map((e) => ({
      x: e.pageX - this.currentStartingPoint.x,
      y: e.pageY - this.currentStartingPoint.y
    })), filter((e) => Math.abs(e.x) > this.draggingThreshold || Math.abs(e.y) > this.draggingThreshold), finalize(() => this.teardownDraggingSequence()));
  }
  registerDraggingHandler(isTouch) {
    if (isTouch) {
      this.handleRegistry.add({
        teardown: this.renderer.listen("document", "touchmove", (e) => {
          if (this.currentDraggingSequence) {
            this.currentDraggingSequence.next(e.touches[0] || e.changedTouches[0]);
          }
        })
      });
      this.handleRegistry.add({
        teardown: this.renderer.listen("document", "touchend", () => {
          if (this.currentDraggingSequence) {
            this.currentDraggingSequence.complete();
          }
        })
      });
    } else {
      this.handleRegistry.add({
        teardown: this.renderer.listen("document", "mousemove", (e) => {
          if (this.currentDraggingSequence) {
            this.currentDraggingSequence.next(e);
          }
        })
      });
      this.handleRegistry.add({
        teardown: this.renderer.listen("document", "mouseup", () => {
          if (this.currentDraggingSequence) {
            this.currentDraggingSequence.complete();
          }
        })
      });
    }
  }
  teardownDraggingSequence() {
    this.currentDraggingSequence = null;
  }
};
_NzDragService.\u0275fac = function NzDragService_Factory(t) {
  return new (t || _NzDragService)(\u0275\u0275inject(RendererFactory2));
};
_NzDragService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzDragService,
  factory: _NzDragService.\u0275fac,
  providedIn: "root"
});
var NzDragService = _NzDragService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDragService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RendererFactory2
  }], null);
})();
function easeInOutCubic(t, b, c, d) {
  const cc = c - b;
  let tt = t / (d / 2);
  if (tt < 1) {
    return cc / 2 * tt * tt * tt + b;
  } else {
    return cc / 2 * ((tt -= 2) * tt * tt + 2) + b;
  }
}
var _NzScrollService = class _NzScrollService {
  constructor(ngZone, doc) {
    this.ngZone = ngZone;
    this.doc = doc;
  }
  /** Set the position of the scroll bar of `el`. */
  setScrollTop(el, topValue = 0) {
    if (el === window) {
      this.doc.body.scrollTop = topValue;
      this.doc.documentElement.scrollTop = topValue;
    } else {
      el.scrollTop = topValue;
    }
  }
  /** Get position of `el` against window. */
  getOffset(el) {
    const ret = {
      top: 0,
      left: 0
    };
    if (!el || !el.getClientRects().length) {
      return ret;
    }
    const rect = el.getBoundingClientRect();
    if (rect.width || rect.height) {
      const doc = el.ownerDocument.documentElement;
      ret.top = rect.top - doc.clientTop;
      ret.left = rect.left - doc.clientLeft;
    } else {
      ret.top = rect.top;
      ret.left = rect.left;
    }
    return ret;
  }
  /** Get the position of the scoll bar of `el`. */
  // TODO: remove '| Window' as the fallback already happens here
  getScroll(target, top = true) {
    if (typeof window === "undefined") {
      return 0;
    }
    const method = top ? "scrollTop" : "scrollLeft";
    let result = 0;
    if (this.isWindow(target)) {
      result = target[top ? "pageYOffset" : "pageXOffset"];
    } else if (target instanceof Document) {
      result = target.documentElement[method];
    } else if (target) {
      result = target[method];
    }
    if (target && !this.isWindow(target) && typeof result !== "number") {
      result = (target.ownerDocument || target).documentElement[method];
    }
    return result;
  }
  isWindow(obj) {
    return obj !== null && obj !== void 0 && obj === obj.window;
  }
  /**
   * Scroll `el` to some position with animation.
   *
   * @param containerEl container, `window` by default
   * @param y Scroll to `top`, 0 by default
   */
  scrollTo(containerEl, y = 0, options = {}) {
    const target = containerEl ? containerEl : window;
    const scrollTop = this.getScroll(target);
    const startTime = Date.now();
    const {
      easing,
      callback,
      duration = 450
    } = options;
    const frameFunc = () => {
      const timestamp = Date.now();
      const time = timestamp - startTime;
      const nextScrollTop = (easing || easeInOutCubic)(time > duration ? duration : time, scrollTop, y, duration);
      if (this.isWindow(target)) {
        target.scrollTo(window.pageXOffset, nextScrollTop);
      } else if (target instanceof HTMLDocument || target.constructor.name === "HTMLDocument") {
        target.documentElement.scrollTop = nextScrollTop;
      } else {
        target.scrollTop = nextScrollTop;
      }
      if (time < duration) {
        reqAnimFrame(frameFunc);
      } else if (typeof callback === "function") {
        this.ngZone.run(callback);
      }
    };
    this.ngZone.runOutsideAngular(() => reqAnimFrame(frameFunc));
  }
};
_NzScrollService.\u0275fac = function NzScrollService_Factory(t) {
  return new (t || _NzScrollService)(\u0275\u0275inject(NgZone), \u0275\u0275inject(DOCUMENT));
};
_NzScrollService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzScrollService,
  factory: _NzScrollService.\u0275fac,
  providedIn: "root"
});
var NzScrollService = _NzScrollService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzScrollService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var NzBreakpointEnum;
(function(NzBreakpointEnum2) {
  NzBreakpointEnum2["xxl"] = "xxl";
  NzBreakpointEnum2["xl"] = "xl";
  NzBreakpointEnum2["lg"] = "lg";
  NzBreakpointEnum2["md"] = "md";
  NzBreakpointEnum2["sm"] = "sm";
  NzBreakpointEnum2["xs"] = "xs";
})(NzBreakpointEnum || (NzBreakpointEnum = {}));
var gridResponsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)"
};
var _NzBreakpointService = class _NzBreakpointService {
  constructor(resizeService, mediaMatcher) {
    this.resizeService = resizeService;
    this.mediaMatcher = mediaMatcher;
    this.destroy$ = new Subject();
    this.resizeService.subscribe().pipe(takeUntil(this.destroy$)).subscribe(() => {
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  subscribe(breakpointMap, fullMap) {
    if (fullMap) {
      const get = () => this.matchMedia(breakpointMap, true);
      return this.resizeService.subscribe().pipe(map(get), startWith(get()), distinctUntilChanged((x, y) => x[0] === y[0]), map((x) => x[1]));
    } else {
      const get = () => this.matchMedia(breakpointMap);
      return this.resizeService.subscribe().pipe(map(get), startWith(get()), distinctUntilChanged());
    }
  }
  matchMedia(breakpointMap, fullMap) {
    let bp = NzBreakpointEnum.md;
    const breakpointBooleanMap = {};
    Object.keys(breakpointMap).map((breakpoint) => {
      const castBP = breakpoint;
      const matched = this.mediaMatcher.matchMedia(gridResponsiveMap[castBP]).matches;
      breakpointBooleanMap[breakpoint] = matched;
      if (matched) {
        bp = castBP;
      }
    });
    if (fullMap) {
      return [bp, breakpointBooleanMap];
    } else {
      return bp;
    }
  }
};
_NzBreakpointService.\u0275fac = function NzBreakpointService_Factory(t) {
  return new (t || _NzBreakpointService)(\u0275\u0275inject(NzResizeService), \u0275\u0275inject(MediaMatcher));
};
_NzBreakpointService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzBreakpointService,
  factory: _NzBreakpointService.\u0275fac,
  providedIn: "root"
});
var NzBreakpointService = _NzBreakpointService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzBreakpointService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NzResizeService
  }, {
    type: MediaMatcher
  }], null);
})();
var _NzDestroyService = class _NzDestroyService extends Subject {
  ngOnDestroy() {
    this.next();
    this.complete();
  }
};
_NzDestroyService.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NzDestroyService_BaseFactory;
  return function NzDestroyService_Factory(t) {
    return (\u0275NzDestroyService_BaseFactory || (\u0275NzDestroyService_BaseFactory = \u0275\u0275getInheritedFactory(_NzDestroyService)))(t || _NzDestroyService);
  };
})();
_NzDestroyService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzDestroyService,
  factory: _NzDestroyService.\u0275fac
});
var NzDestroyService = _NzDestroyService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDestroyService, [{
    type: Injectable
  }], null, null);
})();
var _ImagePreloadService = class _ImagePreloadService {
  constructor(document2, platform) {
    this.document = document2;
    this.platform = platform;
    this.counter = /* @__PURE__ */ new Map();
    this.linkRefs = /* @__PURE__ */ new Map();
  }
  addPreload(option) {
    if (this.platform.isBrowser) {
      return () => void 0;
    }
    const uniqueKey = `${option.src}${option.srcset}`;
    let currentCount = this.counter.get(uniqueKey) || 0;
    currentCount++;
    this.counter.set(uniqueKey, currentCount);
    if (!this.linkRefs.has(uniqueKey)) {
      const linkNode = this.appendPreloadLink(option);
      this.linkRefs.set(uniqueKey, linkNode);
    }
    return () => {
      if (this.counter.has(uniqueKey)) {
        let count = this.counter.get(uniqueKey);
        count--;
        if (count === 0) {
          const linkNode = this.linkRefs.get(uniqueKey);
          this.removePreloadLink(linkNode);
          this.counter.delete(uniqueKey);
          this.linkRefs.delete(uniqueKey);
        } else {
          this.counter.set(uniqueKey, count);
        }
      }
    };
  }
  appendPreloadLink(option) {
    const linkNode = this.document.createElement("link");
    linkNode.setAttribute("rel", "preload");
    linkNode.setAttribute("as", "image");
    linkNode.setAttribute("href", option.src);
    if (option.srcset) {
      linkNode.setAttribute("imagesrcset", option.srcset);
    }
    this.document.head.appendChild(linkNode);
    return linkNode;
  }
  removePreloadLink(linkNode) {
    if (this.document.head.contains(linkNode)) {
      this.document.head.removeChild(linkNode);
    }
  }
};
_ImagePreloadService.\u0275fac = function ImagePreloadService_Factory(t) {
  return new (t || _ImagePreloadService)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(Platform));
};
_ImagePreloadService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ImagePreloadService,
  factory: _ImagePreloadService.\u0275fac,
  providedIn: "root"
});
var ImagePreloadService = _ImagePreloadService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImagePreloadService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }], null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-message.mjs
function NzMessageComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 10);
  }
}
function NzMessageComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 11);
  }
}
function NzMessageComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 12);
  }
}
function NzMessageComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 13);
  }
}
function NzMessageComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 14);
  }
}
function NzMessageComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 15);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r5.instance.content, \u0275\u0275sanitizeHtml);
  }
}
function NzMessageContainerComponent_nz_message_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-message", 2);
    \u0275\u0275listener("destroyed", function NzMessageContainerComponent_nz_message_1_Template_nz_message_destroyed_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.remove($event.id, $event.userAction));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const instance_r1 = ctx.$implicit;
    \u0275\u0275property("instance", instance_r1);
  }
}
var globalCounter = 0;
var NzMNService = class {
  constructor(nzSingletonService, overlay, injector) {
    this.nzSingletonService = nzSingletonService;
    this.overlay = overlay;
    this.injector = injector;
  }
  remove(id) {
    if (this.container) {
      if (id) {
        this.container.remove(id);
      } else {
        this.container.removeAll();
      }
    }
  }
  getInstanceId() {
    return `${this.componentPrefix}-${globalCounter++}`;
  }
  withContainer(ctor) {
    let containerInstance = this.nzSingletonService.getSingletonWithKey(this.componentPrefix);
    if (containerInstance) {
      return containerInstance;
    }
    const overlayRef = this.overlay.create({
      hasBackdrop: false,
      scrollStrategy: this.overlay.scrollStrategies.noop(),
      positionStrategy: this.overlay.position().global()
    });
    const componentPortal = new ComponentPortal(ctor, null, this.injector);
    const componentRef = overlayRef.attach(componentPortal);
    const overlayWrapper = overlayRef.hostElement;
    overlayWrapper.style.zIndex = "1010";
    if (!containerInstance) {
      this.container = containerInstance = componentRef.instance;
      this.nzSingletonService.registerSingletonWithKey(this.componentPrefix, containerInstance);
      this.container.afterAllInstancesRemoved.subscribe(() => {
        this.container = void 0;
        this.nzSingletonService.unregisterSingletonWithKey(this.componentPrefix);
        overlayRef.dispose();
      });
    }
    return containerInstance;
  }
};
var _NzMNContainerComponent = class _NzMNContainerComponent {
  constructor(cdr, nzConfigService) {
    this.cdr = cdr;
    this.nzConfigService = nzConfigService;
    this.instances = [];
    this._afterAllInstancesRemoved = new Subject();
    this.afterAllInstancesRemoved = this._afterAllInstancesRemoved.asObservable();
    this.destroy$ = new Subject();
    this.updateConfig();
  }
  ngOnInit() {
    this.subscribeConfigChange();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  create(data) {
    const instance = this.onCreate(data);
    if (this.instances.length >= this.config.nzMaxStack) {
      this.instances = this.instances.slice(1);
    }
    this.instances = [...this.instances, instance];
    this.readyInstances();
    return instance;
  }
  remove(id, userAction = false) {
    this.instances.map((instance, index) => ({
      index,
      instance
    })).filter(({
      instance
    }) => instance.messageId === id).forEach(({
      index,
      instance
    }) => {
      this.instances.splice(index, 1);
      this.instances = [...this.instances];
      this.onRemove(instance, userAction);
      this.readyInstances();
    });
    if (!this.instances.length) {
      this.onAllInstancesRemoved();
    }
  }
  removeAll() {
    this.instances.forEach((i) => this.onRemove(i, false));
    this.instances = [];
    this.readyInstances();
    this.onAllInstancesRemoved();
  }
  onCreate(instance) {
    instance.options = this.mergeOptions(instance.options);
    instance.onClose = new Subject();
    return instance;
  }
  onRemove(instance, userAction) {
    instance.onClose.next(userAction);
    instance.onClose.complete();
  }
  onAllInstancesRemoved() {
    this._afterAllInstancesRemoved.next();
    this._afterAllInstancesRemoved.complete();
  }
  readyInstances() {
    this.cdr.detectChanges();
  }
  mergeOptions(options) {
    const {
      nzDuration,
      nzAnimate,
      nzPauseOnHover
    } = this.config;
    return __spreadValues({
      nzDuration,
      nzAnimate,
      nzPauseOnHover
    }, options);
  }
};
_NzMNContainerComponent.\u0275fac = function NzMNContainerComponent_Factory(t) {
  return new (t || _NzMNContainerComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzConfigService));
};
_NzMNContainerComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzMNContainerComponent
});
var NzMNContainerComponent = _NzMNContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMNContainerComponent, [{
    type: Directive
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzConfigService
  }], null);
})();
var _NzMNComponent = class _NzMNComponent {
  constructor(cdr) {
    this.cdr = cdr;
    this.destroyed = new EventEmitter();
    this.animationStateChanged = new Subject();
    this.userAction = false;
    this.eraseTimer = null;
  }
  ngOnInit() {
    this.options = this.instance.options;
    if (this.options.nzAnimate) {
      this.instance.state = "enter";
      this.animationStateChanged.pipe(filter((event) => event.phaseName === "done" && event.toState === "leave"), take(1)).subscribe(() => {
        clearTimeout(this.closeTimer);
        this.destroyed.next({
          id: this.instance.messageId,
          userAction: this.userAction
        });
      });
    }
    this.autoClose = this.options.nzDuration > 0;
    if (this.autoClose) {
      this.initErase();
      this.startEraseTimeout();
    }
  }
  ngOnDestroy() {
    if (this.autoClose) {
      this.clearEraseTimeout();
    }
    this.animationStateChanged.complete();
  }
  onEnter() {
    if (this.autoClose && this.options.nzPauseOnHover) {
      this.clearEraseTimeout();
      this.updateTTL();
    }
  }
  onLeave() {
    if (this.autoClose && this.options.nzPauseOnHover) {
      this.startEraseTimeout();
    }
  }
  destroy(userAction = false) {
    this.userAction = userAction;
    if (this.options.nzAnimate) {
      this.instance.state = "leave";
      this.cdr.detectChanges();
      this.closeTimer = setTimeout(() => {
        this.closeTimer = void 0;
        this.destroyed.next({
          id: this.instance.messageId,
          userAction
        });
      }, 200);
    } else {
      this.destroyed.next({
        id: this.instance.messageId,
        userAction
      });
    }
  }
  initErase() {
    this.eraseTTL = this.options.nzDuration;
    this.eraseTimingStart = Date.now();
  }
  updateTTL() {
    if (this.autoClose) {
      this.eraseTTL -= Date.now() - this.eraseTimingStart;
    }
  }
  startEraseTimeout() {
    if (this.eraseTTL > 0) {
      this.clearEraseTimeout();
      this.eraseTimer = setTimeout(() => this.destroy(), this.eraseTTL);
      this.eraseTimingStart = Date.now();
    } else {
      this.destroy();
    }
  }
  clearEraseTimeout() {
    if (this.eraseTimer !== null) {
      clearTimeout(this.eraseTimer);
      this.eraseTimer = null;
    }
  }
};
_NzMNComponent.\u0275fac = function NzMNComponent_Factory(t) {
  return new (t || _NzMNComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_NzMNComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzMNComponent
});
var NzMNComponent = _NzMNComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMNComponent, [{
    type: Directive
  }], () => [{
    type: ChangeDetectorRef
  }], null);
})();
var _NzMessageComponent = class _NzMessageComponent extends NzMNComponent {
  constructor(cdr) {
    super(cdr);
    this.destroyed = new EventEmitter();
  }
};
_NzMessageComponent.\u0275fac = function NzMessageComponent_Factory(t) {
  return new (t || _NzMessageComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_NzMessageComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzMessageComponent,
  selectors: [["nz-message"]],
  inputs: {
    instance: "instance"
  },
  outputs: {
    destroyed: "destroyed"
  },
  exportAs: ["nzMessage"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 10,
  vars: 9,
  consts: [[1, "ant-message-notice", 3, "mouseenter", "mouseleave"], [1, "ant-message-notice-content"], [1, "ant-message-custom-content", 3, "ngClass"], [3, "ngSwitch"], ["nz-icon", "", "nzType", "check-circle", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "info-circle", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "exclamation-circle", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "close-circle", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "loading", 4, "ngSwitchCase"], [4, "nzStringTemplateOutlet"], ["nz-icon", "", "nzType", "check-circle"], ["nz-icon", "", "nzType", "info-circle"], ["nz-icon", "", "nzType", "exclamation-circle"], ["nz-icon", "", "nzType", "close-circle"], ["nz-icon", "", "nzType", "loading"], [3, "innerHTML"]],
  template: function NzMessageComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275listener("@moveUpMotion.done", function NzMessageComponent_Template_div_animation_moveUpMotion_done_0_listener($event) {
        return ctx.animationStateChanged.next($event);
      })("mouseenter", function NzMessageComponent_Template_div_mouseenter_0_listener() {
        return ctx.onEnter();
      })("mouseleave", function NzMessageComponent_Template_div_mouseleave_0_listener() {
        return ctx.onLeave();
      });
      \u0275\u0275elementStart(1, "div", 1)(2, "div", 2);
      \u0275\u0275elementContainerStart(3, 3);
      \u0275\u0275template(4, NzMessageComponent_span_4_Template, 1, 0, "span", 4)(5, NzMessageComponent_span_5_Template, 1, 0, "span", 5)(6, NzMessageComponent_span_6_Template, 1, 0, "span", 6)(7, NzMessageComponent_span_7_Template, 1, 0, "span", 7)(8, NzMessageComponent_span_8_Template, 1, 0, "span", 8);
      \u0275\u0275elementContainerEnd();
      \u0275\u0275template(9, NzMessageComponent_ng_container_9_Template, 2, 1, "ng-container", 9);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("@moveUpMotion", ctx.instance.state);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngClass", "ant-message-" + ctx.instance.type);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitch", ctx.instance.type);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "success");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "info");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "warning");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "error");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "loading");
      \u0275\u0275advance(1);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.instance.content);
    }
  },
  dependencies: [NgClass, NgSwitch, NgSwitchCase, NzIconModule, NzIconDirective, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  data: {
    animation: [moveUpMotion]
  },
  changeDetection: 0
});
var NzMessageComponent = _NzMessageComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMessageComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-message",
      exportAs: "nzMessage",
      preserveWhitespaces: false,
      animations: [moveUpMotion],
      template: `
    <div
      class="ant-message-notice"
      [@moveUpMotion]="instance.state"
      (@moveUpMotion.done)="animationStateChanged.next($event)"
      (mouseenter)="onEnter()"
      (mouseleave)="onLeave()"
    >
      <div class="ant-message-notice-content">
        <div class="ant-message-custom-content" [ngClass]="'ant-message-' + instance.type">
          <ng-container [ngSwitch]="instance.type">
            <span *ngSwitchCase="'success'" nz-icon nzType="check-circle"></span>
            <span *ngSwitchCase="'info'" nz-icon nzType="info-circle"></span>
            <span *ngSwitchCase="'warning'" nz-icon nzType="exclamation-circle"></span>
            <span *ngSwitchCase="'error'" nz-icon nzType="close-circle"></span>
            <span *ngSwitchCase="'loading'" nz-icon nzType="loading"></span>
          </ng-container>
          <ng-container *nzStringTemplateOutlet="instance.content">
            <span [innerHTML]="instance.content"></span>
          </ng-container>
        </div>
      </div>
    </div>
  `,
      imports: [NgClass, NgSwitch, NgSwitchCase, NzIconModule, NzOutletModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    instance: [{
      type: Input
    }],
    destroyed: [{
      type: Output
    }]
  });
})();
var NZ_CONFIG_COMPONENT_NAME = "message";
var NZ_MESSAGE_DEFAULT_CONFIG = {
  nzAnimate: true,
  nzDuration: 3e3,
  nzMaxStack: 7,
  nzPauseOnHover: true,
  nzTop: 24,
  nzDirection: "ltr"
};
var _NzMessageContainerComponent = class _NzMessageContainerComponent extends NzMNContainerComponent {
  constructor(cdr, nzConfigService) {
    super(cdr, nzConfigService);
    this.dir = "ltr";
    const config = this.nzConfigService.getConfigForComponent(NZ_CONFIG_COMPONENT_NAME);
    this.dir = config?.nzDirection || "ltr";
  }
  subscribeConfigChange() {
    this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_COMPONENT_NAME).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.updateConfig();
      const config = this.nzConfigService.getConfigForComponent(NZ_CONFIG_COMPONENT_NAME);
      if (config) {
        const {
          nzDirection
        } = config;
        this.dir = nzDirection || this.dir;
      }
    });
  }
  updateConfig() {
    this.config = __spreadValues(__spreadValues(__spreadValues({}, NZ_MESSAGE_DEFAULT_CONFIG), this.config), this.nzConfigService.getConfigForComponent(NZ_CONFIG_COMPONENT_NAME));
    this.top = toCssPixel(this.config.nzTop);
    this.cdr.markForCheck();
  }
};
_NzMessageContainerComponent.\u0275fac = function NzMessageContainerComponent_Factory(t) {
  return new (t || _NzMessageContainerComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzConfigService));
};
_NzMessageContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzMessageContainerComponent,
  selectors: [["nz-message-container"]],
  exportAs: ["nzMessageContainer"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 5,
  consts: [[1, "ant-message"], [3, "instance", "destroyed", 4, "ngFor", "ngForOf"], [3, "instance", "destroyed"]],
  template: function NzMessageContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, NzMessageContainerComponent_nz_message_1_Template, 1, 1, "nz-message", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("top", ctx.top);
      \u0275\u0275classProp("ant-message-rtl", ctx.dir === "rtl");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.instances);
    }
  },
  dependencies: [NzMessageComponent, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzMessageContainerComponent = _NzMessageContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMessageContainerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-message-container",
      exportAs: "nzMessageContainer",
      preserveWhitespaces: false,
      template: `
    <div class="ant-message" [class.ant-message-rtl]="dir === 'rtl'" [style.top]="top">
      <nz-message
        *ngFor="let instance of instances"
        [instance]="instance"
        (destroyed)="remove($event.id, $event.userAction)"
      ></nz-message>
    </div>
  `,
      imports: [NzMessageComponent, NgForOf],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzConfigService
  }], null);
})();
var _NzMessageModule = class _NzMessageModule {
};
_NzMessageModule.\u0275fac = function NzMessageModule_Factory(t) {
  return new (t || _NzMessageModule)();
};
_NzMessageModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzMessageModule
});
_NzMessageModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzMessageContainerComponent, NzMessageComponent]
});
var NzMessageModule = _NzMessageModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMessageModule, [{
    type: NgModule,
    args: [{
      imports: [NzMessageContainerComponent, NzMessageComponent]
    }]
  }], null, null);
})();
var _NzMessageService = class _NzMessageService extends NzMNService {
  constructor(nzSingletonService, overlay, injector) {
    super(nzSingletonService, overlay, injector);
    this.componentPrefix = "message-";
  }
  success(content, options) {
    return this.createInstance({
      type: "success",
      content
    }, options);
  }
  error(content, options) {
    return this.createInstance({
      type: "error",
      content
    }, options);
  }
  info(content, options) {
    return this.createInstance({
      type: "info",
      content
    }, options);
  }
  warning(content, options) {
    return this.createInstance({
      type: "warning",
      content
    }, options);
  }
  loading(content, options) {
    return this.createInstance({
      type: "loading",
      content
    }, options);
  }
  create(type, content, options) {
    return this.createInstance({
      type,
      content
    }, options);
  }
  createInstance(message, options) {
    this.container = this.withContainer(NzMessageContainerComponent);
    return this.container.create(__spreadValues(__spreadValues({}, message), {
      createdAt: /* @__PURE__ */ new Date(),
      messageId: this.getInstanceId(),
      options
    }));
  }
};
_NzMessageService.\u0275fac = function NzMessageService_Factory(t) {
  return new (t || _NzMessageService)(\u0275\u0275inject(NzSingletonService), \u0275\u0275inject(Overlay), \u0275\u0275inject(Injector));
};
_NzMessageService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzMessageService,
  factory: _NzMessageService.\u0275fac,
  providedIn: "root"
});
var NzMessageService = _NzMessageService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMessageService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NzSingletonService
  }, {
    type: Overlay
  }, {
    type: Injector
  }], null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-notification.mjs
function NzNotificationComponent_div_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 17);
  }
}
function NzNotificationComponent_div_1_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 18);
  }
}
function NzNotificationComponent_div_1_span_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 19);
  }
}
function NzNotificationComponent_div_1_span_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 20);
  }
}
function NzNotificationComponent_div_1_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 21);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r9.instance.title, \u0275\u0275sanitizeHtml);
  }
}
function NzNotificationComponent_div_1_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 21);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r10.instance.content, \u0275\u0275sanitizeHtml);
  }
}
function NzNotificationComponent_div_1_span_12_ng_template_1_Template(rf, ctx) {
}
var _c0 = (a0) => ({
  $implicit: a0
});
function NzNotificationComponent_div_1_span_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 22);
    \u0275\u0275template(1, NzNotificationComponent_div_1_span_12_ng_template_1_Template, 0, 0, "ng-template", 23);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const btn_r12 = ctx.ngIf;
    const ctx_r11 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", btn_r12)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c0, ctx_r11));
  }
}
function NzNotificationComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7)(1, "div", 7)(2, "div");
    \u0275\u0275elementContainerStart(3, 8);
    \u0275\u0275template(4, NzNotificationComponent_div_1_span_4_Template, 1, 0, "span", 9)(5, NzNotificationComponent_div_1_span_5_Template, 1, 0, "span", 10)(6, NzNotificationComponent_div_1_span_6_Template, 1, 0, "span", 11)(7, NzNotificationComponent_div_1_span_7_Template, 1, 0, "span", 12);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementStart(8, "div", 13);
    \u0275\u0275template(9, NzNotificationComponent_div_1_ng_container_9_Template, 2, 1, "ng-container", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 15);
    \u0275\u0275template(11, NzNotificationComponent_div_1_ng_container_11_Template, 2, 1, "ng-container", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, NzNotificationComponent_div_1_span_12_Template, 2, 4, "span", 16);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275classProp("ant-notification-notice-with-icon", ctx_r0.instance.type !== "blank");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", ctx_r0.instance.type);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "success");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "info");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "warning");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "error");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.instance.title);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.instance.content);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.instance.options == null ? null : ctx_r0.instance.options.nzButton);
  }
}
function NzNotificationComponent_ng_template_2_Template(rf, ctx) {
}
function NzNotificationComponent_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 24);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const closeIcon_r15 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", closeIcon_r15);
  }
}
function NzNotificationComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzNotificationComponent_ng_container_5_ng_container_1_Template, 2, 1, "ng-container", 14);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2.instance.options == null ? null : ctx_r2.instance.options.nzCloseIcon);
  }
}
function NzNotificationComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 25);
  }
}
var _c1 = (a0, a1) => ({
  $implicit: a0,
  data: a1
});
function NzNotificationContainerComponent_nz_notification_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-notification", 7);
    \u0275\u0275listener("destroyed", function NzNotificationContainerComponent_nz_notification_1_Template_nz_notification_destroyed_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.remove($event.id, $event.userAction));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const instance_r6 = ctx.$implicit;
    \u0275\u0275property("instance", instance_r6)("placement", "topLeft");
  }
}
function NzNotificationContainerComponent_nz_notification_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-notification", 7);
    \u0275\u0275listener("destroyed", function NzNotificationContainerComponent_nz_notification_3_Template_nz_notification_destroyed_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r10 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r10.remove($event.id, $event.userAction));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const instance_r9 = ctx.$implicit;
    \u0275\u0275property("instance", instance_r9)("placement", "topRight");
  }
}
function NzNotificationContainerComponent_nz_notification_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-notification", 7);
    \u0275\u0275listener("destroyed", function NzNotificationContainerComponent_nz_notification_5_Template_nz_notification_destroyed_0_listener($event) {
      \u0275\u0275restoreView(_r14);
      const ctx_r13 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r13.remove($event.id, $event.userAction));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const instance_r12 = ctx.$implicit;
    \u0275\u0275property("instance", instance_r12)("placement", "bottomLeft");
  }
}
function NzNotificationContainerComponent_nz_notification_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-notification", 7);
    \u0275\u0275listener("destroyed", function NzNotificationContainerComponent_nz_notification_7_Template_nz_notification_destroyed_0_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r16 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r16.remove($event.id, $event.userAction));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const instance_r15 = ctx.$implicit;
    \u0275\u0275property("instance", instance_r15)("placement", "bottomRight");
  }
}
function NzNotificationContainerComponent_nz_notification_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-notification", 7);
    \u0275\u0275listener("destroyed", function NzNotificationContainerComponent_nz_notification_9_Template_nz_notification_destroyed_0_listener($event) {
      \u0275\u0275restoreView(_r20);
      const ctx_r19 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r19.remove($event.id, $event.userAction));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const instance_r18 = ctx.$implicit;
    \u0275\u0275property("instance", instance_r18)("placement", "top");
  }
}
function NzNotificationContainerComponent_nz_notification_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-notification", 7);
    \u0275\u0275listener("destroyed", function NzNotificationContainerComponent_nz_notification_11_Template_nz_notification_destroyed_0_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r22 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r22.remove($event.id, $event.userAction));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const instance_r21 = ctx.$implicit;
    \u0275\u0275property("instance", instance_r21)("placement", "bottom");
  }
}
var _NzNotificationComponent = class _NzNotificationComponent extends NzMNComponent {
  constructor(cdr) {
    super(cdr);
    this.destroyed = new EventEmitter();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.instance.onClick.complete();
  }
  onClick(event) {
    this.instance.onClick.next(event);
  }
  close() {
    this.destroy(true);
  }
  get state() {
    if (this.instance.state === "enter") {
      switch (this.placement) {
        case "topLeft":
        case "bottomLeft":
          return "enterLeft";
        case "topRight":
        case "bottomRight":
          return "enterRight";
        case "top":
          return "enterTop";
        case "bottom":
          return "enterBottom";
        default:
          return "enterRight";
      }
    } else {
      return this.instance.state;
    }
  }
};
_NzNotificationComponent.\u0275fac = function NzNotificationComponent_Factory(t) {
  return new (t || _NzNotificationComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_NzNotificationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzNotificationComponent,
  selectors: [["nz-notification"]],
  inputs: {
    instance: "instance",
    index: "index",
    placement: "placement"
  },
  outputs: {
    destroyed: "destroyed"
  },
  exportAs: ["nzNotification"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 8,
  vars: 12,
  consts: [[1, "ant-notification-notice", "ant-notification-notice-closable", 3, "ngStyle", "ngClass", "click", "mouseenter", "mouseleave"], ["class", "ant-notification-notice-content", 4, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], ["tabindex", "0", 1, "ant-notification-notice-close", 3, "click"], [1, "ant-notification-notice-close-x"], [4, "ngIf", "ngIfElse"], ["iconTpl", ""], [1, "ant-notification-notice-content"], [3, "ngSwitch"], ["nz-icon", "", "nzType", "check-circle", "class", "ant-notification-notice-icon ant-notification-notice-icon-success", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "info-circle", "class", "ant-notification-notice-icon ant-notification-notice-icon-info", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "exclamation-circle", "class", "ant-notification-notice-icon ant-notification-notice-icon-warning", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "close-circle", "class", "ant-notification-notice-icon ant-notification-notice-icon-error", 4, "ngSwitchCase"], [1, "ant-notification-notice-message"], [4, "nzStringTemplateOutlet"], [1, "ant-notification-notice-description"], ["class", "ant-notification-notice-btn", 4, "ngIf"], ["nz-icon", "", "nzType", "check-circle", 1, "ant-notification-notice-icon", "ant-notification-notice-icon-success"], ["nz-icon", "", "nzType", "info-circle", 1, "ant-notification-notice-icon", "ant-notification-notice-icon-info"], ["nz-icon", "", "nzType", "exclamation-circle", 1, "ant-notification-notice-icon", "ant-notification-notice-icon-warning"], ["nz-icon", "", "nzType", "close-circle", 1, "ant-notification-notice-icon", "ant-notification-notice-icon-error"], [3, "innerHTML"], [1, "ant-notification-notice-btn"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["nz-icon", "", 3, "nzType"], ["nz-icon", "", "nzType", "close", 1, "ant-notification-close-icon"]],
  template: function NzNotificationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275listener("@notificationMotion.done", function NzNotificationComponent_Template_div_animation_notificationMotion_done_0_listener($event) {
        return ctx.animationStateChanged.next($event);
      })("click", function NzNotificationComponent_Template_div_click_0_listener($event) {
        return ctx.onClick($event);
      })("mouseenter", function NzNotificationComponent_Template_div_mouseenter_0_listener() {
        return ctx.onEnter();
      })("mouseleave", function NzNotificationComponent_Template_div_mouseleave_0_listener() {
        return ctx.onLeave();
      });
      \u0275\u0275template(1, NzNotificationComponent_div_1_Template, 13, 10, "div", 1)(2, NzNotificationComponent_ng_template_2_Template, 0, 0, "ng-template", 2);
      \u0275\u0275elementStart(3, "a", 3);
      \u0275\u0275listener("click", function NzNotificationComponent_Template_a_click_3_listener() {
        return ctx.close();
      });
      \u0275\u0275elementStart(4, "span", 4);
      \u0275\u0275template(5, NzNotificationComponent_ng_container_5_Template, 2, 1, "ng-container", 5)(6, NzNotificationComponent_ng_template_6_Template, 1, 0, "ng-template", null, 6, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      const _r4 = \u0275\u0275reference(7);
      \u0275\u0275property("ngStyle", (ctx.instance.options == null ? null : ctx.instance.options.nzStyle) || null)("ngClass", (ctx.instance.options == null ? null : ctx.instance.options.nzClass) || "")("@notificationMotion", ctx.state);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.instance.template);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.instance.template)("ngTemplateOutlet", ctx.instance.template)("ngTemplateOutletContext", \u0275\u0275pureFunction2(9, _c1, ctx, ctx.instance.options == null ? null : ctx.instance.options.nzData));
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.instance.options == null ? null : ctx.instance.options.nzCloseIcon)("ngIfElse", _r4);
    }
  },
  dependencies: [NgStyle, NgClass, NgIf, NgSwitch, NgSwitchCase, NzIconModule, NzIconDirective, NzOutletModule, NzStringTemplateOutletDirective, NgTemplateOutlet],
  encapsulation: 2,
  data: {
    animation: [notificationMotion]
  }
});
var NzNotificationComponent = _NzNotificationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzNotificationComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-notification",
      exportAs: "nzNotification",
      preserveWhitespaces: false,
      animations: [notificationMotion],
      template: `
    <div
      class="ant-notification-notice ant-notification-notice-closable"
      [ngStyle]="instance.options?.nzStyle || null"
      [ngClass]="instance.options?.nzClass || ''"
      [@notificationMotion]="state"
      (@notificationMotion.done)="animationStateChanged.next($event)"
      (click)="onClick($event)"
      (mouseenter)="onEnter()"
      (mouseleave)="onLeave()"
    >
      <div *ngIf="!instance.template" class="ant-notification-notice-content">
        <div class="ant-notification-notice-content">
          <div [class.ant-notification-notice-with-icon]="instance.type !== 'blank'">
            <ng-container [ngSwitch]="instance.type">
              <span
                *ngSwitchCase="'success'"
                nz-icon
                nzType="check-circle"
                class="ant-notification-notice-icon ant-notification-notice-icon-success"
              ></span>
              <span
                *ngSwitchCase="'info'"
                nz-icon
                nzType="info-circle"
                class="ant-notification-notice-icon ant-notification-notice-icon-info"
              ></span>
              <span
                *ngSwitchCase="'warning'"
                nz-icon
                nzType="exclamation-circle"
                class="ant-notification-notice-icon ant-notification-notice-icon-warning"
              ></span>
              <span
                *ngSwitchCase="'error'"
                nz-icon
                nzType="close-circle"
                class="ant-notification-notice-icon ant-notification-notice-icon-error"
              ></span>
            </ng-container>
            <div class="ant-notification-notice-message">
              <ng-container *nzStringTemplateOutlet="instance.title">
                <div [innerHTML]="instance.title"></div>
              </ng-container>
            </div>
            <div class="ant-notification-notice-description">
              <ng-container *nzStringTemplateOutlet="instance.content">
                <div [innerHTML]="instance.content"></div>
              </ng-container>
            </div>
            <span *ngIf="instance.options?.nzButton as btn" class="ant-notification-notice-btn">
              <ng-template [ngTemplateOutlet]="btn" [ngTemplateOutletContext]="{ $implicit: this }"></ng-template>
            </span>
          </div>
        </div>
      </div>
      <ng-template
        [ngIf]="instance.template"
        [ngTemplateOutlet]="instance.template!"
        [ngTemplateOutletContext]="{ $implicit: this, data: instance.options?.nzData }"
      ></ng-template>
      <a tabindex="0" class="ant-notification-notice-close" (click)="close()">
        <span class="ant-notification-notice-close-x">
          <ng-container *ngIf="instance.options?.nzCloseIcon; else iconTpl">
            <ng-container *nzStringTemplateOutlet="instance.options?.nzCloseIcon; let closeIcon">
              <span nz-icon [nzType]="closeIcon"></span>
            </ng-container>
          </ng-container>
          <ng-template #iconTpl>
            <span nz-icon nzType="close" class="ant-notification-close-icon"></span>
          </ng-template>
        </span>
      </a>
    </div>
  `,
      imports: [NgStyle, NgClass, NgIf, NgSwitch, NgSwitchCase, NzIconModule, NzOutletModule, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    instance: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    placement: [{
      type: Input
    }],
    destroyed: [{
      type: Output
    }]
  });
})();
var NZ_CONFIG_MODULE_NAME = "notification";
var NZ_NOTIFICATION_DEFAULT_CONFIG = {
  nzTop: "24px",
  nzBottom: "24px",
  nzPlacement: "topRight",
  nzDuration: 4500,
  nzMaxStack: 7,
  nzPauseOnHover: true,
  nzAnimate: true,
  nzDirection: "ltr"
};
var _NzNotificationContainerComponent = class _NzNotificationContainerComponent extends NzMNContainerComponent {
  constructor(cdr, nzConfigService) {
    super(cdr, nzConfigService);
    this.dir = "ltr";
    this.instances = [];
    this.topLeftInstances = [];
    this.topRightInstances = [];
    this.bottomLeftInstances = [];
    this.bottomRightInstances = [];
    this.topInstances = [];
    this.bottomInstances = [];
    const config = this.nzConfigService.getConfigForComponent(NZ_CONFIG_MODULE_NAME);
    this.dir = config?.nzDirection || "ltr";
  }
  create(notification) {
    const noti = this.onCreate(notification);
    const key = noti.options.nzKey;
    const notificationWithSameKey = this.instances.find((msg) => msg.options.nzKey === notification.options.nzKey);
    if (key && notificationWithSameKey) {
      this.replaceNotification(notificationWithSameKey, noti);
    } else {
      if (this.instances.length >= this.config.nzMaxStack) {
        this.instances = this.instances.slice(1);
      }
      this.instances = [...this.instances, noti];
    }
    this.readyInstances();
    return noti;
  }
  onCreate(instance) {
    instance.options = this.mergeOptions(instance.options);
    instance.onClose = new Subject();
    instance.onClick = new Subject();
    return instance;
  }
  subscribeConfigChange() {
    this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.updateConfig();
      const config = this.nzConfigService.getConfigForComponent(NZ_CONFIG_MODULE_NAME);
      if (config) {
        const {
          nzDirection
        } = config;
        this.dir = nzDirection || this.dir;
      }
    });
  }
  updateConfig() {
    this.config = __spreadValues(__spreadValues(__spreadValues({}, NZ_NOTIFICATION_DEFAULT_CONFIG), this.config), this.nzConfigService.getConfigForComponent(NZ_CONFIG_MODULE_NAME));
    this.top = toCssPixel(this.config.nzTop);
    this.bottom = toCssPixel(this.config.nzBottom);
    this.cdr.markForCheck();
  }
  replaceNotification(old, _new) {
    old.title = _new.title;
    old.content = _new.content;
    old.template = _new.template;
    old.type = _new.type;
    old.options = _new.options;
  }
  readyInstances() {
    const instancesMap = {
      topLeft: [],
      topRight: [],
      bottomLeft: [],
      bottomRight: [],
      top: [],
      bottom: []
    };
    this.instances.forEach((m) => {
      const placement = m.options.nzPlacement;
      switch (placement) {
        case "topLeft":
          instancesMap.topLeft.push(m);
          break;
        case "topRight":
          instancesMap.topRight.push(m);
          break;
        case "bottomLeft":
          instancesMap.bottomLeft.push(m);
          break;
        case "bottomRight":
          instancesMap.bottomRight.push(m);
          break;
        case "top":
          instancesMap.top.push(m);
          break;
        case "bottom":
          instancesMap.bottom.push(m);
          break;
        default:
          instancesMap.topRight.push(m);
      }
    });
    this.topLeftInstances = instancesMap.topLeft;
    this.topRightInstances = instancesMap.topRight;
    this.bottomLeftInstances = instancesMap.bottomLeft;
    this.bottomRightInstances = instancesMap.bottomRight;
    this.topInstances = instancesMap.top;
    this.bottomInstances = instancesMap.bottom;
    this.cdr.detectChanges();
  }
  mergeOptions(options) {
    const {
      nzDuration,
      nzAnimate,
      nzPauseOnHover,
      nzPlacement
    } = this.config;
    return __spreadValues({
      nzDuration,
      nzAnimate,
      nzPauseOnHover,
      nzPlacement
    }, options);
  }
};
_NzNotificationContainerComponent.\u0275fac = function NzNotificationContainerComponent_Factory(t) {
  return new (t || _NzNotificationContainerComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzConfigService));
};
_NzNotificationContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzNotificationContainerComponent,
  selectors: [["nz-notification-container"]],
  exportAs: ["nzNotificationContainer"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 12,
  vars: 46,
  consts: [[1, "ant-notification", "ant-notification-topLeft"], [3, "instance", "placement", "destroyed", 4, "ngFor", "ngForOf"], [1, "ant-notification", "ant-notification-topRight"], [1, "ant-notification", "ant-notification-bottomLeft"], [1, "ant-notification", "ant-notification-bottomRight"], [1, "ant-notification", "ant-notification-top"], [1, "ant-notification", "ant-notification-bottom"], [3, "instance", "placement", "destroyed"]],
  template: function NzNotificationContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, NzNotificationContainerComponent_nz_notification_1_Template, 1, 2, "nz-notification", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "div", 2);
      \u0275\u0275template(3, NzNotificationContainerComponent_nz_notification_3_Template, 1, 2, "nz-notification", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "div", 3);
      \u0275\u0275template(5, NzNotificationContainerComponent_nz_notification_5_Template, 1, 2, "nz-notification", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "div", 4);
      \u0275\u0275template(7, NzNotificationContainerComponent_nz_notification_7_Template, 1, 2, "nz-notification", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(8, "div", 5);
      \u0275\u0275template(9, NzNotificationContainerComponent_nz_notification_9_Template, 1, 2, "nz-notification", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(10, "div", 6);
      \u0275\u0275template(11, NzNotificationContainerComponent_nz_notification_11_Template, 1, 2, "nz-notification", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("top", ctx.top)("left", "0px");
      \u0275\u0275classProp("ant-notification-rtl", ctx.dir === "rtl");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.topLeftInstances);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("top", ctx.top)("right", "0px");
      \u0275\u0275classProp("ant-notification-rtl", ctx.dir === "rtl");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.topRightInstances);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("bottom", ctx.bottom)("left", "0px");
      \u0275\u0275classProp("ant-notification-rtl", ctx.dir === "rtl");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.bottomLeftInstances);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("bottom", ctx.bottom)("right", "0px");
      \u0275\u0275classProp("ant-notification-rtl", ctx.dir === "rtl");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.bottomRightInstances);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("top", ctx.top)("left", "50%")("transform", "translateX(-50%)");
      \u0275\u0275classProp("ant-notification-rtl", ctx.dir === "rtl");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.topInstances);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("bottom", ctx.bottom)("left", "50%")("transform", "translateX(-50%)");
      \u0275\u0275classProp("ant-notification-rtl", ctx.dir === "rtl");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.bottomInstances);
    }
  },
  dependencies: [NzNotificationComponent, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzNotificationContainerComponent = _NzNotificationContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzNotificationContainerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-notification-container",
      exportAs: "nzNotificationContainer",
      preserveWhitespaces: false,
      template: `
    <div
      class="ant-notification ant-notification-topLeft"
      [class.ant-notification-rtl]="dir === 'rtl'"
      [style.top]="top"
      [style.left]="'0px'"
    >
      <nz-notification
        *ngFor="let instance of topLeftInstances"
        [instance]="instance"
        [placement]="'topLeft'"
        (destroyed)="remove($event.id, $event.userAction)"
      ></nz-notification>
    </div>
    <div
      class="ant-notification ant-notification-topRight"
      [class.ant-notification-rtl]="dir === 'rtl'"
      [style.top]="top"
      [style.right]="'0px'"
    >
      <nz-notification
        *ngFor="let instance of topRightInstances"
        [instance]="instance"
        [placement]="'topRight'"
        (destroyed)="remove($event.id, $event.userAction)"
      ></nz-notification>
    </div>
    <div
      class="ant-notification ant-notification-bottomLeft"
      [class.ant-notification-rtl]="dir === 'rtl'"
      [style.bottom]="bottom"
      [style.left]="'0px'"
    >
      <nz-notification
        *ngFor="let instance of bottomLeftInstances"
        [instance]="instance"
        [placement]="'bottomLeft'"
        (destroyed)="remove($event.id, $event.userAction)"
      ></nz-notification>
    </div>
    <div
      class="ant-notification ant-notification-bottomRight"
      [class.ant-notification-rtl]="dir === 'rtl'"
      [style.bottom]="bottom"
      [style.right]="'0px'"
    >
      <nz-notification
        *ngFor="let instance of bottomRightInstances"
        [instance]="instance"
        [placement]="'bottomRight'"
        (destroyed)="remove($event.id, $event.userAction)"
      ></nz-notification>
    </div>
    <div
      class="ant-notification ant-notification-top"
      [class.ant-notification-rtl]="dir === 'rtl'"
      [style.top]="top"
      [style.left]="'50%'"
      [style.transform]="'translateX(-50%)'"
    >
      <nz-notification
        *ngFor="let instance of topInstances"
        [instance]="instance"
        [placement]="'top'"
        (destroyed)="remove($event.id, $event.userAction)"
      ></nz-notification>
    </div>
    <div
      class="ant-notification ant-notification-bottom"
      [class.ant-notification-rtl]="dir === 'rtl'"
      [style.bottom]="bottom"
      [style.left]="'50%'"
      [style.transform]="'translateX(-50%)'"
    >
      <nz-notification
        *ngFor="let instance of bottomInstances"
        [instance]="instance"
        [placement]="'bottom'"
        (destroyed)="remove($event.id, $event.userAction)"
      ></nz-notification>
    </div>
  `,
      imports: [NzNotificationComponent, NgForOf],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzConfigService
  }], null);
})();
var _NzNotificationModule = class _NzNotificationModule {
};
_NzNotificationModule.\u0275fac = function NzNotificationModule_Factory(t) {
  return new (t || _NzNotificationModule)();
};
_NzNotificationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzNotificationModule
});
_NzNotificationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzNotificationComponent, NzNotificationContainerComponent]
});
var NzNotificationModule = _NzNotificationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzNotificationModule, [{
    type: NgModule,
    args: [{
      imports: [NzNotificationComponent, NzNotificationContainerComponent]
    }]
  }], null, null);
})();
var notificationId = 0;
var _NzNotificationService = class _NzNotificationService extends NzMNService {
  constructor(nzSingletonService, overlay, injector) {
    super(nzSingletonService, overlay, injector);
    this.componentPrefix = "notification-";
  }
  success(title, content, options) {
    return this.create("success", title, content, options);
  }
  error(title, content, options) {
    return this.create("error", title, content, options);
  }
  info(title, content, options) {
    return this.create("info", title, content, options);
  }
  warning(title, content, options) {
    return this.create("warning", title, content, options);
  }
  blank(title, content, options) {
    return this.create("blank", title, content, options);
  }
  create(type, title, content, options) {
    return this.createInstance({
      type,
      title,
      content
    }, options);
  }
  template(template, options) {
    return this.createInstance({
      template
    }, options);
  }
  generateMessageId() {
    return `${this.componentPrefix}-${notificationId++}`;
  }
  createInstance(message, options) {
    this.container = this.withContainer(NzNotificationContainerComponent);
    return this.container.create(__spreadValues(__spreadValues({}, message), {
      createdAt: /* @__PURE__ */ new Date(),
      messageId: options?.nzKey || this.generateMessageId(),
      options
    }));
  }
};
_NzNotificationService.\u0275fac = function NzNotificationService_Factory(t) {
  return new (t || _NzNotificationService)(\u0275\u0275inject(NzSingletonService), \u0275\u0275inject(Overlay), \u0275\u0275inject(Injector));
};
_NzNotificationService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzNotificationService,
  factory: _NzNotificationService.\u0275fac,
  providedIn: "root"
});
var NzNotificationService = _NzNotificationService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzNotificationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NzSingletonService
  }, {
    type: Overlay
  }, {
    type: Injector
  }], null);
})();
var _NzNotificationServiceModule = class _NzNotificationServiceModule {
};
_NzNotificationServiceModule.\u0275fac = function NzNotificationServiceModule_Factory(t) {
  return new (t || _NzNotificationServiceModule)();
};
_NzNotificationServiceModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzNotificationServiceModule
});
_NzNotificationServiceModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzNotificationServiceModule = _NzNotificationServiceModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzNotificationServiceModule, [{
    type: NgModule
  }], null, null);
})();

// src/app/core/net/helper.ts
var CODEMESSAGE = {
  200: "\u670D\u52A1\u5668\u6210\u529F\u8FD4\u56DE\u8BF7\u6C42\u7684\u6570\u636E\u3002",
  201: "\u65B0\u5EFA\u6216\u4FEE\u6539\u6570\u636E\u6210\u529F\u3002",
  202: "\u4E00\u4E2A\u8BF7\u6C42\u5DF2\u7ECF\u8FDB\u5165\u540E\u53F0\u6392\u961F\uFF08\u5F02\u6B65\u4EFB\u52A1\uFF09\u3002",
  204: "\u5220\u9664\u6570\u636E\u6210\u529F\u3002",
  400: "\u53D1\u51FA\u7684\u8BF7\u6C42\u6709\u9519\u8BEF\uFF0C\u670D\u52A1\u5668\u6CA1\u6709\u8FDB\u884C\u65B0\u5EFA\u6216\u4FEE\u6539\u6570\u636E\u7684\u64CD\u4F5C\u3002",
  401: "\u7528\u6237\u6CA1\u6709\u6743\u9650\uFF08\u4EE4\u724C\u3001\u7528\u6237\u540D\u3001\u5BC6\u7801\u9519\u8BEF\uFF09\u3002",
  403: "\u7528\u6237\u5F97\u5230\u6388\u6743\uFF0C\u4F46\u662F\u8BBF\u95EE\u662F\u88AB\u7981\u6B62\u7684\u3002",
  404: "\u53D1\u51FA\u7684\u8BF7\u6C42\u9488\u5BF9\u7684\u662F\u4E0D\u5B58\u5728\u7684\u8BB0\u5F55\uFF0C\u670D\u52A1\u5668\u6CA1\u6709\u8FDB\u884C\u64CD\u4F5C\u3002",
  406: "\u8BF7\u6C42\u7684\u683C\u5F0F\u4E0D\u53EF\u5F97\u3002",
  410: "\u8BF7\u6C42\u7684\u8D44\u6E90\u88AB\u6C38\u4E45\u5220\u9664\uFF0C\u4E14\u4E0D\u4F1A\u518D\u5F97\u5230\u7684\u3002",
  422: "\u5F53\u521B\u5EFA\u4E00\u4E2A\u5BF9\u8C61\u65F6\uFF0C\u53D1\u751F\u4E00\u4E2A\u9A8C\u8BC1\u9519\u8BEF\u3002",
  500: "\u670D\u52A1\u5668\u53D1\u751F\u9519\u8BEF\uFF0C\u8BF7\u68C0\u67E5\u670D\u52A1\u5668\u3002",
  502: "\u7F51\u5173\u9519\u8BEF\u3002",
  503: "\u670D\u52A1\u4E0D\u53EF\u7528\uFF0C\u670D\u52A1\u5668\u6682\u65F6\u8FC7\u8F7D\u6216\u7EF4\u62A4\u3002",
  504: "\u7F51\u5173\u8D85\u65F6\u3002"
};
function goTo(injector, url) {
  setTimeout(() => injector.get(Router).navigateByUrl(url));
}
function toLogin(injector) {
  injector.get(NzNotificationService).error(`\u672A\u767B\u5F55\u6216\u767B\u5F55\u5DF2\u8FC7\u671F\uFF0C\u8BF7\u91CD\u65B0\u767B\u5F55\u3002`, ``);
  goTo(injector, injector.get(DA_SERVICE_TOKEN).login_url);
}
function getAdditionalHeaders(headers) {
  const res = {};
  const lang = inject(ALAIN_I18N_TOKEN).currentLang;
  if (!headers?.has("Accept-Language") && lang) {
    res["Accept-Language"] = lang;
  }
  return res;
}
function checkStatus(injector, ev) {
  if (ev.status >= 200 && ev.status < 300 || ev.status === 401) {
    return;
  }
  const errortext = CODEMESSAGE[ev.status] || ev.statusText;
  injector.get(NzNotificationService).error(`\u8BF7\u6C42\u9519\u8BEF ${ev.status}: ${ev.url}`, errortext);
}

// src/app/core/net/refresh-token.ts
var refreshToking = false;
var refreshToken$ = new BehaviorSubject(null);
function reAttachToken(injector, req) {
  const token = injector.get(DA_SERVICE_TOKEN).get()?.token;
  return req.clone({
    setHeaders: {
      token: `Bearer ${token}`
    }
  });
}
function refreshTokenRequest(injector) {
  const model = injector.get(DA_SERVICE_TOKEN).get();
  return injector.get(HttpClient).post(`/api/auth/refresh`, { headers: { refresh_token: model?.["refresh_token"] || "" } });
}
function tryRefreshToken(injector, ev, req, next) {
  if ([`/api/auth/refresh`].some((url) => req.url.includes(url))) {
    toLogin(injector);
    return throwError(() => ev);
  }
  if (refreshToking) {
    return refreshToken$.pipe(filter((v) => !!v), take(1), switchMap(() => next(reAttachToken(injector, req))));
  }
  refreshToking = true;
  refreshToken$.next(null);
  return refreshTokenRequest(injector).pipe(switchMap((res) => {
    refreshToking = false;
    refreshToken$.next(res);
    injector.get(DA_SERVICE_TOKEN).set(res);
    return next(reAttachToken(injector, req));
  }), catchError((err) => {
    refreshToking = false;
    toLogin(injector);
    return throwError(() => err);
  }));
}
function buildAuthRefresh(injector) {
  const tokenSrv = injector.get(DA_SERVICE_TOKEN);
  tokenSrv.refresh.pipe(filter(() => !refreshToking), switchMap((res) => {
    console.log(res);
    refreshToking = true;
    return refreshTokenRequest(injector);
  })).subscribe({
    next: (res) => {
      res.expired = +/* @__PURE__ */ new Date() + 1e4 * 60 * 5;
      refreshToking = false;
      tokenSrv.set(res);
    },
    error: () => toLogin(injector)
  });
}
function provideBindAuthRefresh() {
  return [
    {
      provide: APP_INITIALIZER,
      useFactory: (injector) => () => buildAuthRefresh(injector),
      deps: [Injector],
      multi: true
    }
  ];
}

// src/app/core/net/default.interceptor.ts
function handleData(injector, ev, req, next) {
  checkStatus(injector, ev);
  switch (ev.status) {
    case 200:
      break;
    case 401:
      if (environment2.api.refreshTokenEnabled && environment2.api.refreshTokenType === "re-request") {
        return tryRefreshToken(injector, ev, req, next);
      }
      toLogin(injector);
      break;
    case 403:
    case 404:
    case 500:
      break;
    default:
      if (ev instanceof HttpErrorResponse) {
        console.warn("\u672A\u53EF\u77E5\u9519\u8BEF\uFF0C\u5927\u90E8\u5206\u662F\u7531\u4E8E\u540E\u7AEF\u4E0D\u652F\u6301\u8DE8\u57DFCORS\u6216\u65E0\u6548\u914D\u7F6E\u5F15\u8D77\uFF0C\u8BF7\u53C2\u8003 https://ng-alain.com/docs/server \u89E3\u51B3\u8DE8\u57DF\u95EE\u9898", ev);
      }
      break;
  }
  if (ev instanceof HttpErrorResponse) {
    return throwError(() => ev);
  } else if (ev._throw === true) {
    return throwError(() => ev.body);
  } else {
    return of(ev);
  }
}
var defaultInterceptor = (req, next) => {
  let url = req.url;
  if (!req.context.get(IGNORE_BASE_URL) && !url.startsWith("https://") && !url.startsWith("http://")) {
    const { baseUrl } = environment2.api;
    url = baseUrl + (baseUrl.endsWith("/") && url.startsWith("/") ? url.substring(1) : url);
  }
  const newReq = req.clone({ url, setHeaders: getAdditionalHeaders(req.headers) });
  const injector = inject(Injector);
  return next(newReq).pipe(
    mergeMap((ev) => {
      if (ev instanceof HttpResponseBase) {
        return handleData(injector, ev, newReq, next);
      }
      return of(ev);
    })
    // catchError((err: HttpErrorResponse) => handleData(injector, err, newReq, next))
  );
};

// src/app/core/startup/startup.service.ts
function provideStartup() {
  return [
    StartupService,
    {
      provide: APP_INITIALIZER,
      useFactory: (startupService) => () => startupService.load(),
      deps: [StartupService],
      multi: true
    }
  ];
}
var _StartupService = class _StartupService {
  constructor() {
    this.menuService = inject(MenuService);
    this.settingService = inject(SettingsService);
    this.tokenService = inject(DA_SERVICE_TOKEN);
    this.aclService = inject(ACLService);
    this.titleService = inject(TitleService);
    this.httpClient = inject(HttpClient);
    this.router = inject(Router);
    this.i18n = inject(ALAIN_I18N_TOKEN);
    this.appData$ = this.httpClient.get("assets/tmp/app-data.json").pipe(catchError((res) => {
      console.warn(`StartupService.load: Network request failed`, res);
      setTimeout(() => this.router.navigateByUrl(`/exception/500`));
      return of({});
    }));
  }
  handleAppData(res) {
    this.settingService.setApp(res.app);
    this.settingService.setUser(res.user);
    this.aclService.setFull(true);
    this.menuService.add(res.menu ?? []);
    this.titleService.suffix = res.app?.name;
  }
  viaHttp() {
    const defaultLang2 = this.i18n.defaultLang;
    return zip(this.i18n.loadLangData(defaultLang2), this.appData$).pipe(map(([langData, appData]) => {
      this.i18n.use(defaultLang2, langData);
      this.handleAppData(appData);
    }));
  }
  viaMockI18n() {
    const defaultLang2 = this.i18n.defaultLang;
    return this.i18n.loadLangData(defaultLang2).pipe(map((langData) => {
      this.i18n.use(defaultLang2, langData);
      this.viaMock();
    }));
  }
  viaMock() {
    const app = {
      name: `Corn`,
      description: `Corn admin panel front-end framework`
    };
    const user = {
      name: "Ahmed",
      avatar: "https://cdn.iconscout.com/icon/free/png-256/free-avatar-372-456324.png",
      email: "Ahmed@corn.com",
      token: "123456789"
    };
    this.settingService.setApp(app);
    this.settingService.setUser(user);
    this.aclService.setFull(true);
    this.menuService.add([
      {
        text: "Main",
        group: true,
        children: [
          {
            text: "Dashboard",
            link: "/dashboard",
            icon: { type: "icon", value: "appstore" }
          }
        ]
      },
      {
        text: "Pages",
        group: true,
        children: [
          {
            text: "Maintenance",
            link: "/maintenance",
            icon: { type: "icon", value: "box-plot" }
          },
          {
            text: "Power",
            link: "/power",
            icon: { type: "icon", value: "thunderbolt" }
          },
          {
            text: "Vehicles",
            link: "/vehicles",
            icon: { type: "icon", value: "global" }
          },
          {
            text: "Machines",
            link: "/machines",
            icon: { type: "icon", value: "dashboard" }
          },
          {
            text: "Inventory",
            link: "/inventory",
            icon: { type: "icon", value: "usb" }
          },
          {
            text: "Supply-Chain",
            link: "/supply-chain",
            icon: { type: "icon", value: "api" }
          },
          {
            text: "AI",
            link: "/ai",
            icon: { type: "icon", value: "cloud" }
          },
          {
            text: "Reports",
            link: "/report",
            icon: { type: "icon", value: "file" }
          },
          {
            text: "Orders",
            link: "/orders",
            icon: { type: "icon", value: "file-done" }
          }
        ]
      },
      {
        text: "Live",
        group: true,
        children: [
          {
            text: "Clean Corn",
            link: "/clean",
            icon: { type: "icon", value: "filter" }
          },
          {
            text: "Semi Clean Corn",
            link: "/semi-corn",
            icon: { type: "icon", value: "funnel-plot" }
          }
        ]
      }
    ]);
    this.titleService.suffix = app.name;
    return of(void 0);
  }
  load() {
    return this.viaMockI18n();
  }
};
_StartupService.\u0275fac = function StartupService_Factory(t) {
  return new (t || _StartupService)();
};
_StartupService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _StartupService, factory: _StartupService.\u0275fac });
var StartupService = _StartupService;

// node_modules/@angular/common/locales/zh.mjs
var u2 = void 0;
function plural2(val) {
  const n = val;
  return 5;
}
var zh_default = ["zh", [["\u4E0A\u5348", "\u4E0B\u5348"], u2, u2], u2, [["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"], ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"], ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"], ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"]], u2, [["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"]], u2, [["\u516C\u5143\u524D", "\u516C\u5143"], u2, u2], 0, [6, 0], ["y/M/d", "y\u5E74M\u6708d\u65E5", u2, "y\u5E74M\u6708d\u65E5EEEE"], ["HH:mm", "HH:mm:ss", "z HH:mm:ss", "zzzz HH:mm:ss"], ["{1} {0}", u2, u2, u2], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "CNY", "\xA5", "\u4EBA\u6C11\u5E01", { "AUD": ["AU$", "$"], "BYN": [u2, "\u0440."], "CNY": ["\xA5"], "ILR": ["ILS"], "JPY": ["JP\xA5", "\xA5"], "KRW": ["\uFFE6", "\u20A9"], "PHP": [u2, "\u20B1"], "RUR": [u2, "\u0440."], "TWD": ["NT$"], "USD": ["US$", "$"], "XXX": [] }, "ltr", plural2];

// node_modules/@angular/common/locales/zh-Hant.mjs
var u3 = void 0;
function plural3(val) {
  const n = val;
  return 5;
}
var zh_Hant_default = ["zh-Hant", [["\u4E0A\u5348", "\u4E0B\u5348"], u3, u3], u3, [["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"], ["\u9031\u65E5", "\u9031\u4E00", "\u9031\u4E8C", "\u9031\u4E09", "\u9031\u56DB", "\u9031\u4E94", "\u9031\u516D"], ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"], ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"]], u3, [["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], u3], u3, [["\u897F\u5143\u524D", "\u897F\u5143"], u3, u3], 0, [6, 0], ["y/M/d", "y\u5E74M\u6708d\u65E5", u3, "y\u5E74M\u6708d\u65E5 EEEE"], ["Bh:mm", "Bh:mm:ss", "Bh:mm:ss [z]", "Bh:mm:ss [zzzz]"], ["{1} {0}", u3, u3, u3], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "\u975E\u6578\u503C", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "TWD", "$", "\u65B0\u53F0\u5E63", { "AUD": ["AU$", "$"], "BYN": [u3, "\u0440."], "KRW": ["\uFFE6", "\u20A9"], "PHP": [u3, "\u20B1"], "RON": [u3, "L"], "RUR": [u3, "\u0440."], "TWD": ["$"], "USD": ["US$", "$"], "XXX": [] }, "ltr", plural3];

// node_modules/date-fns/esm/_lib/isSameUTCWeek/index.js
function isSameUTCWeek(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var dateLeftStartOfWeek = startOfUTCWeek(dirtyDateLeft, options);
  var dateRightStartOfWeek = startOfUTCWeek(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}

// node_modules/date-fns/esm/locale/zh-CN/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "\u4E0D\u5230 1 \u79D2",
    other: "\u4E0D\u5230 {{count}} \u79D2"
  },
  xSeconds: {
    one: "1 \u79D2",
    other: "{{count}} \u79D2"
  },
  halfAMinute: "\u534A\u5206\u949F",
  lessThanXMinutes: {
    one: "\u4E0D\u5230 1 \u5206\u949F",
    other: "\u4E0D\u5230 {{count}} \u5206\u949F"
  },
  xMinutes: {
    one: "1 \u5206\u949F",
    other: "{{count}} \u5206\u949F"
  },
  xHours: {
    one: "1 \u5C0F\u65F6",
    other: "{{count}} \u5C0F\u65F6"
  },
  aboutXHours: {
    one: "\u5927\u7EA6 1 \u5C0F\u65F6",
    other: "\u5927\u7EA6 {{count}} \u5C0F\u65F6"
  },
  xDays: {
    one: "1 \u5929",
    other: "{{count}} \u5929"
  },
  aboutXWeeks: {
    one: "\u5927\u7EA6 1 \u4E2A\u661F\u671F",
    other: "\u5927\u7EA6 {{count}} \u4E2A\u661F\u671F"
  },
  xWeeks: {
    one: "1 \u4E2A\u661F\u671F",
    other: "{{count}} \u4E2A\u661F\u671F"
  },
  aboutXMonths: {
    one: "\u5927\u7EA6 1 \u4E2A\u6708",
    other: "\u5927\u7EA6 {{count}} \u4E2A\u6708"
  },
  xMonths: {
    one: "1 \u4E2A\u6708",
    other: "{{count}} \u4E2A\u6708"
  },
  aboutXYears: {
    one: "\u5927\u7EA6 1 \u5E74",
    other: "\u5927\u7EA6 {{count}} \u5E74"
  },
  xYears: {
    one: "1 \u5E74",
    other: "{{count}} \u5E74"
  },
  overXYears: {
    one: "\u8D85\u8FC7 1 \u5E74",
    other: "\u8D85\u8FC7 {{count}} \u5E74"
  },
  almostXYears: {
    one: "\u5C06\u8FD1 1 \u5E74",
    other: "\u5C06\u8FD1 {{count}} \u5E74"
  }
};
var formatDistance = function formatDistance2(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "\u5185";
    } else {
      return result + "\u524D";
    }
  }
  return result;
};
var formatDistance_default = formatDistance;

// node_modules/date-fns/esm/locale/zh-CN/_lib/formatLong/index.js
var dateFormats = {
  full: "y'\u5E74'M'\u6708'd'\u65E5' EEEE",
  long: "y'\u5E74'M'\u6708'd'\u65E5'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
var timeFormats = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;

// node_modules/date-fns/esm/locale/zh-CN/_lib/formatRelative/index.js
function checkWeek(date, baseDate, options) {
  var baseFormat = "eeee p";
  if (isSameUTCWeek(date, baseDate, options)) {
    return baseFormat;
  } else if (date.getTime() > baseDate.getTime()) {
    return "'\u4E0B\u4E2A'" + baseFormat;
  }
  return "'\u4E0A\u4E2A'" + baseFormat;
}
var formatRelativeLocale = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'\u6628\u5929' p",
  today: "'\u4ECA\u5929' p",
  tomorrow: "'\u660E\u5929' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: "PP p"
};
var formatRelative = function formatRelative2(token, date, baseDate, options) {
  var format2 = formatRelativeLocale[token];
  if (typeof format2 === "function") {
    return format2(date, baseDate, options);
  }
  return format2;
};
var formatRelative_default = formatRelative;

// node_modules/date-fns/esm/locale/zh-CN/_lib/localize/index.js
var eraValues = {
  narrow: ["\u524D", "\u516C\u5143"],
  abbreviated: ["\u524D", "\u516C\u5143"],
  wide: ["\u516C\u5143\u524D", "\u516C\u5143"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["\u7B2C\u4E00\u5B63", "\u7B2C\u4E8C\u5B63", "\u7B2C\u4E09\u5B63", "\u7B2C\u56DB\u5B63"],
  wide: ["\u7B2C\u4E00\u5B63\u5EA6", "\u7B2C\u4E8C\u5B63\u5EA6", "\u7B2C\u4E09\u5B63\u5EA6", "\u7B2C\u56DB\u5B63\u5EA6"]
};
var monthValues = {
  narrow: ["\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D", "\u5341", "\u5341\u4E00", "\u5341\u4E8C"],
  abbreviated: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"],
  wide: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"]
};
var dayValues = {
  narrow: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  short: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  abbreviated: ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"],
  wide: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"]
};
var dayPeriodValues = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, options) {
  var number = Number(dirtyNumber);
  switch (options === null || options === void 0 ? void 0 : options.unit) {
    case "date":
      return number.toString() + "\u65E5";
    case "hour":
      return number.toString() + "\u65F6";
    case "minute":
      return number.toString() + "\u5206";
    case "second":
      return number.toString() + "\u79D2";
    default:
      return "\u7B2C " + number.toString();
  }
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;

// node_modules/date-fns/esm/locale/zh-CN/_lib/match/index.js
var matchOrdinalNumberPattern = /^(第\s*)?\d+(日|时|分|秒)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
var parseEraPatterns = {
  any: [/^(前)/i, /^(公元)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻钟/i
};
var parseQuarterPatterns = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
var matchMonthPatterns = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
var parseMonthPatterns = {
  narrow: [/^一/i, /^二/i, /^三/i, /^四/i, /^五/i, /^六/i, /^七/i, /^八/i, /^九/i, /^十(?!(一|二))/i, /^十一/i, /^十二/i],
  any: [/^一|1/i, /^二|2/i, /^三|3/i, /^四|4/i, /^五|5/i, /^六|6/i, /^七|7/i, /^八|8/i, /^九|9/i, /^十(?!(一|二))|10/i, /^十一|11/i, /^十二|12/i]
};
var matchDayPatterns = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^周[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
var parseDayPatterns = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
var matchDayPeriodPatterns = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;

// node_modules/date-fns/esm/locale/zh-CN/index.js
var locale = {
  code: "zh-CN",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
var zh_CN_default = locale;

// node_modules/date-fns/esm/locale/zh-TW/_lib/formatDistance/index.js
var formatDistanceLocale2 = {
  lessThanXSeconds: {
    one: "\u5C11\u65BC 1 \u79D2",
    other: "\u5C11\u65BC {{count}} \u79D2"
  },
  xSeconds: {
    one: "1 \u79D2",
    other: "{{count}} \u79D2"
  },
  halfAMinute: "\u534A\u5206\u9418",
  lessThanXMinutes: {
    one: "\u5C11\u65BC 1 \u5206\u9418",
    other: "\u5C11\u65BC {{count}} \u5206\u9418"
  },
  xMinutes: {
    one: "1 \u5206\u9418",
    other: "{{count}} \u5206\u9418"
  },
  xHours: {
    one: "1 \u5C0F\u6642",
    other: "{{count}} \u5C0F\u6642"
  },
  aboutXHours: {
    one: "\u5927\u7D04 1 \u5C0F\u6642",
    other: "\u5927\u7D04 {{count}} \u5C0F\u6642"
  },
  xDays: {
    one: "1 \u5929",
    other: "{{count}} \u5929"
  },
  aboutXWeeks: {
    one: "\u5927\u7D04 1 \u500B\u661F\u671F",
    other: "\u5927\u7D04 {{count}} \u500B\u661F\u671F"
  },
  xWeeks: {
    one: "1 \u500B\u661F\u671F",
    other: "{{count}} \u500B\u661F\u671F"
  },
  aboutXMonths: {
    one: "\u5927\u7D04 1 \u500B\u6708",
    other: "\u5927\u7D04 {{count}} \u500B\u6708"
  },
  xMonths: {
    one: "1 \u500B\u6708",
    other: "{{count}} \u500B\u6708"
  },
  aboutXYears: {
    one: "\u5927\u7D04 1 \u5E74",
    other: "\u5927\u7D04 {{count}} \u5E74"
  },
  xYears: {
    one: "1 \u5E74",
    other: "{{count}} \u5E74"
  },
  overXYears: {
    one: "\u8D85\u904E 1 \u5E74",
    other: "\u8D85\u904E {{count}} \u5E74"
  },
  almostXYears: {
    one: "\u5C07\u8FD1 1 \u5E74",
    other: "\u5C07\u8FD1 {{count}} \u5E74"
  }
};
var formatDistance3 = function formatDistance4(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale2[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "\u5167";
    } else {
      return result + "\u524D";
    }
  }
  return result;
};
var formatDistance_default2 = formatDistance3;

// node_modules/date-fns/esm/locale/zh-TW/_lib/formatLong/index.js
var dateFormats2 = {
  full: "y'\u5E74'M'\u6708'd'\u65E5' EEEE",
  long: "y'\u5E74'M'\u6708'd'\u65E5'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
var timeFormats2 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats2 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong2 = {
  date: buildFormatLongFn({
    formats: dateFormats2,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats2,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats2,
    defaultWidth: "full"
  })
};
var formatLong_default2 = formatLong2;

// node_modules/date-fns/esm/locale/zh-TW/_lib/formatRelative/index.js
var formatRelativeLocale2 = {
  lastWeek: "'\u4E0A\u500B'eeee p",
  yesterday: "'\u6628\u5929' p",
  today: "'\u4ECA\u5929' p",
  tomorrow: "'\u660E\u5929' p",
  nextWeek: "'\u4E0B\u500B'eeee p",
  other: "P"
};
var formatRelative3 = function formatRelative4(token, _date, _baseDate, _options) {
  return formatRelativeLocale2[token];
};
var formatRelative_default2 = formatRelative3;

// node_modules/date-fns/esm/locale/zh-TW/_lib/localize/index.js
var eraValues2 = {
  narrow: ["\u524D", "\u516C\u5143"],
  abbreviated: ["\u524D", "\u516C\u5143"],
  wide: ["\u516C\u5143\u524D", "\u516C\u5143"]
};
var quarterValues2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["\u7B2C\u4E00\u523B", "\u7B2C\u4E8C\u523B", "\u7B2C\u4E09\u523B", "\u7B2C\u56DB\u523B"],
  wide: ["\u7B2C\u4E00\u523B\u9418", "\u7B2C\u4E8C\u523B\u9418", "\u7B2C\u4E09\u523B\u9418", "\u7B2C\u56DB\u523B\u9418"]
};
var monthValues2 = {
  narrow: ["\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D", "\u5341", "\u5341\u4E00", "\u5341\u4E8C"],
  abbreviated: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"],
  wide: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"]
};
var dayValues2 = {
  narrow: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  short: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  abbreviated: ["\u9031\u65E5", "\u9031\u4E00", "\u9031\u4E8C", "\u9031\u4E09", "\u9031\u56DB", "\u9031\u4E94", "\u9031\u516D"],
  wide: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"]
};
var dayPeriodValues2 = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u9593"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u9593"
  }
};
var formattingDayPeriodValues2 = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u9593"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u9593"
  }
};
var ordinalNumber3 = function ordinalNumber4(dirtyNumber, options) {
  var number = Number(dirtyNumber);
  switch (options === null || options === void 0 ? void 0 : options.unit) {
    case "date":
      return number + "\u65E5";
    case "hour":
      return number + "\u6642";
    case "minute":
      return number + "\u5206";
    case "second":
      return number + "\u79D2";
    default:
      return "\u7B2C " + number;
  }
};
var localize2 = {
  ordinalNumber: ordinalNumber3,
  era: buildLocalizeFn({
    values: eraValues2,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues2,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback2(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues2,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues2,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues2,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues2,
    defaultFormattingWidth: "wide"
  })
};
var localize_default2 = localize2;

// node_modules/date-fns/esm/locale/zh-TW/_lib/match/index.js
var matchOrdinalNumberPattern2 = /^(第\s*)?\d+(日|時|分|秒)?/i;
var parseOrdinalNumberPattern2 = /\d+/i;
var matchEraPatterns2 = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
var parseEraPatterns2 = {
  any: [/^(前)/i, /^(公元)/i]
};
var matchQuarterPatterns2 = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻鐘/i
};
var parseQuarterPatterns2 = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
var matchMonthPatterns2 = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
var parseMonthPatterns2 = {
  narrow: [/^一/i, /^二/i, /^三/i, /^四/i, /^五/i, /^六/i, /^七/i, /^八/i, /^九/i, /^十(?!(一|二))/i, /^十一/i, /^十二/i],
  any: [/^一|1/i, /^二|2/i, /^三|3/i, /^四|4/i, /^五|5/i, /^六|6/i, /^七|7/i, /^八|8/i, /^九|9/i, /^十(?!(一|二))|10/i, /^十一|11/i, /^十二|12/i]
};
var matchDayPatterns2 = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^週[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
var parseDayPatterns2 = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
var matchDayPeriodPatterns2 = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨)/i
};
var parseDayPeriodPatterns2 = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
var match2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern2,
    parsePattern: parseOrdinalNumberPattern2,
    valueCallback: function valueCallback3(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns2,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns2,
    defaultParseWidth: "any",
    valueCallback: function valueCallback4(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns2,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns2,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns2,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns2,
    defaultParseWidth: "any"
  })
};
var match_default2 = match2;

// node_modules/date-fns/esm/locale/zh-TW/index.js
var locale2 = {
  code: "zh-TW",
  formatDistance: formatDistance_default2,
  formatLong: formatLong_default2,
  formatRelative: formatRelative_default2,
  localize: localize_default2,
  match: match_default2,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
var zh_TW_default = locale2;

// src/app/core/i18n/i18n.service.ts
var DEFAULT = "zh-CN";
var LANGS = {
  "zh-CN": {
    text: "\u7B80\u4F53\u4E2D\u6587",
    ng: zh_default,
    zorro: zh_CN,
    date: zh_CN_default,
    delon: zhCN,
    abbr: "\u{1F1E8}\u{1F1F3}"
  },
  "zh-TW": {
    text: "\u7E41\u4F53\u4E2D\u6587",
    ng: zh_Hant_default,
    zorro: zh_TW,
    date: zh_TW_default,
    delon: zhTW,
    abbr: "\u{1F1ED}\u{1F1F0}"
  },
  "en-US": {
    text: "English",
    ng: en_default,
    zorro: en_US,
    date: en_US_default,
    delon: enUS,
    abbr: "\u{1F1EC}\u{1F1E7}"
  }
};
var _I18NService = class _I18NService extends AlainI18nBaseService {
  constructor(http, settings, nzI18nService, delonLocaleService, platform, cogSrv) {
    super(cogSrv);
    this.http = http;
    this.settings = settings;
    this.nzI18nService = nzI18nService;
    this.delonLocaleService = delonLocaleService;
    this.platform = platform;
    this._defaultLang = DEFAULT;
    this._langs = Object.keys(LANGS).map((code) => {
      const item = LANGS[code];
      return { code, text: item.text, abbr: item.abbr };
    });
    const defaultLang2 = this.getDefaultLang();
    this._defaultLang = this._langs.findIndex((w) => w.code === defaultLang2) === -1 ? DEFAULT : defaultLang2;
  }
  getDefaultLang() {
    if (!this.platform.isBrowser) {
      return DEFAULT;
    }
    if (this.settings.layout.lang) {
      return this.settings.layout.lang;
    }
    let res = (navigator.languages ? navigator.languages[0] : null) || navigator.language;
    const arr = res.split("-");
    return arr.length <= 1 ? res : `${arr[0]}-${arr[1].toUpperCase()}`;
  }
  loadLangData(lang) {
    return this.http.get(`assets/tmp/i18n/${lang}.json`);
  }
  use(lang, data) {
    if (this._currentLang === lang)
      return;
    this._data = this.flatData(data, []);
    const item = LANGS[lang];
    registerLocaleData(item.ng);
    this.nzI18nService.setLocale(item.zorro);
    this.nzI18nService.setDateLocale(item.date);
    this.delonLocaleService.setLocale(item.delon);
    this._currentLang = lang;
    this._change$.next(lang);
  }
  getLangs() {
    return this._langs;
  }
};
_I18NService.\u0275fac = function I18NService_Factory(t) {
  return new (t || _I18NService)(\u0275\u0275inject(_HttpClient), \u0275\u0275inject(SettingsService), \u0275\u0275inject(NzI18nService), \u0275\u0275inject(DelonLocaleService), \u0275\u0275inject(Platform), \u0275\u0275inject(AlainConfigService));
};
_I18NService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _I18NService, factory: _I18NService.\u0275fac, providedIn: "root" });
var I18NService = _I18NService;

// node_modules/@angular/forms/fesm2022/forms.mjs
var _BaseControlValueAccessor = class _BaseControlValueAccessor {
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
    this.onChange = (_) => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @nodoc
   */
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  /**
   * Registers a function called when the control is touched.
   * @nodoc
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @nodoc
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
};
_BaseControlValueAccessor.\u0275fac = function BaseControlValueAccessor_Factory(t) {
  return new (t || _BaseControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_BaseControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _BaseControlValueAccessor
});
var BaseControlValueAccessor = _BaseControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var _BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
};
_BuiltInControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BuiltInControlValueAccessor_BaseFactory;
  return function BuiltInControlValueAccessor_Factory(t) {
    return (\u0275BuiltInControlValueAccessor_BaseFactory || (\u0275BuiltInControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_BuiltInControlValueAccessor)))(t || _BuiltInControlValueAccessor);
  };
})();
_BuiltInControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _BuiltInControlValueAccessor,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var BuiltInControlValueAccessor = _BuiltInControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken("NgValueAccessor");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var _CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("checked", value);
  }
};
_CheckboxControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275CheckboxControlValueAccessor_BaseFactory;
  return function CheckboxControlValueAccessor_Factory(t) {
    return (\u0275CheckboxControlValueAccessor_BaseFactory || (\u0275CheckboxControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxControlValueAccessor)))(t || _CheckboxControlValueAccessor);
  };
})();
_CheckboxControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CheckboxControlValueAccessor,
  selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
  hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.checked);
      })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var CheckboxControlValueAccessor = _CheckboxControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken("CompositionEventMode");
var _DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    this._composing = false;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
};
_DefaultValueAccessor.\u0275fac = function DefaultValueAccessor_Factory(t) {
  return new (t || _DefaultValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));
};
_DefaultValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _DefaultValueAccessor,
  selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
  hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
        return ctx._handleInput($event.target.value);
      })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
        return ctx._compositionStart();
      })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
        return ctx._compositionEnd($event.target.value);
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var DefaultValueAccessor = _DefaultValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || (typeof value === "string" || Array.isArray(value)) && value.length === 0;
}
function hasValidLength(value) {
  return value != null && typeof value.length === "number";
}
var NG_VALIDATORS = new InjectionToken("NgValidators");
var NG_ASYNC_VALIDATORS = new InjectionToken("NgAsyncValidators");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var Validators = class {
  /**
   * @description
   * Validator that requires the control's value to be greater than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a minimum of 3
   *
   * ```typescript
   * const control = new FormControl(2, Validators.min(3));
   *
   * console.log(control.errors); // {min: {min: 3, actual: 2}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `min` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static min(min) {
    return minValidator(min);
  }
  /**
   * @description
   * Validator that requires the control's value to be less than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a maximum of 15
   *
   * ```typescript
   * const control = new FormControl(16, Validators.max(15));
   *
   * console.log(control.errors); // {max: {max: 15, actual: 16}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `max` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static max(max) {
    return maxValidator(max);
  }
  /**
   * @description
   * Validator that requires the control have a non-empty value.
   *
   * @usageNotes
   *
   * ### Validate that the field is non-empty
   *
   * ```typescript
   * const control = new FormControl('', Validators.required);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map with the `required` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static required(control) {
    return requiredValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value be true. This validator is commonly
   * used for required checkboxes.
   *
   * @usageNotes
   *
   * ### Validate that the field value is true
   *
   * ```typescript
   * const control = new FormControl('some value', Validators.requiredTrue);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map that contains the `required` property
   * set to `true` if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static requiredTrue(control) {
    return requiredTrueValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value pass an email validation test.
   *
   * Tests the value using a [regular
   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
   * pattern suitable for common use cases. The pattern is based on the definition of a valid email
   * address in the [WHATWG HTML
   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
   * lengths of different parts of the address).
   *
   * The differences from the WHATWG version include:
   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
   * - Disallow `local-part` to be longer than 64 characters.
   * - Disallow the whole address to be longer than 254 characters.
   *
   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
   * validate the value against a different pattern.
   *
   * @usageNotes
   *
   * ### Validate that the field matches a valid email pattern
   *
   * ```typescript
   * const control = new FormControl('bad@', Validators.email);
   *
   * console.log(control.errors); // {email: true}
   * ```
   *
   * @returns An error map with the `email` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static email(control) {
    return emailValidator(control);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be greater than or equal
   * to the provided minimum length. This validator is also provided by default if you use the
   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays. The
   * `minLength` validator logic is also not invoked for values when their `length` property is 0
   * (for example in case of an empty string or an empty array), to support optional controls. You
   * can use the standard `required` validator if empty values should not be considered valid.
   *
   * @usageNotes
   *
   * ### Validate that the field has a minimum of 3 characters
   *
   * ```typescript
   * const control = new FormControl('ng', Validators.minLength(3));
   *
   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
   * ```
   *
   * ```html
   * <input minlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `minlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static minLength(minLength) {
    return minLengthValidator(minLength);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be less than or equal
   * to the provided maximum length. This validator is also provided by default if you use the
   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays.
   *
   * @usageNotes
   *
   * ### Validate that the field has maximum of 5 characters
   *
   * ```typescript
   * const control = new FormControl('Angular', Validators.maxLength(5));
   *
   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
   * ```
   *
   * ```html
   * <input maxlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `maxlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static maxLength(maxLength) {
    return maxLengthValidator(maxLength);
  }
  /**
   * @description
   * Validator that requires the control's value to match a regex pattern. This validator is also
   * provided by default if you use the HTML5 `pattern` attribute.
   *
   * @usageNotes
   *
   * ### Validate that the field only contains letters or spaces
   *
   * ```typescript
   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
   *
   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
   * ```
   *
   * ```html
   * <input pattern="[a-zA-Z ]*">
   * ```
   *
   * ### Pattern matching with the global or sticky flag
   *
   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
   * can produce different results on the same input when validations are run consecutively. This is
   * due to how the behavior of `RegExp.prototype.test` is
   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
   * Due to this behavior, it is recommended that when using
   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
   * flag enabled.
   *
   * ```typescript
   * // Not recommended (since the `g` flag is used)
   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
   *
   * // Good
   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
   * ```
   *
   * @param pattern A regular expression to be used as is to test the values, or a string.
   * If a string is passed, the `^` character is prepended and the `$` character is
   * appended to the provided string (if not already present), and the resulting regular
   * expression is used to test the values.
   *
   * @returns A validator function that returns an error map with the
   * `pattern` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static pattern(pattern) {
    return patternValidator(pattern);
  }
  /**
   * @description
   * Validator that performs no operation.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static nullValidator(control) {
    return nullValidator(control);
  }
  static compose(validators) {
    return compose(validators);
  }
  /**
   * @description
   * Compose multiple async validators into a single function that returns the union
   * of the individual error objects for the provided control.
   *
   * @returns A validator function that returns an error map with the
   * merged error objects of the async validators if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static composeAsync(validators) {
    return composeAsync(validators);
  }
};
function minValidator(min) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      return null;
    }
    return control.value.length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      "maxlength": {
        "requiredLength": maxLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function patternValidator(pattern) {
  if (!pattern)
    return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^")
      regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$")
      regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators)
    return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0)
    return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators)
    return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0)
    return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null)
    return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators)
    return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  constructor() {
    this._rawValidators = [];
    this._rawAsyncValidators = [];
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value = void 0) {
    if (this.control)
      this.control.reset(value);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  constructor() {
    super(...arguments);
    this._parent = null;
    this.name = null;
    this.valueAccessor = null;
  }
};
var AbstractControlStatus = class {
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var _NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
};
_NgControlStatus.\u0275fac = function NgControlStatus_Factory(t) {
  return new (t || _NgControlStatus)(\u0275\u0275directiveInject(NgControl, 2));
};
_NgControlStatus.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgControlStatus,
  selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
  hostVars: 14,
  hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NgControlStatus = _NgControlStatus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var _NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
};
_NgControlStatusGroup.\u0275fac = function NgControlStatusGroup_Factory(t) {
  return new (t || _NgControlStatusGroup)(\u0275\u0275directiveInject(ControlContainer, 10));
};
_NgControlStatusGroup.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgControlStatusGroup,
  selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
  hostVars: 16,
  hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NgControlStatusGroup = _NgControlStatusGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException() {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formControlNameExample}`);
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._pendingDirty = false;
    this._hasOwnPendingAsyncValidator = false;
    this._pendingTouched = false;
    this._onCollectionChange = () => {
    };
    this._parent = null;
    this.pristine = true;
    this.touched = false;
    this._onDisabledChange = [];
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  /**
   * Marks the control as `touched`. A control is touched by focus and
   * blur events that do not change the value.
   *
   * @see {@link markAsUntouched()}
   * @see {@link markAsDirty()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsTouched(opts = {}) {
    this.touched = true;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(opts);
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   */
  markAllAsTouched() {
    this.markAsTouched({
      onlySelf: true
    });
    this._forEachChild((control) => control.markAllAsTouched());
  }
  /**
   * Marks the control as `untouched`.
   *
   * If the control has any children, also marks all children as `untouched`
   * and recalculates the `touched` status of all parent controls.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsDirty()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after the marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsUntouched(opts = {}) {
    this.touched = false;
    this._pendingTouched = false;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /**
   * Marks the control as `dirty`. A control becomes dirty when
   * the control's value is changed through the UI; compare `markAsTouched`.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsUntouched()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsDirty(opts = {}) {
    this.pristine = false;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(opts);
    }
  }
  /**
   * Marks the control as `pristine`.
   *
   * If the control has any children, marks all children as `pristine`,
   * and recalculates the `pristine` status of all parent
   * controls.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsUntouched()}
   * @see {@link markAsDirty()}
   *
   * @param opts Configuration options that determine how the control emits events after
   * marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsPristine(opts = {}) {
    this.pristine = true;
    this._pendingDirty = false;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /**
   * Marks the control as `pending`.
   *
   * A control is pending while the control performs async validation.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates changes and
   * emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
   * observable emits an event with the latest status the control is marked pending.
   * When false, no events are emitted.
   *
   */
  markAsPending(opts = {}) {
    this.status = PENDING;
    if (opts.emitEvent !== false) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(opts);
    }
  }
  /**
   * Disables the control. This means the control is exempt from validation checks and
   * excluded from the aggregate value of any parent. Its status is `DISABLED`.
   *
   * If the control has children, all children are also disabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates
   * changes and emits events after the control is disabled.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is disabled.
   * When false, no events are emitted.
   */
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine();
      }
      this._parent._updateTouched();
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  /**
   * Recalculates the value and validation status of the control.
   *
   * By default, it also updates the value and validity of its ancestors.
   *
   * @param opts Configuration options determine how the control propagates changes and emits events
   * after updates and validity checks are applied.
   * * `onlySelf`: When true, only update this control. When false or not supplied,
   * update all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is updated.
   * When false, no events are emitted.
   */
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(opts.emitEvent);
      }
    }
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = true;
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = false;
        this.setErrors(errors, {
          emitEvent
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      this._hasOwnPendingAsyncValidator = false;
    }
  }
  /**
   * Sets errors on a form control when running validations manually, rather than automatically.
   *
   * Calling `setErrors` also updates the validity of the parent control.
   *
   * @param opts Configuration options that determine how the control propagates
   * changes and emits events after the control errors are set.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
   * observable emits an event after the errors are set.
   *
   * @usageNotes
   *
   * ### Manually set the errors for a control
   *
   * ```
   * const login = new FormControl('someLogin');
   * login.setErrors({
   *   notUnique: true
   * });
   *
   * expect(login.valid).toEqual(false);
   * expect(login.errors).toEqual({ notUnique: true });
   *
   * login.setValue('someOtherLogin');
   *
   * expect(login.valid).toEqual(true);
   * ```
   */
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    let currPath = path;
    if (currPath == null)
      return null;
    if (!Array.isArray(currPath))
      currPath = currPath.split(".");
    if (currPath.length === 0)
      return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled())
      return DISABLED;
    if (this.errors)
      return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING))
      return PENDING;
    if (this._anyControlsHaveStatus(INVALID))
      return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts = {}) {
    this.pristine = !this._anyControlsDirty();
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /** @internal */
  _updateTouched(opts = {}) {
    this.touched = this._anyControlsTouched();
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  registerControl(name, control) {
    if (this.controls[name])
      return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name])
      this.controls[name]._registerOnCollectionChange(() => {
      });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name])
      this.controls[name]._registerOnCollectionChange(() => {
      });
    delete this.controls[name];
    if (control)
      this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null)
      return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated)
      this.updateValueAndValidity({
        onlySelf: true
      });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken("CallSetDisabledState", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control)
      _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor)
      _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange)
      validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change")
      updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange)
      updateControl(control, dir);
    if (control.updateOn !== "submit")
      control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty)
    control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent)
      dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode))
    _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1)
    return `path: '${path.join(" -> ")}'`;
  if (path?.[0])
    return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model"))
    return false;
  const change = changes["model"];
  if (change.isFirstChange())
    return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors)
    return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode))
    _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode))
        _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode))
        _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor)
    return customAccessor;
  if (builtinAccessor)
    return builtinAccessor;
  if (defaultAccessor)
    return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list2, el) {
  const index = list2.indexOf(el);
  if (index > -1)
    list2.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never")
    return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var _NgForm = class _NgForm extends ControlContainer {
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.submitted = false;
    this._directives = /* @__PURE__ */ new Set();
    this.ngSubmit = new EventEmitter();
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @nodoc */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group = new FormGroup({});
      setUpFormContainer(group, dir);
      container.registerControl(dir.name, group);
      group.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value) {
    this.control.setValue(value);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submitted = false;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
};
_NgForm.\u0275fac = function NgForm_Factory(t) {
  return new (t || _NgForm)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_NgForm.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgForm,
  selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
  hostBindings: function NgForm_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("submit", function NgForm_submit_HostBindingHandler($event) {
        return ctx.onSubmit($event);
      })("reset", function NgForm_reset_HostBindingHandler() {
        return ctx.onReset();
      });
    }
  },
  inputs: {
    options: ["ngFormOptions", "options"]
  },
  outputs: {
    ngSubmit: "ngSubmit"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$1]), \u0275\u0275InheritDefinitionFeature]
});
var NgForm = _NgForm;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list2, el) {
  const index = list2.indexOf(el);
  if (index > -1)
    list2.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.defaultValue = null;
    this._onChange = [];
    this._pendingChange = false;
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty)
        this.markAsDirty();
      if (this._pendingTouched)
        this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var _AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /** @nodoc */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
};
_AbstractFormGroupDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275AbstractFormGroupDirective_BaseFactory;
  return function AbstractFormGroupDirective_Factory(t) {
    return (\u0275AbstractFormGroupDirective_BaseFactory || (\u0275AbstractFormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(_AbstractFormGroupDirective)))(t || _AbstractFormGroupDirective);
  };
})();
_AbstractFormGroupDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AbstractFormGroupDirective,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var AbstractFormGroupDirective = _AbstractFormGroupDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var _NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = "";
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
};
_NgModelGroup.\u0275fac = function NgModelGroup_Factory(t) {
  return new (t || _NgModelGroup)(\u0275\u0275directiveInject(ControlContainer, 5), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_NgModelGroup.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgModelGroup,
  selectors: [["", "ngModelGroup", ""]],
  inputs: {
    name: ["ngModelGroup", "name"]
  },
  exportAs: ["ngModelGroup"],
  features: [\u0275\u0275ProvidersFeature([modelGroupProvider]), \u0275\u0275InheritDefinitionFeature]
});
var NgModelGroup = _NgModelGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup"
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var _NgModel = class _NgModel extends NgControl {
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this.control = new FormControl();
    this._registered = false;
    this.name = "";
    this.update = new EventEmitter();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if (!this._isStandalone()) {
      this._checkParentType();
    }
    this._checkName();
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
        throw formGroupNameException();
      } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
        throw modelParentException();
      }
    }
  }
  _checkName() {
    if (this.options && this.options.name)
      this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
};
_NgModel.\u0275fac = function NgModel_Factory(t) {
  return new (t || _NgModel)(\u0275\u0275directiveInject(ControlContainer, 9), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(ChangeDetectorRef, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_NgModel.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgModel,
  selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
  inputs: {
    name: "name",
    isDisabled: ["disabled", "isDisabled"],
    model: ["ngModel", "model"],
    options: ["ngModelOptions", "options"]
  },
  outputs: {
    update: "ngModelChange"
  },
  exportAs: ["ngModel"],
  features: [\u0275\u0275ProvidersFeature([formControlBinding$1]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var NgModel = _NgModel;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel"
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var _\u0275NgNoValidate = class _\u0275NgNoValidate {
};
_\u0275NgNoValidate.\u0275fac = function \u0275NgNoValidate_Factory(t) {
  return new (t || _\u0275NgNoValidate)();
};
_\u0275NgNoValidate.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _\u0275NgNoValidate,
  selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
  hostAttrs: ["novalidate", ""]
});
var \u0275NgNoValidate = _\u0275NgNoValidate;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      }
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var _NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
};
_NumberValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NumberValueAccessor_BaseFactory;
  return function NumberValueAccessor_Factory(t) {
    return (\u0275NumberValueAccessor_BaseFactory || (\u0275NumberValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_NumberValueAccessor)))(t || _NumberValueAccessor);
  };
})();
_NumberValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NumberValueAccessor,
  selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
  hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var NumberValueAccessor = _NumberValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var _RadioControlRegistryModule = class _RadioControlRegistryModule {
};
_RadioControlRegistryModule.\u0275fac = function RadioControlRegistryModule_Factory(t) {
  return new (t || _RadioControlRegistryModule)();
};
_RadioControlRegistryModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _RadioControlRegistryModule
});
_RadioControlRegistryModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var RadioControlRegistryModule = _RadioControlRegistryModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistryModule, [{
    type: NgModule
  }], null, null);
})();
var _RadioControlRegistry = class _RadioControlRegistry {
  constructor() {
    this._accessors = [];
  }
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control)
      return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
};
_RadioControlRegistry.\u0275fac = function RadioControlRegistry_Factory(t) {
  return new (t || _RadioControlRegistry)();
};
_RadioControlRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _RadioControlRegistry,
  factory: _RadioControlRegistry.\u0275fac,
  providedIn: RadioControlRegistryModule
});
var RadioControlRegistry = _RadioControlRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: RadioControlRegistryModule
    }]
  }], null, null);
})();
var _RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
    this.setDisabledStateFired = false;
    this.onChange = () => {
    };
    this.callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
      optional: true
    }) ?? setDisabledStateDefault;
  }
  /** @nodoc */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @nodoc */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @nodoc
   */
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @nodoc */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName)
      this.name = this.formControlName;
  }
};
_RadioControlValueAccessor.\u0275fac = function RadioControlValueAccessor_Factory(t) {
  return new (t || _RadioControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RadioControlRegistry), \u0275\u0275directiveInject(Injector));
};
_RadioControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RadioControlValueAccessor,
  selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
  hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
        return ctx.onChange();
      })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    name: "name",
    formControlName: "formControlName",
    value: "value"
  },
  features: [\u0275\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var RadioControlValueAccessor = _RadioControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var _RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
};
_RangeValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275RangeValueAccessor_BaseFactory;
  return function RangeValueAccessor_Factory(t) {
    return (\u0275RangeValueAccessor_BaseFactory || (\u0275RangeValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_RangeValueAccessor)))(t || _RangeValueAccessor);
  };
})();
_RangeValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RangeValueAccessor,
  selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
  hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [\u0275\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var RangeValueAccessor = _RangeValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken("NgModelWithFormControlWarning");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var _FormControlDirective = class _FormControlDirective extends NgControl {
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this.update = new EventEmitter();
    this._ngModelWarningSent = false;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
};
_FormControlDirective._ngModelWarningSentOnce = false;
_FormControlDirective.\u0275fac = function FormControlDirective_Factory(t) {
  return new (t || _FormControlDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_FormControlDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormControlDirective,
  selectors: [["", "formControl", ""]],
  inputs: {
    form: ["formControl", "form"],
    isDisabled: ["disabled", "isDisabled"],
    model: ["ngModel", "model"]
  },
  outputs: {
    update: "ngModelChange"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formControlBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormControlDirective = _FormControlDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var _FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.submitted = false;
    this._onCollectionChange = () => this._updateDomValue();
    this.directives = [];
    this.form = null;
    this.ngSubmit = new EventEmitter();
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkFormPresent();
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submitted = false;
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  _checkFormPresent() {
    if (!this.form && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingFormException();
    }
  }
};
_FormGroupDirective.\u0275fac = function FormGroupDirective_Factory(t) {
  return new (t || _FormGroupDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
};
_FormGroupDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormGroupDirective,
  selectors: [["", "formGroup", ""]],
  hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
        return ctx.onSubmit($event);
      })("reset", function FormGroupDirective_reset_HostBindingHandler() {
        return ctx.onReset();
      });
    }
  },
  inputs: {
    form: ["formGroup", "form"]
  },
  outputs: {
    ngSubmit: "ngSubmit"
  },
  exportAs: ["ngForm"],
  features: [\u0275\u0275ProvidersFeature([formDirectiveProvider]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormGroupDirective = _FormGroupDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var _FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = null;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
};
_FormGroupName.\u0275fac = function FormGroupName_Factory(t) {
  return new (t || _FormGroupName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_FormGroupName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormGroupName,
  selectors: [["", "formGroupName", ""]],
  inputs: {
    name: ["formGroupName", "name"]
  },
  features: [\u0275\u0275ProvidersFeature([formGroupNameProvider]), \u0275\u0275InheritDefinitionFeature]
});
var FormGroupName = _FormGroupName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var _FormArrayName = class _FormArrayName extends ControlContainer {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = null;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @nodoc
   */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @nodoc
   */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormArray(this);
    }
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
  }
};
_FormArrayName.\u0275fac = function FormArrayName_Factory(t) {
  return new (t || _FormArrayName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
};
_FormArrayName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormArrayName,
  selectors: [["", "formArrayName", ""]],
  inputs: {
    name: ["formArrayName", "name"]
  },
  features: [\u0275\u0275ProvidersFeature([formArrayNameProvider]), \u0275\u0275InheritDefinitionFeature]
});
var FormArrayName = _FormArrayName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function _hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var _FormControlName = class _FormControlName extends NgControl {
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._added = false;
    this.name = null;
    this.update = new EventEmitter();
    this._ngModelWarningSent = false;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (!this._added)
      this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
        throw ngModelGroupException();
      } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
        throw controlParentException();
      }
    }
  }
  _setUpControl() {
    this._checkParentType();
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
};
_FormControlName._ngModelWarningSentOnce = false;
_FormControlName.\u0275fac = function FormControlName_Factory(t) {
  return new (t || _FormControlName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
};
_FormControlName.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FormControlName,
  selectors: [["", "formControlName", ""]],
  inputs: {
    name: ["formControlName", "name"],
    isDisabled: ["disabled", "isDisabled"],
    model: ["ngModel", "model"]
  },
  outputs: {
    update: "ngModelChange"
  },
  features: [\u0275\u0275ProvidersFeature([controlNameBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
});
var FormControlName = _FormControlName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null)
    return `${value}`;
  if (value && typeof value === "object")
    value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var _SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  constructor() {
    super(...arguments);
    this._optionMap = /* @__PURE__ */ new Map();
    this._idCounter = 0;
    this._compareWith = Object.is;
  }
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  /**
   * Sets the "value" property on the select element.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value))
        return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
};
_SelectControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275SelectControlValueAccessor_BaseFactory;
  return function SelectControlValueAccessor_Factory(t) {
    return (\u0275SelectControlValueAccessor_BaseFactory || (\u0275SelectControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectControlValueAccessor)))(t || _SelectControlValueAccessor);
  };
})();
_SelectControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SelectControlValueAccessor,
  selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
  hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    compareWith: "compareWith"
  },
  features: [\u0275\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var SelectControlValueAccessor = _SelectControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR]
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var _NgSelectOption = class _NgSelectOption {
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select)
      this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null)
      return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    this._setElementValue(value);
    if (this._select)
      this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
};
_NgSelectOption.\u0275fac = function NgSelectOption_Factory(t) {
  return new (t || _NgSelectOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectControlValueAccessor, 9));
};
_NgSelectOption.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NgSelectOption,
  selectors: [["option"]],
  inputs: {
    ngValue: "ngValue",
    value: "value"
  }
});
var NgSelectOption = _NgSelectOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null)
    return `${value}`;
  if (typeof value === "string")
    value = `'${value}'`;
  if (value && typeof value === "object")
    value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var _SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  constructor() {
    super(...arguments);
    this._optionMap = /* @__PURE__ */ new Map();
    this._idCounter = 0;
    this._compareWith = Object.is;
  }
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value))
        return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
};
_SelectMultipleControlValueAccessor.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275SelectMultipleControlValueAccessor_BaseFactory;
  return function SelectMultipleControlValueAccessor_Factory(t) {
    return (\u0275SelectMultipleControlValueAccessor_BaseFactory || (\u0275SelectMultipleControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectMultipleControlValueAccessor)))(t || _SelectMultipleControlValueAccessor);
  };
})();
_SelectMultipleControlValueAccessor.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SelectMultipleControlValueAccessor,
  selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
  hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target);
      })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    compareWith: "compareWith"
  },
  features: [\u0275\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
});
var SelectMultipleControlValueAccessor = _SelectMultipleControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var _\u0275NgSelectMultipleOption = class _\u0275NgSelectMultipleOption {
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null)
      return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
};
_\u0275NgSelectMultipleOption.\u0275fac = function \u0275NgSelectMultipleOption_Factory(t) {
  return new (t || _\u0275NgSelectMultipleOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectMultipleControlValueAccessor, 9));
};
_\u0275NgSelectMultipleOption.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _\u0275NgSelectMultipleOption,
  selectors: [["option"]],
  inputs: {
    ngValue: "ngValue",
    value: "value"
  }
});
var \u0275NgSelectMultipleOption = _\u0275NgSelectMultipleOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var _AbstractValidatorDirective = class _AbstractValidatorDirective {
  constructor() {
    this._validator = nullValidator;
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input);
      this._validator = this._enabled ? this.createValidator(input) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @nodoc */
  validate(control) {
    return this._validator(control);
  }
  /** @nodoc */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input) {
    return input != null;
  }
};
_AbstractValidatorDirective.\u0275fac = function AbstractValidatorDirective_Factory(t) {
  return new (t || _AbstractValidatorDirective)();
};
_AbstractValidatorDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AbstractValidatorDirective,
  features: [\u0275\u0275NgOnChangesFeature]
});
var AbstractValidatorDirective = _AbstractValidatorDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var _MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "max";
    this.normalizeInput = (input) => toFloat(input);
    this.createValidator = (max) => maxValidator(max);
  }
};
_MaxValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MaxValidator_BaseFactory;
  return function MaxValidator_Factory(t) {
    return (\u0275MaxValidator_BaseFactory || (\u0275MaxValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxValidator)))(t || _MaxValidator);
  };
})();
_MaxValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MaxValidator,
  selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MaxValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("max", ctx._enabled ? ctx.max : null);
    }
  },
  inputs: {
    max: "max"
  },
  features: [\u0275\u0275ProvidersFeature([MAX_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MaxValidator = _MaxValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      }
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var _MinValidator = class _MinValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "min";
    this.normalizeInput = (input) => toFloat(input);
    this.createValidator = (min) => minValidator(min);
  }
};
_MinValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MinValidator_BaseFactory;
  return function MinValidator_Factory(t) {
    return (\u0275MinValidator_BaseFactory || (\u0275MinValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinValidator)))(t || _MinValidator);
  };
})();
_MinValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MinValidator,
  selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MinValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("min", ctx._enabled ? ctx.min : null);
    }
  },
  inputs: {
    min: "min"
  },
  features: [\u0275\u0275ProvidersFeature([MIN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MinValidator = _MinValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      }
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var _RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "required";
    this.normalizeInput = booleanAttribute;
    this.createValidator = (input) => requiredValidator;
  }
  /** @nodoc */
  enabled(input) {
    return input;
  }
};
_RequiredValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275RequiredValidator_BaseFactory;
  return function RequiredValidator_Factory(t) {
    return (\u0275RequiredValidator_BaseFactory || (\u0275RequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_RequiredValidator)))(t || _RequiredValidator);
  };
})();
_RequiredValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _RequiredValidator,
  selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
  hostVars: 1,
  hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("required", ctx._enabled ? "" : null);
    }
  },
  inputs: {
    required: "required"
  },
  features: [\u0275\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var RequiredValidator = _RequiredValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      }
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var _CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  constructor() {
    super(...arguments);
    this.createValidator = (input) => requiredTrueValidator;
  }
};
_CheckboxRequiredValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275CheckboxRequiredValidator_BaseFactory;
  return function CheckboxRequiredValidator_Factory(t) {
    return (\u0275CheckboxRequiredValidator_BaseFactory || (\u0275CheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxRequiredValidator)))(t || _CheckboxRequiredValidator);
  };
})();
_CheckboxRequiredValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CheckboxRequiredValidator,
  selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("required", ctx._enabled ? "" : null);
    }
  },
  features: [\u0275\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var CheckboxRequiredValidator = _CheckboxRequiredValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      }
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var _EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "email";
    this.normalizeInput = booleanAttribute;
    this.createValidator = (input) => emailValidator;
  }
  /** @nodoc */
  enabled(input) {
    return input;
  }
};
_EmailValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275EmailValidator_BaseFactory;
  return function EmailValidator_Factory(t) {
    return (\u0275EmailValidator_BaseFactory || (\u0275EmailValidator_BaseFactory = \u0275\u0275getInheritedFactory(_EmailValidator)))(t || _EmailValidator);
  };
})();
_EmailValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _EmailValidator,
  selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
  inputs: {
    email: "email"
  },
  features: [\u0275\u0275ProvidersFeature([EMAIL_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var EmailValidator = _EmailValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR]
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var _MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "minlength";
    this.normalizeInput = (input) => toInteger(input);
    this.createValidator = (minlength) => minLengthValidator(minlength);
  }
};
_MinLengthValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MinLengthValidator_BaseFactory;
  return function MinLengthValidator_Factory(t) {
    return (\u0275MinLengthValidator_BaseFactory || (\u0275MinLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinLengthValidator)))(t || _MinLengthValidator);
  };
})();
_MinLengthValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MinLengthValidator,
  selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("minlength", ctx._enabled ? ctx.minlength : null);
    }
  },
  inputs: {
    minlength: "minlength"
  },
  features: [\u0275\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MinLengthValidator = _MinLengthValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      }
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var _MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "maxlength";
    this.normalizeInput = (input) => toInteger(input);
    this.createValidator = (maxlength) => maxLengthValidator(maxlength);
  }
};
_MaxLengthValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275MaxLengthValidator_BaseFactory;
  return function MaxLengthValidator_Factory(t) {
    return (\u0275MaxLengthValidator_BaseFactory || (\u0275MaxLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxLengthValidator)))(t || _MaxLengthValidator);
  };
})();
_MaxLengthValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _MaxLengthValidator,
  selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
    }
  },
  inputs: {
    maxlength: "maxlength"
  },
  features: [\u0275\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var MaxLengthValidator = _MaxLengthValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      }
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var _PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "pattern";
    this.normalizeInput = (input) => input;
    this.createValidator = (input) => patternValidator(input);
  }
};
_PatternValidator.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275PatternValidator_BaseFactory;
  return function PatternValidator_Factory(t) {
    return (\u0275PatternValidator_BaseFactory || (\u0275PatternValidator_BaseFactory = \u0275\u0275getInheritedFactory(_PatternValidator)))(t || _PatternValidator);
  };
})();
_PatternValidator.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _PatternValidator,
  selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function PatternValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("pattern", ctx._enabled ? ctx.pattern : null);
    }
  },
  inputs: {
    pattern: "pattern"
  },
  features: [\u0275\u0275ProvidersFeature([PATTERN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
});
var PatternValidator = _PatternValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      }
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var _\u0275InternalFormsSharedModule = class _\u0275InternalFormsSharedModule {
};
_\u0275InternalFormsSharedModule.\u0275fac = function \u0275InternalFormsSharedModule_Factory(t) {
  return new (t || _\u0275InternalFormsSharedModule)();
};
_\u0275InternalFormsSharedModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _\u0275InternalFormsSharedModule
});
_\u0275InternalFormsSharedModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [RadioControlRegistryModule]
});
var \u0275InternalFormsSharedModule = _\u0275InternalFormsSharedModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275InternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      imports: [RadioControlRegistryModule],
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0)
      adjustedIndex = 0;
    if (this.controls[adjustedIndex])
      this.controls[adjustedIndex]._registerOnCollectionChange(() => {
      });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0)
      adjustedIndex = 0;
    if (this.controls[adjustedIndex])
      this.controls[adjustedIndex]._registerOnCollectionChange(() => {
      });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null)
      return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1)
      return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated)
      this.updateValueAndValidity({
        onlySelf: true
      });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled)
        return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var _FormBuilder = class _FormBuilder {
  constructor() {
    this.useNonNullable = false;
  }
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
   * </code-example>
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
};
_FormBuilder.\u0275fac = function FormBuilder_Factory(t) {
  return new (t || _FormBuilder)();
};
_FormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FormBuilder,
  factory: _FormBuilder.\u0275fac,
  providedIn: "root"
});
var FormBuilder = _FormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NonNullableFormBuilder = class _NonNullableFormBuilder {
};
_NonNullableFormBuilder.\u0275fac = function NonNullableFormBuilder_Factory(t) {
  return new (t || _NonNullableFormBuilder)();
};
_NonNullableFormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NonNullableFormBuilder,
  factory: () => (() => inject(FormBuilder).nonNullable)(),
  providedIn: "root"
});
var NonNullableFormBuilder = _NonNullableFormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var _UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
};
_UntypedFormBuilder.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275UntypedFormBuilder_BaseFactory;
  return function UntypedFormBuilder_Factory(t) {
    return (\u0275UntypedFormBuilder_BaseFactory || (\u0275UntypedFormBuilder_BaseFactory = \u0275\u0275getInheritedFactory(_UntypedFormBuilder)))(t || _UntypedFormBuilder);
  };
})();
_UntypedFormBuilder.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _UntypedFormBuilder,
  factory: _UntypedFormBuilder.\u0275fac,
  providedIn: "root"
});
var UntypedFormBuilder = _UntypedFormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION3 = new Version("17.0.8");
var _FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
};
_FormsModule.\u0275fac = function FormsModule_Factory(t) {
  return new (t || _FormsModule)();
};
_FormsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FormsModule
});
_FormsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [\u0275InternalFormsSharedModule]
});
var FormsModule = _FormsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var _ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
};
_ReactiveFormsModule.\u0275fac = function ReactiveFormsModule_Factory(t) {
  return new (t || _ReactiveFormsModule)();
};
_ReactiveFormsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ReactiveFormsModule
});
_ReactiveFormsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [\u0275InternalFormsSharedModule]
});
var ReactiveFormsModule = _ReactiveFormsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@delon/util/fesm2022/decorator.mjs
function propDecoratorFactory(name, fallback, defaultValue) {
  function propDecorator(target, propName, originalDescriptor) {
    const privatePropName = `$$__${propName}`;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
        warn(`The prop "${privatePropName}" is already exist, it will be overrided by ${name} decorator.`);
      }
    }
    Object.defineProperty(target, privatePropName, {
      configurable: true,
      writable: true
    });
    return {
      get() {
        return originalDescriptor && originalDescriptor.get ? originalDescriptor.get.bind(this)() : this[privatePropName];
      },
      set(value) {
        if (originalDescriptor && originalDescriptor.set) {
          originalDescriptor.set.bind(this)(fallback(value, defaultValue));
        }
        this[privatePropName] = fallback(value, defaultValue);
      }
    };
  }
  return propDecorator;
}
function toBoolean2(value, defaultValue = false) {
  return value == null ? defaultValue : `${value}` !== "false";
}
function InputBoolean2(defaultValue = false) {
  return propDecoratorFactory("InputBoolean", toBoolean2, defaultValue);
}
function toNumber2(value, fallbackValue = 0) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value)) ? Number(value) : fallbackValue;
}
function InputNumber2(defaultValue = 0) {
  return propDecoratorFactory("InputNumber", toNumber2, defaultValue);
}
function makeFn(type, options) {
  return (_, __, descriptor) => {
    const source = descriptor.value;
    descriptor.value = function(...data) {
      const that = this;
      const ngZone = that[options?.ngZoneName || "ngZone"];
      if (!ngZone) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          warn(`ZoneOutside: Decorator should have 'ngZone' property with 'NgZone' class.`);
        }
        return source.call(this, ...data);
      }
      let res;
      ngZone[type](() => {
        res = source.call(this, ...data);
      });
      return res;
    };
    return descriptor;
  };
}
function ZoneOutside(options) {
  return makeFn("runOutsideAngular", options);
}

// node_modules/@delon/util/fesm2022/token.mjs
var WINDOW = new InjectionToken("WINDOW", {
  factory: () => {
    const { defaultView } = inject(DOCUMENT);
    if (!defaultView) {
      throw new Error("Window is not available");
    }
    return defaultView;
  }
});
var PAGE_VISIBILITY = new InjectionToken("PAGE_VISIBILITY`", {
  factory: () => {
    const doc = inject(DOCUMENT);
    return fromEvent(doc, "visibilitychange").pipe(startWith(0), map(() => !doc.hidden), distinctUntilChanged(), share());
  }
});

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-badge.mjs
function NzBadgeSupComponent_ng_container_0_span_1_ng_container_1_p_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 6);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const p_r8 = ctx.$implicit;
    const i_r5 = \u0275\u0275nextContext(2).index;
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("current", p_r8 === ctx_r7.countArray[i_r5]);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", p_r8, " ");
  }
}
function NzBadgeSupComponent_ng_container_0_span_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzBadgeSupComponent_ng_container_0_span_1_ng_container_1_p_1_Template, 2, 3, "p", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r6.countSingleArray);
  }
}
function NzBadgeSupComponent_ng_container_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 3);
    \u0275\u0275template(1, NzBadgeSupComponent_ng_container_0_span_1_ng_container_1_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r5 = ctx.index;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("transform", "translateY(" + -ctx_r3.countArray[i_r5] * 100 + "%)");
    \u0275\u0275property("nzNoAnimation", ctx_r3.noAnimation);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r3.nzDot && ctx_r3.countArray[i_r5] !== void 0);
  }
}
function NzBadgeSupComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzBadgeSupComponent_ng_container_0_span_1_Template, 2, 4, "span", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.maxNumberArray);
  }
}
function NzBadgeSupComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate1("", ctx_r1.nzOverflowCount, "+");
  }
}
function NzBadgeComponent_ng_container_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r2.nzText);
  }
}
function NzBadgeComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 2);
    \u0275\u0275elementStart(2, "span", 3);
    \u0275\u0275template(3, NzBadgeComponent_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("ant-badge-status-dot ant-badge-status-", ctx_r0.nzStatus || ctx_r0.presetColor, "");
    \u0275\u0275styleProp("background", !ctx_r0.presetColor && ctx_r0.nzColor);
    \u0275\u0275property("ngStyle", ctx_r0.nzStyle);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.nzText);
  }
}
function NzBadgeComponent_ng_container_2_nz_badge_sup_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-badge-sup", 5);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzOffset", ctx_r3.nzOffset)("nzSize", ctx_r3.nzSize)("nzTitle", ctx_r3.nzTitle)("nzStyle", ctx_r3.nzStyle)("nzDot", ctx_r3.nzDot)("nzOverflowCount", ctx_r3.nzOverflowCount)("disableAnimation", !!(ctx_r3.nzStandalone || ctx_r3.nzStatus || ctx_r3.nzColor || (ctx_r3.noAnimation == null ? null : ctx_r3.noAnimation.nzNoAnimation)))("nzCount", ctx_r3.nzCount)("noAnimation", !!(ctx_r3.noAnimation == null ? null : ctx_r3.noAnimation.nzNoAnimation));
  }
}
function NzBadgeComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzBadgeComponent_ng_container_2_nz_badge_sup_1_Template, 1, 9, "nz-badge-sup", 4);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r1.showSup);
  }
}
var _c02 = ["*"];
function NzRibbonComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "span", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.nzText);
  }
}
var _NzBadgeSupComponent = class _NzBadgeSupComponent {
  constructor() {
    this.nzStyle = null;
    this.nzDot = false;
    this.nzOverflowCount = 99;
    this.disableAnimation = false;
    this.noAnimation = false;
    this.nzSize = "default";
    this.maxNumberArray = [];
    this.countArray = [];
    this.count = 0;
    this.countSingleArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  }
  generateMaxNumberArray() {
    this.maxNumberArray = this.nzOverflowCount.toString().split("");
  }
  ngOnInit() {
    this.generateMaxNumberArray();
  }
  ngOnChanges(changes) {
    const {
      nzOverflowCount,
      nzCount
    } = changes;
    if (nzCount && typeof nzCount.currentValue === "number") {
      this.count = Math.max(0, nzCount.currentValue);
      this.countArray = this.count.toString().split("").map((item) => +item);
    }
    if (nzOverflowCount) {
      this.generateMaxNumberArray();
    }
  }
};
_NzBadgeSupComponent.\u0275fac = function NzBadgeSupComponent_Factory(t) {
  return new (t || _NzBadgeSupComponent)();
};
_NzBadgeSupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzBadgeSupComponent,
  selectors: [["nz-badge-sup"]],
  hostAttrs: [1, "ant-scroll-number"],
  hostVars: 17,
  hostBindings: function NzBadgeSupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("title", ctx.nzTitle === null ? "" : ctx.nzTitle || ctx.nzCount);
      \u0275\u0275syntheticHostProperty("@.disabled", ctx.disableAnimation)("@zoomBadgeMotion", void 0);
      \u0275\u0275styleMap(ctx.nzStyle);
      \u0275\u0275styleProp("right", ctx.nzOffset && ctx.nzOffset[0] ? -ctx.nzOffset[0] : null, "px")("margin-top", ctx.nzOffset && ctx.nzOffset[1] ? ctx.nzOffset[1] : null, "px");
      \u0275\u0275classProp("ant-badge-count", !ctx.nzDot)("ant-badge-count-sm", ctx.nzSize === "small")("ant-badge-dot", ctx.nzDot)("ant-badge-multiple-words", ctx.countArray.length >= 2);
    }
  },
  inputs: {
    nzOffset: "nzOffset",
    nzTitle: "nzTitle",
    nzStyle: "nzStyle",
    nzDot: "nzDot",
    nzOverflowCount: "nzOverflowCount",
    disableAnimation: "disableAnimation",
    nzCount: "nzCount",
    noAnimation: "noAnimation",
    nzSize: "nzSize"
  },
  exportAs: ["nzBadgeSup"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 3,
  vars: 2,
  consts: [[4, "ngIf", "ngIfElse"], ["overflowTemplate", ""], ["class", "ant-scroll-number-only", 3, "nzNoAnimation", "transform", 4, "ngFor", "ngForOf"], [1, "ant-scroll-number-only", 3, "nzNoAnimation"], [4, "ngIf"], ["class", "ant-scroll-number-only-unit", 3, "current", 4, "ngFor", "ngForOf"], [1, "ant-scroll-number-only-unit"]],
  template: function NzBadgeSupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzBadgeSupComponent_ng_container_0_Template, 2, 1, "ng-container", 0)(1, NzBadgeSupComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.count <= ctx.nzOverflowCount)("ngIfElse", _r2);
    }
  },
  dependencies: [NgForOf, NgIf, NzNoAnimationDirective],
  encapsulation: 2,
  data: {
    animation: [zoomBadgeMotion]
  },
  changeDetection: 0
});
var NzBadgeSupComponent = _NzBadgeSupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzBadgeSupComponent, [{
    type: Component,
    args: [{
      selector: "nz-badge-sup",
      exportAs: "nzBadgeSup",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [zoomBadgeMotion],
      standalone: true,
      imports: [NgForOf, NgIf, NzNoAnimationDirective],
      template: `
    <ng-container *ngIf="count <= nzOverflowCount; else overflowTemplate">
      <span
        [nzNoAnimation]="noAnimation"
        *ngFor="let n of maxNumberArray; let i = index"
        class="ant-scroll-number-only"
        [style.transform]="'translateY(' + -countArray[i] * 100 + '%)'"
      >
        <ng-container *ngIf="!nzDot && countArray[i] !== undefined">
          <p
            *ngFor="let p of countSingleArray"
            class="ant-scroll-number-only-unit"
            [class.current]="p === countArray[i]"
          >
            {{ p }}
          </p>
        </ng-container>
      </span>
    </ng-container>
    <ng-template #overflowTemplate>{{ nzOverflowCount }}+</ng-template>
  `,
      host: {
        class: "ant-scroll-number",
        "[@.disabled]": `disableAnimation`,
        "[@zoomBadgeMotion]": "",
        "[attr.title]": `nzTitle === null ? '' : nzTitle || nzCount`,
        "[style]": `nzStyle`,
        "[style.right.px]": `nzOffset && nzOffset[0] ? -nzOffset[0] : null`,
        "[style.margin-top.px]": `nzOffset && nzOffset[1] ? nzOffset[1] : null`,
        "[class.ant-badge-count]": `!nzDot`,
        "[class.ant-badge-count-sm]": `nzSize === 'small'`,
        "[class.ant-badge-dot]": `nzDot`,
        "[class.ant-badge-multiple-words]": `countArray.length >= 2`
      }
    }]
  }], () => [], {
    nzOffset: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    nzStyle: [{
      type: Input
    }],
    nzDot: [{
      type: Input
    }],
    nzOverflowCount: [{
      type: Input
    }],
    disableAnimation: [{
      type: Input
    }],
    nzCount: [{
      type: Input
    }],
    noAnimation: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }]
  });
})();
var badgePresetColors = ["pink", "red", "yellow", "orange", "cyan", "green", "blue", "purple", "geekblue", "magenta", "volcano", "gold", "lime"];
var NZ_CONFIG_MODULE_NAME2 = "badge";
var _NzBadgeComponent = class _NzBadgeComponent {
  constructor(nzConfigService, renderer, cdr, elementRef, directionality, noAnimation) {
    this.nzConfigService = nzConfigService;
    this.renderer = renderer;
    this.cdr = cdr;
    this.elementRef = elementRef;
    this.directionality = directionality;
    this.noAnimation = noAnimation;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME2;
    this.showSup = false;
    this.presetColor = null;
    this.dir = "ltr";
    this.destroy$ = new Subject();
    this.nzShowZero = false;
    this.nzShowDot = true;
    this.nzStandalone = false;
    this.nzDot = false;
    this.nzOverflowCount = 99;
    this.nzColor = void 0;
    this.nzStyle = null;
    this.nzText = null;
    this.nzSize = "default";
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.prepareBadgeForRtl();
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.prepareBadgeForRtl();
  }
  ngOnChanges(changes) {
    const {
      nzColor,
      nzShowDot,
      nzDot,
      nzCount,
      nzShowZero
    } = changes;
    if (nzColor) {
      this.presetColor = this.nzColor && badgePresetColors.indexOf(this.nzColor) !== -1 ? this.nzColor : null;
    }
    if (nzShowDot || nzDot || nzCount || nzShowZero) {
      this.showSup = this.nzShowDot && this.nzDot || typeof this.nzCount === "number" && this.nzCount > 0 || typeof this.nzCount === "number" && this.nzCount <= 0 && this.nzShowZero;
    }
  }
  prepareBadgeForRtl() {
    if (this.isRtlLayout) {
      this.renderer.addClass(this.elementRef.nativeElement, "ant-badge-rtl");
    } else {
      this.renderer.removeClass(this.elementRef.nativeElement, "ant-badge-rtl");
    }
  }
  get isRtlLayout() {
    return this.dir === "rtl";
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzBadgeComponent.\u0275fac = function NzBadgeComponent_Factory(t) {
  return new (t || _NzBadgeComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzBadgeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzBadgeComponent,
  selectors: [["nz-badge"]],
  hostAttrs: [1, "ant-badge"],
  hostVars: 4,
  hostBindings: function NzBadgeComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-badge-status", ctx.nzStatus)("ant-badge-not-a-wrapper", !!(ctx.nzStandalone || ctx.nzStatus || ctx.nzColor));
    }
  },
  inputs: {
    nzShowZero: "nzShowZero",
    nzShowDot: "nzShowDot",
    nzStandalone: "nzStandalone",
    nzDot: "nzDot",
    nzOverflowCount: "nzOverflowCount",
    nzColor: "nzColor",
    nzStyle: "nzStyle",
    nzText: "nzText",
    nzTitle: "nzTitle",
    nzStatus: "nzStatus",
    nzCount: "nzCount",
    nzOffset: "nzOffset",
    nzSize: "nzSize"
  },
  exportAs: ["nzBadge"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c02,
  decls: 3,
  vars: 2,
  consts: [[4, "ngIf"], [4, "nzStringTemplateOutlet"], [3, "ngStyle"], [1, "ant-badge-status-text"], [3, "nzOffset", "nzSize", "nzTitle", "nzStyle", "nzDot", "nzOverflowCount", "disableAnimation", "nzCount", "noAnimation", 4, "ngIf"], [3, "nzOffset", "nzSize", "nzTitle", "nzStyle", "nzDot", "nzOverflowCount", "disableAnimation", "nzCount", "noAnimation"]],
  template: function NzBadgeComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzBadgeComponent_ng_container_0_Template, 4, 7, "ng-container", 0);
      \u0275\u0275projection(1);
      \u0275\u0275template(2, NzBadgeComponent_ng_container_2_Template, 2, 1, "ng-container", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.nzStatus || ctx.nzColor);
      \u0275\u0275advance(2);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzCount);
    }
  },
  dependencies: [NgIf, NgStyle, NzBadgeSupComponent, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  data: {
    animation: [zoomBadgeMotion]
  },
  changeDetection: 0
});
var NzBadgeComponent = _NzBadgeComponent;
__decorate([InputBoolean()], NzBadgeComponent.prototype, "nzShowZero", void 0);
__decorate([InputBoolean()], NzBadgeComponent.prototype, "nzShowDot", void 0);
__decorate([InputBoolean()], NzBadgeComponent.prototype, "nzStandalone", void 0);
__decorate([InputBoolean()], NzBadgeComponent.prototype, "nzDot", void 0);
__decorate([WithConfig()], NzBadgeComponent.prototype, "nzOverflowCount", void 0);
__decorate([WithConfig()], NzBadgeComponent.prototype, "nzColor", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzBadgeComponent, [{
    type: Component,
    args: [{
      selector: "nz-badge",
      exportAs: "nzBadge",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [zoomBadgeMotion],
      standalone: true,
      imports: [NgIf, NgStyle, NzBadgeSupComponent, NzOutletModule],
      template: `
    <ng-container *ngIf="nzStatus || nzColor">
      <span
        class="ant-badge-status-dot ant-badge-status-{{ nzStatus || presetColor }}"
        [style.background]="!presetColor && nzColor"
        [ngStyle]="nzStyle"
      ></span>
      <span class="ant-badge-status-text">
        <ng-container *nzStringTemplateOutlet="nzText">{{ nzText }}</ng-container>
      </span>
    </ng-container>
    <ng-content></ng-content>
    <ng-container *nzStringTemplateOutlet="nzCount">
      <nz-badge-sup
        *ngIf="showSup"
        [nzOffset]="nzOffset"
        [nzSize]="nzSize"
        [nzTitle]="nzTitle"
        [nzStyle]="nzStyle"
        [nzDot]="nzDot"
        [nzOverflowCount]="nzOverflowCount"
        [disableAnimation]="!!(nzStandalone || nzStatus || nzColor || noAnimation?.nzNoAnimation)"
        [nzCount]="nzCount"
        [noAnimation]="!!noAnimation?.nzNoAnimation"
      ></nz-badge-sup>
    </ng-container>
  `,
      host: {
        class: "ant-badge",
        "[class.ant-badge-status]": "nzStatus",
        "[class.ant-badge-not-a-wrapper]": "!!(nzStandalone || nzStatus || nzColor)"
      }
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    nzShowZero: [{
      type: Input
    }],
    nzShowDot: [{
      type: Input
    }],
    nzStandalone: [{
      type: Input
    }],
    nzDot: [{
      type: Input
    }],
    nzOverflowCount: [{
      type: Input
    }],
    nzColor: [{
      type: Input
    }],
    nzStyle: [{
      type: Input
    }],
    nzText: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzCount: [{
      type: Input
    }],
    nzOffset: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }]
  });
})();
var _NzRibbonComponent = class _NzRibbonComponent {
  constructor() {
    this.nzPlacement = "end";
    this.nzText = null;
    this.presetColor = null;
  }
  ngOnChanges(changes) {
    const {
      nzColor
    } = changes;
    if (nzColor) {
      this.presetColor = this.nzColor && badgePresetColors.indexOf(this.nzColor) !== -1 ? this.nzColor : null;
    }
  }
};
_NzRibbonComponent.\u0275fac = function NzRibbonComponent_Factory(t) {
  return new (t || _NzRibbonComponent)();
};
_NzRibbonComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzRibbonComponent,
  selectors: [["nz-ribbon"]],
  hostAttrs: [1, "ant-ribbon-wrapper"],
  inputs: {
    nzColor: "nzColor",
    nzPlacement: "nzPlacement",
    nzText: "nzText"
  },
  exportAs: ["nzRibbon"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c02,
  decls: 4,
  vars: 11,
  consts: [[1, "ant-ribbon"], [4, "nzStringTemplateOutlet"], [1, "ant-ribbon-corner"], [1, "ant-ribbon-text"]],
  template: function NzRibbonComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
      \u0275\u0275elementStart(1, "div", 0);
      \u0275\u0275template(2, NzRibbonComponent_ng_container_2_Template, 3, 1, "ng-container", 1);
      \u0275\u0275element(3, "div", 2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275classMap(ctx.presetColor && "ant-ribbon-color-" + ctx.presetColor);
      \u0275\u0275styleProp("background-color", !ctx.presetColor && ctx.nzColor);
      \u0275\u0275classProp("ant-ribbon-placement-end", ctx.nzPlacement === "end")("ant-ribbon-placement-start", ctx.nzPlacement === "start");
      \u0275\u0275advance(1);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzText);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("color", !ctx.presetColor && ctx.nzColor);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzRibbonComponent = _NzRibbonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRibbonComponent, [{
    type: Component,
    args: [{
      selector: "nz-ribbon",
      exportAs: "nzRibbon",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [NzOutletModule],
      template: `
    <ng-content></ng-content>
    <div
      class="ant-ribbon"
      [class]="presetColor && 'ant-ribbon-color-' + presetColor"
      [class.ant-ribbon-placement-end]="nzPlacement === 'end'"
      [class.ant-ribbon-placement-start]="nzPlacement === 'start'"
      [style.background-color]="!presetColor && nzColor"
    >
      <ng-container *nzStringTemplateOutlet="nzText">
        <span class="ant-ribbon-text">{{ nzText }}</span>
      </ng-container>
      <div class="ant-ribbon-corner" [style.color]="!presetColor && nzColor"></div>
    </div>
  `,
      host: {
        class: "ant-ribbon-wrapper"
      }
    }]
  }], () => [], {
    nzColor: [{
      type: Input
    }],
    nzPlacement: [{
      type: Input
    }],
    nzText: [{
      type: Input
    }]
  });
})();
var _NzBadgeModule = class _NzBadgeModule {
};
_NzBadgeModule.\u0275fac = function NzBadgeModule_Factory(t) {
  return new (t || _NzBadgeModule)();
};
_NzBadgeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzBadgeModule
});
_NzBadgeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzBadgeComponent, NzRibbonComponent]
});
var NzBadgeModule = _NzBadgeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzBadgeModule, [{
    type: NgModule,
    args: [{
      exports: [NzBadgeComponent, NzRibbonComponent],
      imports: [NzBadgeComponent, NzRibbonComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-core-form.mjs
function NzFormItemFeedbackIconComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzType", ctx_r0.iconType);
  }
}
var _NzFormStatusService = class _NzFormStatusService {
  constructor() {
    this.formStatusChanges = new ReplaySubject(1);
  }
};
_NzFormStatusService.\u0275fac = function NzFormStatusService_Factory(t) {
  return new (t || _NzFormStatusService)();
};
_NzFormStatusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzFormStatusService,
  factory: _NzFormStatusService.\u0275fac
});
var NzFormStatusService = _NzFormStatusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormStatusService, [{
    type: Injectable
  }], null, null);
})();
var _NzFormNoStatusService = class _NzFormNoStatusService {
  constructor() {
    this.noFormStatus = new BehaviorSubject(false);
  }
};
_NzFormNoStatusService.\u0275fac = function NzFormNoStatusService_Factory(t) {
  return new (t || _NzFormNoStatusService)();
};
_NzFormNoStatusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzFormNoStatusService,
  factory: _NzFormNoStatusService.\u0275fac
});
var NzFormNoStatusService = _NzFormNoStatusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormNoStatusService, [{
    type: Injectable
  }], null, null);
})();
var iconTypeMap = {
  error: "close-circle-fill",
  validating: "loading",
  success: "check-circle-fill",
  warning: "exclamation-circle-fill"
};
var _NzFormItemFeedbackIconComponent = class _NzFormItemFeedbackIconComponent {
  constructor(cdr) {
    this.cdr = cdr;
    this.status = "";
    this.iconType = null;
  }
  ngOnChanges(_changes) {
    this.updateIcon();
  }
  updateIcon() {
    this.iconType = this.status ? iconTypeMap[this.status] : null;
    this.cdr.markForCheck();
  }
};
_NzFormItemFeedbackIconComponent.\u0275fac = function NzFormItemFeedbackIconComponent_Factory(t) {
  return new (t || _NzFormItemFeedbackIconComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_NzFormItemFeedbackIconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzFormItemFeedbackIconComponent,
  selectors: [["nz-form-item-feedback-icon"]],
  hostAttrs: [1, "ant-form-item-feedback-icon"],
  hostVars: 8,
  hostBindings: function NzFormItemFeedbackIconComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-form-item-feedback-icon-error", ctx.status === "error")("ant-form-item-feedback-icon-warning", ctx.status === "warning")("ant-form-item-feedback-icon-success", ctx.status === "success")("ant-form-item-feedback-icon-validating", ctx.status === "validating");
    }
  },
  inputs: {
    status: "status"
  },
  exportAs: ["nzFormFeedbackIcon"],
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 1,
  vars: 1,
  consts: [["nz-icon", "", 3, "nzType", 4, "ngIf"], ["nz-icon", "", 3, "nzType"]],
  template: function NzFormItemFeedbackIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzFormItemFeedbackIconComponent_span_0_Template, 1, 1, "span", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.iconType);
    }
  },
  dependencies: [NgIf, NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzFormItemFeedbackIconComponent = _NzFormItemFeedbackIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormItemFeedbackIconComponent, [{
    type: Component,
    args: [{
      selector: "nz-form-item-feedback-icon",
      exportAs: "nzFormFeedbackIcon",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: ` <span *ngIf="iconType" nz-icon [nzType]="iconType"></span> `,
      host: {
        class: "ant-form-item-feedback-icon",
        "[class.ant-form-item-feedback-icon-error]": 'status==="error"',
        "[class.ant-form-item-feedback-icon-warning]": 'status==="warning"',
        "[class.ant-form-item-feedback-icon-success]": 'status==="success"',
        "[class.ant-form-item-feedback-icon-validating]": 'status==="validating"'
      }
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    status: [{
      type: Input
    }]
  });
})();
var _NzFormPatchModule = class _NzFormPatchModule {
};
_NzFormPatchModule.\u0275fac = function NzFormPatchModule_Factory(t) {
  return new (t || _NzFormPatchModule)();
};
_NzFormPatchModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzFormPatchModule
});
_NzFormPatchModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzIconModule]
});
var NzFormPatchModule = _NzFormPatchModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormPatchModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzIconModule],
      exports: [NzFormItemFeedbackIconComponent],
      declarations: [NzFormItemFeedbackIconComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-checkbox.mjs
var _c03 = ["*"];
var _c12 = ["inputElement"];
var _c2 = ["nz-checkbox", ""];
function NzCheckboxGroupComponent_label_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 1);
    \u0275\u0275listener("nzCheckedChange", function NzCheckboxGroupComponent_label_0_Template_label_nzCheckedChange_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const o_r1 = restoredCtx.$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCheckedChange(o_r1, $event));
    });
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const o_r1 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzDisabled", o_r1.disabled || ctx_r0.nzDisabled)("nzChecked", o_r1.checked);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(o_r1.label);
  }
}
var _NzCheckboxWrapperComponent = class _NzCheckboxWrapperComponent {
  constructor() {
    this.nzOnChange = new EventEmitter();
    this.checkboxList = [];
  }
  addCheckbox(value) {
    this.checkboxList.push(value);
  }
  removeCheckbox(value) {
    this.checkboxList.splice(this.checkboxList.indexOf(value), 1);
  }
  onChange() {
    const listOfCheckedValue = this.checkboxList.filter((item) => item.nzChecked).map((item) => item.nzValue);
    this.nzOnChange.emit(listOfCheckedValue);
  }
};
_NzCheckboxWrapperComponent.\u0275fac = function NzCheckboxWrapperComponent_Factory(t) {
  return new (t || _NzCheckboxWrapperComponent)();
};
_NzCheckboxWrapperComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzCheckboxWrapperComponent,
  selectors: [["nz-checkbox-wrapper"]],
  hostAttrs: [1, "ant-checkbox-group"],
  outputs: {
    nzOnChange: "nzOnChange"
  },
  exportAs: ["nzCheckboxWrapper"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c03,
  decls: 1,
  vars: 0,
  template: function NzCheckboxWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzCheckboxWrapperComponent = _NzCheckboxWrapperComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCheckboxWrapperComponent, [{
    type: Component,
    args: [{
      selector: "nz-checkbox-wrapper",
      exportAs: "nzCheckboxWrapper",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: ` <ng-content></ng-content> `,
      host: {
        class: "ant-checkbox-group"
      },
      standalone: true
    }]
  }], null, {
    nzOnChange: [{
      type: Output
    }]
  });
})();
var _NzCheckboxComponent = class _NzCheckboxComponent {
  innerCheckedChange(checked) {
    if (!this.nzDisabled) {
      this.nzChecked = checked;
      this.onChange(this.nzChecked);
      this.nzCheckedChange.emit(this.nzChecked);
      if (this.nzCheckboxWrapperComponent) {
        this.nzCheckboxWrapperComponent.onChange();
      }
    }
  }
  writeValue(value) {
    this.nzChecked = value;
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(disabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || disabled;
    this.isNzDisableFirstChange = false;
    this.cdr.markForCheck();
  }
  focus() {
    this.focusMonitor.focusVia(this.inputElement, "keyboard");
  }
  blur() {
    this.inputElement.nativeElement.blur();
  }
  constructor(ngZone, elementRef, nzCheckboxWrapperComponent, cdr, focusMonitor, directionality, nzFormStatusService) {
    this.ngZone = ngZone;
    this.elementRef = elementRef;
    this.nzCheckboxWrapperComponent = nzCheckboxWrapperComponent;
    this.cdr = cdr;
    this.focusMonitor = focusMonitor;
    this.directionality = directionality;
    this.nzFormStatusService = nzFormStatusService;
    this.dir = "ltr";
    this.destroy$ = new Subject();
    this.isNzDisableFirstChange = true;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.nzCheckedChange = new EventEmitter();
    this.nzValue = null;
    this.nzAutoFocus = false;
    this.nzDisabled = false;
    this.nzIndeterminate = false;
    this.nzChecked = false;
    this.nzId = null;
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe((focusOrigin) => {
      if (!focusOrigin) {
        Promise.resolve().then(() => this.onTouched());
      }
    });
    if (this.nzCheckboxWrapperComponent) {
      this.nzCheckboxWrapperComponent.addCheckbox(this);
    }
    this.directionality.change.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.elementRef.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        event.preventDefault();
        this.focus();
        if (this.nzDisabled) {
          return;
        }
        this.ngZone.run(() => {
          this.innerCheckedChange(!this.nzChecked);
          this.cdr.markForCheck();
        });
      });
      fromEvent(this.inputElement.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe((event) => event.stopPropagation());
    });
  }
  ngAfterViewInit() {
    if (this.nzAutoFocus) {
      this.focus();
    }
  }
  ngOnDestroy() {
    this.focusMonitor.stopMonitoring(this.elementRef);
    if (this.nzCheckboxWrapperComponent) {
      this.nzCheckboxWrapperComponent.removeCheckbox(this);
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzCheckboxComponent.\u0275fac = function NzCheckboxComponent_Factory(t) {
  return new (t || _NzCheckboxComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NzCheckboxWrapperComponent, 8), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(FocusMonitor), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzFormStatusService, 8));
};
_NzCheckboxComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzCheckboxComponent,
  selectors: [["", "nz-checkbox", ""]],
  viewQuery: function NzCheckboxComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c12, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inputElement = _t.first);
    }
  },
  hostAttrs: [1, "ant-checkbox-wrapper"],
  hostVars: 6,
  hostBindings: function NzCheckboxComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-checkbox-wrapper-in-form-item", !!ctx.nzFormStatusService)("ant-checkbox-wrapper-checked", ctx.nzChecked)("ant-checkbox-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzValue: "nzValue",
    nzAutoFocus: "nzAutoFocus",
    nzDisabled: "nzDisabled",
    nzIndeterminate: "nzIndeterminate",
    nzChecked: "nzChecked",
    nzId: "nzId"
  },
  outputs: {
    nzCheckedChange: "nzCheckedChange"
  },
  exportAs: ["nzCheckbox"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NzCheckboxComponent),
    multi: true
  }]), \u0275\u0275StandaloneFeature],
  attrs: _c2,
  ngContentSelectors: _c03,
  decls: 6,
  vars: 11,
  consts: [[1, "ant-checkbox"], ["type", "checkbox", 1, "ant-checkbox-input", 3, "checked", "ngModel", "disabled", "ngModelChange"], ["inputElement", ""], [1, "ant-checkbox-inner"]],
  template: function NzCheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "span", 0)(1, "input", 1, 2);
      \u0275\u0275listener("ngModelChange", function NzCheckboxComponent_Template_input_ngModelChange_1_listener($event) {
        return ctx.innerCheckedChange($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275element(3, "span", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "span");
      \u0275\u0275projection(5);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-checkbox-checked", ctx.nzChecked && !ctx.nzIndeterminate)("ant-checkbox-disabled", ctx.nzDisabled)("ant-checkbox-indeterminate", ctx.nzIndeterminate);
      \u0275\u0275advance(1);
      \u0275\u0275property("checked", ctx.nzChecked)("ngModel", ctx.nzChecked)("disabled", ctx.nzDisabled);
      \u0275\u0275attribute("autofocus", ctx.nzAutoFocus ? "autofocus" : null)("id", ctx.nzId);
    }
  },
  dependencies: [FormsModule, CheckboxControlValueAccessor, NgControlStatus, NgModel],
  encapsulation: 2,
  changeDetection: 0
});
var NzCheckboxComponent = _NzCheckboxComponent;
__decorate([InputBoolean()], NzCheckboxComponent.prototype, "nzAutoFocus", void 0);
__decorate([InputBoolean()], NzCheckboxComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzCheckboxComponent.prototype, "nzIndeterminate", void 0);
__decorate([InputBoolean()], NzCheckboxComponent.prototype, "nzChecked", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCheckboxComponent, [{
    type: Component,
    args: [{
      selector: "[nz-checkbox]",
      exportAs: "nzCheckbox",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <span
      class="ant-checkbox"
      [class.ant-checkbox-checked]="nzChecked && !nzIndeterminate"
      [class.ant-checkbox-disabled]="nzDisabled"
      [class.ant-checkbox-indeterminate]="nzIndeterminate"
    >
      <input
        #inputElement
        type="checkbox"
        class="ant-checkbox-input"
        [attr.autofocus]="nzAutoFocus ? 'autofocus' : null"
        [attr.id]="nzId"
        [checked]="nzChecked"
        [ngModel]="nzChecked"
        [disabled]="nzDisabled"
        (ngModelChange)="innerCheckedChange($event)"
      />
      <span class="ant-checkbox-inner"></span>
    </span>
    <span><ng-content></ng-content></span>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NzCheckboxComponent),
        multi: true
      }],
      host: {
        class: "ant-checkbox-wrapper",
        "[class.ant-checkbox-wrapper-in-form-item]": "!!nzFormStatusService",
        "[class.ant-checkbox-wrapper-checked]": "nzChecked",
        "[class.ant-checkbox-rtl]": `dir === 'rtl'`
      },
      imports: [FormsModule],
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: NzCheckboxWrapperComponent,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: FocusMonitor
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    inputElement: [{
      type: ViewChild,
      args: ["inputElement", {
        static: true
      }]
    }],
    nzCheckedChange: [{
      type: Output
    }],
    nzValue: [{
      type: Input
    }],
    nzAutoFocus: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzIndeterminate: [{
      type: Input
    }],
    nzChecked: [{
      type: Input
    }],
    nzId: [{
      type: Input
    }]
  });
})();
var _NzCheckboxGroupComponent = class _NzCheckboxGroupComponent {
  trackByOption(_, option) {
    return option.value;
  }
  onCheckedChange(option, checked) {
    option.checked = checked;
    this.onChange(this.options);
  }
  constructor(elementRef, focusMonitor, cdr, directionality) {
    this.elementRef = elementRef;
    this.focusMonitor = focusMonitor;
    this.cdr = cdr;
    this.directionality = directionality;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.options = [];
    this.nzDisabled = false;
    this.dir = "ltr";
    this.destroy$ = new Subject();
    this.isNzDisableFirstChange = true;
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe((focusOrigin) => {
      if (!focusOrigin) {
        Promise.resolve().then(() => this.onTouched());
      }
    });
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnDestroy() {
    this.focusMonitor.stopMonitoring(this.elementRef);
    this.destroy$.next();
    this.destroy$.complete();
  }
  writeValue(value) {
    this.options = value;
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(disabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || disabled;
    this.isNzDisableFirstChange = false;
    this.cdr.markForCheck();
  }
};
_NzCheckboxGroupComponent.\u0275fac = function NzCheckboxGroupComponent_Factory(t) {
  return new (t || _NzCheckboxGroupComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(FocusMonitor), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzCheckboxGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzCheckboxGroupComponent,
  selectors: [["nz-checkbox-group"]],
  hostAttrs: [1, "ant-checkbox-group"],
  hostVars: 2,
  hostBindings: function NzCheckboxGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-checkbox-group-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzDisabled: "nzDisabled"
  },
  exportAs: ["nzCheckboxGroup"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NzCheckboxGroupComponent),
    multi: true
  }]), \u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 2,
  consts: [["nz-checkbox", "", "class", "ant-checkbox-group-item", 3, "nzDisabled", "nzChecked", "nzCheckedChange", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["nz-checkbox", "", 1, "ant-checkbox-group-item", 3, "nzDisabled", "nzChecked", "nzCheckedChange"]],
  template: function NzCheckboxGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzCheckboxGroupComponent_label_0_Template, 3, 3, "label", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.options)("ngForTrackBy", ctx.trackByOption);
    }
  },
  dependencies: [NgForOf, NzCheckboxComponent],
  encapsulation: 2
});
var NzCheckboxGroupComponent = _NzCheckboxGroupComponent;
__decorate([InputBoolean()], NzCheckboxGroupComponent.prototype, "nzDisabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCheckboxGroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-checkbox-group",
      exportAs: "nzCheckboxGroup",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <label
      nz-checkbox
      class="ant-checkbox-group-item"
      *ngFor="let o of options; trackBy: trackByOption"
      [nzDisabled]="o.disabled || nzDisabled"
      [nzChecked]="o.checked!"
      (nzCheckedChange)="onCheckedChange(o, $event)"
    >
      <span>{{ o.label }}</span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NzCheckboxGroupComponent),
        multi: true
      }],
      host: {
        class: "ant-checkbox-group",
        "[class.ant-checkbox-group-rtl]": `dir === 'rtl'`
      },
      imports: [NgForOf, NzCheckboxComponent],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: FocusMonitor
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzDisabled: [{
      type: Input
    }]
  });
})();
var _NzCheckboxModule = class _NzCheckboxModule {
};
_NzCheckboxModule.\u0275fac = function NzCheckboxModule_Factory(t) {
  return new (t || _NzCheckboxModule)();
};
_NzCheckboxModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzCheckboxModule
});
_NzCheckboxModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzCheckboxComponent, NzCheckboxGroupComponent]
});
var NzCheckboxModule = _NzCheckboxModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [NzCheckboxComponent, NzCheckboxGroupComponent, NzCheckboxWrapperComponent],
      exports: [NzCheckboxComponent, NzCheckboxGroupComponent, NzCheckboxWrapperComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-radio.mjs
var _c04 = ["*"];
var _c13 = ["inputElement"];
var _c22 = ["nz-radio", ""];
var _NzRadioButtonDirective = class _NzRadioButtonDirective {
};
_NzRadioButtonDirective.\u0275fac = function NzRadioButtonDirective_Factory(t) {
  return new (t || _NzRadioButtonDirective)();
};
_NzRadioButtonDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzRadioButtonDirective,
  selectors: [["", "nz-radio-button", ""]],
  standalone: true
});
var NzRadioButtonDirective = _NzRadioButtonDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRadioButtonDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-radio-button]",
      standalone: true
    }]
  }], null, null);
})();
var _NzRadioService = class _NzRadioService {
  constructor() {
    this.selected$ = new ReplaySubject(1);
    this.touched$ = new Subject();
    this.disabled$ = new ReplaySubject(1);
    this.name$ = new ReplaySubject(1);
  }
  touch() {
    this.touched$.next();
  }
  select(value) {
    this.selected$.next(value);
  }
  setDisabled(value) {
    this.disabled$.next(value);
  }
  setName(value) {
    this.name$.next(value);
  }
};
_NzRadioService.\u0275fac = function NzRadioService_Factory(t) {
  return new (t || _NzRadioService)();
};
_NzRadioService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzRadioService,
  factory: _NzRadioService.\u0275fac
});
var NzRadioService = _NzRadioService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRadioService, [{
    type: Injectable
  }], null, null);
})();
var _NzRadioGroupComponent = class _NzRadioGroupComponent {
  constructor(cdr, nzRadioService, directionality) {
    this.cdr = cdr;
    this.nzRadioService = nzRadioService;
    this.directionality = directionality;
    this.value = null;
    this.destroy$ = new Subject();
    this.isNzDisableFirstChange = true;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.nzDisabled = false;
    this.nzButtonStyle = "outline";
    this.nzSize = "default";
    this.nzName = null;
    this.dir = "ltr";
  }
  ngOnInit() {
    this.nzRadioService.selected$.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      if (this.value !== value) {
        this.value = value;
        this.onChange(this.value);
      }
    });
    this.nzRadioService.touched$.pipe(takeUntil(this.destroy$)).subscribe(() => {
      Promise.resolve().then(() => this.onTouched());
    });
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnChanges(changes) {
    const {
      nzDisabled,
      nzName
    } = changes;
    if (nzDisabled) {
      this.nzRadioService.setDisabled(this.nzDisabled);
    }
    if (nzName) {
      this.nzRadioService.setName(this.nzName);
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  writeValue(value) {
    this.value = value;
    this.nzRadioService.select(value);
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || isDisabled;
    this.isNzDisableFirstChange = false;
    this.nzRadioService.setDisabled(this.nzDisabled);
    this.cdr.markForCheck();
  }
};
_NzRadioGroupComponent.\u0275fac = function NzRadioGroupComponent_Factory(t) {
  return new (t || _NzRadioGroupComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzRadioService), \u0275\u0275directiveInject(Directionality, 8));
};
_NzRadioGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzRadioGroupComponent,
  selectors: [["nz-radio-group"]],
  hostAttrs: [1, "ant-radio-group"],
  hostVars: 8,
  hostBindings: function NzRadioGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-radio-group-large", ctx.nzSize === "large")("ant-radio-group-small", ctx.nzSize === "small")("ant-radio-group-solid", ctx.nzButtonStyle === "solid")("ant-radio-group-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzDisabled: "nzDisabled",
    nzButtonStyle: "nzButtonStyle",
    nzSize: "nzSize",
    nzName: "nzName"
  },
  exportAs: ["nzRadioGroup"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzRadioService, {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NzRadioGroupComponent),
    multi: true
  }]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c04,
  decls: 1,
  vars: 0,
  template: function NzRadioGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzRadioGroupComponent = _NzRadioGroupComponent;
__decorate([InputBoolean()], NzRadioGroupComponent.prototype, "nzDisabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRadioGroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-radio-group",
      exportAs: "nzRadioGroup",
      preserveWhitespaces: false,
      template: ` <ng-content></ng-content> `,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [NzRadioService, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NzRadioGroupComponent),
        multi: true
      }],
      host: {
        class: "ant-radio-group",
        "[class.ant-radio-group-large]": `nzSize === 'large'`,
        "[class.ant-radio-group-small]": `nzSize === 'small'`,
        "[class.ant-radio-group-solid]": `nzButtonStyle === 'solid'`,
        "[class.ant-radio-group-rtl]": `dir === 'rtl'`
      },
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzRadioService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzDisabled: [{
      type: Input
    }],
    nzButtonStyle: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzName: [{
      type: Input
    }]
  });
})();
var _NzRadioComponent = class _NzRadioComponent {
  focus() {
    this.focusMonitor.focusVia(this.inputElement, "keyboard");
  }
  blur() {
    this.inputElement.nativeElement.blur();
  }
  constructor(ngZone, elementRef, cdr, focusMonitor, directionality, nzRadioService, nzRadioButtonDirective, nzFormStatusService) {
    this.ngZone = ngZone;
    this.elementRef = elementRef;
    this.cdr = cdr;
    this.focusMonitor = focusMonitor;
    this.directionality = directionality;
    this.nzRadioService = nzRadioService;
    this.nzRadioButtonDirective = nzRadioButtonDirective;
    this.nzFormStatusService = nzFormStatusService;
    this.isNgModel = false;
    this.destroy$ = new Subject();
    this.isNzDisableFirstChange = true;
    this.isChecked = false;
    this.name = null;
    this.isRadioButton = !!this.nzRadioButtonDirective;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.nzValue = null;
    this.nzDisabled = false;
    this.nzAutoFocus = false;
    this.dir = "ltr";
  }
  setDisabledState(disabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || disabled;
    this.isNzDisableFirstChange = false;
    this.cdr.markForCheck();
  }
  writeValue(value) {
    this.isChecked = value;
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.isNgModel = true;
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  ngOnInit() {
    if (this.nzRadioService) {
      this.nzRadioService.name$.pipe(takeUntil(this.destroy$)).subscribe((name) => {
        this.name = name;
        this.cdr.markForCheck();
      });
      this.nzRadioService.disabled$.pipe(takeUntil(this.destroy$)).subscribe((disabled) => {
        this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || disabled;
        this.isNzDisableFirstChange = false;
        this.cdr.markForCheck();
      });
      this.nzRadioService.selected$.pipe(takeUntil(this.destroy$)).subscribe((value) => {
        const isChecked = this.isChecked;
        this.isChecked = this.nzValue === value;
        if (this.isNgModel && isChecked !== this.isChecked && // We're only intereted if `isChecked` has been changed to `false` value to emit `false` to the ascendant form,
        // since we already emit `true` within the `setupClickListener`.
        this.isChecked === false) {
          this.onChange(false);
        }
        this.cdr.markForCheck();
      });
    }
    this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe((focusOrigin) => {
      if (!focusOrigin) {
        Promise.resolve().then(() => this.onTouched());
        if (this.nzRadioService) {
          this.nzRadioService.touch();
        }
      }
    });
    this.directionality.change.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.setupClickListener();
  }
  ngAfterViewInit() {
    if (this.nzAutoFocus) {
      this.focus();
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.focusMonitor.stopMonitoring(this.elementRef);
  }
  setupClickListener() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.elementRef.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        event.stopPropagation();
        event.preventDefault();
        if (this.nzDisabled || this.isChecked) {
          return;
        }
        this.ngZone.run(() => {
          this.focus();
          this.nzRadioService?.select(this.nzValue);
          if (this.isNgModel) {
            this.isChecked = true;
            this.onChange(true);
          }
          this.cdr.markForCheck();
        });
      });
    });
  }
};
_NzRadioComponent.\u0275fac = function NzRadioComponent_Factory(t) {
  return new (t || _NzRadioComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(FocusMonitor), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzRadioService, 8), \u0275\u0275directiveInject(NzRadioButtonDirective, 8), \u0275\u0275directiveInject(NzFormStatusService, 8));
};
_NzRadioComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzRadioComponent,
  selectors: [["", "nz-radio", ""], ["", "nz-radio-button", ""]],
  viewQuery: function NzRadioComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c13, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inputElement = _t.first);
    }
  },
  hostVars: 18,
  hostBindings: function NzRadioComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-radio-wrapper-in-form-item", !!ctx.nzFormStatusService)("ant-radio-wrapper", !ctx.isRadioButton)("ant-radio-button-wrapper", ctx.isRadioButton)("ant-radio-wrapper-checked", ctx.isChecked && !ctx.isRadioButton)("ant-radio-button-wrapper-checked", ctx.isChecked && ctx.isRadioButton)("ant-radio-wrapper-disabled", ctx.nzDisabled && !ctx.isRadioButton)("ant-radio-button-wrapper-disabled", ctx.nzDisabled && ctx.isRadioButton)("ant-radio-wrapper-rtl", !ctx.isRadioButton && ctx.dir === "rtl")("ant-radio-button-wrapper-rtl", ctx.isRadioButton && ctx.dir === "rtl");
    }
  },
  inputs: {
    nzValue: "nzValue",
    nzDisabled: "nzDisabled",
    nzAutoFocus: "nzAutoFocus"
  },
  exportAs: ["nzRadio"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NzRadioComponent),
    multi: true
  }]), \u0275\u0275StandaloneFeature],
  attrs: _c22,
  ngContentSelectors: _c04,
  decls: 6,
  vars: 24,
  consts: [["type", "radio", 3, "disabled", "checked"], ["inputElement", ""]],
  template: function NzRadioComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "span");
      \u0275\u0275element(1, "input", 0, 1)(3, "span");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "span");
      \u0275\u0275projection(5);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-radio", !ctx.isRadioButton)("ant-radio-checked", ctx.isChecked && !ctx.isRadioButton)("ant-radio-disabled", ctx.nzDisabled && !ctx.isRadioButton)("ant-radio-button", ctx.isRadioButton)("ant-radio-button-checked", ctx.isChecked && ctx.isRadioButton)("ant-radio-button-disabled", ctx.nzDisabled && ctx.isRadioButton);
      \u0275\u0275advance(1);
      \u0275\u0275classProp("ant-radio-input", !ctx.isRadioButton)("ant-radio-button-input", ctx.isRadioButton);
      \u0275\u0275property("disabled", ctx.nzDisabled)("checked", ctx.isChecked);
      \u0275\u0275attribute("autofocus", ctx.nzAutoFocus ? "autofocus" : null)("name", ctx.name);
      \u0275\u0275advance(2);
      \u0275\u0275classProp("ant-radio-inner", !ctx.isRadioButton)("ant-radio-button-inner", ctx.isRadioButton);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzRadioComponent = _NzRadioComponent;
__decorate([InputBoolean()], NzRadioComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzRadioComponent.prototype, "nzAutoFocus", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRadioComponent, [{
    type: Component,
    args: [{
      selector: "[nz-radio],[nz-radio-button]",
      exportAs: "nzRadio",
      preserveWhitespaces: false,
      template: `
    <span
      [class.ant-radio]="!isRadioButton"
      [class.ant-radio-checked]="isChecked && !isRadioButton"
      [class.ant-radio-disabled]="nzDisabled && !isRadioButton"
      [class.ant-radio-button]="isRadioButton"
      [class.ant-radio-button-checked]="isChecked && isRadioButton"
      [class.ant-radio-button-disabled]="nzDisabled && isRadioButton"
    >
      <input
        #inputElement
        type="radio"
        [attr.autofocus]="nzAutoFocus ? 'autofocus' : null"
        [class.ant-radio-input]="!isRadioButton"
        [class.ant-radio-button-input]="isRadioButton"
        [disabled]="nzDisabled"
        [checked]="isChecked"
        [attr.name]="name"
      />
      <span [class.ant-radio-inner]="!isRadioButton" [class.ant-radio-button-inner]="isRadioButton"></span>
    </span>
    <span><ng-content></ng-content></span>
  `,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NzRadioComponent),
        multi: true
      }],
      host: {
        "[class.ant-radio-wrapper-in-form-item]": "!!nzFormStatusService",
        "[class.ant-radio-wrapper]": "!isRadioButton",
        "[class.ant-radio-button-wrapper]": "isRadioButton",
        "[class.ant-radio-wrapper-checked]": "isChecked && !isRadioButton",
        "[class.ant-radio-button-wrapper-checked]": "isChecked && isRadioButton",
        "[class.ant-radio-wrapper-disabled]": "nzDisabled && !isRadioButton",
        "[class.ant-radio-button-wrapper-disabled]": "nzDisabled && isRadioButton",
        "[class.ant-radio-wrapper-rtl]": `!isRadioButton && dir === 'rtl'`,
        "[class.ant-radio-button-wrapper-rtl]": `isRadioButton && dir === 'rtl'`
      },
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: FocusMonitor
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzRadioService,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NzRadioService]
    }]
  }, {
    type: NzRadioButtonDirective,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NzRadioButtonDirective]
    }]
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    inputElement: [{
      type: ViewChild,
      args: ["inputElement", {
        static: true
      }]
    }],
    nzValue: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzAutoFocus: [{
      type: Input
    }]
  });
})();
var _NzRadioModule = class _NzRadioModule {
};
_NzRadioModule.\u0275fac = function NzRadioModule_Factory(t) {
  return new (t || _NzRadioModule)();
};
_NzRadioModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzRadioModule
});
_NzRadioModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzRadioModule = _NzRadioModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRadioModule, [{
    type: NgModule,
    args: [{
      imports: [NzRadioComponent, NzRadioButtonDirective, NzRadioGroupComponent],
      exports: [NzRadioComponent, NzRadioButtonDirective, NzRadioGroupComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-tag.mjs
function NzTagComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 1);
    \u0275\u0275listener("click", function NzTagComponent_span_1_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closeTag($event));
    });
    \u0275\u0275elementEnd();
  }
}
var _c05 = ["*"];
var _NzTagComponent = class _NzTagComponent {
  constructor(cdr, renderer, elementRef, directionality) {
    this.cdr = cdr;
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.directionality = directionality;
    this.isPresetColor = false;
    this.nzMode = "default";
    this.nzChecked = false;
    this.nzOnClose = new EventEmitter();
    this.nzCheckedChange = new EventEmitter();
    this.dir = "ltr";
    this.destroy$ = new Subject();
  }
  updateCheckedStatus() {
    if (this.nzMode === "checkable") {
      this.nzChecked = !this.nzChecked;
      this.nzCheckedChange.emit(this.nzChecked);
    }
  }
  closeTag(e) {
    this.nzOnClose.emit(e);
    if (!e.defaultPrevented) {
      this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), this.elementRef.nativeElement);
    }
  }
  clearPresetColor() {
    const hostElement = this.elementRef.nativeElement;
    const regexp = new RegExp(`(ant-tag-(?:${[...presetColors, ...statusColors].join("|")}))`, "g");
    const classname = hostElement.classList.toString();
    const matches = [];
    let match3 = regexp.exec(classname);
    while (match3 !== null) {
      matches.push(match3[1]);
      match3 = regexp.exec(classname);
    }
    hostElement.classList.remove(...matches);
  }
  setPresetColor() {
    const hostElement = this.elementRef.nativeElement;
    this.clearPresetColor();
    if (!this.nzColor) {
      this.isPresetColor = false;
    } else {
      this.isPresetColor = isPresetColor(this.nzColor) || isStatusColor(this.nzColor);
    }
    if (this.isPresetColor) {
      hostElement.classList.add(`ant-tag-${this.nzColor}`);
    }
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnChanges(changes) {
    const {
      nzColor
    } = changes;
    if (nzColor) {
      this.setPresetColor();
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzTagComponent.\u0275fac = function NzTagComponent_Factory(t) {
  return new (t || _NzTagComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzTagComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTagComponent,
  selectors: [["nz-tag"]],
  hostAttrs: [1, "ant-tag"],
  hostVars: 10,
  hostBindings: function NzTagComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzTagComponent_click_HostBindingHandler() {
        return ctx.updateCheckedStatus();
      });
    }
    if (rf & 2) {
      \u0275\u0275styleProp("background-color", ctx.isPresetColor ? "" : ctx.nzColor);
      \u0275\u0275classProp("ant-tag-has-color", ctx.nzColor && !ctx.isPresetColor)("ant-tag-checkable", ctx.nzMode === "checkable")("ant-tag-checkable-checked", ctx.nzChecked)("ant-tag-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzMode: "nzMode",
    nzColor: "nzColor",
    nzChecked: "nzChecked"
  },
  outputs: {
    nzOnClose: "nzOnClose",
    nzCheckedChange: "nzCheckedChange"
  },
  exportAs: ["nzTag"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c05,
  decls: 2,
  vars: 1,
  consts: [["nz-icon", "", "nzType", "close", "class", "ant-tag-close-icon", "tabindex", "-1", 3, "click", 4, "ngIf"], ["nz-icon", "", "nzType", "close", "tabindex", "-1", 1, "ant-tag-close-icon", 3, "click"]],
  template: function NzTagComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
      \u0275\u0275template(1, NzTagComponent_span_1_Template, 1, 0, "span", 0);
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzMode === "closeable");
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NzTagComponent = _NzTagComponent;
__decorate([InputBoolean()], NzTagComponent.prototype, "nzChecked", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTagComponent, [{
    type: Component,
    args: [{
      selector: "nz-tag",
      exportAs: "nzTag",
      preserveWhitespaces: false,
      template: `
    <ng-content></ng-content>
    <span
      nz-icon
      nzType="close"
      class="ant-tag-close-icon"
      *ngIf="nzMode === 'closeable'"
      tabindex="-1"
      (click)="closeTag($event)"
    ></span>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      host: {
        class: "ant-tag",
        "[style.background-color]": `isPresetColor ? '' : nzColor`,
        "[class.ant-tag-has-color]": `nzColor && !isPresetColor`,
        "[class.ant-tag-checkable]": `nzMode === 'checkable'`,
        "[class.ant-tag-checkable-checked]": `nzChecked`,
        "[class.ant-tag-rtl]": `dir === 'rtl'`,
        "(click)": "updateCheckedStatus()"
      },
      imports: [NzIconModule, NgIf],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzMode: [{
      type: Input
    }],
    nzColor: [{
      type: Input
    }],
    nzChecked: [{
      type: Input
    }],
    nzOnClose: [{
      type: Output
    }],
    nzCheckedChange: [{
      type: Output
    }]
  });
})();
var _NzTagModule = class _NzTagModule {
};
_NzTagModule.\u0275fac = function NzTagModule_Factory(t) {
  return new (t || _NzTagModule)();
};
_NzTagModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzTagModule
});
_NzTagModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzTagComponent]
});
var NzTagModule = _NzTagModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTagModule, [{
    type: NgModule,
    args: [{
      imports: [NzTagComponent],
      exports: [NzTagComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-core-overlay.mjs
var POSITION_MAP = {
  top: new ConnectionPositionPair({
    originX: "center",
    originY: "top"
  }, {
    overlayX: "center",
    overlayY: "bottom"
  }),
  topCenter: new ConnectionPositionPair({
    originX: "center",
    originY: "top"
  }, {
    overlayX: "center",
    overlayY: "bottom"
  }),
  topLeft: new ConnectionPositionPair({
    originX: "start",
    originY: "top"
  }, {
    overlayX: "start",
    overlayY: "bottom"
  }),
  topRight: new ConnectionPositionPair({
    originX: "end",
    originY: "top"
  }, {
    overlayX: "end",
    overlayY: "bottom"
  }),
  right: new ConnectionPositionPair({
    originX: "end",
    originY: "center"
  }, {
    overlayX: "start",
    overlayY: "center"
  }),
  rightTop: new ConnectionPositionPair({
    originX: "end",
    originY: "top"
  }, {
    overlayX: "start",
    overlayY: "top"
  }),
  rightBottom: new ConnectionPositionPair({
    originX: "end",
    originY: "bottom"
  }, {
    overlayX: "start",
    overlayY: "bottom"
  }),
  bottom: new ConnectionPositionPair({
    originX: "center",
    originY: "bottom"
  }, {
    overlayX: "center",
    overlayY: "top"
  }),
  bottomCenter: new ConnectionPositionPair({
    originX: "center",
    originY: "bottom"
  }, {
    overlayX: "center",
    overlayY: "top"
  }),
  bottomLeft: new ConnectionPositionPair({
    originX: "start",
    originY: "bottom"
  }, {
    overlayX: "start",
    overlayY: "top"
  }),
  bottomRight: new ConnectionPositionPair({
    originX: "end",
    originY: "bottom"
  }, {
    overlayX: "end",
    overlayY: "top"
  }),
  left: new ConnectionPositionPair({
    originX: "start",
    originY: "center"
  }, {
    overlayX: "end",
    overlayY: "center"
  }),
  leftTop: new ConnectionPositionPair({
    originX: "start",
    originY: "top"
  }, {
    overlayX: "end",
    overlayY: "top"
  }),
  leftBottom: new ConnectionPositionPair({
    originX: "start",
    originY: "bottom"
  }, {
    overlayX: "end",
    overlayY: "bottom"
  })
};
var DEFAULT_TOOLTIP_POSITIONS = [POSITION_MAP.top, POSITION_MAP.right, POSITION_MAP.bottom, POSITION_MAP.left];
var DEFAULT_CASCADER_POSITIONS = [POSITION_MAP.bottomLeft, POSITION_MAP.bottomRight, POSITION_MAP.topLeft, POSITION_MAP.topRight, POSITION_MAP.topCenter, POSITION_MAP.bottomCenter];
var DEFAULT_MENTION_TOP_POSITIONS = [new ConnectionPositionPair({
  originX: "start",
  originY: "bottom"
}, {
  overlayX: "start",
  overlayY: "bottom"
}), new ConnectionPositionPair({
  originX: "start",
  originY: "bottom"
}, {
  overlayX: "end",
  overlayY: "bottom"
})];
var DEFAULT_MENTION_BOTTOM_POSITIONS = [POSITION_MAP.bottomLeft, new ConnectionPositionPair({
  originX: "start",
  originY: "bottom"
}, {
  overlayX: "end",
  overlayY: "top"
})];
function getPlacementName(position) {
  for (const placement in POSITION_MAP) {
    if (position.connectionPair.originX === POSITION_MAP[placement].originX && position.connectionPair.originY === POSITION_MAP[placement].originY && position.connectionPair.overlayX === POSITION_MAP[placement].overlayX && position.connectionPair.overlayY === POSITION_MAP[placement].overlayY) {
      return placement;
    }
  }
  return void 0;
}
var DATE_PICKER_POSITION_MAP = {
  bottomLeft: new ConnectionPositionPair({
    originX: "start",
    originY: "bottom"
  }, {
    overlayX: "start",
    overlayY: "top"
  }, void 0, 2),
  topLeft: new ConnectionPositionPair({
    originX: "start",
    originY: "top"
  }, {
    overlayX: "start",
    overlayY: "bottom"
  }, void 0, -2),
  bottomRight: new ConnectionPositionPair({
    originX: "end",
    originY: "bottom"
  }, {
    overlayX: "end",
    overlayY: "top"
  }, void 0, 2),
  topRight: new ConnectionPositionPair({
    originX: "end",
    originY: "top"
  }, {
    overlayX: "end",
    overlayY: "bottom"
  }, void 0, -2)
};
var DEFAULT_DATE_PICKER_POSITIONS = [DATE_PICKER_POSITION_MAP.bottomLeft, DATE_PICKER_POSITION_MAP.topLeft, DATE_PICKER_POSITION_MAP.bottomRight, DATE_PICKER_POSITION_MAP.topRight];
var _NzConnectedOverlayDirective = class _NzConnectedOverlayDirective {
  constructor(cdkConnectedOverlay, nzDestroyService) {
    this.cdkConnectedOverlay = cdkConnectedOverlay;
    this.nzDestroyService = nzDestroyService;
    this.nzArrowPointAtCenter = false;
    this.cdkConnectedOverlay.backdropClass = "nz-overlay-transparent-backdrop";
    this.cdkConnectedOverlay.positionChange.pipe(takeUntil(this.nzDestroyService)).subscribe((position) => {
      if (this.nzArrowPointAtCenter) {
        this.updateArrowPosition(position);
      }
    });
  }
  updateArrowPosition(position) {
    const originRect = this.getOriginRect();
    const placement = getPlacementName(position);
    let offsetX = 0;
    let offsetY = 0;
    if (placement === "topLeft" || placement === "bottomLeft") {
      offsetX = originRect.width / 2 - 14;
    } else if (placement === "topRight" || placement === "bottomRight") {
      offsetX = -(originRect.width / 2 - 14);
    } else if (placement === "leftTop" || placement === "rightTop") {
      offsetY = originRect.height / 2 - 10;
    } else if (placement === "leftBottom" || placement === "rightBottom") {
      offsetY = -(originRect.height / 2 - 10);
    }
    if (this.cdkConnectedOverlay.offsetX !== offsetX || this.cdkConnectedOverlay.offsetY !== offsetY) {
      this.cdkConnectedOverlay.offsetY = offsetY;
      this.cdkConnectedOverlay.offsetX = offsetX;
      this.cdkConnectedOverlay.overlayRef.updatePosition();
    }
  }
  getFlexibleConnectedPositionStrategyOrigin() {
    if (this.cdkConnectedOverlay.origin instanceof CdkOverlayOrigin) {
      return this.cdkConnectedOverlay.origin.elementRef;
    } else {
      return this.cdkConnectedOverlay.origin;
    }
  }
  getOriginRect() {
    const origin = this.getFlexibleConnectedPositionStrategyOrigin();
    if (origin instanceof ElementRef) {
      return origin.nativeElement.getBoundingClientRect();
    }
    if (origin instanceof Element) {
      return origin.getBoundingClientRect();
    }
    const width = origin.width || 0;
    const height = origin.height || 0;
    return {
      top: origin.y,
      bottom: origin.y + height,
      left: origin.x,
      right: origin.x + width,
      height,
      width
    };
  }
};
_NzConnectedOverlayDirective.\u0275fac = function NzConnectedOverlayDirective_Factory(t) {
  return new (t || _NzConnectedOverlayDirective)(\u0275\u0275directiveInject(CdkConnectedOverlay), \u0275\u0275directiveInject(NzDestroyService));
};
_NzConnectedOverlayDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzConnectedOverlayDirective,
  selectors: [["", "cdkConnectedOverlay", "", "nzConnectedOverlay", ""]],
  inputs: {
    nzArrowPointAtCenter: "nzArrowPointAtCenter"
  },
  exportAs: ["nzConnectedOverlay"],
  features: [\u0275\u0275ProvidersFeature([NzDestroyService])]
});
var NzConnectedOverlayDirective = _NzConnectedOverlayDirective;
__decorate([InputBoolean()], NzConnectedOverlayDirective.prototype, "nzArrowPointAtCenter", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzConnectedOverlayDirective, [{
    type: Directive,
    args: [{
      selector: "[cdkConnectedOverlay][nzConnectedOverlay]",
      exportAs: "nzConnectedOverlay",
      providers: [NzDestroyService]
    }]
  }], () => [{
    type: CdkConnectedOverlay
  }, {
    type: NzDestroyService
  }], {
    nzArrowPointAtCenter: [{
      type: Input
    }]
  });
})();
var _NzOverlayModule = class _NzOverlayModule {
};
_NzOverlayModule.\u0275fac = function NzOverlayModule_Factory(t) {
  return new (t || _NzOverlayModule)();
};
_NzOverlayModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzOverlayModule
});
_NzOverlayModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzOverlayModule = _NzOverlayModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzOverlayModule, [{
    type: NgModule,
    args: [{
      declarations: [NzConnectedOverlayDirective],
      exports: [NzConnectedOverlayDirective]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-tooltip.mjs
var _c06 = ["overlay"];
function NzToolTipComponent_ng_template_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r2.nzTitle);
  }
}
function NzToolTipComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "div", 4);
    \u0275\u0275element(3, "span", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 6);
    \u0275\u0275template(5, NzToolTipComponent_ng_template_0_ng_container_5_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-tooltip-rtl", ctx_r0.dir === "rtl");
    \u0275\u0275property("ngClass", ctx_r0._classMap)("ngStyle", ctx_r0.nzOverlayStyle)("@.disabled", !!(ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation))("nzNoAnimation", ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation)("@zoomBigMotion", "active");
    \u0275\u0275advance(3);
    \u0275\u0275property("ngStyle", ctx_r0._contentStyleMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngStyle", ctx_r0._contentStyleMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.nzTitle)("nzStringTemplateOutletContext", ctx_r0.nzTitleContext);
  }
}
var _NzTooltipBaseDirective = class _NzTooltipBaseDirective {
  /**
   * This true title that would be used in other parts on this component.
   */
  get _title() {
    return this.title || this.directiveTitle || null;
  }
  get _content() {
    return this.content || this.directiveContent || null;
  }
  get _trigger() {
    return typeof this.trigger !== "undefined" ? this.trigger : "hover";
  }
  get _placement() {
    const p = this.placement;
    return Array.isArray(p) && p.length > 0 ? p : typeof p === "string" && p ? [p] : ["top"];
  }
  get _visible() {
    return (typeof this.visible !== "undefined" ? this.visible : this.internalVisible) || false;
  }
  get _mouseEnterDelay() {
    return this.mouseEnterDelay || 0.15;
  }
  get _mouseLeaveDelay() {
    return this.mouseLeaveDelay || 0.1;
  }
  get _overlayClassName() {
    return this.overlayClassName || null;
  }
  get _overlayStyle() {
    return this.overlayStyle || null;
  }
  getProxyPropertyMap() {
    return {
      noAnimation: ["noAnimation", () => !!this.noAnimation]
    };
  }
  constructor(elementRef, hostView, renderer, noAnimation, nzConfigService) {
    this.elementRef = elementRef;
    this.hostView = hostView;
    this.renderer = renderer;
    this.noAnimation = noAnimation;
    this.nzConfigService = nzConfigService;
    this.visibleChange = new EventEmitter();
    this.internalVisible = false;
    this.destroy$ = new Subject();
    this.triggerDisposables = [];
  }
  ngOnChanges(changes) {
    const {
      trigger: trigger2
    } = changes;
    if (trigger2 && !trigger2.isFirstChange()) {
      this.registerTriggers();
    }
    if (this.component) {
      this.updatePropertiesByChanges(changes);
    }
  }
  ngAfterViewInit() {
    this.createComponent();
    this.registerTriggers();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.clearTogglingTimer();
    this.removeTriggerListeners();
  }
  show() {
    this.component?.show();
  }
  hide() {
    this.component?.hide();
  }
  /**
   * Force the component to update its position.
   */
  updatePosition() {
    if (this.component) {
      this.component.updatePosition();
    }
  }
  /**
   * Create a dynamic tooltip component. This method can be override.
   */
  createComponent() {
    const componentRef = this.componentRef;
    this.component = componentRef.instance;
    this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), componentRef.location.nativeElement);
    this.component.setOverlayOrigin(this.origin || this.elementRef);
    this.initProperties();
    const ngVisibleChange$ = this.component.nzVisibleChange.pipe(distinctUntilChanged());
    ngVisibleChange$.pipe(takeUntil(this.destroy$)).subscribe((visible) => {
      this.internalVisible = visible;
      this.visibleChange.emit(visible);
    });
    ngVisibleChange$.pipe(filter((visible) => visible), delay(0, asapScheduler), filter(() => Boolean(this.component?.overlay?.overlayRef)), takeUntil(this.destroy$)).subscribe(() => {
      this.component?.updatePosition();
    });
  }
  registerTriggers() {
    const el = this.elementRef.nativeElement;
    const trigger2 = this.trigger;
    this.removeTriggerListeners();
    if (trigger2 === "hover") {
      let overlayElement;
      this.triggerDisposables.push(this.renderer.listen(el, "mouseenter", () => {
        this.delayEnterLeave(true, true, this._mouseEnterDelay);
      }));
      this.triggerDisposables.push(this.renderer.listen(el, "mouseleave", () => {
        this.delayEnterLeave(true, false, this._mouseLeaveDelay);
        if (this.component?.overlay.overlayRef && !overlayElement) {
          overlayElement = this.component.overlay.overlayRef.overlayElement;
          this.triggerDisposables.push(this.renderer.listen(overlayElement, "mouseenter", () => {
            this.delayEnterLeave(false, true, this._mouseEnterDelay);
          }));
          this.triggerDisposables.push(this.renderer.listen(overlayElement, "mouseleave", () => {
            this.delayEnterLeave(false, false, this._mouseLeaveDelay);
          }));
        }
      }));
    } else if (trigger2 === "focus") {
      this.triggerDisposables.push(this.renderer.listen(el, "focusin", () => this.show()));
      this.triggerDisposables.push(this.renderer.listen(el, "focusout", () => this.hide()));
    } else if (trigger2 === "click") {
      this.triggerDisposables.push(this.renderer.listen(el, "click", (e) => {
        e.preventDefault();
        this.show();
      }));
    }
  }
  updatePropertiesByChanges(changes) {
    this.updatePropertiesByKeys(Object.keys(changes));
  }
  updatePropertiesByKeys(keys) {
    const mappingProperties = __spreadValues({
      // common mappings
      title: ["nzTitle", () => this._title],
      directiveTitle: ["nzTitle", () => this._title],
      content: ["nzContent", () => this._content],
      directiveContent: ["nzContent", () => this._content],
      trigger: ["nzTrigger", () => this._trigger],
      placement: ["nzPlacement", () => this._placement],
      visible: ["nzVisible", () => this._visible],
      mouseEnterDelay: ["nzMouseEnterDelay", () => this._mouseEnterDelay],
      mouseLeaveDelay: ["nzMouseLeaveDelay", () => this._mouseLeaveDelay],
      overlayClassName: ["nzOverlayClassName", () => this._overlayClassName],
      overlayStyle: ["nzOverlayStyle", () => this._overlayStyle],
      arrowPointAtCenter: ["nzArrowPointAtCenter", () => this.arrowPointAtCenter],
      cdkConnectedOverlayPush: ["cdkConnectedOverlayPush", () => this.cdkConnectedOverlayPush]
    }, this.getProxyPropertyMap());
    (keys || Object.keys(mappingProperties).filter((key) => !key.startsWith("directive"))).forEach((property) => {
      if (mappingProperties[property]) {
        const [name, valueFn] = mappingProperties[property];
        this.updateComponentValue(name, valueFn());
      }
    });
    this.component?.updateByDirective();
  }
  initProperties() {
    this.updatePropertiesByKeys();
  }
  updateComponentValue(key, value) {
    if (typeof value !== "undefined") {
      this.component[key] = value;
    }
  }
  delayEnterLeave(isOrigin, isEnter, delay2 = -1) {
    if (this.delayTimer) {
      this.clearTogglingTimer();
    } else if (delay2 > 0) {
      this.delayTimer = setTimeout(() => {
        this.delayTimer = void 0;
        isEnter ? this.show() : this.hide();
      }, delay2 * 1e3);
    } else {
      isEnter && isOrigin ? this.show() : this.hide();
    }
  }
  removeTriggerListeners() {
    this.triggerDisposables.forEach((dispose) => dispose());
    this.triggerDisposables.length = 0;
  }
  clearTogglingTimer() {
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = void 0;
    }
  }
};
_NzTooltipBaseDirective.\u0275fac = function NzTooltipBaseDirective_Factory(t) {
  return new (t || _NzTooltipBaseDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzNoAnimationDirective), \u0275\u0275directiveInject(NzConfigService));
};
_NzTooltipBaseDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTooltipBaseDirective,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzTooltipBaseDirective = _NzTooltipBaseDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTooltipBaseDirective, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: Renderer2
  }, {
    type: NzNoAnimationDirective
  }, {
    type: NzConfigService
  }], null);
})();
var _NzTooltipBaseComponent = class _NzTooltipBaseComponent {
  set nzVisible(value) {
    const visible = toBoolean(value);
    if (this._visible !== visible) {
      this._visible = visible;
      this.nzVisibleChange.next(visible);
    }
  }
  get nzVisible() {
    return this._visible;
  }
  set nzTrigger(value) {
    this._trigger = value;
  }
  get nzTrigger() {
    return this._trigger;
  }
  set nzPlacement(value) {
    const preferredPosition = value.map((placement) => POSITION_MAP[placement]);
    this._positions = [...preferredPosition, ...DEFAULT_TOOLTIP_POSITIONS];
  }
  constructor(cdr, directionality, noAnimation) {
    this.cdr = cdr;
    this.directionality = directionality;
    this.noAnimation = noAnimation;
    this.nzTitle = null;
    this.nzContent = null;
    this.nzArrowPointAtCenter = false;
    this.nzOverlayStyle = {};
    this.nzBackdrop = false;
    this.cdkConnectedOverlayPush = true;
    this.nzVisibleChange = new Subject();
    this._visible = false;
    this._trigger = "hover";
    this.preferredPlacement = "top";
    this.dir = "ltr";
    this._classMap = {};
    this._prefix = "ant-tooltip";
    this._positions = [...DEFAULT_TOOLTIP_POSITIONS];
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnDestroy() {
    this.nzVisibleChange.complete();
    this.destroy$.next();
    this.destroy$.complete();
  }
  show() {
    if (this.nzVisible) {
      return;
    }
    if (!this.isEmpty()) {
      this.nzVisible = true;
      this.nzVisibleChange.next(true);
      this.cdr.detectChanges();
    }
    if (this.origin && this.overlay && this.overlay.overlayRef && this.overlay.overlayRef.getDirection() === "rtl") {
      this.overlay.overlayRef.setDirection("ltr");
    }
  }
  hide() {
    if (!this.nzVisible) {
      return;
    }
    this.nzVisible = false;
    this.nzVisibleChange.next(false);
    this.cdr.detectChanges();
  }
  updateByDirective() {
    this.updateStyles();
    this.cdr.detectChanges();
    Promise.resolve().then(() => {
      this.updatePosition();
      this.updateVisibilityByTitle();
    });
  }
  /**
   * Force the component to update its position.
   */
  updatePosition() {
    if (this.origin && this.overlay && this.overlay.overlayRef) {
      this.overlay.overlayRef.updatePosition();
    }
  }
  onPositionChange(position) {
    this.preferredPlacement = getPlacementName(position);
    this.updateStyles();
    this.cdr.detectChanges();
  }
  setOverlayOrigin(origin) {
    this.origin = origin;
    this.cdr.markForCheck();
  }
  onClickOutside(event) {
    if (!this.origin.nativeElement.contains(event.target) && this.nzTrigger !== null) {
      this.hide();
    }
  }
  /**
   * Hide the component while the content is empty.
   */
  updateVisibilityByTitle() {
    if (this.isEmpty()) {
      this.hide();
    }
  }
  updateStyles() {
    this._classMap = {
      [this.nzOverlayClassName]: true,
      [`${this._prefix}-placement-${this.preferredPlacement}`]: true
    };
  }
};
_NzTooltipBaseComponent.\u0275fac = function NzTooltipBaseComponent_Factory(t) {
  return new (t || _NzTooltipBaseComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective));
};
_NzTooltipBaseComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTooltipBaseComponent,
  viewQuery: function NzTooltipBaseComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c06, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.overlay = _t.first);
    }
  }
});
var NzTooltipBaseComponent = _NzTooltipBaseComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTooltipBaseComponent, [{
    type: Directive
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective
  }], {
    overlay: [{
      type: ViewChild,
      args: ["overlay", {
        static: false
      }]
    }]
  });
})();
function isTooltipEmpty(value) {
  return value instanceof TemplateRef ? false : value === "" || !isNotNil(value);
}
var _NzTooltipDirective = class _NzTooltipDirective extends NzTooltipBaseDirective {
  constructor(elementRef, hostView, renderer, noAnimation) {
    super(elementRef, hostView, renderer, noAnimation);
    this.titleContext = null;
    this.trigger = "hover";
    this.placement = "top";
    this.cdkConnectedOverlayPush = true;
    this.visibleChange = new EventEmitter();
    this.componentRef = this.hostView.createComponent(NzToolTipComponent);
  }
  getProxyPropertyMap() {
    return __spreadProps(__spreadValues({}, super.getProxyPropertyMap()), {
      nzTooltipColor: ["nzColor", () => this.nzTooltipColor],
      titleContext: ["nzTitleContext", () => this.titleContext]
    });
  }
};
_NzTooltipDirective.\u0275fac = function NzTooltipDirective_Factory(t) {
  return new (t || _NzTooltipDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzTooltipDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTooltipDirective,
  selectors: [["", "nz-tooltip", ""]],
  hostVars: 2,
  hostBindings: function NzTooltipDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-tooltip-open", ctx.visible);
    }
  },
  inputs: {
    title: ["nzTooltipTitle", "title"],
    titleContext: ["nzTooltipTitleContext", "titleContext"],
    directiveTitle: ["nz-tooltip", "directiveTitle"],
    trigger: ["nzTooltipTrigger", "trigger"],
    placement: ["nzTooltipPlacement", "placement"],
    origin: ["nzTooltipOrigin", "origin"],
    visible: ["nzTooltipVisible", "visible"],
    mouseEnterDelay: ["nzTooltipMouseEnterDelay", "mouseEnterDelay"],
    mouseLeaveDelay: ["nzTooltipMouseLeaveDelay", "mouseLeaveDelay"],
    overlayClassName: ["nzTooltipOverlayClassName", "overlayClassName"],
    overlayStyle: ["nzTooltipOverlayStyle", "overlayStyle"],
    arrowPointAtCenter: ["nzTooltipArrowPointAtCenter", "arrowPointAtCenter"],
    cdkConnectedOverlayPush: "cdkConnectedOverlayPush",
    nzTooltipColor: "nzTooltipColor"
  },
  outputs: {
    visibleChange: "nzTooltipVisibleChange"
  },
  exportAs: ["nzTooltip"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NzTooltipDirective = _NzTooltipDirective;
__decorate([InputBoolean()], NzTooltipDirective.prototype, "arrowPointAtCenter", void 0);
__decorate([InputBoolean()], NzTooltipDirective.prototype, "cdkConnectedOverlayPush", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-tooltip]",
      exportAs: "nzTooltip",
      host: {
        "[class.ant-tooltip-open]": "visible"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: Renderer2
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    title: [{
      type: Input,
      args: ["nzTooltipTitle"]
    }],
    titleContext: [{
      type: Input,
      args: ["nzTooltipTitleContext"]
    }],
    directiveTitle: [{
      type: Input,
      args: ["nz-tooltip"]
    }],
    trigger: [{
      type: Input,
      args: ["nzTooltipTrigger"]
    }],
    placement: [{
      type: Input,
      args: ["nzTooltipPlacement"]
    }],
    origin: [{
      type: Input,
      args: ["nzTooltipOrigin"]
    }],
    visible: [{
      type: Input,
      args: ["nzTooltipVisible"]
    }],
    mouseEnterDelay: [{
      type: Input,
      args: ["nzTooltipMouseEnterDelay"]
    }],
    mouseLeaveDelay: [{
      type: Input,
      args: ["nzTooltipMouseLeaveDelay"]
    }],
    overlayClassName: [{
      type: Input,
      args: ["nzTooltipOverlayClassName"]
    }],
    overlayStyle: [{
      type: Input,
      args: ["nzTooltipOverlayStyle"]
    }],
    arrowPointAtCenter: [{
      type: Input,
      args: ["nzTooltipArrowPointAtCenter"]
    }],
    cdkConnectedOverlayPush: [{
      type: Input
    }],
    nzTooltipColor: [{
      type: Input
    }],
    visibleChange: [{
      type: Output,
      args: ["nzTooltipVisibleChange"]
    }]
  });
})();
var _NzToolTipComponent = class _NzToolTipComponent extends NzTooltipBaseComponent {
  constructor(cdr, directionality, noAnimation) {
    super(cdr, directionality, noAnimation);
    this.nzTitle = null;
    this.nzTitleContext = null;
    this._contentStyleMap = {};
  }
  isEmpty() {
    return isTooltipEmpty(this.nzTitle);
  }
  updateStyles() {
    const isColorPreset = this.nzColor && isPresetColor(this.nzColor);
    this._classMap = {
      [this.nzOverlayClassName]: true,
      [`${this._prefix}-placement-${this.preferredPlacement}`]: true,
      [`${this._prefix}-${this.nzColor}`]: isColorPreset
    };
    this._contentStyleMap = {
      backgroundColor: !!this.nzColor && !isColorPreset ? this.nzColor : null,
      "--color": this.nzColor
    };
  }
};
_NzToolTipComponent.\u0275fac = function NzToolTipComponent_Factory(t) {
  return new (t || _NzToolTipComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzToolTipComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzToolTipComponent,
  selectors: [["nz-tooltip"]],
  exportAs: ["nzTooltipComponent"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 5,
  consts: [["cdkConnectedOverlay", "", "nzConnectedOverlay", "", 3, "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayPush", "nzArrowPointAtCenter", "overlayOutsideClick", "detach", "positionChange"], ["overlay", "cdkConnectedOverlay"], [1, "ant-tooltip", 3, "ngClass", "ngStyle", "nzNoAnimation"], [1, "ant-tooltip-content"], [1, "ant-tooltip-arrow"], [1, "ant-tooltip-arrow-content", 3, "ngStyle"], [1, "ant-tooltip-inner", 3, "ngStyle"], [4, "nzStringTemplateOutlet", "nzStringTemplateOutletContext"]],
  template: function NzToolTipComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzToolTipComponent_ng_template_0_Template, 6, 11, "ng-template", 0, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275listener("overlayOutsideClick", function NzToolTipComponent_Template_ng_template_overlayOutsideClick_0_listener($event) {
        return ctx.onClickOutside($event);
      })("detach", function NzToolTipComponent_Template_ng_template_detach_0_listener() {
        return ctx.hide();
      })("positionChange", function NzToolTipComponent_Template_ng_template_positionChange_0_listener($event) {
        return ctx.onPositionChange($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275property("cdkConnectedOverlayOrigin", ctx.origin)("cdkConnectedOverlayOpen", ctx._visible)("cdkConnectedOverlayPositions", ctx._positions)("cdkConnectedOverlayPush", ctx.cdkConnectedOverlayPush)("nzArrowPointAtCenter", ctx.nzArrowPointAtCenter);
    }
  },
  dependencies: [OverlayModule, CdkConnectedOverlay, NgClass, NgStyle, NzNoAnimationDirective, NzOutletModule, NzStringTemplateOutletDirective, NzOverlayModule, NzConnectedOverlayDirective],
  encapsulation: 2,
  data: {
    animation: [zoomBigMotion]
  },
  changeDetection: 0
});
var NzToolTipComponent = _NzToolTipComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzToolTipComponent, [{
    type: Component,
    args: [{
      selector: "nz-tooltip",
      exportAs: "nzTooltipComponent",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      animations: [zoomBigMotion],
      template: `
    <ng-template
      #overlay="cdkConnectedOverlay"
      cdkConnectedOverlay
      nzConnectedOverlay
      [cdkConnectedOverlayOrigin]="origin"
      [cdkConnectedOverlayOpen]="_visible"
      [cdkConnectedOverlayPositions]="_positions"
      [cdkConnectedOverlayPush]="cdkConnectedOverlayPush"
      [nzArrowPointAtCenter]="nzArrowPointAtCenter"
      (overlayOutsideClick)="onClickOutside($event)"
      (detach)="hide()"
      (positionChange)="onPositionChange($event)"
    >
      <div
        class="ant-tooltip"
        [class.ant-tooltip-rtl]="dir === 'rtl'"
        [ngClass]="_classMap"
        [ngStyle]="nzOverlayStyle"
        [@.disabled]="!!noAnimation?.nzNoAnimation"
        [nzNoAnimation]="noAnimation?.nzNoAnimation"
        [@zoomBigMotion]="'active'"
      >
        <div class="ant-tooltip-content">
          <div class="ant-tooltip-arrow">
            <span class="ant-tooltip-arrow-content" [ngStyle]="_contentStyleMap"></span>
          </div>
          <div class="ant-tooltip-inner" [ngStyle]="_contentStyleMap">
            <ng-container *nzStringTemplateOutlet="nzTitle; context: nzTitleContext">{{ nzTitle }}</ng-container>
          </div>
        </div>
      </div>
    </ng-template>
  `,
      preserveWhitespaces: false,
      imports: [OverlayModule, NgClass, NgStyle, NzNoAnimationDirective, NzOutletModule, NzOverlayModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], null);
})();
var _NzToolTipModule = class _NzToolTipModule {
};
_NzToolTipModule.\u0275fac = function NzToolTipModule_Factory(t) {
  return new (t || _NzToolTipModule)();
};
_NzToolTipModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzToolTipModule
});
_NzToolTipModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzToolTipComponent]
});
var NzToolTipModule = _NzToolTipModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzToolTipModule, [{
    type: NgModule,
    args: [{
      imports: [NzToolTipComponent, NzTooltipDirective],
      exports: [NzToolTipComponent, NzTooltipDirective]
    }]
  }], null, null);
})();

// node_modules/@delon/util/fesm2022/format.mjs
function formatMask(value, option) {
  if (!value) {
    return "";
  }
  const opt = __spreadValues({}, typeof option === "string" ? {
    mask: option
  } : option);
  const tokens = __spreadValues({
    "0": {
      pattern: /\d/,
      default: "0"
    },
    "9": {
      pattern: /\d/
    },
    "#": {
      pattern: /[a-zA-Z0-9]/
    },
    U: {
      pattern: /[a-zA-Z]/,
      transform: (char) => char.toLocaleUpperCase()
    },
    L: {
      pattern: /[a-zA-Z]/,
      transform: (char) => char.toLocaleLowerCase()
    },
    "*": {
      pattern: /.*/,
      transform: (_) => `*`
    }
  }, opt.tokens);
  const splitValue = value.split("");
  return opt.mask.split("").reduce((res, cur) => {
    const token = tokens[cur];
    if (!token) {
      res.push(cur);
      return res;
    }
    const value2 = splitValue.shift() ?? "";
    if (!token.pattern.test(value2)) {
      if (token.default)
        res.push(token.default);
      return res;
    }
    if (typeof token.transform === "function") {
      res.push(token.transform(value2));
    } else {
      res.push(value2);
    }
    return res;
  }, []).join("");
}
var REGEX_STR = {
  num: `(([-+]?\\d+\\.\\d+)|([-+]?\\d+)|([-+]?\\.\\d+))(?:[eE]([-+]?\\d+))?`,
  idCard: `(^\\d{15}$)|(^\\d{17}(?:[0-9]|X)$)`,
  mobile: `^(0|\\+?86|17951)?1[0-9]{10}$`,
  url: `(((^https?:(?://)?)(?:[-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9.-]+(?::\\d+)?|(?:www.|[-;:&=\\+\\$,\\w]+@)[A-Za-z0-9.-]+)((?:/[\\+~%\\/.\\w-_]*)?\\??(?:[-\\+=&;%@.\\w_]*)#?(?:[\\w]*))?)`,
  ip: `(?:^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$)|(?:^(?:(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)`,
  color: `(?:#|0x)(?:[a-f0-9]{3}|[a-f0-9]{6})\\b|(?:rgb|hsl)a?\\([^\\)]*\\)`,
  chinese: `[\u4E00-\u9FA5]+`
};
function genRegex(str, flags) {
  return new RegExp(`^${str}$`, flags);
}
var REGEX = {
  num: genRegex(REGEX_STR.num),
  idCard: genRegex(REGEX_STR.idCard, "i"),
  mobile: genRegex(REGEX_STR.mobile),
  url: genRegex(REGEX_STR.url),
  ip: genRegex(REGEX_STR.ip),
  color: genRegex(REGEX_STR.color),
  chinese: genRegex(REGEX_STR.chinese)
};
var CurrencyMega_Powers = [{
  unit: "Q",
  value: Math.pow(10, 15)
}, {
  unit: "T",
  value: Math.pow(10, 12)
}, {
  unit: "B",
  value: Math.pow(10, 9)
}, {
  unit: "M",
  value: Math.pow(10, 6)
}, {
  unit: "K",
  value: 1e3
}];
var _CurrencyService = class _CurrencyService {
  constructor(cog, locale3, _defaultCurrencyCode = "USD") {
    this.locale = locale3;
    this.currencyPipe = new CurrencyPipe(locale3, _defaultCurrencyCode);
    this.c = cog.merge("utilCurrency", {
      startingUnit: "yuan",
      megaUnit: {
        Q: "\u4EAC",
        T: "\u5146",
        B: "\u4EBF",
        M: "\u4E07",
        K: "\u5343"
      },
      precision: 2,
      ingoreZeroPrecision: true
    });
  }
  /**
   * Format a number with commas as thousands separators
   *
   * 格式化货币，用逗号将数字格式化为千位分隔符
   * ```ts
   * 10000 => `10,000`
   * 10000.567 => `10,000.57`
   * ```
   */
  format(value, options) {
    options = __spreadValues({
      startingUnit: this.c.startingUnit,
      precision: this.c.precision,
      ingoreZeroPrecision: this.c.ingoreZeroPrecision,
      ngCurrency: this.c.ngCurrency
    }, options);
    let truthValue = Number(value);
    if (value == null || isNaN(truthValue)) {
      return "";
    }
    if (options.startingUnit === "cent") {
      truthValue = truthValue / 100;
    }
    if (options.ngCurrency != null) {
      const cur = options.ngCurrency;
      return this.currencyPipe.transform(truthValue, cur.currencyCode, cur.display, cur.digitsInfo, cur.locale || this.locale);
    }
    const res = formatNumber(truthValue, this.locale, `.${options.ingoreZeroPrecision ? 1 : options.precision}-${options.precision}`);
    return options.ingoreZeroPrecision ? res.replace(/(?:\.[0]+)$/g, "") : res;
  }
  /**
   * Large number format filter
   *
   * 大数据格式化
   * ```ts
   * 1000 => { value: '1', unit: 'K', unitI18n: '千' }
   * 12456 => { value: '12.46', unit: 'K', unitI18n: '千' }
   * ```
   */
  mega(value, options) {
    options = __spreadValues({
      precision: this.c.precision,
      unitI18n: this.c.megaUnit,
      startingUnit: this.c.startingUnit
    }, options);
    let num = Number(value);
    const res = {
      raw: value,
      value: "",
      unit: "",
      unitI18n: ""
    };
    if (isNaN(num) || num === 0) {
      res.value = value.toString();
      return res;
    }
    if (options.startingUnit === "cent") {
      num = num / 100;
    }
    let abs = Math.abs(+num);
    const rounder = Math.pow(10, options.precision);
    const isNegative = num < 0;
    for (const p of CurrencyMega_Powers) {
      let reduced = abs / p.value;
      reduced = Math.round(reduced * rounder) / rounder;
      if (reduced >= 1) {
        abs = reduced;
        res.unit = p.unit;
        break;
      }
    }
    res.value = (isNegative ? "-" : "") + abs;
    res.unitI18n = options.unitI18n[res.unit];
    return res;
  }
  /**
   * Converted into RMB notation.
   *
   * 转化成人民币表示法
   */
  cny(value, options) {
    options = __spreadValues({
      inWords: true,
      minusSymbol: "\u8D1F",
      startingUnit: this.c.startingUnit
    }, options);
    value = Number(value);
    if (isNaN(value)) {
      return "";
    }
    if (options.startingUnit === "cent") {
      value = value / 100;
    }
    value = value.toString();
    let integer;
    let decimal;
    [integer, decimal] = value.split(".");
    let symbol = "";
    if (integer.startsWith("-")) {
      symbol = options.minusSymbol;
      integer = integer.substring(1);
    }
    if (/^-?\d+$/.test(value)) {
      decimal = null;
    }
    integer = (+integer).toString();
    const inWords = options.inWords;
    const unit = {
      num: inWords ? ["", "\u58F9", "\u8D30", "\u53C1", "\u8086", "\u4F0D", "\u9646", "\u67D2", "\u634C", "\u7396", "\u70B9"] : ["", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D", "\u70B9"],
      radice: inWords ? ["", "\u62FE", "\u4F70", "\u4EDF", "\u4E07", "\u62FE", "\u4F70", "\u4EDF", "\u4EBF", "\u62FE", "\u4F70", "\u4EDF", "\u4E07\u4EBF", "\u62FE", "\u4F70", "\u4EDF", "\u5146", "\u62FE", "\u4F70", "\u4EDF"] : ["", "\u5341", "\u767E", "\u5343", "\u4E07", "\u5341", "\u767E", "\u5343", "\u4EBF", "\u5341", "\u767E", "\u5343", "\u4E07\u4EBF", "\u5341", "\u767E", "\u5343", "\u5146", "\u5341", "\u767E", "\u5343"],
      dec: ["\u89D2", "\u5206", "\u5398", "\u6BEB"]
    };
    if (inWords) {
      value = (+value).toFixed(5).toString();
    }
    let integerRes = "";
    const integerCount = integer.length;
    if (integer === "0" || integerCount === 0) {
      integerRes = "\u96F6";
    } else {
      let cnDesc = "";
      for (let i = 0; i < integerCount; i++) {
        const n = +integer[i];
        const j = integerCount - i - 1;
        const isZero = i > 1 && n !== 0 && integer[i - 1] === "0";
        const cnZero = isZero ? "\u96F6" : "";
        const isEmpptyUnit = n === 0 && j % 4 !== 0 || integer.substring(i - 3, i - 3 + 4) === "0000";
        const descMark = cnDesc;
        let cnNum = unit.num[n];
        cnDesc = isEmpptyUnit ? "" : unit.radice[j];
        if (i === 0 && cnNum === "\u4E00" && cnDesc === "\u5341")
          cnNum = "";
        const isChangeEr = n > 1 && cnNum === "\u4E8C" && // 去除首位
        ["", "\u5341", "\u767E"].indexOf(cnDesc) === -1 && // 不读两\两十\两百
        descMark !== "\u5341";
        if (isChangeEr)
          cnNum = "\u4E24";
        integerRes += cnZero + cnNum + cnDesc;
      }
    }
    let decimalRes = "";
    const decimalCount = decimal ? decimal.toString().length : 0;
    if (decimal === null) {
      decimalRes = inWords ? "\u6574" : "";
    } else if (decimal === "0") {
      decimalRes = "\u96F6";
    } else {
      for (let i = 0; i < decimalCount; i++) {
        if (inWords && i > unit.dec.length - 1)
          break;
        const n = decimal[i];
        const cnZero = n === "0" ? "\u96F6" : "";
        const cnNum = unit.num[+n];
        const cnDesc = inWords ? unit.dec[i] : "";
        decimalRes += cnZero + cnNum + cnDesc;
      }
    }
    const ret = symbol + (inWords ? integerRes + (decimalRes === "\u96F6" ? "\u5143\u6574" : `\u5143${decimalRes}`) : integerRes + (decimalRes === "" ? "" : `\u70B9${decimalRes}`));
    return ret;
  }
};
_CurrencyService.\u0275fac = function CurrencyService_Factory(t) {
  return new (t || _CurrencyService)(\u0275\u0275inject(AlainConfigService), \u0275\u0275inject(LOCALE_ID), \u0275\u0275inject(DEFAULT_CURRENCY_CODE));
};
_CurrencyService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CurrencyService,
  factory: _CurrencyService.\u0275fac,
  providedIn: "root"
});
var CurrencyService = _CurrencyService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrencyService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AlainConfigService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DEFAULT_CURRENCY_CODE]
    }]
  }], null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-image.mjs
var _c07 = ["imgRef"];
var _c14 = ["imagePreviewWrapper"];
function NzImagePreviewComponent_li_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 10);
    \u0275\u0275listener("click", function NzImagePreviewComponent_li_5_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r6);
      const option_r4 = restoredCtx.$implicit;
      return \u0275\u0275resetView(option_r4.onClick());
    });
    \u0275\u0275element(1, "span", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r4 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-image-preview-operations-operation-disabled", ctx_r0.zoomOutDisabled && option_r4.type === "zoomOut");
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", option_r4.icon);
  }
}
function NzImagePreviewComponent_ng_container_8_img_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 13, 14);
  }
  if (rf & 2) {
    const image_r7 = \u0275\u0275nextContext().$implicit;
    const ctx_r9 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("width", image_r7.width)("height", image_r7.height)("transform", ctx_r9.previewImageTransform);
    \u0275\u0275attribute("src", ctx_r9.sanitizerResourceUrl(image_r7.src), \u0275\u0275sanitizeUrl)("srcset", image_r7.srcset)("alt", image_r7.alt);
  }
}
function NzImagePreviewComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzImagePreviewComponent_ng_container_8_img_1_Template, 2, 9, "img", 12);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const imageIndex_r8 = ctx.index;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.index === imageIndex_r8);
  }
}
function NzImagePreviewComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 15);
    \u0275\u0275listener("click", function NzImagePreviewComponent_ng_container_9_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r13);
      const ctx_r12 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r12.onSwitchLeft($event));
    });
    \u0275\u0275element(2, "span", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 17);
    \u0275\u0275listener("click", function NzImagePreviewComponent_ng_container_9_Template_div_click_3_listener($event) {
      \u0275\u0275restoreView(_r13);
      const ctx_r14 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r14.onSwitchRight($event));
    });
    \u0275\u0275element(4, "span", 18);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275classProp("ant-image-preview-switch-left-disabled", ctx_r3.index <= 0);
    \u0275\u0275advance(2);
    \u0275\u0275classProp("ant-image-preview-switch-right-disabled", ctx_r3.index >= ctx_r3.images.length - 1);
  }
}
var _c23 = ["*"];
var FADE_CLASS_NAME_MAP = {
  enter: "ant-fade-enter",
  enterActive: "ant-fade-enter-active",
  leave: "ant-fade-leave",
  leaveActive: "ant-fade-leave-active"
};
var IMAGE_PREVIEW_MASK_CLASS_NAME = "ant-image-preview-mask";
var NZ_CONFIG_MODULE_NAME$1 = "image";
function getFitContentPosition(params) {
  let fixPos = {};
  if (params.width <= params.clientWidth && params.height <= params.clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  }
  if (params.width > params.clientWidth || params.height > params.clientHeight) {
    fixPos = {
      x: fitPoint(params.left, params.width, params.clientWidth),
      y: fitPoint(params.top, params.height, params.clientHeight)
    };
  }
  return fixPos;
}
function getOffset(node) {
  const box = node.getBoundingClientRect();
  const docElem = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
function getClientSize() {
  const width = document.documentElement.clientWidth;
  const height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
function fitPoint(start, size, clientSize) {
  const startAddSize = start + size;
  const offsetStart = (size - clientSize) / 2;
  let distance = null;
  if (size > clientSize) {
    if (start > 0) {
      distance = offsetStart;
    }
    if (start < 0 && startAddSize < clientSize) {
      distance = -offsetStart;
    }
  } else {
    if (start < 0 || startAddSize > clientSize) {
      distance = start < 0 ? offsetStart : -offsetStart;
    }
  }
  return distance;
}
var NzImagePreviewOptions = class {
  constructor() {
    this.nzKeyboard = true;
    this.nzNoAnimation = false;
    this.nzMaskClosable = true;
    this.nzCloseOnNavigation = true;
  }
};
var initialPosition = {
  x: 0,
  y: 0
};
var NZ_DEFAULT_SCALE_STEP = 0.5;
var NZ_DEFAULT_ZOOM = 1;
var NZ_DEFAULT_ROTATE = 0;
var _NzImagePreviewComponent = class _NzImagePreviewComponent {
  get animationDisabled() {
    return this.config.nzNoAnimation ?? false;
  }
  get maskClosable() {
    const defaultConfig = this.nzConfigService.getConfigForComponent(NZ_CONFIG_MODULE_NAME$1) || {};
    return this.config.nzMaskClosable ?? defaultConfig.nzMaskClosable ?? true;
  }
  constructor(ngZone, host, cdr, nzConfigService, config, overlayRef, destroy$, sanitizer) {
    this.ngZone = ngZone;
    this.host = host;
    this.cdr = cdr;
    this.nzConfigService = nzConfigService;
    this.config = config;
    this.overlayRef = overlayRef;
    this.destroy$ = destroy$;
    this.sanitizer = sanitizer;
    this._defaultNzZoom = NZ_DEFAULT_ZOOM;
    this._defaultNzScaleStep = NZ_DEFAULT_SCALE_STEP;
    this._defaultNzRotate = NZ_DEFAULT_ROTATE;
    this.images = [];
    this.index = 0;
    this.isDragging = false;
    this.visible = true;
    this.animationState = "enter";
    this.animationStateChanged = new EventEmitter();
    this.scaleStepMap = /* @__PURE__ */ new Map();
    this.previewImageTransform = "";
    this.previewImageWrapperTransform = "";
    this.operations = [{
      icon: "close",
      onClick: () => {
        this.onClose();
      },
      type: "close"
    }, {
      icon: "zoom-in",
      onClick: () => {
        this.onZoomIn();
      },
      type: "zoomIn"
    }, {
      icon: "zoom-out",
      onClick: () => {
        this.onZoomOut();
      },
      type: "zoomOut"
    }, {
      icon: "rotate-right",
      onClick: () => {
        this.onRotateRight();
      },
      type: "rotateRight"
    }, {
      icon: "rotate-left",
      onClick: () => {
        this.onRotateLeft();
      },
      type: "rotateLeft"
    }];
    this.zoomOutDisabled = false;
    this.position = __spreadValues({}, initialPosition);
    this.containerClick = new EventEmitter();
    this.closeClick = new EventEmitter();
    this.zoom = this.config.nzZoom ?? this._defaultNzZoom;
    this.scaleStep = this.config.nzScaleStep ?? this._defaultNzScaleStep;
    this.rotate = this.config.nzRotate ?? this._defaultNzRotate;
    this.updateZoomOutDisabled();
    this.updatePreviewImageTransform();
    this.updatePreviewImageWrapperTransform();
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.host.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        if (event.target === event.currentTarget && this.maskClosable && this.containerClick.observers.length) {
          this.ngZone.run(() => this.containerClick.emit());
        }
      });
      fromEvent(this.imagePreviewWrapper.nativeElement, "mousedown").pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.isDragging = true;
      });
    });
  }
  setImages(images, scaleStepMap) {
    if (scaleStepMap)
      this.scaleStepMap = scaleStepMap;
    this.images = images;
    this.cdr.markForCheck();
  }
  switchTo(index) {
    this.index = index;
    this.cdr.markForCheck();
  }
  next() {
    if (this.index < this.images.length - 1) {
      this.reset();
      this.index++;
      this.updatePreviewImageTransform();
      this.updatePreviewImageWrapperTransform();
      this.updateZoomOutDisabled();
      this.cdr.markForCheck();
    }
  }
  prev() {
    if (this.index > 0) {
      this.reset();
      this.index--;
      this.updatePreviewImageTransform();
      this.updatePreviewImageWrapperTransform();
      this.updateZoomOutDisabled();
      this.cdr.markForCheck();
    }
  }
  markForCheck() {
    this.cdr.markForCheck();
  }
  onClose() {
    this.closeClick.emit();
  }
  onZoomIn() {
    const zoomStep = this.scaleStepMap.get(this.images[this.index].src ?? this.images[this.index].srcset) ?? this.scaleStep;
    this.zoom += zoomStep;
    this.updatePreviewImageTransform();
    this.updateZoomOutDisabled();
    this.position = __spreadValues({}, initialPosition);
  }
  onZoomOut() {
    if (this.zoom > 1) {
      const zoomStep = this.scaleStepMap.get(this.images[this.index].src ?? this.images[this.index].srcset) ?? this.scaleStep;
      this.zoom -= zoomStep;
      this.updatePreviewImageTransform();
      this.updateZoomOutDisabled();
      this.position = __spreadValues({}, initialPosition);
    }
  }
  onRotateRight() {
    this.rotate += 90;
    this.updatePreviewImageTransform();
  }
  onRotateLeft() {
    this.rotate -= 90;
    this.updatePreviewImageTransform();
  }
  onSwitchLeft(event) {
    event.preventDefault();
    event.stopPropagation();
    this.prev();
  }
  onSwitchRight(event) {
    event.preventDefault();
    event.stopPropagation();
    this.next();
  }
  onAnimationStart(event) {
    if (event.toState === "enter") {
      this.setEnterAnimationClass();
    } else if (event.toState === "leave") {
      this.setLeaveAnimationClass();
    }
    this.animationStateChanged.emit(event);
  }
  onAnimationDone(event) {
    if (event.toState === "enter") {
      this.setEnterAnimationClass();
    } else if (event.toState === "leave") {
      this.setLeaveAnimationClass();
    }
    this.animationStateChanged.emit(event);
  }
  startLeaveAnimation() {
    this.animationState = "leave";
    this.cdr.markForCheck();
  }
  onDragReleased() {
    this.isDragging = false;
    const width = this.imageRef.nativeElement.offsetWidth * this.zoom;
    const height = this.imageRef.nativeElement.offsetHeight * this.zoom;
    const {
      left,
      top
    } = getOffset(this.imageRef.nativeElement);
    const {
      width: clientWidth,
      height: clientHeight
    } = getClientSize();
    const isRotate = this.rotate % 180 !== 0;
    const fitContentParams = {
      width: isRotate ? height : width,
      height: isRotate ? width : height,
      left,
      top,
      clientWidth,
      clientHeight
    };
    const fitContentPos = getFitContentPosition(fitContentParams);
    if (isNotNil(fitContentPos.x) || isNotNil(fitContentPos.y)) {
      this.position = __spreadValues(__spreadValues({}, this.position), fitContentPos);
    }
  }
  sanitizerResourceUrl(url) {
    return this.sanitizer.bypassSecurityTrustResourceUrl(url);
  }
  updatePreviewImageTransform() {
    this.previewImageTransform = `scale3d(${this.zoom}, ${this.zoom}, 1) rotate(${this.rotate}deg)`;
  }
  updatePreviewImageWrapperTransform() {
    this.previewImageWrapperTransform = `translate3d(${this.position.x}px, ${this.position.y}px, 0)`;
  }
  updateZoomOutDisabled() {
    this.zoomOutDisabled = this.zoom <= 1;
  }
  setEnterAnimationClass() {
    if (this.animationDisabled) {
      return;
    }
    const backdropElement = this.overlayRef.backdropElement;
    if (backdropElement) {
      backdropElement.classList.add(FADE_CLASS_NAME_MAP.enter);
      backdropElement.classList.add(FADE_CLASS_NAME_MAP.enterActive);
    }
  }
  setLeaveAnimationClass() {
    if (this.animationDisabled) {
      return;
    }
    const backdropElement = this.overlayRef.backdropElement;
    if (backdropElement) {
      backdropElement.classList.add(FADE_CLASS_NAME_MAP.leave);
      backdropElement.classList.add(FADE_CLASS_NAME_MAP.leaveActive);
    }
  }
  reset() {
    this.zoom = this.config.nzZoom ?? this._defaultNzZoom;
    this.scaleStep = this.config.nzScaleStep ?? this._defaultNzScaleStep;
    this.rotate = this.config.nzRotate ?? this._defaultNzRotate;
    this.position = __spreadValues({}, initialPosition);
  }
};
_NzImagePreviewComponent.\u0275fac = function NzImagePreviewComponent_Factory(t) {
  return new (t || _NzImagePreviewComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(NzImagePreviewOptions), \u0275\u0275directiveInject(OverlayRef), \u0275\u0275directiveInject(NzDestroyService), \u0275\u0275directiveInject(DomSanitizer));
};
_NzImagePreviewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzImagePreviewComponent,
  selectors: [["nz-image-preview"]],
  viewQuery: function NzImagePreviewComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c07, 5);
      \u0275\u0275viewQuery(_c14, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.imageRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.imagePreviewWrapper = _t.first);
    }
  },
  hostAttrs: ["tabindex", "-1", "role", "document", 1, "ant-image-preview-wrap"],
  hostVars: 6,
  hostBindings: function NzImagePreviewComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275syntheticHostListener("@fadeMotion.start", function NzImagePreviewComponent_animation_fadeMotion_start_HostBindingHandler($event) {
        return ctx.onAnimationStart($event);
      })("@fadeMotion.done", function NzImagePreviewComponent_animation_fadeMotion_done_HostBindingHandler($event) {
        return ctx.onAnimationDone($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275syntheticHostProperty("@.disabled", ctx.config.nzNoAnimation)("@fadeMotion", ctx.animationState);
      \u0275\u0275styleProp("z-index", ctx.config.nzZIndex);
      \u0275\u0275classProp("ant-image-preview-moving", ctx.isDragging);
    }
  },
  exportAs: ["nzImagePreview"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService]), \u0275\u0275StandaloneFeature],
  decls: 11,
  vars: 6,
  consts: [[1, "ant-image-preview"], ["tabindex", "0", "aria-hidden", "true", 2, "width", "0", "height", "0", "overflow", "hidden", "outline", "none"], [1, "ant-image-preview-content"], [1, "ant-image-preview-body"], [1, "ant-image-preview-operations"], ["class", "ant-image-preview-operations-operation", 3, "ant-image-preview-operations-operation-disabled", "click", 4, "ngFor", "ngForOf"], ["cdkDrag", "", 1, "ant-image-preview-img-wrapper", 3, "cdkDragFreeDragPosition", "cdkDragReleased"], ["imagePreviewWrapper", ""], [4, "ngFor", "ngForOf"], [4, "ngIf"], [1, "ant-image-preview-operations-operation", 3, "click"], ["nz-icon", "", "nzTheme", "outline", 1, "ant-image-preview-operations-icon", 3, "nzType"], ["cdkDragHandle", "", "class", "ant-image-preview-img", 3, "width", "height", "transform", 4, "ngIf"], ["cdkDragHandle", "", 1, "ant-image-preview-img"], ["imgRef", ""], [1, "ant-image-preview-switch-left", 3, "click"], ["nz-icon", "", "nzType", "left", "nzTheme", "outline"], [1, "ant-image-preview-switch-right", 3, "click"], ["nz-icon", "", "nzType", "right", "nzTheme", "outline"]],
  template: function NzImagePreviewComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275element(1, "div", 1);
      \u0275\u0275elementStart(2, "div", 2)(3, "div", 3)(4, "ul", 4);
      \u0275\u0275template(5, NzImagePreviewComponent_li_5_Template, 2, 3, "li", 5);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "div", 6, 7);
      \u0275\u0275listener("cdkDragReleased", function NzImagePreviewComponent_Template_div_cdkDragReleased_6_listener() {
        return ctx.onDragReleased();
      });
      \u0275\u0275template(8, NzImagePreviewComponent_ng_container_8_Template, 2, 1, "ng-container", 8);
      \u0275\u0275elementEnd();
      \u0275\u0275template(9, NzImagePreviewComponent_ng_container_9_Template, 5, 4, "ng-container", 9);
      \u0275\u0275elementEnd()();
      \u0275\u0275element(10, "div", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(5);
      \u0275\u0275property("ngForOf", ctx.operations);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("transform", ctx.previewImageWrapperTransform);
      \u0275\u0275property("cdkDragFreeDragPosition", ctx.position);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.images);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.images.length > 1);
    }
  },
  dependencies: [NgForOf, NzIconModule, NzIconDirective, CdkDragHandle, CdkDrag, NgIf],
  encapsulation: 2,
  data: {
    animation: [fadeMotion]
  },
  changeDetection: 0
});
var NzImagePreviewComponent = _NzImagePreviewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzImagePreviewComponent, [{
    type: Component,
    args: [{
      selector: "nz-image-preview",
      exportAs: "nzImagePreview",
      animations: [fadeMotion],
      standalone: true,
      template: `
    <div class="ant-image-preview">
      <div tabindex="0" aria-hidden="true" style="width: 0; height: 0; overflow: hidden; outline: none;"></div>
      <div class="ant-image-preview-content">
        <div class="ant-image-preview-body">
          <ul class="ant-image-preview-operations">
            <li
              class="ant-image-preview-operations-operation"
              [class.ant-image-preview-operations-operation-disabled]="zoomOutDisabled && option.type === 'zoomOut'"
              (click)="option.onClick()"
              *ngFor="let option of operations"
            >
              <span class="ant-image-preview-operations-icon" nz-icon [nzType]="option.icon" nzTheme="outline"></span>
            </li>
          </ul>
          <div
            class="ant-image-preview-img-wrapper"
            #imagePreviewWrapper
            cdkDrag
            [style.transform]="previewImageWrapperTransform"
            [cdkDragFreeDragPosition]="position"
            (cdkDragReleased)="onDragReleased()"
          >
            <ng-container *ngFor="let image of images; index as imageIndex">
              <img
                cdkDragHandle
                class="ant-image-preview-img"
                #imgRef
                *ngIf="index === imageIndex"
                [attr.src]="sanitizerResourceUrl(image.src)"
                [attr.srcset]="image.srcset"
                [attr.alt]="image.alt"
                [style.width]="image.width"
                [style.height]="image.height"
                [style.transform]="previewImageTransform"
              />
            </ng-container>
          </div>
          <ng-container *ngIf="images.length > 1">
            <div
              class="ant-image-preview-switch-left"
              [class.ant-image-preview-switch-left-disabled]="index <= 0"
              (click)="onSwitchLeft($event)"
            >
              <span nz-icon nzType="left" nzTheme="outline"></span>
            </div>
            <div
              class="ant-image-preview-switch-right"
              [class.ant-image-preview-switch-right-disabled]="index >= images.length - 1"
              (click)="onSwitchRight($event)"
            >
              <span nz-icon nzType="right" nzTheme="outline"></span>
            </div>
          </ng-container>
        </div>
      </div>
      <div tabindex="0" aria-hidden="true" style="width: 0; height: 0; overflow: hidden; outline: none;"></div>
    </div>
  `,
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      host: {
        class: "ant-image-preview-wrap",
        "[class.ant-image-preview-moving]": "isDragging",
        "[style.zIndex]": "config.nzZIndex",
        "[@.disabled]": "config.nzNoAnimation",
        "[@fadeMotion]": "animationState",
        "(@fadeMotion.start)": "onAnimationStart($event)",
        "(@fadeMotion.done)": "onAnimationDone($event)",
        tabindex: "-1",
        role: "document"
      },
      imports: [NgForOf, NzIconModule, CdkDragHandle, CdkDrag, NgIf],
      providers: [NzDestroyService]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzConfigService
  }, {
    type: NzImagePreviewOptions
  }, {
    type: OverlayRef
  }, {
    type: NzDestroyService
  }, {
    type: DomSanitizer
  }], {
    imageRef: [{
      type: ViewChild,
      args: ["imgRef"]
    }],
    imagePreviewWrapper: [{
      type: ViewChild,
      args: ["imagePreviewWrapper", {
        static: true
      }]
    }]
  });
})();
var NzImagePreviewRef = class {
  constructor(previewInstance, config, overlayRef) {
    this.previewInstance = previewInstance;
    this.config = config;
    this.overlayRef = overlayRef;
    this.destroy$ = new Subject();
    overlayRef.keydownEvents().pipe(filter((event) => this.config.nzKeyboard && (event.keyCode === ESCAPE || event.keyCode === LEFT_ARROW || event.keyCode === RIGHT_ARROW) && !hasModifierKey(event))).subscribe((event) => {
      event.preventDefault();
      if (event.keyCode === ESCAPE) {
        this.close();
      }
      if (event.keyCode === LEFT_ARROW) {
        this.prev();
      }
      if (event.keyCode === RIGHT_ARROW) {
        this.next();
      }
    });
    overlayRef.detachments().subscribe(() => {
      this.overlayRef.dispose();
    });
    previewInstance.containerClick.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {
      this.close();
    });
    previewInstance.closeClick.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {
      this.close();
    });
    previewInstance.animationStateChanged.pipe(filter((event) => event.phaseName === "done" && event.toState === "leave"), take(1)).subscribe(() => {
      this.dispose();
    });
  }
  switchTo(index) {
    this.previewInstance.switchTo(index);
  }
  next() {
    this.previewInstance.next();
  }
  prev() {
    this.previewInstance.prev();
  }
  close() {
    this.previewInstance.startLeaveAnimation();
  }
  dispose() {
    this.destroy$.next();
    this.overlayRef.dispose();
  }
};
var _NzImageService = class _NzImageService {
  constructor(overlay, injector, nzConfigService, directionality) {
    this.overlay = overlay;
    this.injector = injector;
    this.nzConfigService = nzConfigService;
    this.directionality = directionality;
  }
  preview(images, options, zoomMap) {
    return this.display(images, options, zoomMap);
  }
  display(images, config, scaleStepMap) {
    const configMerged = __spreadValues(__spreadValues({}, new NzImagePreviewOptions()), config ?? {});
    const overlayRef = this.createOverlay(configMerged);
    const previewComponent = this.attachPreviewComponent(overlayRef, configMerged);
    previewComponent.setImages(images, scaleStepMap);
    const previewRef = new NzImagePreviewRef(previewComponent, configMerged, overlayRef);
    previewComponent.previewRef = previewRef;
    return previewRef;
  }
  attachPreviewComponent(overlayRef, config) {
    const injector = Injector.create({
      parent: this.injector,
      providers: [{
        provide: OverlayRef,
        useValue: overlayRef
      }, {
        provide: NzImagePreviewOptions,
        useValue: config
      }]
    });
    const containerPortal = new ComponentPortal(NzImagePreviewComponent, null, injector);
    const containerRef = overlayRef.attach(containerPortal);
    return containerRef.instance;
  }
  createOverlay(config) {
    const globalConfig = this.nzConfigService.getConfigForComponent(NZ_CONFIG_MODULE_NAME$1) || {};
    const overLayConfig = new OverlayConfig({
      hasBackdrop: true,
      scrollStrategy: this.overlay.scrollStrategies.block(),
      positionStrategy: this.overlay.position().global(),
      disposeOnNavigation: config.nzCloseOnNavigation ?? globalConfig.nzCloseOnNavigation ?? true,
      backdropClass: IMAGE_PREVIEW_MASK_CLASS_NAME,
      direction: config.nzDirection || globalConfig.nzDirection || this.directionality.value
    });
    return this.overlay.create(overLayConfig);
  }
};
_NzImageService.\u0275fac = function NzImageService_Factory(t) {
  return new (t || _NzImageService)(\u0275\u0275inject(Overlay), \u0275\u0275inject(Injector), \u0275\u0275inject(NzConfigService), \u0275\u0275inject(Directionality, 8));
};
_NzImageService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzImageService,
  factory: _NzImageService.\u0275fac
});
var NzImageService = _NzImageService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzImageService, [{
    type: Injectable
  }], () => [{
    type: Overlay
  }, {
    type: Injector
  }, {
    type: NzConfigService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _NzImageGroupComponent = class _NzImageGroupComponent {
  constructor() {
    this.nzScaleStep = null;
    this.images = [];
  }
  addImage(image) {
    this.images.push(image);
  }
};
_NzImageGroupComponent.\u0275fac = function NzImageGroupComponent_Factory(t) {
  return new (t || _NzImageGroupComponent)();
};
_NzImageGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzImageGroupComponent,
  selectors: [["nz-image-group"]],
  inputs: {
    nzScaleStep: "nzScaleStep"
  },
  exportAs: ["nzImageGroup"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c23,
  decls: 1,
  vars: 0,
  template: function NzImageGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzImageGroupComponent = _NzImageGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzImageGroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-image-group",
      exportAs: "nzImageGroup",
      template: "<ng-content></ng-content>",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true
    }]
  }], null, {
    nzScaleStep: [{
      type: Input
    }]
  });
})();
var NZ_CONFIG_MODULE_NAME3 = "image";
var _NzImageDirective = class _NzImageDirective {
  get previewable() {
    return !this.nzDisablePreview && this.status !== "error";
  }
  constructor(document2, nzConfigService, elementRef, nzImageService, cdr, parentGroup, directionality) {
    this.document = document2;
    this.nzConfigService = nzConfigService;
    this.elementRef = elementRef;
    this.nzImageService = nzImageService;
    this.cdr = cdr;
    this.parentGroup = parentGroup;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME3;
    this.nzSrc = "";
    this.nzSrcset = "";
    this.nzDisablePreview = false;
    this.nzFallback = null;
    this.nzPlaceholder = null;
    this.nzScaleStep = null;
    this.status = "normal";
    this.backLoadDestroy$ = new Subject();
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.backLoad();
    if (this.parentGroup) {
      this.parentGroup.addImage(this);
    }
    if (this.directionality) {
      this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
        this.dir = direction;
        this.cdr.detectChanges();
      });
      this.dir = this.directionality.value;
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onPreview() {
    if (!this.previewable) {
      return;
    }
    if (this.parentGroup) {
      const previewAbleImages = this.parentGroup.images.filter((e) => e.previewable);
      const previewImages = previewAbleImages.map((e) => ({
        src: e.nzSrc,
        srcset: e.nzSrcset
      }));
      const previewIndex = previewAbleImages.findIndex((el) => this === el);
      const scaleStepMap = /* @__PURE__ */ new Map();
      previewAbleImages.forEach((imageDirective) => {
        scaleStepMap.set(imageDirective.nzSrc ?? imageDirective.nzSrcset, imageDirective.nzScaleStep ?? this.parentGroup.nzScaleStep ?? this.nzScaleStep ?? NZ_DEFAULT_SCALE_STEP);
      });
      const previewRef = this.nzImageService.preview(previewImages, {
        nzDirection: this.dir
      }, scaleStepMap);
      previewRef.switchTo(previewIndex);
    } else {
      const previewImages = [{
        src: this.nzSrc,
        srcset: this.nzSrcset
      }];
      this.nzImageService.preview(previewImages, {
        nzDirection: this.dir,
        nzScaleStep: this.nzScaleStep ?? NZ_DEFAULT_SCALE_STEP
      });
    }
  }
  getElement() {
    return this.elementRef;
  }
  ngOnChanges(changes) {
    const {
      nzSrc
    } = changes;
    if (nzSrc) {
      this.getElement().nativeElement.src = nzSrc.currentValue;
      this.backLoad();
    }
  }
  /**
   * use internal Image object handle fallback & placeholder
   *
   * @private
   */
  backLoad() {
    this.backLoadImage = this.document.createElement("img");
    this.backLoadImage.src = this.nzSrc;
    this.backLoadImage.srcset = this.nzSrcset;
    this.status = "loading";
    this.backLoadDestroy$.next();
    this.backLoadDestroy$.complete();
    this.backLoadDestroy$ = new Subject();
    if (this.backLoadImage.complete) {
      this.status = "normal";
      this.getElement().nativeElement.src = this.nzSrc;
      this.getElement().nativeElement.srcset = this.nzSrcset;
    } else {
      if (this.nzPlaceholder) {
        this.getElement().nativeElement.src = this.nzPlaceholder;
        this.getElement().nativeElement.srcset = "";
      } else {
        this.getElement().nativeElement.src = this.nzSrc;
        this.getElement().nativeElement.srcset = this.nzSrcset;
      }
      fromEvent(this.backLoadImage, "load").pipe(takeUntil(this.backLoadDestroy$), takeUntil(this.destroy$)).subscribe(() => {
        this.status = "normal";
        this.getElement().nativeElement.src = this.nzSrc;
        this.getElement().nativeElement.srcset = this.nzSrcset;
      });
      fromEvent(this.backLoadImage, "error").pipe(takeUntil(this.backLoadDestroy$), takeUntil(this.destroy$)).subscribe(() => {
        this.status = "error";
        if (this.nzFallback) {
          this.getElement().nativeElement.src = this.nzFallback;
          this.getElement().nativeElement.srcset = "";
        }
      });
    }
  }
};
_NzImageDirective.\u0275fac = function NzImageDirective_Factory(t) {
  return new (t || _NzImageDirective)(\u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NzImageService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzImageGroupComponent, 8), \u0275\u0275directiveInject(Directionality, 8));
};
_NzImageDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzImageDirective,
  selectors: [["img", "nz-image", ""]],
  hostBindings: function NzImageDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzImageDirective_click_HostBindingHandler() {
        return ctx.onPreview();
      });
    }
  },
  inputs: {
    nzSrc: "nzSrc",
    nzSrcset: "nzSrcset",
    nzDisablePreview: "nzDisablePreview",
    nzFallback: "nzFallback",
    nzPlaceholder: "nzPlaceholder",
    nzScaleStep: "nzScaleStep"
  },
  exportAs: ["nzImage"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzImageDirective = _NzImageDirective;
__decorate([InputBoolean(), WithConfig()], NzImageDirective.prototype, "nzDisablePreview", void 0);
__decorate([WithConfig()], NzImageDirective.prototype, "nzFallback", void 0);
__decorate([WithConfig()], NzImageDirective.prototype, "nzPlaceholder", void 0);
__decorate([WithConfig()], NzImageDirective.prototype, "nzScaleStep", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzImageDirective, [{
    type: Directive,
    args: [{
      selector: "img[nz-image]",
      exportAs: "nzImage",
      host: {
        "(click)": "onPreview()"
      },
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NzConfigService
  }, {
    type: ElementRef
  }, {
    type: NzImageService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzImageGroupComponent,
    decorators: [{
      type: Optional
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzSrc: [{
      type: Input
    }],
    nzSrcset: [{
      type: Input
    }],
    nzDisablePreview: [{
      type: Input
    }],
    nzFallback: [{
      type: Input
    }],
    nzPlaceholder: [{
      type: Input
    }],
    nzScaleStep: [{
      type: Input
    }]
  });
})();
var _NzImageModule = class _NzImageModule {
};
_NzImageModule.\u0275fac = function NzImageModule_Factory(t) {
  return new (t || _NzImageModule)();
};
_NzImageModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzImageModule
});
_NzImageModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [NzImageService],
  imports: [NzImagePreviewComponent]
});
var NzImageModule = _NzImageModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzImageModule, [{
    type: NgModule,
    args: [{
      imports: [NzImageDirective, NzImagePreviewComponent, NzImageGroupComponent],
      exports: [NzImageDirective, NzImagePreviewComponent, NzImageGroupComponent],
      providers: [NzImageService]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-experimental-image.mjs
var _c08 = ["imageRef"];
function isFixedSize(size) {
  return typeof size === "number" || /^(\d)+(px)?$/.test(size);
}
var defaultImageSrcLoader = ({
  src
}) => {
  return src;
};
var NZ_CONFIG_MODULE_NAME4 = "imageExperimental";
var sizeBreakpoints = [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840];
var _NzImageViewComponent = class _NzImageViewComponent {
  constructor(cdr, nzConfigService, imagePreloadService) {
    this.cdr = cdr;
    this.nzConfigService = nzConfigService;
    this.imagePreloadService = imagePreloadService;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME4;
    this.nzSrc = "";
    this.nzAlt = "";
    this.nzWidth = "auto";
    this.nzHeight = "auto";
    this.nzSrcLoader = defaultImageSrcLoader;
    this.nzAutoSrcset = false;
    this.nzPriority = false;
    this.nzFallback = null;
    this.nzPlaceholder = null;
    this.nzDisablePreview = false;
    this.src = "";
    this.width = "auto";
    this.height = "auto";
    this.srcset = "";
    this.destroy$ = new Subject();
    this.reloadDisposeHandler = () => void 0;
    this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME4).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.composeImageAttrs();
      this.cdr.markForCheck();
    });
  }
  ngOnInit() {
    if (this.nzPriority) {
      this.preload();
    }
  }
  ngOnChanges(changes) {
    const {
      nzLoader,
      nzSrc,
      nzOptimize
    } = changes;
    if (nzSrc || nzLoader || nzOptimize) {
      this.composeImageAttrs();
    }
  }
  ngOnDestroy() {
    this.reloadDisposeHandler();
    this.destroy$.next();
    this.destroy$.complete();
  }
  preload() {
    this.reloadDisposeHandler = this.imagePreloadService.addPreload({
      src: this.src,
      srcset: this.srcset
    });
  }
  optimizable() {
    if (this.nzAutoSrcset) {
      if (!isFixedSize(this.nzWidth) || !isFixedSize(this.nzHeight)) {
        warn2(`When using "nzAutoSrcset" you should use a fixed size width and height, for more information please refer to CLS (https://web.dev/cls/) performance metrics`);
        return false;
      }
      if (this.nzSrc.endsWith(".svg")) {
        warn2(`SVG does not need to be optimized`);
        return false;
      }
      if (this.nzSrc.startsWith("data:")) {
        warn2(`Data URLs cannot be optimized`);
        return false;
      }
      return true;
    }
    return false;
  }
  composeImageAttrs() {
    const loader = this.getLoader();
    if (!this.optimizable()) {
      this.src = loader({
        src: this.nzSrc
      });
      this.width = this.nzWidth;
      this.height = this.nzHeight;
      return;
    }
    this.width = typeof this.nzWidth === "number" ? this.nzWidth : parseInt(this.nzWidth, 10);
    this.height = typeof this.nzHeight === "number" ? this.nzHeight : parseInt(this.nzHeight, 10);
    const widths = this.convertWidths(this.width, sizeBreakpoints);
    this.src = loader({
      src: this.nzSrc,
      width: widths[0]
    });
    this.srcset = widths.map((w, i) => `${loader({
      src: this.nzSrc,
      width: w
    })} ${i + 1}x`).join(", ");
  }
  getLoader() {
    return this.nzSrcLoader || defaultImageSrcLoader;
  }
  convertWidths(width, optimizeSizes) {
    const allSizes = [...optimizeSizes].sort((a, b) => a - b);
    return [...new Set(
      // 2x scale is sufficient
      // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
      [width, width * 2].map((w) => allSizes.find((p) => p >= w) || w)
    )];
  }
};
_NzImageViewComponent.\u0275fac = function NzImageViewComponent_Factory(t) {
  return new (t || _NzImageViewComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ImagePreloadService));
};
_NzImageViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzImageViewComponent,
  selectors: [["nz-image"]],
  viewQuery: function NzImageViewComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c08, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.imageRef = _t.first);
    }
  },
  inputs: {
    nzSrc: "nzSrc",
    nzAlt: "nzAlt",
    nzWidth: "nzWidth",
    nzHeight: "nzHeight",
    nzSrcLoader: "nzSrcLoader",
    nzAutoSrcset: "nzAutoSrcset",
    nzPriority: "nzPriority",
    nzFallback: "nzFallback",
    nzPlaceholder: "nzPlaceholder",
    nzDisablePreview: "nzDisablePreview"
  },
  exportAs: ["nzImage"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 9,
  consts: [["nz-image", "", 3, "nzSrc", "nzSrcset", "nzDisablePreview", "nzFallback", "nzPlaceholder"], ["imageRef", ""]],
  template: function NzImageViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "img", 0, 1);
    }
    if (rf & 2) {
      \u0275\u0275property("nzSrc", ctx.src)("nzSrcset", ctx.srcset)("nzDisablePreview", ctx.nzDisablePreview)("nzFallback", ctx.nzFallback)("nzPlaceholder", ctx.nzPlaceholder);
      \u0275\u0275attribute("width", ctx.width)("height", ctx.height)("srcset", ctx.srcset)("alt", ctx.nzAlt || null);
    }
  },
  dependencies: [NzImageDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzImageViewComponent = _NzImageViewComponent;
__decorate([WithConfig()], NzImageViewComponent.prototype, "nzSrcLoader", void 0);
__decorate([InputBoolean(), WithConfig()], NzImageViewComponent.prototype, "nzAutoSrcset", void 0);
__decorate([InputBoolean()], NzImageViewComponent.prototype, "nzPriority", void 0);
__decorate([WithConfig()], NzImageViewComponent.prototype, "nzFallback", void 0);
__decorate([WithConfig()], NzImageViewComponent.prototype, "nzPlaceholder", void 0);
__decorate([InputBoolean(), WithConfig()], NzImageViewComponent.prototype, "nzDisablePreview", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzImageViewComponent, [{
    type: Component,
    args: [{
      selector: "nz-image",
      exportAs: "nzImage",
      template: `
    <img
      #imageRef
      nz-image
      [nzSrc]="src"
      [nzSrcset]="srcset"
      [nzDisablePreview]="nzDisablePreview"
      [nzFallback]="nzFallback"
      [nzPlaceholder]="nzPlaceholder"
      [attr.width]="width"
      [attr.height]="height"
      [attr.srcset]="srcset"
      [attr.alt]="nzAlt || null"
    />
  `,
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      imports: [NzImageDirective],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzConfigService
  }, {
    type: ImagePreloadService
  }], {
    nzSrc: [{
      type: Input
    }],
    nzAlt: [{
      type: Input
    }],
    nzWidth: [{
      type: Input
    }],
    nzHeight: [{
      type: Input
    }],
    nzSrcLoader: [{
      type: Input
    }],
    nzAutoSrcset: [{
      type: Input
    }],
    nzPriority: [{
      type: Input
    }],
    nzFallback: [{
      type: Input
    }],
    nzPlaceholder: [{
      type: Input
    }],
    nzDisablePreview: [{
      type: Input
    }],
    imageRef: [{
      type: ViewChild,
      args: ["imageRef"]
    }]
  });
})();
var _NzImageModule2 = class _NzImageModule2 {
};
_NzImageModule2.\u0275fac = function NzImageModule_Factory(t) {
  return new (t || _NzImageModule2)();
};
_NzImageModule2.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzImageModule2
});
_NzImageModule2.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzImageModule2 = _NzImageModule2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzImageModule2, [{
    type: NgModule,
    args: [{
      imports: [NzImageViewComponent],
      exports: [NzImageViewComponent]
    }]
  }], null, null);
})();

// node_modules/@delon/abc/fesm2022/cell.mjs
function CellComponent_ng_template_0_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 3);
    \u0275\u0275listener("ngModelChange", function CellComponent_ng_template_0_Case_0_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r15);
      const ctx_r14 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r14.change($event));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzDisabled", ctx_r6.disabled)("ngModel", ctx_r6.value);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r6.safeOpt.checkbox == null ? null : ctx_r6.safeOpt.checkbox.label, " ");
  }
}
function CellComponent_ng_template_0_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 4);
    \u0275\u0275listener("ngModelChange", function CellComponent_ng_template_0_Case_1_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r16 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r16.change($event));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzDisabled", ctx_r7.disabled)("ngModel", ctx_r7.value);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r7.safeOpt.radio == null ? null : ctx_r7.safeOpt.radio.label, " ");
  }
}
function CellComponent_ng_template_0_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 5);
    \u0275\u0275listener("click", function CellComponent_ng_template_0_Case_2_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r19);
      const ctx_r18 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r18._link($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    \u0275\u0275property("innerHTML", ctx_r8._text, \u0275\u0275sanitizeHtml);
    \u0275\u0275attribute("target", ctx_r8.safeOpt.link == null ? null : ctx_r8.safeOpt.link.target)("title", ctx_r8.value);
  }
}
function CellComponent_ng_template_0_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-tag", 6);
    \u0275\u0275element(1, "span", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzColor", ctx_r9.res == null ? null : ctx_r9.res.result == null ? null : ctx_r9.res.result.color);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r9._text, \u0275\u0275sanitizeHtml);
  }
}
function CellComponent_ng_template_0_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-badge", 8);
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275propertyInterpolate("nzText", ctx_r10._text);
    \u0275\u0275property("nzStatus", ctx_r10.res == null ? null : ctx_r10.res.result == null ? null : ctx_r10.res.result.color);
  }
}
function CellComponent_ng_template_0_Case_5_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_template_0_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CellComponent_ng_template_0_Case_5_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r11 = \u0275\u0275nextContext(2);
    \u0275\u0275property("data", ctx_r11.hostData);
  }
}
function CellComponent_ng_template_0_Case_6_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "img", 10);
    \u0275\u0275listener("click", function CellComponent_ng_template_0_Case_6_For_1_Template_img_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r28);
      const i_r22 = restoredCtx.$implicit;
      const ctx_r27 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r27._showImg(i_r22));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r22 = ctx.$implicit;
    const ctx_r21 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("point", ctx_r21.safeOpt.img == null ? null : ctx_r21.safeOpt.img.big);
    \u0275\u0275attribute("src", i_r22, \u0275\u0275sanitizeUrl)("height", ctx_r21.safeOpt.img == null ? null : ctx_r21.safeOpt.img.size)("width", ctx_r21.safeOpt.img == null ? null : ctx_r21.safeOpt.img.size);
  }
}
function CellComponent_ng_template_0_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, CellComponent_ng_template_0_Case_6_For_1_Template, 1, 5, "img", 11, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r12 = \u0275\u0275nextContext(2);
    \u0275\u0275repeater(ctx_r12._text);
  }
}
function CellComponent_ng_template_0_Case_7_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 12);
  }
  if (rf & 2) {
    const ctx_r29 = \u0275\u0275nextContext(3);
    \u0275\u0275property("innerText", ctx_r29._text);
    \u0275\u0275attribute("title", ctx_r29.value);
  }
}
function CellComponent_ng_template_0_Case_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r30 = \u0275\u0275nextContext(3);
    \u0275\u0275property("innerHTML", ctx_r30._text, \u0275\u0275sanitizeHtml);
    \u0275\u0275attribute("title", ctx_r30.value);
  }
}
function CellComponent_ng_template_0_Case_7_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r31 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r31._unit);
  }
}
function CellComponent_ng_template_0_Case_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CellComponent_ng_template_0_Case_7_Conditional_0_Template, 1, 2, "span", 12)(1, CellComponent_ng_template_0_Case_7_Conditional_1_Template, 1, 2)(2, CellComponent_ng_template_0_Case_7_Conditional_2_Template, 2, 1, "span", 13);
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(0, ctx_r13.isText ? 0 : 1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(2, ctx_r13._unit ? 2 : -1);
  }
}
function CellComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CellComponent_ng_template_0_Case_0_Template, 2, 3)(1, CellComponent_ng_template_0_Case_1_Template, 2, 3)(2, CellComponent_ng_template_0_Case_2_Template, 1, 3)(3, CellComponent_ng_template_0_Case_3_Template, 2, 2)(4, CellComponent_ng_template_0_Case_4_Template, 1, 2)(5, CellComponent_ng_template_0_Case_5_Template, 1, 1)(6, CellComponent_ng_template_0_Case_6_Template, 2, 0)(7, CellComponent_ng_template_0_Case_7_Template, 3, 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    let CellComponent_ng_template_0_contFlowTmp;
    \u0275\u0275conditional(0, (CellComponent_ng_template_0_contFlowTmp = ctx_r0.safeOpt.type) === "checkbox" ? 0 : CellComponent_ng_template_0_contFlowTmp === "radio" ? 1 : CellComponent_ng_template_0_contFlowTmp === "link" ? 2 : CellComponent_ng_template_0_contFlowTmp === "tag" ? 3 : CellComponent_ng_template_0_contFlowTmp === "badge" ? 4 : CellComponent_ng_template_0_contFlowTmp === "widget" ? 5 : CellComponent_ng_template_0_contFlowTmp === "img" ? 6 : 7);
  }
}
function CellComponent_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r32 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r32.safeOpt.default == null ? null : ctx_r32.safeOpt.default.text, " ");
  }
}
function CellComponent_ng_template_2_Conditional_1_Conditional_0_ng_template_1_Template(rf, ctx) {
}
function CellComponent_ng_template_2_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275template(1, CellComponent_ng_template_2_Conditional_1_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r34 = \u0275\u0275nextContext(3);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("nz-tooltip", ctx_r34.safeOpt.tooltip);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function CellComponent_ng_template_2_Conditional_1_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_template_2_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CellComponent_ng_template_2_Conditional_1_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(3);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function CellComponent_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CellComponent_ng_template_2_Conditional_1_Conditional_0_Template, 2, 2, "span", 15)(1, CellComponent_ng_template_2_Conditional_1_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const ctx_r33 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(0, ctx_r33.safeOpt.tooltip ? 0 : 1);
  }
}
function CellComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CellComponent_ng_template_2_Conditional_0_Template, 1, 1)(1, CellComponent_ng_template_2_Conditional_1_Template, 2, 1);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275conditional(0, ctx_r2.showDefault ? 0 : 1);
  }
}
function CellComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 2);
  }
}
function CellComponent_Conditional_5_ng_template_0_Template(rf, ctx) {
}
function CellComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CellComponent_Conditional_5_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275property("ngTemplateOutlet", _r3);
  }
}
var _CellService = class _CellService {
  constructor(configSrv, nzI18n, currency, dom) {
    this.nzI18n = nzI18n;
    this.currency = currency;
    this.dom = dom;
    this.widgets = {
      date: {
        type: "fn",
        ref: (value, opt) => {
          return {
            text: formatDate(value, opt.date.format, this.nzI18n.getDateLocale())
          };
        }
      },
      mega: {
        type: "fn",
        ref: (value, opt) => {
          const res = this.currency.mega(value, opt.mega);
          return {
            text: res.value,
            unit: res.unitI18n
          };
        }
      },
      currency: {
        type: "fn",
        ref: (value, opt) => {
          return {
            text: this.currency.format(value, opt.currency)
          };
        }
      },
      cny: {
        type: "fn",
        ref: (value, opt) => {
          return {
            text: this.currency.cny(value, opt.cny)
          };
        }
      },
      boolean: {
        type: "fn",
        ref: (value, opt) => {
          return {
            text: this.dom.bypassSecurityTrustHtml(yn(value, opt.boolean))
          };
        }
      },
      img: {
        type: "fn",
        ref: (value) => {
          return {
            text: Array.isArray(value) ? value : [value]
          };
        }
      }
    };
    this.globalOptions = configSrv.merge("cell", {
      date: {
        format: "yyyy-MM-dd HH:mm:ss"
      },
      img: {
        size: 32
      },
      default: {
        text: "-"
      }
    });
  }
  registerWidget(key, widget) {
    this.widgets[key] = {
      type: "widget",
      ref: widget
    };
  }
  getWidget(key) {
    return this.widgets[key];
  }
  genType(value, options) {
    if (options.type != null)
      return options.type;
    const typeOf = typeof value;
    if (typeOf === "number" && /^[0-9]{13}$/g.test(value))
      return "date";
    if (value instanceof Date || options.date != null)
      return "date";
    if (options.widget != null)
      return "widget";
    else if (options.mega != null)
      return "mega";
    else if (options.currency != null)
      return "currency";
    else if (options.cny != null)
      return "cny";
    else if (options.img != null)
      return "img";
    else if (options.link != null)
      return "link";
    else if (options.html != null)
      return "html";
    else if (options.badge != null)
      return "badge";
    else if (options.tag != null)
      return "tag";
    else if (options.checkbox != null)
      return "checkbox";
    else if (options.radio != null)
      return "radio";
    else if (options.enum != null)
      return "enum";
    else if (typeOf === "number")
      return "number";
    else if (typeOf === "boolean" || options.boolean != null)
      return "boolean";
    else
      return "string";
  }
  fixOptions(options) {
    return deepMerge({}, this.globalOptions, options);
  }
  get(value, options) {
    const type = this.genType(value, __spreadValues({}, options));
    const opt = this.fixOptions(options);
    opt.type = type;
    const isSafeHtml = typeof value === "object" && typeof value?.getTypeName === "function" && value?.getTypeName() != null;
    let res = {
      result: typeof value === "object" && !isSafeHtml ? value : {
        text: value == null ? "" : isSafeHtml ? value : `${value}`
      },
      options: opt
    };
    const widget = this.widgets[type];
    if (widget?.type === "fn") {
      res.result = widget.ref(value, opt);
    }
    return (typeof value === "function" ? value(value, opt) : of(res.result)).pipe(map((text) => {
      res.result = text;
      let dictData;
      switch (type) {
        case "badge":
          dictData = (opt.badge?.data ?? {})[value];
          res.result = __spreadValues({
            color: "default"
          }, dictData);
          break;
        case "tag":
          dictData = (opt.tag?.data ?? {})[value];
          res.result = dictData;
          break;
        case "enum":
          res.result = {
            text: (opt.enum ?? {})[value]
          };
          break;
        case "html":
          res.safeHtml = opt.html?.safe;
          break;
        case "string":
          if (isSafeHtml)
            res.safeHtml = "safeHtml";
          break;
      }
      if ((type === "badge" || type === "tag") && dictData?.tooltip != null) {
        res.options.tooltip = dictData.tooltip;
      }
      if (opt.mask != null) {
        res.result.text = formatMask(res.result.text, opt.mask);
      }
      return res;
    }));
  }
};
_CellService.\u0275fac = function CellService_Factory(t) {
  return new (t || _CellService)(\u0275\u0275inject(AlainConfigService), \u0275\u0275inject(NzI18nService), \u0275\u0275inject(CurrencyService), \u0275\u0275inject(DomSanitizer));
};
_CellService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _CellService,
  factory: _CellService.\u0275fac,
  providedIn: "root"
});
var CellService = _CellService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AlainConfigService
  }, {
    type: NzI18nService
  }, {
    type: CurrencyService
  }, {
    type: DomSanitizer
  }], null);
})();
var _CellHostDirective = class _CellHostDirective {
  constructor(srv, viewContainerRef) {
    this.srv = srv;
    this.viewContainerRef = viewContainerRef;
  }
  ngOnInit() {
    const widget = this.data.options.widget;
    const componentType = this.srv.getWidget(widget.key)?.ref;
    if (componentType == null) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        warn(`cell: No widget for type "${widget.key}"`);
      }
      return;
    }
    this.viewContainerRef.clear();
    const componentRef = this.viewContainerRef.createComponent(componentType);
    componentRef.instance.data = this.data;
  }
};
_CellHostDirective.\u0275fac = function CellHostDirective_Factory(t) {
  return new (t || _CellHostDirective)(\u0275\u0275directiveInject(CellService), \u0275\u0275directiveInject(ViewContainerRef));
};
_CellHostDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CellHostDirective,
  selectors: [["", "cell-widget-host", ""]],
  inputs: {
    data: "data"
  },
  standalone: true
});
var CellHostDirective = _CellHostDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellHostDirective, [{
    type: Directive,
    args: [{
      selector: "[cell-widget-host]",
      standalone: true
    }]
  }], () => [{
    type: CellService
  }, {
    type: ViewContainerRef
  }], {
    data: [{
      type: Input
    }]
  });
})();
var _CellComponent = class _CellComponent {
  get safeOpt() {
    return this.res?.options ?? {};
  }
  get isText() {
    return this.res?.safeHtml === "text";
  }
  get hostData() {
    return {
      value: this.value,
      options: this.srv.fixOptions(this.options)
    };
  }
  constructor(srv, router, cdr, el, renderer, imgSrv, win) {
    this.srv = srv;
    this.router = router;
    this.cdr = cdr;
    this.el = el;
    this.renderer = renderer;
    this.imgSrv = imgSrv;
    this.win = win;
    this.showDefault = false;
    this.valueChange = new EventEmitter();
    this.loading = false;
    this.disabled = false;
  }
  updateValue() {
    this.destroy$?.unsubscribe();
    this.destroy$ = this.srv.get(this.value, this.options).subscribe((res) => {
      this.res = res;
      this.showDefault = this.value == this.safeOpt.default.condition;
      this._text = res.result?.text ?? "";
      this._unit = res.result?.unit ?? this.safeOpt?.unit;
      this.cdr.detectChanges();
      this.setClass();
    });
  }
  setClass() {
    const {
      el,
      renderer
    } = this;
    const {
      renderType,
      size,
      type
    } = this.safeOpt;
    updateHostClass(el.nativeElement, renderer, {
      [`cell`]: true,
      [`cell__${renderType}`]: renderType != null,
      [`cell__${size}`]: size != null,
      [`cell__has-unit`]: this._unit,
      [`cell__has-default`]: this.showDefault,
      [`cell__disabled`]: this.disabled
    });
    el.nativeElement.setAttribute("data-type", `${type}`);
  }
  ngOnChanges(changes) {
    if (Object.keys(changes).every((k) => ["loading", "disabled"].includes(k))) {
      this.setClass();
    } else {
      this.updateValue();
    }
  }
  change(value) {
    this.value = value;
    this.valueChange.emit(value);
  }
  _link(e) {
    e.preventDefault();
    e.stopPropagation();
    if (this.disabled)
      return;
    const link = this.safeOpt.link;
    const url = link?.url;
    if (url == null)
      return;
    if (/https?:\/\//g.test(url)) {
      this.win.open(url, link?.target);
    } else {
      this.router.navigateByUrl(url);
    }
  }
  _showImg(img) {
    const config = this.safeOpt.img;
    if (config == null || config.big == null)
      return;
    let idx = -1;
    const list2 = this._text.map((p, index) => {
      if (idx === -1 && p === img)
        idx = index;
      return typeof config.big === "function" ? config.big(p) : p;
    });
    this.imgSrv.preview(list2.map((p) => ({
      src: p
    })), config.previewOptions).switchTo(idx);
  }
  ngOnDestroy() {
    this.destroy$?.unsubscribe();
  }
};
_CellComponent.\u0275fac = function CellComponent_Factory(t) {
  return new (t || _CellComponent)(\u0275\u0275directiveInject(CellService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzImageService), \u0275\u0275directiveInject(WINDOW));
};
_CellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CellComponent,
  selectors: [["cell"], ["", "cell", ""]],
  inputs: {
    value: "value",
    options: "options",
    loading: "loading",
    disabled: "disabled"
  },
  outputs: {
    valueChange: "valueChange"
  },
  exportAs: ["cell"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 6,
  vars: 1,
  consts: [["text", ""], ["textWrap", ""], ["nz-icon", "", "nzType", "loading"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel", "ngModelChange"], ["nz-radio", "", 3, "nzDisabled", "ngModel", "ngModelChange"], [3, "innerHTML", "click"], [3, "nzColor"], [3, "innerHTML"], [3, "nzStatus", "nzText"], ["cell-widget-host", "", 3, "data"], [1, "img", 3, "click"], ["class", "img", 3, "point"], [3, "innerText"], ["class", "unit"], [1, "unit"], [3, "nz-tooltip"], [3, "ngTemplateOutlet"]],
  template: function CellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, CellComponent_ng_template_0_Template, 8, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, CellComponent_ng_template_2_Template, 2, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(4, CellComponent_Conditional_4_Template, 1, 0, "span", 2)(5, CellComponent_Conditional_5_Template, 1, 1);
    }
    if (rf & 2) {
      \u0275\u0275advance(4);
      \u0275\u0275conditional(4, ctx.loading ? 4 : 5);
    }
  },
  dependencies: [FormsModule, NgControlStatus, NgModel, NgTemplateOutlet, NzCheckboxModule, NzCheckboxComponent, NzRadioModule, NzRadioComponent, NzIconModule, NzIconDirective, NzTagModule, NzTagComponent, NzBadgeModule, NzBadgeComponent, NzToolTipModule, NzTooltipDirective, CellHostDirective],
  encapsulation: 2,
  changeDetection: 0
});
var CellComponent = _CellComponent;
__decorate([InputBoolean2()], CellComponent.prototype, "loading", void 0);
__decorate([InputBoolean2()], CellComponent.prototype, "disabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellComponent, [{
    type: Component,
    args: [{
      selector: "cell, [cell]",
      template: `
    <ng-template #text>
      @switch (safeOpt.type) {
        @case ('checkbox') {
          <label nz-checkbox [nzDisabled]="disabled" [ngModel]="value" (ngModelChange)="change($event)">
            {{ safeOpt.checkbox?.label }}
          </label>
        }
        @case ('radio') {
          <label nz-radio [nzDisabled]="disabled" [ngModel]="value" (ngModelChange)="change($event)">
            {{ safeOpt.radio?.label }}
          </label>
        }
        @case ('link') {
          <a (click)="_link($event)" [attr.target]="safeOpt.link?.target" [attr.title]="value" [innerHTML]="_text"></a>
        }
        @case ('tag') {
          <nz-tag [nzColor]="res?.result?.color">
            <span [innerHTML]="_text"></span>
          </nz-tag>
        }
        @case ('badge') {
          <nz-badge [nzStatus]="res?.result?.color" nzText="{{ _text }}" />
        }
        @case ('widget') {
          <ng-template cell-widget-host [data]="hostData" />
        }
        @case ('img') {
          @for (i of $any(_text); track $index) {
            <img
              [attr.src]="i"
              [attr.height]="safeOpt.img?.size"
              [attr.width]="safeOpt.img?.size"
              (click)="_showImg(i)"
              class="img"
              [class.point]="safeOpt.img?.big"
            />
          }
        }
        @default {
          @if (isText) {
            <span [innerText]="_text" [attr.title]="value"></span>
          } @else {
            <span [innerHTML]="_text" [attr.title]="value"></span>
          }
          @if (_unit) {
            <span class="unit">{{ _unit }}</span>
          }
        }
      }
    </ng-template>
    <ng-template #textWrap>
      @if (showDefault) {
        {{ safeOpt.default?.text }}
      } @else {
        @if (safeOpt.tooltip) {
          <span [nz-tooltip]="safeOpt.tooltip">
            <ng-template [ngTemplateOutlet]="text" />
          </span>
        } @else {
          <ng-template [ngTemplateOutlet]="text" />
        }
      }
    </ng-template>
    @if (loading) {
      <span nz-icon nzType="loading"></span>
    } @else {
      <ng-template [ngTemplateOutlet]="textWrap" />
    }
  `,
      exportAs: "cell",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [FormsModule, NgTemplateOutlet, NzCheckboxModule, NzRadioModule, NzIconModule, NzTagModule, NzBadgeModule, NzToolTipModule, CellHostDirective]
    }]
  }], () => [{
    type: CellService
  }, {
    type: Router
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NzImageService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [WINDOW]
    }]
  }], {
    value: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    options: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var COMPS = [CellComponent];
var _CellModule = class _CellModule {
};
_CellModule.\u0275fac = function CellModule_Factory(t) {
  return new (t || _CellModule)();
};
_CellModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _CellModule
});
_CellModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, FormsModule, NzCheckboxModule, NzRadioModule, NzBadgeModule, NzTagModule, NzToolTipModule, NzIconModule, NzImageModule2, COMPS]
});
var CellModule = _CellModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, NzCheckboxModule, NzRadioModule, NzBadgeModule, NzTagModule, NzToolTipModule, NzIconModule, NzImageModule2, ...COMPS, CellHostDirective],
      exports: COMPS
    }]
  }], null, null);
})();
function provideCellWidgets(...widgets) {
  return makeEnvironmentProviders([{
    provide: ENVIRONMENT_INITIALIZER,
    multi: true,
    useValue: () => {
      const srv = inject(CellService);
      widgets.forEach((widget) => srv.registerWidget(widget.KEY, widget.type));
    }
  }]);
}

// node_modules/isutf8/dist/index.esm.js
function isUtf8(buf) {
  if (!buf) {
    return false;
  }
  var i = 0;
  var len = buf.length;
  while (i < len) {
    if (buf[i] <= 127) {
      i++;
      continue;
    }
    if (buf[i] >= 194 && buf[i] <= 223) {
      if (buf[i + 1] >> 6 === 2) {
        i += 2;
        continue;
      } else {
        return false;
      }
    }
    if ((buf[i] === 224 && buf[i + 1] >= 160 && buf[i + 1] <= 191 || buf[i] === 237 && buf[i + 1] >= 128 && buf[i + 1] <= 159) && buf[i + 2] >> 6 === 2) {
      i += 3;
      continue;
    }
    if ((buf[i] >= 225 && buf[i] <= 236 || buf[i] >= 238 && buf[i] <= 239) && buf[i + 1] >> 6 === 2 && buf[i + 2] >> 6 === 2) {
      i += 3;
      continue;
    }
    if ((buf[i] === 240 && buf[i + 1] >= 144 && buf[i + 1] <= 191 || buf[i] >= 241 && buf[i] <= 243 && buf[i + 1] >> 6 === 2 || buf[i] === 244 && buf[i + 1] >= 128 && buf[i + 1] <= 143) && buf[i + 2] >> 6 === 2 && buf[i + 3] >> 6 === 2) {
      i += 4;
      continue;
    }
    return false;
  }
  return true;
}

// node_modules/@delon/abc/fesm2022/xlsx.mjs
var _XlsxService = class _XlsxService {
  constructor(http, lazy, configSrv, ngZone) {
    this.http = http;
    this.lazy = lazy;
    this.ngZone = ngZone;
    this.cog = configSrv.merge("xlsx", {
      url: "https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js",
      modules: [`https://cdn.jsdelivr.net/npm/xlsx/dist/cpexcel.js`]
    });
  }
  init() {
    return typeof XLSX !== "undefined" ? Promise.resolve([]) : this.lazy.load([this.cog.url].concat(this.cog.modules));
  }
  read(data) {
    const {
      read,
      utils: {
        sheet_to_json
      }
    } = XLSX;
    const ret = {};
    const buf = new Uint8Array(data);
    let type = "array";
    if (!isUtf8(buf)) {
      try {
        data = cptable.utils.decode(936, buf);
        type = "string";
      } catch {
      }
    }
    const wb = read(data, {
      type
    });
    wb.SheetNames.forEach((name) => {
      const sheet = wb.Sheets[name];
      ret[name] = sheet_to_json(sheet, {
        header: 1
      });
    });
    return ret;
  }
  /**
   * 导入Excel并输出JSON，支持 `<input type="file">`、URL 形式
   */
  import(fileOrUrl) {
    return new Promise((resolve, reject) => {
      const r = (data) => this.ngZone.run(() => resolve(this.read(data)));
      this.init().then(() => {
        if (typeof fileOrUrl === "string") {
          this.http.request("GET", fileOrUrl, {
            responseType: "arraybuffer"
          }).subscribe({
            next: (res) => r(new Uint8Array(res)),
            error: (err) => reject(err)
          });
          return;
        }
        const reader = new FileReader();
        reader.onload = (e) => r(e.target.result);
        reader.onerror = (e) => reject(e);
        reader.readAsArrayBuffer(fileOrUrl);
      }).catch(() => reject(`Unable to load xlsx.js`));
    });
  }
  export(options) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        this.init().then(() => {
          options = __spreadValues({
            format: "xlsx"
          }, options);
          const {
            writeFile,
            utils: {
              book_new,
              aoa_to_sheet,
              book_append_sheet
            }
          } = XLSX;
          const wb = book_new();
          if (Array.isArray(options.sheets)) {
            options.sheets.forEach((value, index) => {
              const ws = aoa_to_sheet(value.data);
              book_append_sheet(wb, ws, value.name || `Sheet${index + 1}`);
            });
          } else {
            wb.SheetNames = Object.keys(options.sheets);
            wb.Sheets = options.sheets;
          }
          if (options.callback)
            options.callback(wb);
          const filename = options.filename || `export.${options.format}`;
          writeFile(wb, filename, __spreadValues({
            bookType: options.format,
            bookSST: false,
            type: "array"
          }, options.opts));
          resolve({
            filename,
            wb
          });
        }).catch((err) => reject(err));
      });
    });
  }
  /**
   * 数据转符号名
   * - `1` => `A`
   * - `27` => `AA`
   * - `703` => `AAA`
   */
  numberToSchema(val) {
    const startCode = "A".charCodeAt(0);
    let res = "";
    do {
      --val;
      res = String.fromCharCode(startCode + val % 26) + res;
      val = val / 26 >> 0;
    } while (val > 0);
    return res;
  }
};
_XlsxService.\u0275fac = function XlsxService_Factory(t) {
  return new (t || _XlsxService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(LazyService), \u0275\u0275inject(AlainConfigService), \u0275\u0275inject(NgZone));
};
_XlsxService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _XlsxService,
  factory: _XlsxService.\u0275fac,
  providedIn: "root"
});
var XlsxService = _XlsxService;
__decorate([ZoneOutside()], XlsxService.prototype, "read", null);
__decorate([ZoneOutside()], XlsxService.prototype, "export", null);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XlsxService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }, {
    type: LazyService
  }, {
    type: AlainConfigService
  }, {
    type: NgZone
  }], {
    read: [],
    export: []
  });
})();
var _XlsxDirective = class _XlsxDirective {
  constructor(srv) {
    this.srv = srv;
  }
  _click() {
    this.srv.export(this.data);
  }
};
_XlsxDirective.\u0275fac = function XlsxDirective_Factory(t) {
  return new (t || _XlsxDirective)(\u0275\u0275directiveInject(XlsxService));
};
_XlsxDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _XlsxDirective,
  selectors: [["", "xlsx", ""]],
  hostBindings: function XlsxDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function XlsxDirective_click_HostBindingHandler() {
        return ctx._click();
      });
    }
  },
  inputs: {
    data: ["xlsx", "data"]
  },
  exportAs: ["xlsx"],
  standalone: true
});
var XlsxDirective = _XlsxDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XlsxDirective, [{
    type: Directive,
    args: [{
      selector: "[xlsx]",
      exportAs: "xlsx",
      host: {
        "(click)": "_click()"
      },
      standalone: true
    }]
  }], () => [{
    type: XlsxService
  }], {
    data: [{
      type: Input,
      args: ["xlsx"]
    }]
  });
})();
var COMPONENTS = [XlsxDirective];
var _XlsxModule = class _XlsxModule {
};
_XlsxModule.\u0275fac = function XlsxModule_Factory(t) {
  return new (t || _XlsxModule)();
};
_XlsxModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _XlsxModule
});
_XlsxModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var XlsxModule = _XlsxModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XlsxModule, [{
    type: NgModule,
    args: [{
      imports: [COMPONENTS],
      exports: COMPONENTS
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-menu.mjs
var _c09 = ["nz-menu-item", ""];
var _c15 = ["*"];
var _c24 = ["nz-submenu-inline-child", ""];
function NzSubmenuInlineChildComponent_ng_template_0_Template(rf, ctx) {
}
var _c3 = ["nz-submenu-none-inline-child", ""];
function NzSubmenuNoneInlineChildComponent_ng_template_1_Template(rf, ctx) {
}
var _c4 = ["nz-submenu-title", ""];
function NzSubMenuTitleComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzType", ctx_r0.nzIcon);
  }
}
function NzSubMenuTitleComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "span", 5);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.nzTitle);
  }
}
function NzSubMenuTitleComponent_span_3_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 9);
  }
}
function NzSubMenuTitleComponent_span_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 10);
  }
}
function NzSubMenuTitleComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 6);
    \u0275\u0275template(1, NzSubMenuTitleComponent_span_3_span_1_Template, 1, 0, "span", 7)(2, NzSubMenuTitleComponent_span_3_span_2_Template, 1, 0, "span", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngSwitch", ctx_r2.dir);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "rtl");
  }
}
function NzSubMenuTitleComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 11);
  }
}
var _c5 = ["nz-submenu", ""];
function NzSubMenuComponent_ng_content_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0, 0, ["*ngIf", "!nzTitle"]);
  }
}
function NzSubMenuComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 6);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(7);
    \u0275\u0275property("mode", ctx_r2.mode)("nzOpen", ctx_r2.nzOpen)("@.disabled", !!(ctx_r2.noAnimation == null ? null : ctx_r2.noAnimation.nzNoAnimation))("nzNoAnimation", ctx_r2.noAnimation == null ? null : ctx_r2.noAnimation.nzNoAnimation)("menuClass", ctx_r2.nzMenuClassName)("templateOutlet", _r6);
  }
}
function NzSubMenuComponent_ng_template_4_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275listener("subMenuMouseState", function NzSubMenuComponent_ng_template_4_ng_template_0_Template_div_subMenuMouseState_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r8 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r8.setMouseEnterState($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    const _r6 = \u0275\u0275reference(7);
    \u0275\u0275property("theme", ctx_r7.theme)("mode", ctx_r7.mode)("nzOpen", ctx_r7.nzOpen)("position", ctx_r7.position)("nzDisabled", ctx_r7.nzDisabled)("isMenuInsideDropDown", ctx_r7.isMenuInsideDropDown)("templateOutlet", _r6)("menuClass", ctx_r7.nzMenuClassName)("@.disabled", !!(ctx_r7.noAnimation == null ? null : ctx_r7.noAnimation.nzNoAnimation))("nzNoAnimation", ctx_r7.noAnimation == null ? null : ctx_r7.noAnimation.nzNoAnimation);
  }
}
function NzSubMenuComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275template(0, NzSubMenuComponent_ng_template_4_ng_template_0_Template, 1, 10, "ng-template", 7);
    \u0275\u0275listener("positionChange", function NzSubMenuComponent_ng_template_4_Template_ng_template_positionChange_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r10 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r10.onPositionChange($event));
    });
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("cdkConnectedOverlayPositions", ctx_r3.overlayPositions)("cdkConnectedOverlayOrigin", _r0)("cdkConnectedOverlayWidth", ctx_r3.triggerWidth)("cdkConnectedOverlayOpen", ctx_r3.nzOpen)("cdkConnectedOverlayTransformOriginOn", ".ant-menu-submenu");
  }
}
function NzSubMenuComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0, 1);
  }
}
var _c6 = [[["", "title", ""]], "*"];
var _c7 = ["[title]", "*"];
var _c8 = ["titleElement"];
var _c9 = ["nz-menu-group", ""];
function NzMenuGroupComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r1.nzTitle);
  }
}
function NzMenuGroupComponent_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0, 1, ["*ngIf", "!nzTitle"]);
  }
}
var _c10 = ["*", [["", "title", ""]]];
var _c11 = ["*", "[title]"];
var NzIsMenuInsideDropDownToken = new InjectionToken("NzIsInDropDownMenuToken");
var NzMenuServiceLocalToken = new InjectionToken("NzMenuServiceLocalToken");
var _MenuService = class _MenuService {
  constructor() {
    this.descendantMenuItemClick$ = new Subject();
    this.childMenuItemClick$ = new Subject();
    this.theme$ = new BehaviorSubject("light");
    this.mode$ = new BehaviorSubject("vertical");
    this.inlineIndent$ = new BehaviorSubject(24);
    this.isChildSubMenuOpen$ = new BehaviorSubject(false);
  }
  onDescendantMenuItemClick(menu) {
    this.descendantMenuItemClick$.next(menu);
  }
  onChildMenuItemClick(menu) {
    this.childMenuItemClick$.next(menu);
  }
  setMode(mode) {
    this.mode$.next(mode);
  }
  setTheme(theme) {
    this.theme$.next(theme);
  }
  setInlineIndent(indent) {
    this.inlineIndent$.next(indent);
  }
};
_MenuService.\u0275fac = function MenuService_Factory(t) {
  return new (t || _MenuService)();
};
_MenuService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _MenuService,
  factory: _MenuService.\u0275fac
});
var MenuService2 = _MenuService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuService2, [{
    type: Injectable
  }], null, null);
})();
var _NzSubmenuService = class _NzSubmenuService {
  /**
   * menu item inside submenu clicked
   *
   * @param menu
   */
  onChildMenuItemClick(menu) {
    this.childMenuItemClick$.next(menu);
  }
  setOpenStateWithoutDebounce(value) {
    this.isCurrentSubMenuOpen$.next(value);
  }
  setMouseEnterTitleOrOverlayState(value) {
    this.isMouseEnterTitleOrOverlay$.next(value);
  }
  constructor(nzHostSubmenuService, nzMenuService, isMenuInsideDropDown) {
    this.nzHostSubmenuService = nzHostSubmenuService;
    this.nzMenuService = nzMenuService;
    this.isMenuInsideDropDown = isMenuInsideDropDown;
    this.mode$ = this.nzMenuService.mode$.pipe(map((mode) => {
      if (mode === "inline") {
        return "inline";
      } else if (mode === "vertical" || this.nzHostSubmenuService) {
        return "vertical";
      } else {
        return "horizontal";
      }
    }));
    this.level = 1;
    this.isCurrentSubMenuOpen$ = new BehaviorSubject(false);
    this.isChildSubMenuOpen$ = new BehaviorSubject(false);
    this.isMouseEnterTitleOrOverlay$ = new Subject();
    this.childMenuItemClick$ = new Subject();
    this.destroy$ = new Subject();
    if (this.nzHostSubmenuService) {
      this.level = this.nzHostSubmenuService.level + 1;
    }
    const isClosedByMenuItemClick = this.childMenuItemClick$.pipe(mergeMap(() => this.mode$), filter((mode) => mode !== "inline" || this.isMenuInsideDropDown), mapTo(false));
    const isCurrentSubmenuOpen$ = merge(this.isMouseEnterTitleOrOverlay$, isClosedByMenuItemClick);
    const isSubMenuOpenWithDebounce$ = combineLatest([this.isChildSubMenuOpen$, isCurrentSubmenuOpen$]).pipe(map(([isChildSubMenuOpen, isCurrentSubmenuOpen]) => isChildSubMenuOpen || isCurrentSubmenuOpen), auditTime(150), distinctUntilChanged(), takeUntil(this.destroy$));
    isSubMenuOpenWithDebounce$.pipe(distinctUntilChanged()).subscribe((data) => {
      this.setOpenStateWithoutDebounce(data);
      if (this.nzHostSubmenuService) {
        this.nzHostSubmenuService.isChildSubMenuOpen$.next(data);
      } else {
        this.nzMenuService.isChildSubMenuOpen$.next(data);
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzSubmenuService.\u0275fac = function NzSubmenuService_Factory(t) {
  return new (t || _NzSubmenuService)(\u0275\u0275inject(_NzSubmenuService, 12), \u0275\u0275inject(MenuService2), \u0275\u0275inject(NzIsMenuInsideDropDownToken));
};
_NzSubmenuService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzSubmenuService,
  factory: _NzSubmenuService.\u0275fac
});
var NzSubmenuService = _NzSubmenuService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSubmenuService, [{
    type: Injectable
  }], () => [{
    type: NzSubmenuService,
    decorators: [{
      type: SkipSelf
    }, {
      type: Optional
    }]
  }, {
    type: MenuService2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NzIsMenuInsideDropDownToken]
    }]
  }], null);
})();
var _NzMenuItemComponent = class _NzMenuItemComponent {
  /** clear all item selected status except this */
  clickMenuItem(e) {
    if (this.nzDisabled) {
      e.preventDefault();
      e.stopPropagation();
    } else {
      this.nzMenuService.onDescendantMenuItemClick(this);
      if (this.nzSubmenuService) {
        this.nzSubmenuService.onChildMenuItemClick(this);
      } else {
        this.nzMenuService.onChildMenuItemClick(this);
      }
    }
  }
  setSelectedState(value) {
    this.nzSelected = value;
    this.selected$.next(value);
  }
  updateRouterActive() {
    if (!this.listOfRouterLink || !this.router || !this.router.navigated || !this.nzMatchRouter) {
      return;
    }
    Promise.resolve().then(() => {
      const hasActiveLinks = this.hasActiveLinks();
      if (this.nzSelected !== hasActiveLinks) {
        this.nzSelected = hasActiveLinks;
        this.setSelectedState(this.nzSelected);
        this.cdr.markForCheck();
      }
    });
  }
  hasActiveLinks() {
    const isActiveCheckFn = this.isLinkActive(this.router);
    return this.routerLink && isActiveCheckFn(this.routerLink) || this.listOfRouterLink.some(isActiveCheckFn);
  }
  isLinkActive(router) {
    return (link) => router.isActive(link.urlTree || "", {
      paths: this.nzMatchRouterExact ? "exact" : "subset",
      queryParams: this.nzMatchRouterExact ? "exact" : "subset",
      fragment: "ignored",
      matrixParams: "ignored"
    });
  }
  constructor(nzMenuService, cdr, nzSubmenuService, isMenuInsideDropDown, directionality, routerLink, router) {
    this.nzMenuService = nzMenuService;
    this.cdr = cdr;
    this.nzSubmenuService = nzSubmenuService;
    this.isMenuInsideDropDown = isMenuInsideDropDown;
    this.directionality = directionality;
    this.routerLink = routerLink;
    this.router = router;
    this.destroy$ = new Subject();
    this.level = this.nzSubmenuService ? this.nzSubmenuService.level + 1 : 1;
    this.selected$ = new Subject();
    this.inlinePaddingLeft = null;
    this.dir = "ltr";
    this.nzDisabled = false;
    this.nzSelected = false;
    this.nzDanger = false;
    this.nzMatchRouterExact = false;
    this.nzMatchRouter = false;
    if (router) {
      this.router.events.pipe(takeUntil(this.destroy$), filter((e) => e instanceof NavigationEnd)).subscribe(() => {
        this.updateRouterActive();
      });
    }
  }
  ngOnInit() {
    combineLatest([this.nzMenuService.mode$, this.nzMenuService.inlineIndent$]).pipe(takeUntil(this.destroy$)).subscribe(([mode, inlineIndent]) => {
      this.inlinePaddingLeft = mode === "inline" ? this.level * inlineIndent : null;
    });
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngAfterContentInit() {
    this.listOfRouterLink.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.updateRouterActive());
    this.updateRouterActive();
  }
  ngOnChanges(changes) {
    if (changes.nzSelected) {
      this.setSelectedState(this.nzSelected);
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzMenuItemComponent.\u0275fac = function NzMenuItemComponent_Factory(t) {
  return new (t || _NzMenuItemComponent)(\u0275\u0275directiveInject(MenuService2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzSubmenuService, 8), \u0275\u0275directiveInject(NzIsMenuInsideDropDownToken), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(RouterLink, 8), \u0275\u0275directiveInject(Router, 8));
};
_NzMenuItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzMenuItemComponent,
  selectors: [["", "nz-menu-item", ""]],
  contentQueries: function NzMenuItemComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, RouterLink, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfRouterLink = _t);
    }
  },
  hostVars: 20,
  hostBindings: function NzMenuItemComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzMenuItemComponent_click_HostBindingHandler($event) {
        return ctx.clickMenuItem($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275styleProp("padding-left", ctx.dir === "rtl" ? null : ctx.nzPaddingLeft || ctx.inlinePaddingLeft, "px")("padding-right", ctx.dir === "rtl" ? ctx.nzPaddingLeft || ctx.inlinePaddingLeft : null, "px");
      \u0275\u0275classProp("ant-dropdown-menu-item", ctx.isMenuInsideDropDown)("ant-dropdown-menu-item-selected", ctx.isMenuInsideDropDown && ctx.nzSelected)("ant-dropdown-menu-item-danger", ctx.isMenuInsideDropDown && ctx.nzDanger)("ant-dropdown-menu-item-disabled", ctx.isMenuInsideDropDown && ctx.nzDisabled)("ant-menu-item", !ctx.isMenuInsideDropDown)("ant-menu-item-selected", !ctx.isMenuInsideDropDown && ctx.nzSelected)("ant-menu-item-danger", !ctx.isMenuInsideDropDown && ctx.nzDanger)("ant-menu-item-disabled", !ctx.isMenuInsideDropDown && ctx.nzDisabled);
    }
  },
  inputs: {
    nzPaddingLeft: "nzPaddingLeft",
    nzDisabled: "nzDisabled",
    nzSelected: "nzSelected",
    nzDanger: "nzDanger",
    nzMatchRouterExact: "nzMatchRouterExact",
    nzMatchRouter: "nzMatchRouter"
  },
  exportAs: ["nzMenuItem"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c09,
  ngContentSelectors: _c15,
  decls: 2,
  vars: 0,
  consts: [[1, "ant-menu-title-content"]],
  template: function NzMenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzMenuItemComponent = _NzMenuItemComponent;
__decorate([InputBoolean()], NzMenuItemComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzMenuItemComponent.prototype, "nzSelected", void 0);
__decorate([InputBoolean()], NzMenuItemComponent.prototype, "nzDanger", void 0);
__decorate([InputBoolean()], NzMenuItemComponent.prototype, "nzMatchRouterExact", void 0);
__decorate([InputBoolean()], NzMenuItemComponent.prototype, "nzMatchRouter", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMenuItemComponent, [{
    type: Component,
    args: [{
      selector: "[nz-menu-item]",
      exportAs: "nzMenuItem",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      preserveWhitespaces: false,
      template: `
    <span class="ant-menu-title-content">
      <ng-content></ng-content>
    </span>
  `,
      host: {
        "[class.ant-dropdown-menu-item]": `isMenuInsideDropDown`,
        "[class.ant-dropdown-menu-item-selected]": `isMenuInsideDropDown && nzSelected`,
        "[class.ant-dropdown-menu-item-danger]": `isMenuInsideDropDown && nzDanger`,
        "[class.ant-dropdown-menu-item-disabled]": `isMenuInsideDropDown && nzDisabled`,
        "[class.ant-menu-item]": `!isMenuInsideDropDown`,
        "[class.ant-menu-item-selected]": `!isMenuInsideDropDown && nzSelected`,
        "[class.ant-menu-item-danger]": `!isMenuInsideDropDown && nzDanger`,
        "[class.ant-menu-item-disabled]": `!isMenuInsideDropDown && nzDisabled`,
        "[style.paddingLeft.px]": `dir === 'rtl' ? null : nzPaddingLeft || inlinePaddingLeft`,
        "[style.paddingRight.px]": `dir === 'rtl' ? nzPaddingLeft || inlinePaddingLeft : null`,
        "(click)": "clickMenuItem($event)"
      },
      standalone: true
    }]
  }], () => [{
    type: MenuService2
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzSubmenuService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NzIsMenuInsideDropDownToken]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: RouterLink,
    decorators: [{
      type: Optional
    }]
  }, {
    type: Router,
    decorators: [{
      type: Optional
    }]
  }], {
    nzPaddingLeft: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzSelected: [{
      type: Input
    }],
    nzDanger: [{
      type: Input
    }],
    nzMatchRouterExact: [{
      type: Input
    }],
    nzMatchRouter: [{
      type: Input
    }],
    listOfRouterLink: [{
      type: ContentChildren,
      args: [RouterLink, {
        descendants: true
      }]
    }]
  });
})();
var _NzSubmenuInlineChildComponent = class _NzSubmenuInlineChildComponent {
  constructor(elementRef, renderer, directionality) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.directionality = directionality;
    this.templateOutlet = null;
    this.menuClass = "";
    this.mode = "vertical";
    this.nzOpen = false;
    this.listOfCacheClassName = [];
    this.expandState = "collapsed";
    this.dir = "ltr";
    this.destroy$ = new Subject();
  }
  calcMotionState() {
    if (this.nzOpen) {
      this.expandState = "expanded";
    } else {
      this.expandState = "collapsed";
    }
  }
  ngOnInit() {
    this.calcMotionState();
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngOnChanges(changes) {
    const {
      mode,
      nzOpen,
      menuClass
    } = changes;
    if (mode || nzOpen) {
      this.calcMotionState();
    }
    if (menuClass) {
      if (this.listOfCacheClassName.length) {
        this.listOfCacheClassName.filter((item) => !!item).forEach((className) => {
          this.renderer.removeClass(this.elementRef.nativeElement, className);
        });
      }
      if (this.menuClass) {
        this.listOfCacheClassName = this.menuClass.split(" ");
        this.listOfCacheClassName.filter((item) => !!item).forEach((className) => {
          this.renderer.addClass(this.elementRef.nativeElement, className);
        });
      }
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzSubmenuInlineChildComponent.\u0275fac = function NzSubmenuInlineChildComponent_Factory(t) {
  return new (t || _NzSubmenuInlineChildComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(Directionality, 8));
};
_NzSubmenuInlineChildComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSubmenuInlineChildComponent,
  selectors: [["", "nz-submenu-inline-child", ""]],
  hostAttrs: [1, "ant-menu", "ant-menu-inline", "ant-menu-sub"],
  hostVars: 3,
  hostBindings: function NzSubmenuInlineChildComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275syntheticHostProperty("@collapseMotion", ctx.expandState);
      \u0275\u0275classProp("ant-menu-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    templateOutlet: "templateOutlet",
    menuClass: "menuClass",
    mode: "mode",
    nzOpen: "nzOpen"
  },
  exportAs: ["nzSubmenuInlineChild"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c24,
  decls: 1,
  vars: 1,
  consts: [[3, "ngTemplateOutlet"]],
  template: function NzSubmenuInlineChildComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzSubmenuInlineChildComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngTemplateOutlet", ctx.templateOutlet);
    }
  },
  dependencies: [NgTemplateOutlet],
  encapsulation: 2,
  data: {
    animation: [collapseMotion]
  },
  changeDetection: 0
});
var NzSubmenuInlineChildComponent = _NzSubmenuInlineChildComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSubmenuInlineChildComponent, [{
    type: Component,
    args: [{
      selector: "[nz-submenu-inline-child]",
      animations: [collapseMotion],
      exportAs: "nzSubmenuInlineChild",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: ` <ng-template [ngTemplateOutlet]="templateOutlet"></ng-template> `,
      host: {
        class: "ant-menu ant-menu-inline ant-menu-sub",
        "[class.ant-menu-rtl]": `dir === 'rtl'`,
        "[@collapseMotion]": "expandState"
      },
      imports: [NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    templateOutlet: [{
      type: Input
    }],
    menuClass: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    nzOpen: [{
      type: Input
    }]
  });
})();
var _NzSubmenuNoneInlineChildComponent = class _NzSubmenuNoneInlineChildComponent {
  constructor(directionality) {
    this.directionality = directionality;
    this.menuClass = "";
    this.theme = "light";
    this.templateOutlet = null;
    this.isMenuInsideDropDown = false;
    this.mode = "vertical";
    this.position = "right";
    this.nzDisabled = false;
    this.nzOpen = false;
    this.subMenuMouseState = new EventEmitter();
    this.expandState = "collapsed";
    this.dir = "ltr";
    this.destroy$ = new Subject();
  }
  setMouseState(state2) {
    if (!this.nzDisabled) {
      this.subMenuMouseState.next(state2);
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  calcMotionState() {
    if (this.nzOpen) {
      if (this.mode === "horizontal") {
        this.expandState = "bottom";
      } else if (this.mode === "vertical") {
        this.expandState = "active";
      }
    } else {
      this.expandState = "collapsed";
    }
  }
  ngOnInit() {
    this.calcMotionState();
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngOnChanges(changes) {
    const {
      mode,
      nzOpen
    } = changes;
    if (mode || nzOpen) {
      this.calcMotionState();
    }
  }
};
_NzSubmenuNoneInlineChildComponent.\u0275fac = function NzSubmenuNoneInlineChildComponent_Factory(t) {
  return new (t || _NzSubmenuNoneInlineChildComponent)(\u0275\u0275directiveInject(Directionality, 8));
};
_NzSubmenuNoneInlineChildComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSubmenuNoneInlineChildComponent,
  selectors: [["", "nz-submenu-none-inline-child", ""]],
  hostAttrs: [1, "ant-menu-submenu", "ant-menu-submenu-popup"],
  hostVars: 14,
  hostBindings: function NzSubmenuNoneInlineChildComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseenter", function NzSubmenuNoneInlineChildComponent_mouseenter_HostBindingHandler() {
        return ctx.setMouseState(true);
      })("mouseleave", function NzSubmenuNoneInlineChildComponent_mouseleave_HostBindingHandler() {
        return ctx.setMouseState(false);
      });
    }
    if (rf & 2) {
      \u0275\u0275syntheticHostProperty("@slideMotion", ctx.expandState)("@zoomBigMotion", ctx.expandState);
      \u0275\u0275classProp("ant-menu-light", ctx.theme === "light")("ant-menu-dark", ctx.theme === "dark")("ant-menu-submenu-placement-bottom", ctx.mode === "horizontal")("ant-menu-submenu-placement-right", ctx.mode === "vertical" && ctx.position === "right")("ant-menu-submenu-placement-left", ctx.mode === "vertical" && ctx.position === "left")("ant-menu-submenu-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    menuClass: "menuClass",
    theme: "theme",
    templateOutlet: "templateOutlet",
    isMenuInsideDropDown: "isMenuInsideDropDown",
    mode: "mode",
    position: "position",
    nzDisabled: "nzDisabled",
    nzOpen: "nzOpen"
  },
  outputs: {
    subMenuMouseState: "subMenuMouseState"
  },
  exportAs: ["nzSubmenuNoneInlineChild"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c3,
  decls: 2,
  vars: 16,
  consts: [[3, "ngClass"], [3, "ngTemplateOutlet"]],
  template: function NzSubmenuNoneInlineChildComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, NzSubmenuNoneInlineChildComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-dropdown-menu", ctx.isMenuInsideDropDown)("ant-menu", !ctx.isMenuInsideDropDown)("ant-dropdown-menu-vertical", ctx.isMenuInsideDropDown)("ant-menu-vertical", !ctx.isMenuInsideDropDown)("ant-dropdown-menu-sub", ctx.isMenuInsideDropDown)("ant-menu-sub", !ctx.isMenuInsideDropDown)("ant-menu-rtl", ctx.dir === "rtl");
      \u0275\u0275property("ngClass", ctx.menuClass);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngTemplateOutlet", ctx.templateOutlet);
    }
  },
  dependencies: [NgClass, NgTemplateOutlet],
  encapsulation: 2,
  data: {
    animation: [zoomBigMotion, slideMotion]
  },
  changeDetection: 0
});
var NzSubmenuNoneInlineChildComponent = _NzSubmenuNoneInlineChildComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSubmenuNoneInlineChildComponent, [{
    type: Component,
    args: [{
      selector: "[nz-submenu-none-inline-child]",
      exportAs: "nzSubmenuNoneInlineChild",
      encapsulation: ViewEncapsulation$1.None,
      animations: [zoomBigMotion, slideMotion],
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <div
      [class.ant-dropdown-menu]="isMenuInsideDropDown"
      [class.ant-menu]="!isMenuInsideDropDown"
      [class.ant-dropdown-menu-vertical]="isMenuInsideDropDown"
      [class.ant-menu-vertical]="!isMenuInsideDropDown"
      [class.ant-dropdown-menu-sub]="isMenuInsideDropDown"
      [class.ant-menu-sub]="!isMenuInsideDropDown"
      [class.ant-menu-rtl]="dir === 'rtl'"
      [ngClass]="menuClass"
    >
      <ng-template [ngTemplateOutlet]="templateOutlet"></ng-template>
    </div>
  `,
      host: {
        class: "ant-menu-submenu ant-menu-submenu-popup",
        "[class.ant-menu-light]": "theme === 'light'",
        "[class.ant-menu-dark]": "theme === 'dark'",
        "[class.ant-menu-submenu-placement-bottom]": "mode === 'horizontal'",
        "[class.ant-menu-submenu-placement-right]": "mode === 'vertical' && position === 'right'",
        "[class.ant-menu-submenu-placement-left]": "mode === 'vertical' && position === 'left'",
        "[class.ant-menu-submenu-rtl]": 'dir ==="rtl"',
        "[@slideMotion]": "expandState",
        "[@zoomBigMotion]": "expandState",
        "(mouseenter)": "setMouseState(true)",
        "(mouseleave)": "setMouseState(false)"
      },
      imports: [NgClass, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    menuClass: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    templateOutlet: [{
      type: Input
    }],
    isMenuInsideDropDown: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzOpen: [{
      type: Input
    }],
    subMenuMouseState: [{
      type: Output
    }]
  });
})();
var _NzSubMenuTitleComponent = class _NzSubMenuTitleComponent {
  constructor(cdr, directionality) {
    this.cdr = cdr;
    this.directionality = directionality;
    this.nzIcon = null;
    this.nzTitle = null;
    this.isMenuInsideDropDown = false;
    this.nzDisabled = false;
    this.paddingLeft = null;
    this.mode = "vertical";
    this.toggleSubMenu = new EventEmitter();
    this.subMenuMouseState = new EventEmitter();
    this.dir = "ltr";
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  setMouseState(state2) {
    if (!this.nzDisabled) {
      this.subMenuMouseState.next(state2);
    }
  }
  clickTitle() {
    if (this.mode === "inline" && !this.nzDisabled) {
      this.toggleSubMenu.emit();
    }
  }
};
_NzSubMenuTitleComponent.\u0275fac = function NzSubMenuTitleComponent_Factory(t) {
  return new (t || _NzSubMenuTitleComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzSubMenuTitleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSubMenuTitleComponent,
  selectors: [["", "nz-submenu-title", ""]],
  hostVars: 8,
  hostBindings: function NzSubMenuTitleComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzSubMenuTitleComponent_click_HostBindingHandler() {
        return ctx.clickTitle();
      })("mouseenter", function NzSubMenuTitleComponent_mouseenter_HostBindingHandler() {
        return ctx.setMouseState(true);
      })("mouseleave", function NzSubMenuTitleComponent_mouseleave_HostBindingHandler() {
        return ctx.setMouseState(false);
      });
    }
    if (rf & 2) {
      \u0275\u0275styleProp("padding-left", ctx.dir === "rtl" ? null : ctx.paddingLeft, "px")("padding-right", ctx.dir === "rtl" ? ctx.paddingLeft : null, "px");
      \u0275\u0275classProp("ant-dropdown-menu-submenu-title", ctx.isMenuInsideDropDown)("ant-menu-submenu-title", !ctx.isMenuInsideDropDown);
    }
  },
  inputs: {
    nzIcon: "nzIcon",
    nzTitle: "nzTitle",
    isMenuInsideDropDown: "isMenuInsideDropDown",
    nzDisabled: "nzDisabled",
    paddingLeft: "paddingLeft",
    mode: "mode"
  },
  outputs: {
    toggleSubMenu: "toggleSubMenu",
    subMenuMouseState: "subMenuMouseState"
  },
  exportAs: ["nzSubmenuTitle"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c4,
  ngContentSelectors: _c15,
  decls: 6,
  vars: 4,
  consts: [["nz-icon", "", 3, "nzType", 4, "ngIf"], [4, "nzStringTemplateOutlet"], ["class", "ant-dropdown-menu-submenu-expand-icon", 3, "ngSwitch", 4, "ngIf", "ngIfElse"], ["notDropdownTpl", ""], ["nz-icon", "", 3, "nzType"], [1, "ant-menu-title-content"], [1, "ant-dropdown-menu-submenu-expand-icon", 3, "ngSwitch"], ["nz-icon", "", "nzType", "left", "class", "ant-dropdown-menu-submenu-arrow-icon", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "right", "class", "ant-dropdown-menu-submenu-arrow-icon", 4, "ngSwitchDefault"], ["nz-icon", "", "nzType", "left", 1, "ant-dropdown-menu-submenu-arrow-icon"], ["nz-icon", "", "nzType", "right", 1, "ant-dropdown-menu-submenu-arrow-icon"], [1, "ant-menu-submenu-arrow"]],
  template: function NzSubMenuTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzSubMenuTitleComponent_span_0_Template, 1, 1, "span", 0)(1, NzSubMenuTitleComponent_ng_container_1_Template, 3, 1, "ng-container", 1);
      \u0275\u0275projection(2);
      \u0275\u0275template(3, NzSubMenuTitleComponent_span_3_Template, 3, 2, "span", 2)(4, NzSubMenuTitleComponent_ng_template_4_Template, 1, 0, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r4 = \u0275\u0275reference(5);
      \u0275\u0275property("ngIf", ctx.nzIcon);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzTitle);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.isMenuInsideDropDown)("ngIfElse", _r4);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NgIf, NzOutletModule, NzStringTemplateOutletDirective, NgSwitch, NgSwitchCase, NgSwitchDefault],
  encapsulation: 2,
  changeDetection: 0
});
var NzSubMenuTitleComponent = _NzSubMenuTitleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSubMenuTitleComponent, [{
    type: Component,
    args: [{
      selector: "[nz-submenu-title]",
      exportAs: "nzSubmenuTitle",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span nz-icon [nzType]="nzIcon" *ngIf="nzIcon"></span>
    <ng-container *nzStringTemplateOutlet="nzTitle">
      <span class="ant-menu-title-content">{{ nzTitle }}</span>
    </ng-container>
    <ng-content></ng-content>
    <span
      [ngSwitch]="dir"
      *ngIf="isMenuInsideDropDown; else notDropdownTpl"
      class="ant-dropdown-menu-submenu-expand-icon"
    >
      <span *ngSwitchCase="'rtl'" nz-icon nzType="left" class="ant-dropdown-menu-submenu-arrow-icon"></span>
      <span *ngSwitchDefault nz-icon nzType="right" class="ant-dropdown-menu-submenu-arrow-icon"></span>
    </span>
    <ng-template #notDropdownTpl>
      <span class="ant-menu-submenu-arrow"></span>
    </ng-template>
  `,
      host: {
        "[class.ant-dropdown-menu-submenu-title]": "isMenuInsideDropDown",
        "[class.ant-menu-submenu-title]": "!isMenuInsideDropDown",
        "[style.paddingLeft.px]": `dir === 'rtl' ? null : paddingLeft `,
        "[style.paddingRight.px]": `dir === 'rtl' ? paddingLeft : null`,
        "(click)": "clickTitle()",
        "(mouseenter)": "setMouseState(true)",
        "(mouseleave)": "setMouseState(false)"
      },
      imports: [NzIconModule, NgIf, NzOutletModule, NgSwitch, NgSwitchCase, NgSwitchDefault],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzIcon: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    isMenuInsideDropDown: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    paddingLeft: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    toggleSubMenu: [{
      type: Output
    }],
    subMenuMouseState: [{
      type: Output
    }]
  });
})();
var listOfVerticalPositions = [POSITION_MAP.rightTop, POSITION_MAP.right, POSITION_MAP.rightBottom, POSITION_MAP.leftTop, POSITION_MAP.left, POSITION_MAP.leftBottom];
var listOfHorizontalPositions = [POSITION_MAP.bottomLeft, POSITION_MAP.bottomRight, POSITION_MAP.topRight, POSITION_MAP.topLeft];
var _NzSubMenuComponent = class _NzSubMenuComponent {
  /** set the submenu host open status directly **/
  setOpenStateWithoutDebounce(open) {
    this.nzSubmenuService.setOpenStateWithoutDebounce(open);
  }
  toggleSubMenu() {
    this.setOpenStateWithoutDebounce(!this.nzOpen);
  }
  setMouseEnterState(value) {
    this.isActive = value;
    if (this.mode !== "inline") {
      this.nzSubmenuService.setMouseEnterTitleOrOverlayState(value);
    }
  }
  setTriggerWidth() {
    if (this.mode === "horizontal" && this.platform.isBrowser && this.cdkOverlayOrigin && this.nzPlacement === "bottomLeft") {
      this.triggerWidth = this.cdkOverlayOrigin.nativeElement.getBoundingClientRect().width;
    }
  }
  onPositionChange(position) {
    const placement = getPlacementName(position);
    if (placement === "rightTop" || placement === "rightBottom" || placement === "right") {
      this.position = "right";
    } else if (placement === "leftTop" || placement === "leftBottom" || placement === "left") {
      this.position = "left";
    }
  }
  constructor(nzMenuService, cdr, nzSubmenuService, platform, isMenuInsideDropDown, directionality, noAnimation) {
    this.nzMenuService = nzMenuService;
    this.cdr = cdr;
    this.nzSubmenuService = nzSubmenuService;
    this.platform = platform;
    this.isMenuInsideDropDown = isMenuInsideDropDown;
    this.directionality = directionality;
    this.noAnimation = noAnimation;
    this.nzMenuClassName = "";
    this.nzPaddingLeft = null;
    this.nzTitle = null;
    this.nzIcon = null;
    this.nzOpen = false;
    this.nzDisabled = false;
    this.nzPlacement = "bottomLeft";
    this.nzOpenChange = new EventEmitter();
    this.cdkOverlayOrigin = null;
    this.listOfNzSubMenuComponent = null;
    this.listOfNzMenuItemDirective = null;
    this.level = this.nzSubmenuService.level;
    this.destroy$ = new Subject();
    this.position = "right";
    this.triggerWidth = null;
    this.theme = "light";
    this.mode = "vertical";
    this.inlinePaddingLeft = null;
    this.overlayPositions = listOfVerticalPositions;
    this.isSelected = false;
    this.isActive = false;
    this.dir = "ltr";
  }
  ngOnInit() {
    this.nzMenuService.theme$.pipe(takeUntil(this.destroy$)).subscribe((theme) => {
      this.theme = theme;
      this.cdr.markForCheck();
    });
    this.nzSubmenuService.mode$.pipe(takeUntil(this.destroy$)).subscribe((mode) => {
      this.mode = mode;
      if (mode === "horizontal") {
        this.overlayPositions = [POSITION_MAP[this.nzPlacement], ...listOfHorizontalPositions];
      } else if (mode === "vertical") {
        this.overlayPositions = listOfVerticalPositions;
      }
      this.cdr.markForCheck();
    });
    combineLatest([this.nzSubmenuService.mode$, this.nzMenuService.inlineIndent$]).pipe(takeUntil(this.destroy$)).subscribe(([mode, inlineIndent]) => {
      this.inlinePaddingLeft = mode === "inline" ? this.level * inlineIndent : null;
      this.cdr.markForCheck();
    });
    this.nzSubmenuService.isCurrentSubMenuOpen$.pipe(takeUntil(this.destroy$)).subscribe((open) => {
      this.isActive = open;
      if (open !== this.nzOpen) {
        this.setTriggerWidth();
        this.nzOpen = open;
        this.nzOpenChange.emit(this.nzOpen);
        this.cdr.markForCheck();
      }
    });
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.markForCheck();
    });
  }
  ngAfterContentInit() {
    this.setTriggerWidth();
    const listOfNzMenuItemDirective = this.listOfNzMenuItemDirective;
    const changes = listOfNzMenuItemDirective.changes;
    const mergedObservable = merge(...[changes, ...listOfNzMenuItemDirective.map((menu) => menu.selected$)]);
    changes.pipe(startWith(listOfNzMenuItemDirective), switchMap(() => mergedObservable), startWith(true), map(() => listOfNzMenuItemDirective.some((e) => e.nzSelected)), takeUntil(this.destroy$)).subscribe((selected) => {
      this.isSelected = selected;
      this.cdr.markForCheck();
    });
  }
  ngOnChanges(changes) {
    const {
      nzOpen
    } = changes;
    if (nzOpen) {
      this.nzSubmenuService.setOpenStateWithoutDebounce(this.nzOpen);
      this.setTriggerWidth();
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzSubMenuComponent.\u0275fac = function NzSubMenuComponent_Factory(t) {
  return new (t || _NzSubMenuComponent)(\u0275\u0275directiveInject(MenuService2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzSubmenuService), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(NzIsMenuInsideDropDownToken), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzSubMenuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSubMenuComponent,
  selectors: [["", "nz-submenu", ""]],
  contentQueries: function NzSubMenuComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _NzSubMenuComponent, 5);
      \u0275\u0275contentQuery(dirIndex, NzMenuItemComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzSubMenuComponent = _t);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzMenuItemDirective = _t);
    }
  },
  viewQuery: function NzSubMenuComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(CdkOverlayOrigin, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.cdkOverlayOrigin = _t.first);
    }
  },
  hostVars: 34,
  hostBindings: function NzSubMenuComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-dropdown-menu-submenu", ctx.isMenuInsideDropDown)("ant-dropdown-menu-submenu-disabled", ctx.isMenuInsideDropDown && ctx.nzDisabled)("ant-dropdown-menu-submenu-open", ctx.isMenuInsideDropDown && ctx.nzOpen)("ant-dropdown-menu-submenu-selected", ctx.isMenuInsideDropDown && ctx.isSelected)("ant-dropdown-menu-submenu-vertical", ctx.isMenuInsideDropDown && ctx.mode === "vertical")("ant-dropdown-menu-submenu-horizontal", ctx.isMenuInsideDropDown && ctx.mode === "horizontal")("ant-dropdown-menu-submenu-inline", ctx.isMenuInsideDropDown && ctx.mode === "inline")("ant-dropdown-menu-submenu-active", ctx.isMenuInsideDropDown && ctx.isActive)("ant-menu-submenu", !ctx.isMenuInsideDropDown)("ant-menu-submenu-disabled", !ctx.isMenuInsideDropDown && ctx.nzDisabled)("ant-menu-submenu-open", !ctx.isMenuInsideDropDown && ctx.nzOpen)("ant-menu-submenu-selected", !ctx.isMenuInsideDropDown && ctx.isSelected)("ant-menu-submenu-vertical", !ctx.isMenuInsideDropDown && ctx.mode === "vertical")("ant-menu-submenu-horizontal", !ctx.isMenuInsideDropDown && ctx.mode === "horizontal")("ant-menu-submenu-inline", !ctx.isMenuInsideDropDown && ctx.mode === "inline")("ant-menu-submenu-active", !ctx.isMenuInsideDropDown && ctx.isActive)("ant-menu-submenu-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzMenuClassName: "nzMenuClassName",
    nzPaddingLeft: "nzPaddingLeft",
    nzTitle: "nzTitle",
    nzIcon: "nzIcon",
    nzOpen: "nzOpen",
    nzDisabled: "nzDisabled",
    nzPlacement: "nzPlacement"
  },
  outputs: {
    nzOpenChange: "nzOpenChange"
  },
  exportAs: ["nzSubmenu"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzSubmenuService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c5,
  ngContentSelectors: _c7,
  decls: 8,
  vars: 9,
  consts: [["nz-submenu-title", "", "cdkOverlayOrigin", "", 3, "nzIcon", "nzTitle", "mode", "nzDisabled", "isMenuInsideDropDown", "paddingLeft", "subMenuMouseState", "toggleSubMenu"], ["origin", "cdkOverlayOrigin"], [4, "ngIf"], ["nz-submenu-inline-child", "", 3, "mode", "nzOpen", "nzNoAnimation", "menuClass", "templateOutlet", 4, "ngIf", "ngIfElse"], ["nonInlineTemplate", ""], ["subMenuTemplate", ""], ["nz-submenu-inline-child", "", 3, "mode", "nzOpen", "nzNoAnimation", "menuClass", "templateOutlet"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayPositions", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayWidth", "cdkConnectedOverlayOpen", "cdkConnectedOverlayTransformOriginOn", "positionChange"], ["nz-submenu-none-inline-child", "", 3, "theme", "mode", "nzOpen", "position", "nzDisabled", "isMenuInsideDropDown", "templateOutlet", "menuClass", "nzNoAnimation", "subMenuMouseState"]],
  template: function NzSubMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c6);
      \u0275\u0275elementStart(0, "div", 0, 1);
      \u0275\u0275listener("subMenuMouseState", function NzSubMenuComponent_Template_div_subMenuMouseState_0_listener($event) {
        return ctx.setMouseEnterState($event);
      })("toggleSubMenu", function NzSubMenuComponent_Template_div_toggleSubMenu_0_listener() {
        return ctx.toggleSubMenu();
      });
      \u0275\u0275template(2, NzSubMenuComponent_ng_content_2_Template, 1, 0, "ng-content", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, NzSubMenuComponent_div_3_Template, 1, 6, "div", 3)(4, NzSubMenuComponent_ng_template_4_Template, 1, 5, "ng-template", null, 4, \u0275\u0275templateRefExtractor)(6, NzSubMenuComponent_ng_template_6_Template, 1, 0, "ng-template", null, 5, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r4 = \u0275\u0275reference(5);
      \u0275\u0275property("nzIcon", ctx.nzIcon)("nzTitle", ctx.nzTitle)("mode", ctx.mode)("nzDisabled", ctx.nzDisabled)("isMenuInsideDropDown", ctx.isMenuInsideDropDown)("paddingLeft", ctx.nzPaddingLeft || ctx.inlinePaddingLeft);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", !ctx.nzTitle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.mode === "inline")("ngIfElse", _r4);
    }
  },
  dependencies: [NzSubMenuTitleComponent, NzSubmenuInlineChildComponent, NgIf, NzNoAnimationDirective, NzSubmenuNoneInlineChildComponent, OverlayModule, CdkConnectedOverlay, CdkOverlayOrigin],
  encapsulation: 2,
  changeDetection: 0
});
var NzSubMenuComponent = _NzSubMenuComponent;
__decorate([InputBoolean()], NzSubMenuComponent.prototype, "nzOpen", void 0);
__decorate([InputBoolean()], NzSubMenuComponent.prototype, "nzDisabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSubMenuComponent, [{
    type: Component,
    args: [{
      selector: "[nz-submenu]",
      exportAs: "nzSubmenu",
      providers: [NzSubmenuService],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      preserveWhitespaces: false,
      template: `
    <div
      nz-submenu-title
      cdkOverlayOrigin
      #origin="cdkOverlayOrigin"
      [nzIcon]="nzIcon"
      [nzTitle]="nzTitle"
      [mode]="mode"
      [nzDisabled]="nzDisabled"
      [isMenuInsideDropDown]="isMenuInsideDropDown"
      [paddingLeft]="nzPaddingLeft || inlinePaddingLeft"
      (subMenuMouseState)="setMouseEnterState($event)"
      (toggleSubMenu)="toggleSubMenu()"
    >
      <ng-content select="[title]" *ngIf="!nzTitle"></ng-content>
    </div>
    <div
      *ngIf="mode === 'inline'; else nonInlineTemplate"
      nz-submenu-inline-child
      [mode]="mode"
      [nzOpen]="nzOpen"
      [@.disabled]="!!noAnimation?.nzNoAnimation"
      [nzNoAnimation]="noAnimation?.nzNoAnimation"
      [menuClass]="nzMenuClassName"
      [templateOutlet]="subMenuTemplate"
    ></div>
    <ng-template #nonInlineTemplate>
      <ng-template
        cdkConnectedOverlay
        (positionChange)="onPositionChange($event)"
        [cdkConnectedOverlayPositions]="overlayPositions"
        [cdkConnectedOverlayOrigin]="origin"
        [cdkConnectedOverlayWidth]="triggerWidth!"
        [cdkConnectedOverlayOpen]="nzOpen"
        [cdkConnectedOverlayTransformOriginOn]="'.ant-menu-submenu'"
      >
        <div
          nz-submenu-none-inline-child
          [theme]="theme"
          [mode]="mode"
          [nzOpen]="nzOpen"
          [position]="position"
          [nzDisabled]="nzDisabled"
          [isMenuInsideDropDown]="isMenuInsideDropDown"
          [templateOutlet]="subMenuTemplate"
          [menuClass]="nzMenuClassName"
          [@.disabled]="!!noAnimation?.nzNoAnimation"
          [nzNoAnimation]="noAnimation?.nzNoAnimation"
          (subMenuMouseState)="setMouseEnterState($event)"
        ></div>
      </ng-template>
    </ng-template>

    <ng-template #subMenuTemplate>
      <ng-content></ng-content>
    </ng-template>
  `,
      host: {
        "[class.ant-dropdown-menu-submenu]": `isMenuInsideDropDown`,
        "[class.ant-dropdown-menu-submenu-disabled]": `isMenuInsideDropDown && nzDisabled`,
        "[class.ant-dropdown-menu-submenu-open]": `isMenuInsideDropDown && nzOpen`,
        "[class.ant-dropdown-menu-submenu-selected]": `isMenuInsideDropDown && isSelected`,
        "[class.ant-dropdown-menu-submenu-vertical]": `isMenuInsideDropDown && mode === 'vertical'`,
        "[class.ant-dropdown-menu-submenu-horizontal]": `isMenuInsideDropDown && mode === 'horizontal'`,
        "[class.ant-dropdown-menu-submenu-inline]": `isMenuInsideDropDown && mode === 'inline'`,
        "[class.ant-dropdown-menu-submenu-active]": `isMenuInsideDropDown && isActive`,
        "[class.ant-menu-submenu]": `!isMenuInsideDropDown`,
        "[class.ant-menu-submenu-disabled]": `!isMenuInsideDropDown && nzDisabled`,
        "[class.ant-menu-submenu-open]": `!isMenuInsideDropDown && nzOpen`,
        "[class.ant-menu-submenu-selected]": `!isMenuInsideDropDown && isSelected`,
        "[class.ant-menu-submenu-vertical]": `!isMenuInsideDropDown && mode === 'vertical'`,
        "[class.ant-menu-submenu-horizontal]": `!isMenuInsideDropDown && mode === 'horizontal'`,
        "[class.ant-menu-submenu-inline]": `!isMenuInsideDropDown && mode === 'inline'`,
        "[class.ant-menu-submenu-active]": `!isMenuInsideDropDown && isActive`,
        "[class.ant-menu-submenu-rtl]": `dir === 'rtl'`
      },
      imports: [NzSubMenuTitleComponent, NzSubmenuInlineChildComponent, NgIf, NzNoAnimationDirective, NzSubmenuNoneInlineChildComponent, OverlayModule],
      standalone: true
    }]
  }], () => [{
    type: MenuService2
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzSubmenuService
  }, {
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NzIsMenuInsideDropDownToken]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    nzMenuClassName: [{
      type: Input
    }],
    nzPaddingLeft: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    nzIcon: [{
      type: Input
    }],
    nzOpen: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzPlacement: [{
      type: Input
    }],
    nzOpenChange: [{
      type: Output
    }],
    cdkOverlayOrigin: [{
      type: ViewChild,
      args: [CdkOverlayOrigin, {
        static: true,
        read: ElementRef
      }]
    }],
    listOfNzSubMenuComponent: [{
      type: ContentChildren,
      args: [forwardRef(() => NzSubMenuComponent), {
        descendants: true
      }]
    }],
    listOfNzMenuItemDirective: [{
      type: ContentChildren,
      args: [NzMenuItemComponent, {
        descendants: true
      }]
    }]
  });
})();
function MenuServiceFactory() {
  const serviceInsideDropDown = inject(MenuService2, {
    skipSelf: true,
    optional: true
  });
  const serviceOutsideDropDown = inject(NzMenuServiceLocalToken);
  return serviceInsideDropDown ?? serviceOutsideDropDown;
}
function MenuDropDownTokenFactory() {
  const isMenuInsideDropDownToken = inject(NzIsMenuInsideDropDownToken, {
    skipSelf: true,
    optional: true
  });
  return isMenuInsideDropDownToken ?? false;
}
var _NzMenuDirective = class _NzMenuDirective {
  setInlineCollapsed(inlineCollapsed) {
    this.nzInlineCollapsed = inlineCollapsed;
    this.inlineCollapsed$.next(inlineCollapsed);
  }
  updateInlineCollapse() {
    if (this.listOfNzMenuItemDirective) {
      if (this.nzInlineCollapsed) {
        this.listOfOpenedNzSubMenuComponent = this.listOfNzSubMenuComponent.filter((submenu) => submenu.nzOpen);
        this.listOfNzSubMenuComponent.forEach((submenu) => submenu.setOpenStateWithoutDebounce(false));
      } else {
        this.listOfOpenedNzSubMenuComponent.forEach((submenu) => submenu.setOpenStateWithoutDebounce(true));
        this.listOfOpenedNzSubMenuComponent = [];
      }
    }
  }
  constructor(nzMenuService, isMenuInsideDropDown, cdr, directionality) {
    this.nzMenuService = nzMenuService;
    this.isMenuInsideDropDown = isMenuInsideDropDown;
    this.cdr = cdr;
    this.directionality = directionality;
    this.nzInlineIndent = 24;
    this.nzTheme = "light";
    this.nzMode = "vertical";
    this.nzInlineCollapsed = false;
    this.nzSelectable = !this.isMenuInsideDropDown;
    this.nzClick = new EventEmitter();
    this.actualMode = "vertical";
    this.dir = "ltr";
    this.inlineCollapsed$ = new BehaviorSubject(this.nzInlineCollapsed);
    this.mode$ = new BehaviorSubject(this.nzMode);
    this.destroy$ = new Subject();
    this.listOfOpenedNzSubMenuComponent = [];
  }
  ngOnInit() {
    combineLatest([this.inlineCollapsed$, this.mode$]).pipe(takeUntil(this.destroy$)).subscribe(([inlineCollapsed, mode]) => {
      this.actualMode = inlineCollapsed ? "vertical" : mode;
      this.nzMenuService.setMode(this.actualMode);
      this.cdr.markForCheck();
    });
    this.nzMenuService.descendantMenuItemClick$.pipe(takeUntil(this.destroy$)).subscribe((menu) => {
      this.nzClick.emit(menu);
      if (this.nzSelectable && !menu.nzMatchRouter) {
        this.listOfNzMenuItemDirective.forEach((item) => item.setSelectedState(item === menu));
      }
    });
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.nzMenuService.setMode(this.actualMode);
      this.cdr.markForCheck();
    });
  }
  ngAfterContentInit() {
    this.inlineCollapsed$.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.updateInlineCollapse();
      this.cdr.markForCheck();
    });
  }
  ngOnChanges(changes) {
    const {
      nzInlineCollapsed,
      nzInlineIndent,
      nzTheme,
      nzMode
    } = changes;
    if (nzInlineCollapsed) {
      this.inlineCollapsed$.next(this.nzInlineCollapsed);
    }
    if (nzInlineIndent) {
      this.nzMenuService.setInlineIndent(this.nzInlineIndent);
    }
    if (nzTheme) {
      this.nzMenuService.setTheme(this.nzTheme);
    }
    if (nzMode) {
      this.mode$.next(this.nzMode);
      if (!changes.nzMode.isFirstChange() && this.listOfNzSubMenuComponent) {
        this.listOfNzSubMenuComponent.forEach((submenu) => submenu.setOpenStateWithoutDebounce(false));
      }
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzMenuDirective.\u0275fac = function NzMenuDirective_Factory(t) {
  return new (t || _NzMenuDirective)(\u0275\u0275directiveInject(MenuService2), \u0275\u0275directiveInject(NzIsMenuInsideDropDownToken), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzMenuDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzMenuDirective,
  selectors: [["", "nz-menu", ""]],
  contentQueries: function NzMenuDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzMenuItemComponent, 5);
      \u0275\u0275contentQuery(dirIndex, NzSubMenuComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzMenuItemDirective = _t);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzSubMenuComponent = _t);
    }
  },
  hostVars: 34,
  hostBindings: function NzMenuDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-dropdown-menu", ctx.isMenuInsideDropDown)("ant-dropdown-menu-root", ctx.isMenuInsideDropDown)("ant-dropdown-menu-light", ctx.isMenuInsideDropDown && ctx.nzTheme === "light")("ant-dropdown-menu-dark", ctx.isMenuInsideDropDown && ctx.nzTheme === "dark")("ant-dropdown-menu-vertical", ctx.isMenuInsideDropDown && ctx.actualMode === "vertical")("ant-dropdown-menu-horizontal", ctx.isMenuInsideDropDown && ctx.actualMode === "horizontal")("ant-dropdown-menu-inline", ctx.isMenuInsideDropDown && ctx.actualMode === "inline")("ant-dropdown-menu-inline-collapsed", ctx.isMenuInsideDropDown && ctx.nzInlineCollapsed)("ant-menu", !ctx.isMenuInsideDropDown)("ant-menu-root", !ctx.isMenuInsideDropDown)("ant-menu-light", !ctx.isMenuInsideDropDown && ctx.nzTheme === "light")("ant-menu-dark", !ctx.isMenuInsideDropDown && ctx.nzTheme === "dark")("ant-menu-vertical", !ctx.isMenuInsideDropDown && ctx.actualMode === "vertical")("ant-menu-horizontal", !ctx.isMenuInsideDropDown && ctx.actualMode === "horizontal")("ant-menu-inline", !ctx.isMenuInsideDropDown && ctx.actualMode === "inline")("ant-menu-inline-collapsed", !ctx.isMenuInsideDropDown && ctx.nzInlineCollapsed)("ant-menu-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzInlineIndent: "nzInlineIndent",
    nzTheme: "nzTheme",
    nzMode: "nzMode",
    nzInlineCollapsed: "nzInlineCollapsed",
    nzSelectable: "nzSelectable"
  },
  outputs: {
    nzClick: "nzClick"
  },
  exportAs: ["nzMenu"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([
    {
      provide: NzMenuServiceLocalToken,
      useClass: MenuService2
    },
    /** use the top level service **/
    {
      provide: MenuService2,
      useFactory: MenuServiceFactory
    },
    /** check if menu inside dropdown-menu component **/
    {
      provide: NzIsMenuInsideDropDownToken,
      useFactory: MenuDropDownTokenFactory
    }
  ]), \u0275\u0275NgOnChangesFeature]
});
var NzMenuDirective = _NzMenuDirective;
__decorate([InputBoolean()], NzMenuDirective.prototype, "nzInlineCollapsed", void 0);
__decorate([InputBoolean()], NzMenuDirective.prototype, "nzSelectable", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMenuDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-menu]",
      exportAs: "nzMenu",
      providers: [
        {
          provide: NzMenuServiceLocalToken,
          useClass: MenuService2
        },
        /** use the top level service **/
        {
          provide: MenuService2,
          useFactory: MenuServiceFactory
        },
        /** check if menu inside dropdown-menu component **/
        {
          provide: NzIsMenuInsideDropDownToken,
          useFactory: MenuDropDownTokenFactory
        }
      ],
      host: {
        "[class.ant-dropdown-menu]": `isMenuInsideDropDown`,
        "[class.ant-dropdown-menu-root]": `isMenuInsideDropDown`,
        "[class.ant-dropdown-menu-light]": `isMenuInsideDropDown && nzTheme === 'light'`,
        "[class.ant-dropdown-menu-dark]": `isMenuInsideDropDown && nzTheme === 'dark'`,
        "[class.ant-dropdown-menu-vertical]": `isMenuInsideDropDown && actualMode === 'vertical'`,
        "[class.ant-dropdown-menu-horizontal]": `isMenuInsideDropDown && actualMode === 'horizontal'`,
        "[class.ant-dropdown-menu-inline]": `isMenuInsideDropDown && actualMode === 'inline'`,
        "[class.ant-dropdown-menu-inline-collapsed]": `isMenuInsideDropDown && nzInlineCollapsed`,
        "[class.ant-menu]": `!isMenuInsideDropDown`,
        "[class.ant-menu-root]": `!isMenuInsideDropDown`,
        "[class.ant-menu-light]": `!isMenuInsideDropDown && nzTheme === 'light'`,
        "[class.ant-menu-dark]": `!isMenuInsideDropDown && nzTheme === 'dark'`,
        "[class.ant-menu-vertical]": `!isMenuInsideDropDown && actualMode === 'vertical'`,
        "[class.ant-menu-horizontal]": `!isMenuInsideDropDown && actualMode === 'horizontal'`,
        "[class.ant-menu-inline]": `!isMenuInsideDropDown && actualMode === 'inline'`,
        "[class.ant-menu-inline-collapsed]": `!isMenuInsideDropDown && nzInlineCollapsed`,
        "[class.ant-menu-rtl]": `dir === 'rtl'`
      },
      standalone: true
    }]
  }], () => [{
    type: MenuService2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NzIsMenuInsideDropDownToken]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    listOfNzMenuItemDirective: [{
      type: ContentChildren,
      args: [NzMenuItemComponent, {
        descendants: true
      }]
    }],
    listOfNzSubMenuComponent: [{
      type: ContentChildren,
      args: [NzSubMenuComponent, {
        descendants: true
      }]
    }],
    nzInlineIndent: [{
      type: Input
    }],
    nzTheme: [{
      type: Input
    }],
    nzMode: [{
      type: Input
    }],
    nzInlineCollapsed: [{
      type: Input
    }],
    nzSelectable: [{
      type: Input
    }],
    nzClick: [{
      type: Output
    }]
  });
})();
function MenuGroupFactory() {
  const isMenuInsideDropDownToken = inject(NzIsMenuInsideDropDownToken, {
    optional: true,
    skipSelf: true
  });
  return isMenuInsideDropDownToken ?? false;
}
var _NzMenuGroupComponent = class _NzMenuGroupComponent {
  constructor(elementRef, renderer, isMenuInsideDropDown) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.isMenuInsideDropDown = isMenuInsideDropDown;
    const className = this.isMenuInsideDropDown ? "ant-dropdown-menu-item-group" : "ant-menu-item-group";
    this.renderer.addClass(elementRef.nativeElement, className);
  }
  ngAfterViewInit() {
    const ulElement = this.titleElement.nativeElement.nextElementSibling;
    if (ulElement) {
      const className = this.isMenuInsideDropDown ? "ant-dropdown-menu-item-group-list" : "ant-menu-item-group-list";
      this.renderer.addClass(ulElement, className);
    }
  }
};
_NzMenuGroupComponent.\u0275fac = function NzMenuGroupComponent_Factory(t) {
  return new (t || _NzMenuGroupComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzIsMenuInsideDropDownToken));
};
_NzMenuGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzMenuGroupComponent,
  selectors: [["", "nz-menu-group", ""]],
  viewQuery: function NzMenuGroupComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c8, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.titleElement = _t.first);
    }
  },
  inputs: {
    nzTitle: "nzTitle"
  },
  exportAs: ["nzMenuGroup"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([
    /** check if menu inside dropdown-menu component **/
    {
      provide: NzIsMenuInsideDropDownToken,
      useFactory: MenuGroupFactory
    }
  ]), \u0275\u0275StandaloneFeature],
  attrs: _c9,
  ngContentSelectors: _c11,
  decls: 5,
  vars: 6,
  consts: [["titleElement", ""], [4, "nzStringTemplateOutlet"], [4, "ngIf"]],
  template: function NzMenuGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c10);
      \u0275\u0275elementStart(0, "div", null, 0);
      \u0275\u0275template(2, NzMenuGroupComponent_ng_container_2_Template, 2, 1, "ng-container", 1)(3, NzMenuGroupComponent_ng_content_3_Template, 1, 0, "ng-content", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275projection(4);
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-menu-item-group-title", !ctx.isMenuInsideDropDown)("ant-dropdown-menu-item-group-title", ctx.isMenuInsideDropDown);
      \u0275\u0275advance(2);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzTitle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.nzTitle);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NzMenuGroupComponent = _NzMenuGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMenuGroupComponent, [{
    type: Component,
    args: [{
      selector: "[nz-menu-group]",
      exportAs: "nzMenuGroup",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [
        /** check if menu inside dropdown-menu component **/
        {
          provide: NzIsMenuInsideDropDownToken,
          useFactory: MenuGroupFactory
        }
      ],
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <div
      [class.ant-menu-item-group-title]="!isMenuInsideDropDown"
      [class.ant-dropdown-menu-item-group-title]="isMenuInsideDropDown"
      #titleElement
    >
      <ng-container *nzStringTemplateOutlet="nzTitle">{{ nzTitle }}</ng-container>
      <ng-content select="[title]" *ngIf="!nzTitle"></ng-content>
    </div>
    <ng-content></ng-content>
  `,
      preserveWhitespaces: false,
      imports: [NzOutletModule, NgIf],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NzIsMenuInsideDropDownToken]
    }]
  }], {
    nzTitle: [{
      type: Input
    }],
    titleElement: [{
      type: ViewChild,
      args: ["titleElement"]
    }]
  });
})();
var _NzMenuDividerDirective = class _NzMenuDividerDirective {
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
};
_NzMenuDividerDirective.\u0275fac = function NzMenuDividerDirective_Factory(t) {
  return new (t || _NzMenuDividerDirective)(\u0275\u0275directiveInject(ElementRef));
};
_NzMenuDividerDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzMenuDividerDirective,
  selectors: [["", "nz-menu-divider", ""]],
  hostAttrs: [1, "ant-dropdown-menu-item-divider"],
  exportAs: ["nzMenuDivider"],
  standalone: true
});
var NzMenuDividerDirective = _NzMenuDividerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMenuDividerDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-menu-divider]",
      exportAs: "nzMenuDivider",
      host: {
        class: "ant-dropdown-menu-item-divider"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], null);
})();
var _NzMenuModule = class _NzMenuModule {
};
_NzMenuModule.\u0275fac = function NzMenuModule_Factory(t) {
  return new (t || _NzMenuModule)();
};
_NzMenuModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzMenuModule
});
_NzMenuModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzSubMenuComponent, NzMenuGroupComponent, NzSubMenuTitleComponent]
});
var NzMenuModule = _NzMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMenuModule, [{
    type: NgModule,
    args: [{
      imports: [NzMenuDirective, NzMenuItemComponent, NzSubMenuComponent, NzMenuDividerDirective, NzMenuGroupComponent, NzSubMenuTitleComponent, NzSubmenuInlineChildComponent, NzSubmenuNoneInlineChildComponent],
      exports: [NzMenuDirective, NzMenuItemComponent, NzSubMenuComponent, NzMenuDividerDirective, NzMenuGroupComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-dropdown.mjs
function NzDropdownMenuComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275listener("@slideMotion.done", function NzDropdownMenuComponent_ng_template_0_Template_div_animation_slideMotion_done_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onAnimationEvent($event));
    })("mouseenter", function NzDropdownMenuComponent_ng_template_0_Template_div_mouseenter_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.setMouseState(true));
    })("mouseleave", function NzDropdownMenuComponent_ng_template_0_Template_div_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.setMouseState(false));
    });
    \u0275\u0275projection(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-dropdown-rtl", ctx_r0.dir === "rtl");
    \u0275\u0275property("ngClass", ctx_r0.nzOverlayClassName)("ngStyle", ctx_r0.nzOverlayStyle)("@slideMotion", void 0)("@.disabled", !!(ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation))("nzNoAnimation", ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation);
  }
}
var _c010 = ["*"];
var NZ_CONFIG_MODULE_NAME5 = "dropDown";
var listOfPositions = [POSITION_MAP.bottomLeft, POSITION_MAP.bottomRight, POSITION_MAP.topRight, POSITION_MAP.topLeft];
var _NzDropDownDirective = class _NzDropDownDirective {
  setDropdownMenuValue(key, value) {
    if (this.nzDropdownMenu) {
      this.nzDropdownMenu.setValue(key, value);
    }
  }
  constructor(nzConfigService, elementRef, overlay, renderer, viewContainerRef, platform) {
    this.nzConfigService = nzConfigService;
    this.elementRef = elementRef;
    this.overlay = overlay;
    this.renderer = renderer;
    this.viewContainerRef = viewContainerRef;
    this.platform = platform;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME5;
    this.overlayRef = null;
    this.destroy$ = new Subject();
    this.positionStrategy = this.overlay.position().flexibleConnectedTo(this.elementRef.nativeElement).withLockedPosition().withTransformOriginOn(".ant-dropdown");
    this.inputVisible$ = new BehaviorSubject(false);
    this.nzTrigger$ = new BehaviorSubject("hover");
    this.overlayClose$ = new Subject();
    this.nzDropdownMenu = null;
    this.nzTrigger = "hover";
    this.nzMatchWidthElement = null;
    this.nzBackdrop = false;
    this.nzClickHide = true;
    this.nzDisabled = false;
    this.nzVisible = false;
    this.nzOverlayClassName = "";
    this.nzOverlayStyle = {};
    this.nzPlacement = "bottomLeft";
    this.nzVisibleChange = new EventEmitter();
  }
  ngAfterViewInit() {
    if (this.nzDropdownMenu) {
      const nativeElement = this.elementRef.nativeElement;
      const hostMouseState$ = merge(fromEvent(nativeElement, "mouseenter").pipe(mapTo(true)), fromEvent(nativeElement, "mouseleave").pipe(mapTo(false)));
      const menuMouseState$ = this.nzDropdownMenu.mouseState$;
      const mergedMouseState$ = merge(menuMouseState$, hostMouseState$);
      const hostClickState$ = fromEvent(nativeElement, "click").pipe(map(() => !this.nzVisible));
      const visibleStateByTrigger$ = this.nzTrigger$.pipe(switchMap((trigger2) => {
        if (trigger2 === "hover") {
          return mergedMouseState$;
        } else if (trigger2 === "click") {
          return hostClickState$;
        } else {
          return EMPTY;
        }
      }));
      const descendantMenuItemClick$ = this.nzDropdownMenu.descendantMenuItemClick$.pipe(filter(() => this.nzClickHide), mapTo(false));
      const domTriggerVisible$ = merge(visibleStateByTrigger$, descendantMenuItemClick$, this.overlayClose$).pipe(filter(() => !this.nzDisabled));
      const visible$ = merge(this.inputVisible$, domTriggerVisible$);
      combineLatest([visible$, this.nzDropdownMenu.isChildSubMenuOpen$]).pipe(map(([visible, sub]) => visible || sub), auditTime(150), distinctUntilChanged(), filter(() => this.platform.isBrowser), takeUntil(this.destroy$)).subscribe((visible) => {
        const element = this.nzMatchWidthElement ? this.nzMatchWidthElement.nativeElement : nativeElement;
        const triggerWidth = element.getBoundingClientRect().width;
        if (this.nzVisible !== visible) {
          this.nzVisibleChange.emit(visible);
        }
        this.nzVisible = visible;
        if (visible) {
          if (!this.overlayRef) {
            this.overlayRef = this.overlay.create({
              positionStrategy: this.positionStrategy,
              minWidth: triggerWidth,
              disposeOnNavigation: true,
              hasBackdrop: this.nzBackdrop && this.nzTrigger === "click",
              scrollStrategy: this.overlay.scrollStrategies.reposition()
            });
            merge(this.overlayRef.backdropClick(), this.overlayRef.detachments(), this.overlayRef.outsidePointerEvents().pipe(filter((e) => !this.elementRef.nativeElement.contains(e.target))), this.overlayRef.keydownEvents().pipe(filter((e) => e.keyCode === ESCAPE && !hasModifierKey(e)))).pipe(takeUntil(this.destroy$)).subscribe(() => {
              this.overlayClose$.next(false);
            });
          } else {
            const overlayConfig = this.overlayRef.getConfig();
            overlayConfig.minWidth = triggerWidth;
          }
          this.positionStrategy.withPositions([POSITION_MAP[this.nzPlacement], ...listOfPositions]);
          if (!this.portal || this.portal.templateRef !== this.nzDropdownMenu.templateRef) {
            this.portal = new TemplatePortal(this.nzDropdownMenu.templateRef, this.viewContainerRef);
          }
          this.overlayRef.attach(this.portal);
        } else {
          if (this.overlayRef) {
            this.overlayRef.detach();
          }
        }
      });
      this.nzDropdownMenu.animationStateChange$.pipe(takeUntil(this.destroy$)).subscribe((event) => {
        if (event.toState === "void") {
          if (this.overlayRef) {
            this.overlayRef.dispose();
          }
          this.overlayRef = null;
        }
      });
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
    if (this.overlayRef) {
      this.overlayRef.dispose();
      this.overlayRef = null;
    }
  }
  ngOnChanges(changes) {
    const {
      nzVisible,
      nzDisabled,
      nzOverlayClassName,
      nzOverlayStyle,
      nzTrigger
    } = changes;
    if (nzTrigger) {
      this.nzTrigger$.next(this.nzTrigger);
    }
    if (nzVisible) {
      this.inputVisible$.next(this.nzVisible);
    }
    if (nzDisabled) {
      const nativeElement = this.elementRef.nativeElement;
      if (this.nzDisabled) {
        this.renderer.setAttribute(nativeElement, "disabled", "");
        this.inputVisible$.next(false);
      } else {
        this.renderer.removeAttribute(nativeElement, "disabled");
      }
    }
    if (nzOverlayClassName) {
      this.setDropdownMenuValue("nzOverlayClassName", this.nzOverlayClassName);
    }
    if (nzOverlayStyle) {
      this.setDropdownMenuValue("nzOverlayStyle", this.nzOverlayStyle);
    }
  }
};
_NzDropDownDirective.\u0275fac = function NzDropDownDirective_Factory(t) {
  return new (t || _NzDropDownDirective)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Overlay), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Platform));
};
_NzDropDownDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzDropDownDirective,
  selectors: [["", "nz-dropdown", ""]],
  hostAttrs: [1, "ant-dropdown-trigger"],
  inputs: {
    nzDropdownMenu: "nzDropdownMenu",
    nzTrigger: "nzTrigger",
    nzMatchWidthElement: "nzMatchWidthElement",
    nzBackdrop: "nzBackdrop",
    nzClickHide: "nzClickHide",
    nzDisabled: "nzDisabled",
    nzVisible: "nzVisible",
    nzOverlayClassName: "nzOverlayClassName",
    nzOverlayStyle: "nzOverlayStyle",
    nzPlacement: "nzPlacement"
  },
  outputs: {
    nzVisibleChange: "nzVisibleChange"
  },
  exportAs: ["nzDropdown"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzDropDownDirective = _NzDropDownDirective;
__decorate([WithConfig(), InputBoolean()], NzDropDownDirective.prototype, "nzBackdrop", void 0);
__decorate([InputBoolean()], NzDropDownDirective.prototype, "nzClickHide", void 0);
__decorate([InputBoolean()], NzDropDownDirective.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzDropDownDirective.prototype, "nzVisible", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDropDownDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-dropdown]",
      exportAs: "nzDropdown",
      host: {
        class: "ant-dropdown-trigger"
      },
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: ElementRef
  }, {
    type: Overlay
  }, {
    type: Renderer2
  }, {
    type: ViewContainerRef
  }, {
    type: Platform
  }], {
    nzDropdownMenu: [{
      type: Input
    }],
    nzTrigger: [{
      type: Input
    }],
    nzMatchWidthElement: [{
      type: Input
    }],
    nzBackdrop: [{
      type: Input
    }],
    nzClickHide: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzVisible: [{
      type: Input
    }],
    nzOverlayClassName: [{
      type: Input
    }],
    nzOverlayStyle: [{
      type: Input
    }],
    nzPlacement: [{
      type: Input
    }],
    nzVisibleChange: [{
      type: Output
    }]
  });
})();
var _NzContextMenuServiceModule = class _NzContextMenuServiceModule {
};
_NzContextMenuServiceModule.\u0275fac = function NzContextMenuServiceModule_Factory(t) {
  return new (t || _NzContextMenuServiceModule)();
};
_NzContextMenuServiceModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzContextMenuServiceModule
});
_NzContextMenuServiceModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzContextMenuServiceModule = _NzContextMenuServiceModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzContextMenuServiceModule, [{
    type: NgModule
  }], null, null);
})();
var _NzDropDownADirective = class _NzDropDownADirective {
  constructor() {
  }
};
_NzDropDownADirective.\u0275fac = function NzDropDownADirective_Factory(t) {
  return new (t || _NzDropDownADirective)();
};
_NzDropDownADirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzDropDownADirective,
  selectors: [["a", "nz-dropdown", ""]],
  hostAttrs: [1, "ant-dropdown-link"],
  standalone: true
});
var NzDropDownADirective = _NzDropDownADirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDropDownADirective, [{
    type: Directive,
    args: [{
      selector: "a[nz-dropdown]",
      host: {
        class: "ant-dropdown-link"
      },
      standalone: true
    }]
  }], () => [], null);
})();
var _NzDropdownButtonDirective = class _NzDropdownButtonDirective {
  constructor(renderer, nzButtonGroupComponent, elementRef) {
    this.renderer = renderer;
    this.nzButtonGroupComponent = nzButtonGroupComponent;
    this.elementRef = elementRef;
  }
  ngAfterViewInit() {
    const parentElement = this.renderer.parentNode(this.elementRef.nativeElement);
    if (this.nzButtonGroupComponent && parentElement) {
      this.renderer.addClass(parentElement, "ant-dropdown-button");
    }
  }
};
_NzDropdownButtonDirective.\u0275fac = function NzDropdownButtonDirective_Factory(t) {
  return new (t || _NzDropdownButtonDirective)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzButtonGroupComponent, 9), \u0275\u0275directiveInject(ElementRef));
};
_NzDropdownButtonDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzDropdownButtonDirective,
  selectors: [["", "nz-button", "", "nz-dropdown", ""]],
  standalone: true
});
var NzDropdownButtonDirective = _NzDropdownButtonDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDropdownButtonDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-button][nz-dropdown]",
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: NzButtonGroupComponent,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: ElementRef
  }], null);
})();
var _NzDropdownMenuComponent = class _NzDropdownMenuComponent {
  onAnimationEvent(event) {
    this.animationStateChange$.emit(event);
  }
  setMouseState(visible) {
    this.mouseState$.next(visible);
  }
  setValue(key, value) {
    this[key] = value;
    this.cdr.markForCheck();
  }
  constructor(cdr, elementRef, renderer, viewContainerRef, nzMenuService, directionality, noAnimation) {
    this.cdr = cdr;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.viewContainerRef = viewContainerRef;
    this.nzMenuService = nzMenuService;
    this.directionality = directionality;
    this.noAnimation = noAnimation;
    this.mouseState$ = new BehaviorSubject(false);
    this.isChildSubMenuOpen$ = this.nzMenuService.isChildSubMenuOpen$;
    this.descendantMenuItemClick$ = this.nzMenuService.descendantMenuItemClick$;
    this.animationStateChange$ = new EventEmitter();
    this.nzOverlayClassName = "";
    this.nzOverlayStyle = {};
    this.dir = "ltr";
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngAfterContentInit() {
    this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), this.elementRef.nativeElement);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzDropdownMenuComponent.\u0275fac = function NzDropdownMenuComponent_Factory(t) {
  return new (t || _NzDropdownMenuComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(MenuService2), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzDropdownMenuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzDropdownMenuComponent,
  selectors: [["nz-dropdown-menu"]],
  viewQuery: function NzDropdownMenuComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  exportAs: ["nzDropdownMenu"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([
    MenuService2,
    /** menu is inside dropdown-menu component **/
    {
      provide: NzIsMenuInsideDropDownToken,
      useValue: true
    }
  ]), \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c010,
  decls: 1,
  vars: 0,
  consts: [[1, "ant-dropdown", 3, "ngClass", "ngStyle", "nzNoAnimation", "mouseenter", "mouseleave"]],
  template: function NzDropdownMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzDropdownMenuComponent_ng_template_0_Template, 2, 7, "ng-template");
    }
  },
  dependencies: [NgClass, NgStyle, NzNoAnimationDirective],
  encapsulation: 2,
  data: {
    animation: [slideMotion]
  },
  changeDetection: 0
});
var NzDropdownMenuComponent = _NzDropdownMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDropdownMenuComponent, [{
    type: Component,
    args: [{
      selector: `nz-dropdown-menu`,
      exportAs: `nzDropdownMenu`,
      animations: [slideMotion],
      providers: [
        MenuService2,
        /** menu is inside dropdown-menu component **/
        {
          provide: NzIsMenuInsideDropDownToken,
          useValue: true
        }
      ],
      template: `
    <ng-template>
      <div
        class="ant-dropdown"
        [class.ant-dropdown-rtl]="dir === 'rtl'"
        [ngClass]="nzOverlayClassName"
        [ngStyle]="nzOverlayStyle"
        @slideMotion
        (@slideMotion.done)="onAnimationEvent($event)"
        [@.disabled]="!!noAnimation?.nzNoAnimation"
        [nzNoAnimation]="noAnimation?.nzNoAnimation"
        (mouseenter)="setMouseState(true)"
        (mouseleave)="setMouseState(false)"
      >
        <ng-content></ng-content>
      </div>
    </ng-template>
  `,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [NgClass, NgStyle, NzNoAnimationDirective],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ViewContainerRef
  }, {
    type: MenuService2
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    templateRef: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }]
  });
})();
var _NzDropDownModule = class _NzDropDownModule {
};
_NzDropDownModule.\u0275fac = function NzDropDownModule_Factory(t) {
  return new (t || _NzDropDownModule)();
};
_NzDropDownModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzDropDownModule
});
_NzDropDownModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzContextMenuServiceModule, NzMenuModule]
});
var NzDropDownModule = _NzDropDownModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDropDownModule, [{
    type: NgModule,
    args: [{
      imports: [NzDropDownDirective, NzDropDownADirective, NzDropdownMenuComponent, NzDropdownButtonDirective, NzContextMenuServiceModule],
      exports: [NzMenuModule, NzDropDownDirective, NzDropDownADirective, NzDropdownMenuComponent, NzDropdownButtonDirective]
    }]
  }], null, null);
})();
var LIST_OF_POSITIONS = [new ConnectionPositionPair({
  originX: "start",
  originY: "top"
}, {
  overlayX: "start",
  overlayY: "top"
}), new ConnectionPositionPair({
  originX: "start",
  originY: "top"
}, {
  overlayX: "start",
  overlayY: "bottom"
}), new ConnectionPositionPair({
  originX: "start",
  originY: "top"
}, {
  overlayX: "end",
  overlayY: "bottom"
}), new ConnectionPositionPair({
  originX: "start",
  originY: "top"
}, {
  overlayX: "end",
  overlayY: "top"
})];
var _NzContextMenuService = class _NzContextMenuService {
  constructor(ngZone, overlay) {
    this.ngZone = ngZone;
    this.overlay = overlay;
    this.overlayRef = null;
    this.closeSubscription = Subscription.EMPTY;
  }
  create($event, nzDropdownMenuComponent) {
    this.close(true);
    const {
      x,
      y
    } = $event;
    if ($event instanceof MouseEvent) {
      $event.preventDefault();
    }
    const positionStrategy = this.overlay.position().flexibleConnectedTo({
      x,
      y
    }).withPositions(LIST_OF_POSITIONS).withTransformOriginOn(".ant-dropdown");
    this.overlayRef = this.overlay.create({
      positionStrategy,
      disposeOnNavigation: true,
      scrollStrategy: this.overlay.scrollStrategies.close()
    });
    this.closeSubscription = new Subscription();
    this.closeSubscription.add(nzDropdownMenuComponent.descendantMenuItemClick$.subscribe(() => this.close()));
    this.closeSubscription.add(this.ngZone.runOutsideAngular(() => merge(fromEvent(document, "click").pipe(
      filter((event) => !!this.overlayRef && !this.overlayRef.overlayElement.contains(event.target)),
      /** handle firefox contextmenu event **/
      filter((event) => event.button !== 2)
    ), fromEvent(document, "keydown").pipe(filter((event) => event.key === "Escape"))).pipe(first()).subscribe(() => this.ngZone.run(() => this.close()))));
    return this.overlayRef.attach(new TemplatePortal(nzDropdownMenuComponent.templateRef, nzDropdownMenuComponent.viewContainerRef));
  }
  close(clear = false) {
    if (this.overlayRef) {
      this.overlayRef.detach();
      if (clear) {
        this.overlayRef.dispose();
      }
      this.overlayRef = null;
      this.closeSubscription.unsubscribe();
    }
  }
};
_NzContextMenuService.\u0275fac = function NzContextMenuService_Factory(t) {
  return new (t || _NzContextMenuService)(\u0275\u0275inject(NgZone), \u0275\u0275inject(Overlay));
};
_NzContextMenuService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzContextMenuService,
  factory: _NzContextMenuService.\u0275fac,
  providedIn: NzContextMenuServiceModule
});
var NzContextMenuService = _NzContextMenuService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzContextMenuService, [{
    type: Injectable,
    args: [{
      providedIn: NzContextMenuServiceModule
    }]
  }], () => [{
    type: NgZone
  }, {
    type: Overlay
  }], null);
})();

// node_modules/@delon/abc/fesm2022/let.mjs
var LetContext = class {
  constructor(dir) {
    this.dir = dir;
  }
  get $implicit() {
    return this.dir.let;
  }
  get let() {
    return this.dir.let;
  }
};
var _LetDirective = class _LetDirective {
  constructor(vc, ref) {
    vc.createEmbeddedView(ref, new LetContext(this));
  }
  static ngTemplateContextGuard(_dir, _ctx) {
    return true;
  }
};
_LetDirective.\u0275fac = function LetDirective_Factory(t) {
  return new (t || _LetDirective)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef));
};
_LetDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _LetDirective,
  selectors: [["", "let", ""]],
  inputs: {
    let: "let"
  },
  standalone: true
});
var LetDirective = _LetDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LetDirective, [{
    type: Directive,
    args: [{
      selector: "[let]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef,
    decorators: [{
      type: Inject,
      args: [ViewContainerRef]
    }]
  }, {
    type: TemplateRef,
    decorators: [{
      type: Inject,
      args: [TemplateRef]
    }]
  }], {
    let: [{
      type: Input,
      args: [{
        required: true
      }]
    }]
  });
})();
var DIRECTIVES = [LetDirective];
var _LetModule = class _LetModule {
};
_LetModule.\u0275fac = function LetModule_Factory(t) {
  return new (t || _LetModule)();
};
_LetModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LetModule
});
_LetModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var LetModule = _LetModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LetModule, [{
    type: NgModule,
    args: [{
      imports: DIRECTIVES,
      exports: DIRECTIVES
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-empty.mjs
function NzEmptyComponent_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "img", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("src", ctx_r5.nzNotFoundImage, \u0275\u0275sanitizeUrl)("alt", ctx_r5.isContentString ? ctx_r5.nzNotFoundContent : "empty");
  }
}
function NzEmptyComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzEmptyComponent_ng_container_1_ng_container_1_Template, 2, 2, "ng-container", 4);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.nzNotFoundImage);
  }
}
function NzEmptyComponent_nz_empty_default_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-empty-default");
  }
}
function NzEmptyComponent_nz_empty_simple_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-empty-simple");
  }
}
function NzEmptyComponent_p_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r6.isContentString ? ctx_r6.nzNotFoundContent : ctx_r6.locale["description"], " ");
  }
}
function NzEmptyComponent_p_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 6);
    \u0275\u0275template(1, NzEmptyComponent_p_4_ng_container_1_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.nzNotFoundContent);
  }
}
function NzEmptyComponent_div_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r7.nzNotFoundFooter, " ");
  }
}
function NzEmptyComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275template(1, NzEmptyComponent_div_5_ng_container_1_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r4.nzNotFoundFooter);
  }
}
function NzEmbedEmptyComponent_ng_container_0_nz_empty_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-empty", 6);
  }
  if (rf & 2) {
    \u0275\u0275property("nzNotFoundImage", "simple");
  }
}
function NzEmbedEmptyComponent_ng_container_0_nz_empty_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-empty", 7);
  }
  if (rf & 2) {
    \u0275\u0275property("nzNotFoundImage", "simple");
  }
}
function NzEmbedEmptyComponent_ng_container_0_nz_empty_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-empty");
  }
}
function NzEmbedEmptyComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 2);
    \u0275\u0275template(1, NzEmbedEmptyComponent_ng_container_0_nz_empty_1_Template, 1, 1, "nz-empty", 3)(2, NzEmbedEmptyComponent_ng_container_0_nz_empty_2_Template, 1, 1, "nz-empty", 4)(3, NzEmbedEmptyComponent_ng_container_0_nz_empty_3_Template, 1, 0, "nz-empty", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngSwitch", ctx_r0.size);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "normal");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "small");
  }
}
function NzEmbedEmptyComponent_ng_container_1_1_ng_template_0_Template(rf, ctx) {
}
function NzEmbedEmptyComponent_ng_container_1_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzEmbedEmptyComponent_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275property("cdkPortalOutlet", ctx_r5.contentPortal);
  }
}
function NzEmbedEmptyComponent_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r6.content, " ");
  }
}
function NzEmbedEmptyComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzEmbedEmptyComponent_ng_container_1_1_Template, 1, 1, null, 1)(2, NzEmbedEmptyComponent_ng_container_1_ng_container_2_Template, 2, 1, "ng-container", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r1.contentType !== "string");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r1.contentType === "string");
  }
}
var NZ_EMPTY_COMPONENT_NAME = new InjectionToken("nz-empty-component-name");
var _NzEmptyDefaultComponent = class _NzEmptyDefaultComponent {
};
_NzEmptyDefaultComponent.\u0275fac = function NzEmptyDefaultComponent_Factory(t) {
  return new (t || _NzEmptyDefaultComponent)();
};
_NzEmptyDefaultComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzEmptyDefaultComponent,
  selectors: [["nz-empty-default"]],
  exportAs: ["nzEmptyDefault"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 12,
  vars: 0,
  consts: [["width", "184", "height", "152", "viewBox", "0 0 184 152", "xmlns", "http://www.w3.org/2000/svg", 1, "ant-empty-img-default"], ["fill", "none", "fill-rule", "evenodd"], ["transform", "translate(24 31.67)"], ["cx", "67.797", "cy", "106.89", "rx", "67.797", "ry", "12.668", 1, "ant-empty-img-default-ellipse"], ["d", "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z", 1, "ant-empty-img-default-path-1"], ["d", "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z", "transform", "translate(13.56)", 1, "ant-empty-img-default-path-2"], ["d", "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z", 1, "ant-empty-img-default-path-3"], ["d", "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z", 1, "ant-empty-img-default-path-4"], ["d", "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z", 1, "ant-empty-img-default-path-5"], ["transform", "translate(149.65 15.383)", 1, "ant-empty-img-default-g"], ["cx", "20.654", "cy", "3.167", "rx", "2.849", "ry", "2.815"], ["d", "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"]],
  template: function NzEmptyDefaultComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "svg", 0)(1, "g", 1)(2, "g", 2);
      \u0275\u0275element(3, "ellipse", 3)(4, "path", 4)(5, "path", 5)(6, "path", 6)(7, "path", 7);
      \u0275\u0275elementEnd();
      \u0275\u0275element(8, "path", 8);
      \u0275\u0275elementStart(9, "g", 9);
      \u0275\u0275element(10, "ellipse", 10)(11, "path", 11);
      \u0275\u0275elementEnd()()();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzEmptyDefaultComponent = _NzEmptyDefaultComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzEmptyDefaultComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-empty-default",
      exportAs: "nzEmptyDefault",
      standalone: true,
      template: `
    <svg
      class="ant-empty-img-default"
      width="184"
      height="152"
      viewBox="0 0 184 152"
      xmlns="http://www.w3.org/2000/svg"
    >
      <g fill="none" fill-rule="evenodd">
        <g transform="translate(24 31.67)">
          <ellipse class="ant-empty-img-default-ellipse" cx="67.797" cy="106.89" rx="67.797" ry="12.668" />
          <path
            class="ant-empty-img-default-path-1"
            d="M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
          />
          <path
            class="ant-empty-img-default-path-2"
            d="M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z"
            transform="translate(13.56)"
          />
          <path
            class="ant-empty-img-default-path-3"
            d="M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
          />
          <path
            class="ant-empty-img-default-path-4"
            d="M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
          />
        </g>
        <path
          class="ant-empty-img-default-path-5"
          d="M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
        />
        <g class="ant-empty-img-default-g" transform="translate(149.65 15.383)">
          <ellipse cx="20.654" cy="3.167" rx="2.849" ry="2.815" />
          <path d="M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z" />
        </g>
      </g>
    </svg>
  `
    }]
  }], null, null);
})();
var _NzEmptySimpleComponent = class _NzEmptySimpleComponent {
};
_NzEmptySimpleComponent.\u0275fac = function NzEmptySimpleComponent_Factory(t) {
  return new (t || _NzEmptySimpleComponent)();
};
_NzEmptySimpleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzEmptySimpleComponent,
  selectors: [["nz-empty-simple"]],
  exportAs: ["nzEmptySimple"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 6,
  vars: 0,
  consts: [["width", "64", "height", "41", "viewBox", "0 0 64 41", "xmlns", "http://www.w3.org/2000/svg", 1, "ant-empty-img-simple"], ["transform", "translate(0 1)", "fill", "none", "fill-rule", "evenodd"], ["cx", "32", "cy", "33", "rx", "32", "ry", "7", 1, "ant-empty-img-simple-ellipse"], ["fill-rule", "nonzero", 1, "ant-empty-img-simple-g"], ["d", "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"], ["d", "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z", 1, "ant-empty-img-simple-path"]],
  template: function NzEmptySimpleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "svg", 0)(1, "g", 1);
      \u0275\u0275element(2, "ellipse", 2);
      \u0275\u0275elementStart(3, "g", 3);
      \u0275\u0275element(4, "path", 4)(5, "path", 5);
      \u0275\u0275elementEnd()()();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzEmptySimpleComponent = _NzEmptySimpleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzEmptySimpleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-empty-simple",
      exportAs: "nzEmptySimple",
      template: `
    <svg class="ant-empty-img-simple" width="64" height="41" viewBox="0 0 64 41" xmlns="http://www.w3.org/2000/svg">
      <g transform="translate(0 1)" fill="none" fill-rule="evenodd">
        <ellipse class="ant-empty-img-simple-ellipse" cx="32" cy="33" rx="32" ry="7" />
        <g class="ant-empty-img-simple-g" fill-rule="nonzero">
          <path
            d="M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
          />
          <path
            d="M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z"
            class="ant-empty-img-simple-path"
          />
        </g>
      </g>
    </svg>
  `,
      standalone: true
    }]
  }], null, null);
})();
var NzEmptyDefaultImages = ["default", "simple"];
var _NzEmptyComponent = class _NzEmptyComponent {
  constructor(i18n, cdr) {
    this.i18n = i18n;
    this.cdr = cdr;
    this.nzNotFoundImage = "default";
    this.isContentString = false;
    this.isImageBuildIn = true;
    this.destroy$ = new Subject();
  }
  ngOnChanges(changes) {
    const {
      nzNotFoundContent,
      nzNotFoundImage
    } = changes;
    if (nzNotFoundContent) {
      const content = nzNotFoundContent.currentValue;
      this.isContentString = typeof content === "string";
    }
    if (nzNotFoundImage) {
      const image = nzNotFoundImage.currentValue || "default";
      this.isImageBuildIn = NzEmptyDefaultImages.findIndex((i) => i === image) > -1;
    }
  }
  ngOnInit() {
    this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.locale = this.i18n.getLocaleData("Empty");
      this.cdr.markForCheck();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzEmptyComponent.\u0275fac = function NzEmptyComponent_Factory(t) {
  return new (t || _NzEmptyComponent)(\u0275\u0275directiveInject(NzI18nService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NzEmptyComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzEmptyComponent,
  selectors: [["nz-empty"]],
  hostAttrs: [1, "ant-empty"],
  inputs: {
    nzNotFoundImage: "nzNotFoundImage",
    nzNotFoundContent: "nzNotFoundContent",
    nzNotFoundFooter: "nzNotFoundFooter"
  },
  exportAs: ["nzEmpty"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 6,
  vars: 5,
  consts: [[1, "ant-empty-image"], [4, "ngIf"], ["class", "ant-empty-description", 4, "ngIf"], ["class", "ant-empty-footer", 4, "ngIf"], [4, "nzStringTemplateOutlet"], [3, "src", "alt"], [1, "ant-empty-description"], [1, "ant-empty-footer"]],
  template: function NzEmptyComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, NzEmptyComponent_ng_container_1_Template, 2, 1, "ng-container", 1)(2, NzEmptyComponent_nz_empty_default_2_Template, 1, 0, "nz-empty-default", 1)(3, NzEmptyComponent_nz_empty_simple_3_Template, 1, 0, "nz-empty-simple", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, NzEmptyComponent_p_4_Template, 2, 1, "p", 2)(5, NzEmptyComponent_div_5_Template, 2, 1, "div", 3);
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.isImageBuildIn);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.isImageBuildIn && ctx.nzNotFoundImage !== "simple");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.isImageBuildIn && ctx.nzNotFoundImage === "simple");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzNotFoundContent !== null);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzNotFoundFooter);
    }
  },
  dependencies: [NgIf, NzOutletModule, NzStringTemplateOutletDirective, NzEmptyDefaultComponent, NzEmptySimpleComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzEmptyComponent = _NzEmptyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzEmptyComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-empty",
      exportAs: "nzEmpty",
      template: `
    <div class="ant-empty-image">
      <ng-container *ngIf="!isImageBuildIn">
        <ng-container *nzStringTemplateOutlet="nzNotFoundImage">
          <img [src]="nzNotFoundImage" [alt]="isContentString ? nzNotFoundContent : 'empty'" />
        </ng-container>
      </ng-container>
      <nz-empty-default *ngIf="isImageBuildIn && nzNotFoundImage !== 'simple'"></nz-empty-default>
      <nz-empty-simple *ngIf="isImageBuildIn && nzNotFoundImage === 'simple'"></nz-empty-simple>
    </div>
    <p class="ant-empty-description" *ngIf="nzNotFoundContent !== null">
      <ng-container *nzStringTemplateOutlet="nzNotFoundContent">
        {{ isContentString ? nzNotFoundContent : locale['description'] }}
      </ng-container>
    </p>
    <div class="ant-empty-footer" *ngIf="nzNotFoundFooter">
      <ng-container *nzStringTemplateOutlet="nzNotFoundFooter">
        {{ nzNotFoundFooter }}
      </ng-container>
    </div>
  `,
      host: {
        class: "ant-empty"
      },
      imports: [NgIf, NzOutletModule, NzEmptyDefaultComponent, NzEmptySimpleComponent],
      standalone: true
    }]
  }], () => [{
    type: NzI18nService
  }, {
    type: ChangeDetectorRef
  }], {
    nzNotFoundImage: [{
      type: Input
    }],
    nzNotFoundContent: [{
      type: Input
    }],
    nzNotFoundFooter: [{
      type: Input
    }]
  });
})();
function getEmptySize(componentName) {
  switch (componentName) {
    case "table":
    case "list":
      return "normal";
    case "select":
    case "tree-select":
    case "cascader":
    case "transfer":
      return "small";
    default:
      return "";
  }
}
var _NzEmbedEmptyComponent = class _NzEmbedEmptyComponent {
  constructor(configService, viewContainerRef, cdr, injector) {
    this.configService = configService;
    this.viewContainerRef = viewContainerRef;
    this.cdr = cdr;
    this.injector = injector;
    this.contentType = "string";
    this.size = "";
    this.destroy$ = new Subject();
  }
  ngOnChanges(changes) {
    if (changes.nzComponentName) {
      this.size = getEmptySize(changes.nzComponentName.currentValue);
    }
    if (changes.specificContent && !changes.specificContent.isFirstChange()) {
      this.content = changes.specificContent.currentValue;
      this.renderEmpty();
    }
  }
  ngOnInit() {
    this.subscribeDefaultEmptyContentChange();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  renderEmpty() {
    const content = this.content;
    if (typeof content === "string") {
      this.contentType = "string";
    } else if (content instanceof TemplateRef) {
      const context = {
        $implicit: this.nzComponentName
      };
      this.contentType = "template";
      this.contentPortal = new TemplatePortal(content, this.viewContainerRef, context);
    } else if (content instanceof Type) {
      const injector = Injector.create({
        parent: this.injector,
        providers: [{
          provide: NZ_EMPTY_COMPONENT_NAME,
          useValue: this.nzComponentName
        }]
      });
      this.contentType = "component";
      this.contentPortal = new ComponentPortal(content, this.viewContainerRef, injector);
    } else {
      this.contentType = "string";
      this.contentPortal = void 0;
    }
    this.cdr.detectChanges();
  }
  subscribeDefaultEmptyContentChange() {
    this.configService.getConfigChangeEventForComponent("empty").pipe(startWith(true), takeUntil(this.destroy$)).subscribe(() => {
      this.content = this.specificContent || this.getUserDefaultEmptyContent();
      this.renderEmpty();
    });
  }
  getUserDefaultEmptyContent() {
    return (this.configService.getConfigForComponent("empty") || {}).nzDefaultEmptyContent;
  }
};
_NzEmbedEmptyComponent.\u0275fac = function NzEmbedEmptyComponent_Factory(t) {
  return new (t || _NzEmbedEmptyComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Injector));
};
_NzEmbedEmptyComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzEmbedEmptyComponent,
  selectors: [["nz-embed-empty"]],
  inputs: {
    nzComponentName: "nzComponentName",
    specificContent: "specificContent"
  },
  exportAs: ["nzEmbedEmpty"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 2,
  consts: [[3, "ngSwitch", 4, "ngIf"], [4, "ngIf"], [3, "ngSwitch"], ["class", "ant-empty-normal", 3, "nzNotFoundImage", 4, "ngSwitchCase"], ["class", "ant-empty-small", 3, "nzNotFoundImage", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], [1, "ant-empty-normal", 3, "nzNotFoundImage"], [1, "ant-empty-small", 3, "nzNotFoundImage"], [3, "cdkPortalOutlet"]],
  template: function NzEmbedEmptyComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzEmbedEmptyComponent_ng_container_0_Template, 4, 3, "ng-container", 0)(1, NzEmbedEmptyComponent_ng_container_1_Template, 3, 2, "ng-container", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", !ctx.content && ctx.specificContent !== null);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.content);
    }
  },
  dependencies: [NzEmptyComponent, NgIf, NgSwitch, NgSwitchCase, NgSwitchDefault, PortalModule, CdkPortalOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzEmbedEmptyComponent = _NzEmbedEmptyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzEmbedEmptyComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-embed-empty",
      exportAs: "nzEmbedEmpty",
      template: `
    <ng-container *ngIf="!content && specificContent !== null" [ngSwitch]="size">
      <nz-empty *ngSwitchCase="'normal'" class="ant-empty-normal" [nzNotFoundImage]="'simple'"></nz-empty>
      <nz-empty *ngSwitchCase="'small'" class="ant-empty-small" [nzNotFoundImage]="'simple'"></nz-empty>
      <nz-empty *ngSwitchDefault></nz-empty>
    </ng-container>
    <ng-container *ngIf="content">
      <ng-template *ngIf="contentType !== 'string'" [cdkPortalOutlet]="contentPortal"></ng-template>
      <ng-container *ngIf="contentType === 'string'">
        {{ content }}
      </ng-container>
    </ng-container>
  `,
      imports: [NzEmptyComponent, NgIf, NgSwitch, NgSwitchCase, NgSwitchDefault, PortalModule],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Injector
  }], {
    nzComponentName: [{
      type: Input
    }],
    specificContent: [{
      type: Input
    }]
  });
})();
var _NzEmptyModule = class _NzEmptyModule {
};
_NzEmptyModule.\u0275fac = function NzEmptyModule_Factory(t) {
  return new (t || _NzEmptyModule)();
};
_NzEmptyModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzEmptyModule
});
_NzEmptyModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzEmptyComponent, NzEmbedEmptyComponent]
});
var NzEmptyModule = _NzEmptyModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzEmptyModule, [{
    type: NgModule,
    args: [{
      imports: [NzEmptyComponent, NzEmbedEmptyComponent, NzEmptyDefaultComponent, NzEmptySimpleComponent],
      exports: [NzEmptyComponent, NzEmbedEmptyComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-select.mjs
var _c011 = ["*"];
function NzOptionItemGroupComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r0.nzLabel);
  }
}
function NzOptionItemComponent_ng_template_1_ng_template_0_Template(rf, ctx) {
}
function NzOptionItemComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzOptionItemComponent_ng_template_1_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template);
  }
}
function NzOptionItemComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate(ctx_r1.label);
  }
}
function NzOptionItemComponent_div_4_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
}
function NzOptionItemComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275template(1, NzOptionItemComponent_div_4_span_1_Template, 1, 0, "span", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r3.icon)("ngIfElse", ctx_r3.icon);
  }
}
function NzOptionContainerComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275element(1, "nz-embed-empty", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("specificContent", ctx_r0.notFoundContent);
  }
}
function NzOptionContainerComponent_ng_template_3_nz_option_item_group_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-option-item-group", 9);
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("nzLabel", item_r3.groupLabel);
  }
}
function NzOptionContainerComponent_ng_template_3_nz_option_item_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-option-item", 10);
    \u0275\u0275listener("itemHover", function NzOptionContainerComponent_ng_template_3_nz_option_item_2_Template_nz_option_item_itemHover_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r7 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r7.onItemHover($event));
    })("itemClick", function NzOptionContainerComponent_ng_template_3_nz_option_item_2_Template_nz_option_item_itemClick_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.onItemClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275property("icon", ctx_r5.menuItemSelectedIcon)("customContent", item_r3.nzCustomContent)("template", item_r3.template)("grouped", !!item_r3.groupLabel)("disabled", item_r3.nzDisabled)("showState", ctx_r5.mode === "tags" || ctx_r5.mode === "multiple")("title", item_r3.nzTitle)("label", item_r3.nzLabel)("compareWith", ctx_r5.compareWith)("activatedValue", ctx_r5.activatedValue)("listOfSelectedValue", ctx_r5.listOfSelectedValue)("value", item_r3.nzValue);
  }
}
function NzOptionContainerComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 6);
    \u0275\u0275template(1, NzOptionContainerComponent_ng_template_3_nz_option_item_group_1_Template, 1, 1, "nz-option-item-group", 7)(2, NzOptionContainerComponent_ng_template_3_nz_option_item_2_Template, 1, 12, "nz-option-item", 8);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    \u0275\u0275property("ngSwitch", item_r3.type);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "group");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "item");
  }
}
function NzOptionContainerComponent_ng_template_4_Template(rf, ctx) {
}
function NzOptionComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
function NzSelectArrowComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 3);
  }
}
function NzSelectArrowComponent_ng_template_1_ng_container_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
}
function NzSelectArrowComponent_ng_template_1_ng_container_0_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 9);
  }
}
function NzSelectArrowComponent_ng_template_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzSelectArrowComponent_ng_template_1_ng_container_0_span_1_Template, 1, 0, "span", 6)(2, NzSelectArrowComponent_ng_template_1_ng_container_0_span_2_Template, 1, 0, "span", 7);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r4.search);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r4.search);
  }
}
function NzSelectArrowComponent_ng_template_1_ng_template_1_ng_container_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 11);
  }
  if (rf & 2) {
    const suffixIcon_r10 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("nzType", suffixIcon_r10);
  }
}
function NzSelectArrowComponent_ng_template_1_ng_template_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzSelectArrowComponent_ng_template_1_ng_template_1_ng_container_0_span_1_Template, 1, 1, "span", 10);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const suffixIcon_r10 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", suffixIcon_r10);
  }
}
function NzSelectArrowComponent_ng_template_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzSelectArrowComponent_ng_template_1_ng_template_1_ng_container_0_Template, 2, 1, "ng-container", 2);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r5.suffixIcon);
  }
}
function NzSelectArrowComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzSelectArrowComponent_ng_template_1_ng_container_0_Template, 3, 2, "ng-container", 4)(1, NzSelectArrowComponent_ng_template_1_ng_template_1_Template, 1, 1, "ng-template", null, 5, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const _r6 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r1.showArrow && !ctx_r1.suffixIcon)("ngIfElse", _r6);
  }
}
function NzSelectArrowComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r3.feedbackIcon);
  }
}
function NzSelectClearComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 1);
  }
}
function NzSelectItemComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r2.label);
  }
}
function NzSelectItemComponent_ng_container_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate(ctx_r3.label);
  }
}
function NzSelectItemComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzSelectItemComponent_ng_container_0_div_1_Template, 2, 1, "div", 2)(2, NzSelectItemComponent_ng_container_0_ng_template_2_Template, 1, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r4 = \u0275\u0275reference(3);
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.deletable)("ngIfElse", _r4);
  }
}
function NzSelectItemComponent_span_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
}
function NzSelectItemComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 5);
    \u0275\u0275listener("click", function NzSelectItemComponent_span_1_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.onDelete($event));
    });
    \u0275\u0275template(1, NzSelectItemComponent_span_1_span_1_Template, 1, 0, "span", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r1.removeIcon)("ngIfElse", ctx_r1.removeIcon);
  }
}
var _c16 = (a0) => ({
  $implicit: a0
});
function NzSelectPlaceholderComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r0.placeholder, " ");
  }
}
var _c25 = ["inputElement"];
var _c32 = ["mirrorElement"];
function NzSelectSearchComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 3, 4);
  }
}
function NzSelectTopControlComponent_ng_container_1_nz_select_item_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-select-item", 6);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275property("deletable", false)("disabled", false)("removeIcon", ctx_r3.removeIcon)("label", ctx_r3.listOfTopItem[0].nzLabel)("contentTemplateOutlet", ctx_r3.customTemplate)("contentTemplateOutletContext", ctx_r3.listOfTopItem[0]);
  }
}
function NzSelectTopControlComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "nz-select-search", 4);
    \u0275\u0275listener("isComposingChange", function NzSelectTopControlComponent_ng_container_1_Template_nz_select_search_isComposingChange_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.isComposingChange($event));
    })("valueChange", function NzSelectTopControlComponent_ng_container_1_Template_nz_select_search_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.onInputValueChange($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, NzSelectTopControlComponent_ng_container_1_nz_select_item_2_Template, 1, 6, "nz-select-item", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzId", ctx_r0.nzId)("disabled", ctx_r0.disabled)("value", ctx_r0.inputValue)("showInput", ctx_r0.showSearch)("mirrorSync", false)("autofocus", ctx_r0.autofocus)("focusTrigger", ctx_r0.open);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.isShowSingleLabel);
  }
}
function NzSelectTopControlComponent_ng_container_2_nz_select_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-select-item", 9);
    \u0275\u0275listener("delete", function NzSelectTopControlComponent_ng_container_2_nz_select_item_1_Template_nz_select_item_delete_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r10);
      const item_r8 = restoredCtx.$implicit;
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.onDeleteItem(item_r8.contentTemplateOutletContext));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r8 = ctx.$implicit;
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275property("removeIcon", ctx_r7.removeIcon)("label", item_r8.nzLabel)("disabled", item_r8.nzDisabled || ctx_r7.disabled)("contentTemplateOutlet", item_r8.contentTemplateOutlet)("deletable", true)("contentTemplateOutletContext", item_r8.contentTemplateOutletContext);
  }
}
function NzSelectTopControlComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzSelectTopControlComponent_ng_container_2_nz_select_item_1_Template, 1, 6, "nz-select-item", 7);
    \u0275\u0275elementStart(2, "nz-select-search", 8);
    \u0275\u0275listener("isComposingChange", function NzSelectTopControlComponent_ng_container_2_Template_nz_select_search_isComposingChange_2_listener($event) {
      \u0275\u0275restoreView(_r12);
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11.isComposingChange($event));
    })("valueChange", function NzSelectTopControlComponent_ng_container_2_Template_nz_select_search_valueChange_2_listener($event) {
      \u0275\u0275restoreView(_r12);
      const ctx_r13 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r13.onInputValueChange($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r1.listOfSlicedItem)("ngForTrackBy", ctx_r1.trackValue);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzId", ctx_r1.nzId)("disabled", ctx_r1.disabled)("value", ctx_r1.inputValue)("autofocus", ctx_r1.autofocus)("showInput", true)("mirrorSync", true)("focusTrigger", ctx_r1.open);
  }
}
function NzSelectTopControlComponent_nz_select_placeholder_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-select-placeholder", 10);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("placeholder", ctx_r2.placeHolder);
  }
}
function NzSelectComponent_nz_select_arrow_2_ng_template_1_nz_form_item_feedback_icon_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-form-item-feedback-icon", 8);
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(3);
    \u0275\u0275property("status", ctx_r6.status);
  }
}
function NzSelectComponent_nz_select_arrow_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzSelectComponent_nz_select_arrow_2_ng_template_1_nz_form_item_feedback_icon_0_Template, 1, 1, "nz-form-item-feedback-icon", 7);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngIf", ctx_r4.hasFeedback && !!ctx_r4.status);
  }
}
function NzSelectComponent_nz_select_arrow_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select-arrow", 5);
    \u0275\u0275template(1, NzSelectComponent_nz_select_arrow_2_ng_template_1_Template, 1, 1, "ng-template", null, 6, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _r5 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("showArrow", ctx_r1.nzShowArrow)("loading", ctx_r1.nzLoading)("search", ctx_r1.nzOpen && ctx_r1.nzShowSearch)("suffixIcon", ctx_r1.nzSuffixIcon)("feedbackIcon", _r5);
  }
}
function NzSelectComponent_nz_select_clear_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-select-clear", 9);
    \u0275\u0275listener("clear", function NzSelectComponent_nz_select_clear_3_Template_nz_select_clear_clear_0_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.onClearSelection());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("clearIcon", ctx_r2.nzClearIcon);
  }
}
function NzSelectComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-option-container", 10);
    \u0275\u0275listener("keydown", function NzSelectComponent_ng_template_4_Template_nz_option_container_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.onKeyDown($event));
    })("itemClick", function NzSelectComponent_ng_template_4_Template_nz_option_container_itemClick_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11.onItemClick($event));
    })("scrollToBottom", function NzSelectComponent_ng_template_4_Template_nz_option_container_scrollToBottom_0_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r12 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r12.nzScrollToBottom.emit());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-select-dropdown-placement-bottomLeft", ctx_r3.dropDownPosition === "bottomLeft")("ant-select-dropdown-placement-topLeft", ctx_r3.dropDownPosition === "topLeft")("ant-select-dropdown-placement-bottomRight", ctx_r3.dropDownPosition === "bottomRight")("ant-select-dropdown-placement-topRight", ctx_r3.dropDownPosition === "topRight");
    \u0275\u0275property("ngStyle", ctx_r3.nzDropdownStyle)("itemSize", ctx_r3.nzOptionHeightPx)("maxItemLength", ctx_r3.nzOptionOverflowSize)("matchWidth", ctx_r3.nzDropdownMatchSelectWidth)("@slideMotion", "enter")("@.disabled", !!(ctx_r3.noAnimation == null ? null : ctx_r3.noAnimation.nzNoAnimation))("nzNoAnimation", ctx_r3.noAnimation == null ? null : ctx_r3.noAnimation.nzNoAnimation)("listOfContainerItem", ctx_r3.listOfContainerItem)("menuItemSelectedIcon", ctx_r3.nzMenuItemSelectedIcon)("notFoundContent", ctx_r3.nzNotFoundContent)("activatedValue", ctx_r3.activatedValue)("listOfSelectedValue", ctx_r3.listOfValue)("dropdownRender", ctx_r3.nzDropdownRender)("compareWith", ctx_r3.compareWith)("mode", ctx_r3.nzMode);
  }
}
var _NzOptionGroupComponent = class _NzOptionGroupComponent {
  constructor() {
    this.nzLabel = null;
    this.changes = new Subject();
  }
  ngOnChanges() {
    this.changes.next();
  }
};
_NzOptionGroupComponent.\u0275fac = function NzOptionGroupComponent_Factory(t) {
  return new (t || _NzOptionGroupComponent)();
};
_NzOptionGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzOptionGroupComponent,
  selectors: [["nz-option-group"]],
  inputs: {
    nzLabel: "nzLabel"
  },
  exportAs: ["nzOptionGroup"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c011,
  decls: 1,
  vars: 0,
  template: function NzOptionGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzOptionGroupComponent = _NzOptionGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzOptionGroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-option-group",
      exportAs: "nzOptionGroup",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: ` <ng-content></ng-content> `,
      standalone: true
    }]
  }], null, {
    nzLabel: [{
      type: Input
    }]
  });
})();
var _NzOptionItemGroupComponent = class _NzOptionItemGroupComponent {
  constructor() {
    this.nzLabel = null;
  }
};
_NzOptionItemGroupComponent.\u0275fac = function NzOptionItemGroupComponent_Factory(t) {
  return new (t || _NzOptionItemGroupComponent)();
};
_NzOptionItemGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzOptionItemGroupComponent,
  selectors: [["nz-option-item-group"]],
  hostAttrs: [1, "ant-select-item", "ant-select-item-group"],
  inputs: {
    nzLabel: "nzLabel"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 1,
  consts: [[4, "nzStringTemplateOutlet"]],
  template: function NzOptionItemGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzOptionItemGroupComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzLabel);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzOptionItemGroupComponent = _NzOptionItemGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzOptionItemGroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-option-item-group",
      template: ` <ng-container *nzStringTemplateOutlet="nzLabel">{{ nzLabel }}</ng-container> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      host: {
        class: "ant-select-item ant-select-item-group"
      },
      imports: [NzOutletModule],
      standalone: true
    }]
  }], () => [], {
    nzLabel: [{
      type: Input
    }]
  });
})();
var _NzOptionItemComponent = class _NzOptionItemComponent {
  constructor(elementRef, ngZone, destroy$) {
    this.elementRef = elementRef;
    this.ngZone = ngZone;
    this.destroy$ = destroy$;
    this.selected = false;
    this.activated = false;
    this.grouped = false;
    this.customContent = false;
    this.template = null;
    this.disabled = false;
    this.showState = false;
    this.label = null;
    this.value = null;
    this.activatedValue = null;
    this.listOfSelectedValue = [];
    this.icon = null;
    this.itemClick = new EventEmitter();
    this.itemHover = new EventEmitter();
  }
  ngOnChanges(changes) {
    const {
      value,
      activatedValue,
      listOfSelectedValue
    } = changes;
    if (value || listOfSelectedValue) {
      this.selected = this.listOfSelectedValue.some((v) => this.compareWith(v, this.value));
    }
    if (value || activatedValue) {
      this.activated = this.compareWith(this.activatedValue, this.value);
    }
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.elementRef.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe(() => {
        if (!this.disabled) {
          this.ngZone.run(() => this.itemClick.emit(this.value));
        }
      });
      fromEvent(this.elementRef.nativeElement, "mouseenter").pipe(takeUntil(this.destroy$)).subscribe(() => {
        if (!this.disabled) {
          this.ngZone.run(() => this.itemHover.emit(this.value));
        }
      });
    });
  }
};
_NzOptionItemComponent.\u0275fac = function NzOptionItemComponent_Factory(t) {
  return new (t || _NzOptionItemComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NzDestroyService));
};
_NzOptionItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzOptionItemComponent,
  selectors: [["nz-option-item"]],
  hostAttrs: [1, "ant-select-item", "ant-select-item-option"],
  hostVars: 9,
  hostBindings: function NzOptionItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("title", ctx.title);
      \u0275\u0275classProp("ant-select-item-option-grouped", ctx.grouped)("ant-select-item-option-selected", ctx.selected && !ctx.disabled)("ant-select-item-option-disabled", ctx.disabled)("ant-select-item-option-active", ctx.activated && !ctx.disabled);
    }
  },
  inputs: {
    grouped: "grouped",
    customContent: "customContent",
    template: "template",
    disabled: "disabled",
    showState: "showState",
    title: "title",
    label: "label",
    value: "value",
    activatedValue: "activatedValue",
    listOfSelectedValue: "listOfSelectedValue",
    icon: "icon",
    compareWith: "compareWith"
  },
  outputs: {
    itemClick: "itemClick",
    itemHover: "itemHover"
  },
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 5,
  vars: 3,
  consts: [[1, "ant-select-item-option-content"], [3, "ngIf", "ngIfElse"], ["noCustomContent", ""], ["class", "ant-select-item-option-state", "style", "user-select: none", "unselectable", "on", 4, "ngIf"], [3, "ngTemplateOutlet"], ["unselectable", "on", 1, "ant-select-item-option-state", 2, "user-select", "none"], ["nz-icon", "", "nzType", "check", "class", "ant-select-selected-icon", 4, "ngIf", "ngIfElse"], ["nz-icon", "", "nzType", "check", 1, "ant-select-selected-icon"]],
  template: function NzOptionItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, NzOptionItemComponent_ng_template_1_Template, 1, 1, "ng-template", 1)(2, NzOptionItemComponent_ng_template_2_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, NzOptionItemComponent_div_4_Template, 2, 2, "div", 3);
    }
    if (rf & 2) {
      const _r2 = \u0275\u0275reference(3);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.customContent)("ngIfElse", _r2);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.showState && ctx.selected);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NzIconModule, NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzOptionItemComponent = _NzOptionItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzOptionItemComponent, [{
    type: Component,
    args: [{
      selector: "nz-option-item",
      template: `
    <div class="ant-select-item-option-content">
      <ng-template [ngIf]="customContent" [ngIfElse]="noCustomContent">
        <ng-template [ngTemplateOutlet]="template"></ng-template>
      </ng-template>
      <ng-template #noCustomContent>{{ label }}</ng-template>
    </div>
    <div *ngIf="showState && selected" class="ant-select-item-option-state" style="user-select: none" unselectable="on">
      <span nz-icon nzType="check" class="ant-select-selected-icon" *ngIf="!icon; else icon"></span>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      host: {
        class: "ant-select-item ant-select-item-option",
        "[attr.title]": "title",
        "[class.ant-select-item-option-grouped]": "grouped",
        "[class.ant-select-item-option-selected]": "selected && !disabled",
        "[class.ant-select-item-option-disabled]": "disabled",
        "[class.ant-select-item-option-active]": "activated && !disabled"
      },
      providers: [NzDestroyService],
      imports: [NgIf, NgTemplateOutlet, NzIconModule],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NzDestroyService
  }], {
    grouped: [{
      type: Input
    }],
    customContent: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    showState: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    activatedValue: [{
      type: Input
    }],
    listOfSelectedValue: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    itemClick: [{
      type: Output
    }],
    itemHover: [{
      type: Output
    }]
  });
})();
var _NzOptionContainerComponent = class _NzOptionContainerComponent {
  constructor() {
    this.notFoundContent = void 0;
    this.menuItemSelectedIcon = null;
    this.dropdownRender = null;
    this.activatedValue = null;
    this.listOfSelectedValue = [];
    this.mode = "default";
    this.matchWidth = true;
    this.itemSize = 32;
    this.maxItemLength = 8;
    this.listOfContainerItem = [];
    this.itemClick = new EventEmitter();
    this.scrollToBottom = new EventEmitter();
    this.scrolledIndex = 0;
    this.ngZone = inject(NgZone);
    this.platformId = inject(PLATFORM_ID);
  }
  onItemClick(value) {
    this.itemClick.emit(value);
  }
  onItemHover(value) {
    this.activatedValue = value;
  }
  trackValue(_index, option) {
    return option.key;
  }
  onScrolledIndexChange(index) {
    this.scrolledIndex = index;
    if (index === this.listOfContainerItem.length - this.maxItemLength) {
      this.scrollToBottom.emit();
    }
  }
  scrollToActivatedValue() {
    const index = this.listOfContainerItem.findIndex((item) => this.compareWith(item.key, this.activatedValue));
    if (index < this.scrolledIndex || index >= this.scrolledIndex + this.maxItemLength) {
      this.cdkVirtualScrollViewport.scrollToIndex(index || 0);
    }
  }
  ngOnChanges(changes) {
    const {
      listOfContainerItem,
      activatedValue
    } = changes;
    if (listOfContainerItem || activatedValue) {
      this.scrollToActivatedValue();
    }
  }
  ngAfterViewInit() {
    if (isPlatformBrowser(this.platformId)) {
      this.ngZone.runOutsideAngular(() => setTimeout(() => this.scrollToActivatedValue()));
    }
  }
};
_NzOptionContainerComponent.\u0275fac = function NzOptionContainerComponent_Factory(t) {
  return new (t || _NzOptionContainerComponent)();
};
_NzOptionContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzOptionContainerComponent,
  selectors: [["nz-option-container"]],
  viewQuery: function NzOptionContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(CdkVirtualScrollViewport, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.cdkVirtualScrollViewport = _t.first);
    }
  },
  hostAttrs: [1, "ant-select-dropdown"],
  inputs: {
    notFoundContent: "notFoundContent",
    menuItemSelectedIcon: "menuItemSelectedIcon",
    dropdownRender: "dropdownRender",
    activatedValue: "activatedValue",
    listOfSelectedValue: "listOfSelectedValue",
    compareWith: "compareWith",
    mode: "mode",
    matchWidth: "matchWidth",
    itemSize: "itemSize",
    maxItemLength: "maxItemLength",
    listOfContainerItem: "listOfContainerItem"
  },
  outputs: {
    itemClick: "itemClick",
    scrollToBottom: "scrollToBottom"
  },
  exportAs: ["nzOptionContainer"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 5,
  vars: 14,
  consts: [["class", "ant-select-item-empty", 4, "ngIf"], [3, "itemSize", "maxBufferPx", "minBufferPx", "scrolledIndexChange"], ["cdkVirtualFor", "", 3, "cdkVirtualForOf", "cdkVirtualForTrackBy", "cdkVirtualForTemplateCacheSize"], [3, "ngTemplateOutlet"], [1, "ant-select-item-empty"], ["nzComponentName", "select", 3, "specificContent"], [3, "ngSwitch"], [3, "nzLabel", 4, "ngSwitchCase"], [3, "icon", "customContent", "template", "grouped", "disabled", "showState", "title", "label", "compareWith", "activatedValue", "listOfSelectedValue", "value", "itemHover", "itemClick", 4, "ngSwitchCase"], [3, "nzLabel"], [3, "icon", "customContent", "template", "grouped", "disabled", "showState", "title", "label", "compareWith", "activatedValue", "listOfSelectedValue", "value", "itemHover", "itemClick"]],
  template: function NzOptionContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div");
      \u0275\u0275template(1, NzOptionContainerComponent_div_1_Template, 2, 1, "div", 0);
      \u0275\u0275elementStart(2, "cdk-virtual-scroll-viewport", 1);
      \u0275\u0275listener("scrolledIndexChange", function NzOptionContainerComponent_Template_cdk_virtual_scroll_viewport_scrolledIndexChange_2_listener($event) {
        return ctx.onScrolledIndexChange($event);
      });
      \u0275\u0275template(3, NzOptionContainerComponent_ng_template_3_Template, 3, 3, "ng-template", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, NzOptionContainerComponent_ng_template_4_Template, 0, 0, "ng-template", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.listOfContainerItem.length === 0);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("height", ctx.listOfContainerItem.length * ctx.itemSize, "px")("max-height", ctx.itemSize * ctx.maxItemLength, "px");
      \u0275\u0275classProp("full-width", !ctx.matchWidth);
      \u0275\u0275property("itemSize", ctx.itemSize)("maxBufferPx", ctx.itemSize * ctx.maxItemLength)("minBufferPx", ctx.itemSize * ctx.maxItemLength);
      \u0275\u0275advance(1);
      \u0275\u0275property("cdkVirtualForOf", ctx.listOfContainerItem)("cdkVirtualForTrackBy", ctx.trackValue)("cdkVirtualForTemplateCacheSize", 0);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngTemplateOutlet", ctx.dropdownRender);
    }
  },
  dependencies: [NzEmptyModule, NzEmbedEmptyComponent, NgIf, NgSwitch, NzOptionItemGroupComponent, NgSwitchCase, NzOptionItemComponent, NgTemplateOutlet, OverlayModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, NzOverlayModule],
  encapsulation: 2,
  changeDetection: 0
});
var NzOptionContainerComponent = _NzOptionContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzOptionContainerComponent, [{
    type: Component,
    args: [{
      selector: "nz-option-container",
      exportAs: "nzOptionContainer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      preserveWhitespaces: false,
      template: `
    <div>
      <div *ngIf="listOfContainerItem.length === 0" class="ant-select-item-empty">
        <nz-embed-empty nzComponentName="select" [specificContent]="notFoundContent!"></nz-embed-empty>
      </div>
      <cdk-virtual-scroll-viewport
        [class.full-width]="!matchWidth"
        [itemSize]="itemSize"
        [maxBufferPx]="itemSize * maxItemLength"
        [minBufferPx]="itemSize * maxItemLength"
        (scrolledIndexChange)="onScrolledIndexChange($event)"
        [style.height.px]="listOfContainerItem.length * itemSize"
        [style.max-height.px]="itemSize * maxItemLength"
      >
        <ng-template
          cdkVirtualFor
          [cdkVirtualForOf]="listOfContainerItem"
          [cdkVirtualForTrackBy]="trackValue"
          [cdkVirtualForTemplateCacheSize]="0"
          let-item
        >
          <ng-container [ngSwitch]="item.type">
            <nz-option-item-group *ngSwitchCase="'group'" [nzLabel]="item.groupLabel"></nz-option-item-group>
            <nz-option-item
              *ngSwitchCase="'item'"
              [icon]="menuItemSelectedIcon"
              [customContent]="item.nzCustomContent"
              [template]="item.template"
              [grouped]="!!item.groupLabel"
              [disabled]="item.nzDisabled"
              [showState]="mode === 'tags' || mode === 'multiple'"
              [title]="item.nzTitle"
              [label]="item.nzLabel"
              [compareWith]="compareWith"
              [activatedValue]="activatedValue"
              [listOfSelectedValue]="listOfSelectedValue"
              [value]="item.nzValue"
              (itemHover)="onItemHover($event)"
              (itemClick)="onItemClick($event)"
            ></nz-option-item>
          </ng-container>
        </ng-template>
      </cdk-virtual-scroll-viewport>
      <ng-template [ngTemplateOutlet]="dropdownRender"></ng-template>
    </div>
  `,
      host: {
        class: "ant-select-dropdown"
      },
      imports: [NzEmptyModule, NgIf, NgSwitch, NzOptionItemGroupComponent, NgSwitchCase, NzOptionItemComponent, NgTemplateOutlet, OverlayModule, NzOverlayModule],
      standalone: true
    }]
  }], null, {
    notFoundContent: [{
      type: Input
    }],
    menuItemSelectedIcon: [{
      type: Input
    }],
    dropdownRender: [{
      type: Input
    }],
    activatedValue: [{
      type: Input
    }],
    listOfSelectedValue: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    matchWidth: [{
      type: Input
    }],
    itemSize: [{
      type: Input
    }],
    maxItemLength: [{
      type: Input
    }],
    listOfContainerItem: [{
      type: Input
    }],
    itemClick: [{
      type: Output
    }],
    scrollToBottom: [{
      type: Output
    }],
    cdkVirtualScrollViewport: [{
      type: ViewChild,
      args: [CdkVirtualScrollViewport, {
        static: true
      }]
    }]
  });
})();
var _NzOptionComponent = class _NzOptionComponent {
  constructor(nzOptionGroupComponent, destroy$) {
    this.nzOptionGroupComponent = nzOptionGroupComponent;
    this.destroy$ = destroy$;
    this.changes = new Subject();
    this.groupLabel = null;
    this.nzLabel = null;
    this.nzValue = null;
    this.nzDisabled = false;
    this.nzHide = false;
    this.nzCustomContent = false;
  }
  ngOnInit() {
    if (this.nzOptionGroupComponent) {
      this.nzOptionGroupComponent.changes.pipe(startWith(true), takeUntil(this.destroy$)).subscribe(() => {
        this.groupLabel = this.nzOptionGroupComponent.nzLabel;
      });
    }
  }
  ngOnChanges() {
    this.changes.next();
  }
};
_NzOptionComponent.\u0275fac = function NzOptionComponent_Factory(t) {
  return new (t || _NzOptionComponent)(\u0275\u0275directiveInject(NzOptionGroupComponent, 8), \u0275\u0275directiveInject(NzDestroyService));
};
_NzOptionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzOptionComponent,
  selectors: [["nz-option"]],
  viewQuery: function NzOptionComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.template = _t.first);
    }
  },
  inputs: {
    nzTitle: "nzTitle",
    nzLabel: "nzLabel",
    nzValue: "nzValue",
    nzKey: "nzKey",
    nzDisabled: "nzDisabled",
    nzHide: "nzHide",
    nzCustomContent: "nzCustomContent"
  },
  exportAs: ["nzOption"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c011,
  decls: 1,
  vars: 0,
  template: function NzOptionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzOptionComponent_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzOptionComponent = _NzOptionComponent;
__decorate([InputBoolean()], NzOptionComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzOptionComponent.prototype, "nzHide", void 0);
__decorate([InputBoolean()], NzOptionComponent.prototype, "nzCustomContent", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzOptionComponent, [{
    type: Component,
    args: [{
      selector: "nz-option",
      exportAs: "nzOption",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [NzDestroyService],
      template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `,
      standalone: true
    }]
  }], () => [{
    type: NzOptionGroupComponent,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzDestroyService
  }], {
    template: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    nzTitle: [{
      type: Input
    }],
    nzLabel: [{
      type: Input
    }],
    nzValue: [{
      type: Input
    }],
    nzKey: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzHide: [{
      type: Input
    }],
    nzCustomContent: [{
      type: Input
    }]
  });
})();
var _NzSelectArrowComponent = class _NzSelectArrowComponent {
  constructor() {
    this.loading = false;
    this.search = false;
    this.showArrow = false;
    this.suffixIcon = null;
    this.feedbackIcon = null;
  }
};
_NzSelectArrowComponent.\u0275fac = function NzSelectArrowComponent_Factory(t) {
  return new (t || _NzSelectArrowComponent)();
};
_NzSelectArrowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSelectArrowComponent,
  selectors: [["nz-select-arrow"]],
  hostAttrs: [1, "ant-select-arrow"],
  hostVars: 2,
  hostBindings: function NzSelectArrowComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-select-arrow-loading", ctx.loading);
    }
  },
  inputs: {
    loading: "loading",
    search: "search",
    showArrow: "showArrow",
    suffixIcon: "suffixIcon",
    feedbackIcon: "feedbackIcon"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 4,
  vars: 3,
  consts: [["nz-icon", "", "nzType", "loading", 4, "ngIf", "ngIfElse"], ["defaultArrow", ""], [4, "nzStringTemplateOutlet"], ["nz-icon", "", "nzType", "loading"], [4, "ngIf", "ngIfElse"], ["suffixTemplate", ""], ["nz-icon", "", "nzType", "down", 4, "ngIf"], ["nz-icon", "", "nzType", "search", 4, "ngIf"], ["nz-icon", "", "nzType", "down"], ["nz-icon", "", "nzType", "search"], ["nz-icon", "", 3, "nzType", 4, "ngIf"], ["nz-icon", "", 3, "nzType"]],
  template: function NzSelectArrowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzSelectArrowComponent_span_0_Template, 1, 0, "span", 0)(1, NzSelectArrowComponent_ng_template_1_Template, 3, 2, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, NzSelectArrowComponent_ng_container_3_Template, 2, 1, "ng-container", 2);
    }
    if (rf & 2) {
      const _r2 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.loading)("ngIfElse", _r2);
      \u0275\u0275advance(3);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.feedbackIcon);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NgIf, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzSelectArrowComponent = _NzSelectArrowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSelectArrowComponent, [{
    type: Component,
    args: [{
      selector: "nz-select-arrow",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span nz-icon nzType="loading" *ngIf="loading; else defaultArrow"></span>
    <ng-template #defaultArrow>
      <ng-container *ngIf="showArrow && !suffixIcon; else suffixTemplate">
        <span nz-icon nzType="down" *ngIf="!search"></span>
        <span nz-icon nzType="search" *ngIf="search"></span>
      </ng-container>
      <ng-template #suffixTemplate>
        <ng-container *nzStringTemplateOutlet="suffixIcon; let suffixIcon">
          <span *ngIf="suffixIcon" nz-icon [nzType]="suffixIcon"></span>
        </ng-container>
      </ng-template>
    </ng-template>
    <ng-container *nzStringTemplateOutlet="feedbackIcon">{{ feedbackIcon }}</ng-container>
  `,
      host: {
        class: "ant-select-arrow",
        "[class.ant-select-arrow-loading]": "loading"
      },
      imports: [NzIconModule, NgIf, NzOutletModule],
      standalone: true
    }]
  }], () => [], {
    loading: [{
      type: Input
    }],
    search: [{
      type: Input
    }],
    showArrow: [{
      type: Input
    }],
    suffixIcon: [{
      type: Input
    }],
    feedbackIcon: [{
      type: Input
    }]
  });
})();
var _NzSelectClearComponent = class _NzSelectClearComponent {
  constructor() {
    this.clearIcon = null;
    this.clear = new EventEmitter();
  }
  onClick(e) {
    e.preventDefault();
    e.stopPropagation();
    this.clear.emit(e);
  }
};
_NzSelectClearComponent.\u0275fac = function NzSelectClearComponent_Factory(t) {
  return new (t || _NzSelectClearComponent)();
};
_NzSelectClearComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSelectClearComponent,
  selectors: [["nz-select-clear"]],
  hostAttrs: [1, "ant-select-clear"],
  hostBindings: function NzSelectClearComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzSelectClearComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
  },
  inputs: {
    clearIcon: "clearIcon"
  },
  outputs: {
    clear: "clear"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 2,
  consts: [["nz-icon", "", "nzType", "close-circle", "nzTheme", "fill", "class", "ant-select-close-icon", 4, "ngIf", "ngIfElse"], ["nz-icon", "", "nzType", "close-circle", "nzTheme", "fill", 1, "ant-select-close-icon"]],
  template: function NzSelectClearComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzSelectClearComponent_span_0_Template, 1, 0, "span", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", !ctx.clearIcon)("ngIfElse", ctx.clearIcon);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NzSelectClearComponent = _NzSelectClearComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSelectClearComponent, [{
    type: Component,
    args: [{
      selector: "nz-select-clear",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span
      nz-icon
      nzType="close-circle"
      nzTheme="fill"
      *ngIf="!clearIcon; else clearIcon"
      class="ant-select-close-icon"
    ></span>
  `,
      host: {
        class: "ant-select-clear",
        "(click)": "onClick($event)"
      },
      imports: [NzIconModule, NgIf],
      standalone: true
    }]
  }], () => [], {
    clearIcon: [{
      type: Input
    }],
    clear: [{
      type: Output
    }]
  });
})();
var _NzSelectItemComponent = class _NzSelectItemComponent {
  constructor() {
    this.disabled = false;
    this.label = null;
    this.deletable = false;
    this.removeIcon = null;
    this.contentTemplateOutletContext = null;
    this.contentTemplateOutlet = null;
    this.delete = new EventEmitter();
  }
  onDelete(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!this.disabled) {
      this.delete.next(e);
    }
  }
};
_NzSelectItemComponent.\u0275fac = function NzSelectItemComponent_Factory(t) {
  return new (t || _NzSelectItemComponent)();
};
_NzSelectItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSelectItemComponent,
  selectors: [["nz-select-item"]],
  hostAttrs: [1, "ant-select-selection-item"],
  hostVars: 3,
  hostBindings: function NzSelectItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("title", ctx.label);
      \u0275\u0275classProp("ant-select-selection-item-disabled", ctx.disabled);
    }
  },
  inputs: {
    disabled: "disabled",
    label: "label",
    deletable: "deletable",
    removeIcon: "removeIcon",
    contentTemplateOutletContext: "contentTemplateOutletContext",
    contentTemplateOutlet: "contentTemplateOutlet"
  },
  outputs: {
    delete: "delete"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 5,
  consts: [[4, "nzStringTemplateOutlet", "nzStringTemplateOutletContext"], ["class", "ant-select-selection-item-remove", 3, "click", 4, "ngIf"], ["class", "ant-select-selection-item-content", 4, "ngIf", "ngIfElse"], ["labelTemplate", ""], [1, "ant-select-selection-item-content"], [1, "ant-select-selection-item-remove", 3, "click"], ["nz-icon", "", "nzType", "close", 4, "ngIf", "ngIfElse"], ["nz-icon", "", "nzType", "close"]],
  template: function NzSelectItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzSelectItemComponent_ng_container_0_Template, 4, 2, "ng-container", 0)(1, NzSelectItemComponent_span_1_Template, 2, 2, "span", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("nzStringTemplateOutlet", ctx.contentTemplateOutlet)("nzStringTemplateOutletContext", \u0275\u0275pureFunction1(3, _c16, ctx.contentTemplateOutletContext));
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.deletable && !ctx.disabled);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective, NgIf, NzIconModule, NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzSelectItemComponent = _NzSelectItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSelectItemComponent, [{
    type: Component,
    args: [{
      selector: "nz-select-item",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-container *nzStringTemplateOutlet="contentTemplateOutlet; context: { $implicit: contentTemplateOutletContext }">
      <div class="ant-select-selection-item-content" *ngIf="deletable; else labelTemplate">{{ label }}</div>
      <ng-template #labelTemplate>{{ label }}</ng-template>
    </ng-container>
    <span *ngIf="deletable && !disabled" class="ant-select-selection-item-remove" (click)="onDelete($event)">
      <span nz-icon nzType="close" *ngIf="!removeIcon; else removeIcon"></span>
    </span>
  `,
      host: {
        class: "ant-select-selection-item",
        "[attr.title]": "label",
        "[class.ant-select-selection-item-disabled]": "disabled"
      },
      imports: [NzOutletModule, NgIf, NzIconModule],
      standalone: true
    }]
  }], () => [], {
    disabled: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    deletable: [{
      type: Input
    }],
    removeIcon: [{
      type: Input
    }],
    contentTemplateOutletContext: [{
      type: Input
    }],
    contentTemplateOutlet: [{
      type: Input
    }],
    delete: [{
      type: Output
    }]
  });
})();
var _NzSelectPlaceholderComponent = class _NzSelectPlaceholderComponent {
  constructor() {
    this.placeholder = null;
  }
};
_NzSelectPlaceholderComponent.\u0275fac = function NzSelectPlaceholderComponent_Factory(t) {
  return new (t || _NzSelectPlaceholderComponent)();
};
_NzSelectPlaceholderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSelectPlaceholderComponent,
  selectors: [["nz-select-placeholder"]],
  hostAttrs: [1, "ant-select-selection-placeholder"],
  inputs: {
    placeholder: "placeholder"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 1,
  consts: [[4, "nzStringTemplateOutlet"]],
  template: function NzSelectPlaceholderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzSelectPlaceholderComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("nzStringTemplateOutlet", ctx.placeholder);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzSelectPlaceholderComponent = _NzSelectPlaceholderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSelectPlaceholderComponent, [{
    type: Component,
    args: [{
      selector: "nz-select-placeholder",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-container *nzStringTemplateOutlet="placeholder">
      {{ placeholder }}
    </ng-container>
  `,
      host: {
        class: "ant-select-selection-placeholder"
      },
      imports: [NzOutletModule],
      standalone: true
    }]
  }], () => [], {
    placeholder: [{
      type: Input
    }]
  });
})();
var _NzSelectSearchComponent = class _NzSelectSearchComponent {
  setCompositionState(isComposing) {
    this.isComposingChange.next(isComposing);
  }
  onValueChange(value) {
    this.value = value;
    this.valueChange.next(value);
    if (this.mirrorSync) {
      this.syncMirrorWidth();
    }
  }
  clearInputValue() {
    const inputDOM = this.inputElement.nativeElement;
    inputDOM.value = "";
    this.onValueChange("");
  }
  syncMirrorWidth() {
    const mirrorDOM = this.mirrorElement.nativeElement;
    const hostDOM = this.elementRef.nativeElement;
    const inputDOM = this.inputElement.nativeElement;
    this.renderer.removeStyle(hostDOM, "width");
    this.renderer.setProperty(mirrorDOM, "textContent", `${inputDOM.value}\xA0`);
    this.renderer.setStyle(hostDOM, "width", `${mirrorDOM.scrollWidth}px`);
  }
  focus() {
    this.focusMonitor.focusVia(this.inputElement, "keyboard");
  }
  blur() {
    this.inputElement.nativeElement.blur();
  }
  constructor(elementRef, renderer, focusMonitor) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.focusMonitor = focusMonitor;
    this.nzId = null;
    this.disabled = false;
    this.mirrorSync = false;
    this.showInput = true;
    this.focusTrigger = false;
    this.value = "";
    this.autofocus = false;
    this.valueChange = new EventEmitter();
    this.isComposingChange = new EventEmitter();
  }
  ngOnChanges(changes) {
    const inputDOM = this.inputElement.nativeElement;
    const {
      focusTrigger,
      showInput
    } = changes;
    if (showInput) {
      if (this.showInput) {
        this.renderer.removeAttribute(inputDOM, "readonly");
      } else {
        this.renderer.setAttribute(inputDOM, "readonly", "readonly");
      }
    }
    if (focusTrigger && focusTrigger.currentValue === true && focusTrigger.previousValue === false) {
      inputDOM.focus();
    }
  }
  ngAfterViewInit() {
    if (this.mirrorSync) {
      this.syncMirrorWidth();
    }
    if (this.autofocus) {
      this.focus();
    }
  }
};
_NzSelectSearchComponent.\u0275fac = function NzSelectSearchComponent_Factory(t) {
  return new (t || _NzSelectSearchComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(FocusMonitor));
};
_NzSelectSearchComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSelectSearchComponent,
  selectors: [["nz-select-search"]],
  viewQuery: function NzSelectSearchComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c25, 7);
      \u0275\u0275viewQuery(_c32, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inputElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.mirrorElement = _t.first);
    }
  },
  hostAttrs: [1, "ant-select-selection-search"],
  inputs: {
    nzId: "nzId",
    disabled: "disabled",
    mirrorSync: "mirrorSync",
    showInput: "showInput",
    focusTrigger: "focusTrigger",
    value: "value",
    autofocus: "autofocus"
  },
  outputs: {
    valueChange: "valueChange",
    isComposingChange: "isComposingChange"
  },
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: COMPOSITION_BUFFER_MODE,
    useValue: false
  }]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 3,
  vars: 7,
  consts: [["autocomplete", "off", 1, "ant-select-selection-search-input", 3, "ngModel", "disabled", "ngModelChange", "compositionstart", "compositionend"], ["inputElement", ""], ["class", "ant-select-selection-search-mirror", 4, "ngIf"], [1, "ant-select-selection-search-mirror"], ["mirrorElement", ""]],
  template: function NzSelectSearchComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "input", 0, 1);
      \u0275\u0275listener("ngModelChange", function NzSelectSearchComponent_Template_input_ngModelChange_0_listener($event) {
        return ctx.onValueChange($event);
      })("compositionstart", function NzSelectSearchComponent_Template_input_compositionstart_0_listener() {
        return ctx.setCompositionState(true);
      })("compositionend", function NzSelectSearchComponent_Template_input_compositionend_0_listener() {
        return ctx.setCompositionState(false);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(2, NzSelectSearchComponent_span_2_Template, 2, 0, "span", 2);
    }
    if (rf & 2) {
      \u0275\u0275styleProp("opacity", ctx.showInput ? null : 0);
      \u0275\u0275property("ngModel", ctx.value)("disabled", ctx.disabled);
      \u0275\u0275attribute("id", ctx.nzId)("autofocus", ctx.autofocus ? "autofocus" : null);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.mirrorSync);
    }
  },
  dependencies: [FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NzSelectSearchComponent = _NzSelectSearchComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSelectSearchComponent, [{
    type: Component,
    args: [{
      selector: "nz-select-search",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <input
      #inputElement
      [attr.id]="nzId"
      autocomplete="off"
      class="ant-select-selection-search-input"
      [ngModel]="value"
      [attr.autofocus]="autofocus ? 'autofocus' : null"
      [disabled]="disabled"
      [style.opacity]="showInput ? null : 0"
      (ngModelChange)="onValueChange($event)"
      (compositionstart)="setCompositionState(true)"
      (compositionend)="setCompositionState(false)"
    />
    <span #mirrorElement *ngIf="mirrorSync" class="ant-select-selection-search-mirror"></span>
  `,
      host: {
        class: "ant-select-selection-search"
      },
      providers: [{
        provide: COMPOSITION_BUFFER_MODE,
        useValue: false
      }],
      imports: [FormsModule, NgIf],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: FocusMonitor
  }], {
    nzId: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    mirrorSync: [{
      type: Input
    }],
    showInput: [{
      type: Input
    }],
    focusTrigger: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    autofocus: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    isComposingChange: [{
      type: Output
    }],
    inputElement: [{
      type: ViewChild,
      args: ["inputElement", {
        static: true
      }]
    }],
    mirrorElement: [{
      type: ViewChild,
      args: ["mirrorElement", {
        static: false
      }]
    }]
  });
})();
var _NzSelectTopControlComponent = class _NzSelectTopControlComponent {
  updateTemplateVariable() {
    const isSelectedValueEmpty = this.listOfTopItem.length === 0;
    this.isShowPlaceholder = isSelectedValueEmpty && !this.isComposing && !this.inputValue;
    this.isShowSingleLabel = !isSelectedValueEmpty && !this.isComposing && !this.inputValue;
  }
  isComposingChange(isComposing) {
    this.isComposing = isComposing;
    this.updateTemplateVariable();
  }
  onInputValueChange(value) {
    if (value !== this.inputValue) {
      this.inputValue = value;
      this.updateTemplateVariable();
      this.inputValueChange.emit(value);
      this.tokenSeparate(value, this.tokenSeparators);
    }
  }
  tokenSeparate(inputValue, tokenSeparators) {
    const includesSeparators = (str, separators) => {
      for (let i = 0; i < separators.length; ++i) {
        if (str.lastIndexOf(separators[i]) > 0) {
          return true;
        }
      }
      return false;
    };
    const splitBySeparators = (str, separators) => {
      const reg = new RegExp(`[${separators.join()}]`);
      const array = str.split(reg).filter((token) => token);
      return [...new Set(array)];
    };
    if (inputValue && inputValue.length && tokenSeparators.length && this.mode !== "default" && includesSeparators(inputValue, tokenSeparators)) {
      const listOfLabel = splitBySeparators(inputValue, tokenSeparators);
      this.tokenize.next(listOfLabel);
    }
  }
  clearInputValue() {
    if (this.nzSelectSearchComponent) {
      this.nzSelectSearchComponent.clearInputValue();
    }
  }
  focus() {
    if (this.nzSelectSearchComponent) {
      this.nzSelectSearchComponent.focus();
    }
  }
  blur() {
    if (this.nzSelectSearchComponent) {
      this.nzSelectSearchComponent.blur();
    }
  }
  trackValue(_index, option) {
    return option.nzValue;
  }
  onDeleteItem(item) {
    if (!this.disabled && !item.nzDisabled) {
      this.deleteItem.next(item);
    }
  }
  constructor(elementRef, ngZone, noAnimation) {
    this.elementRef = elementRef;
    this.ngZone = ngZone;
    this.noAnimation = noAnimation;
    this.nzId = null;
    this.showSearch = false;
    this.placeHolder = null;
    this.open = false;
    this.maxTagCount = Infinity;
    this.autofocus = false;
    this.disabled = false;
    this.mode = "default";
    this.customTemplate = null;
    this.maxTagPlaceholder = null;
    this.removeIcon = null;
    this.listOfTopItem = [];
    this.tokenSeparators = [];
    this.tokenize = new EventEmitter();
    this.inputValueChange = new EventEmitter();
    this.deleteItem = new EventEmitter();
    this.listOfSlicedItem = [];
    this.isShowPlaceholder = true;
    this.isShowSingleLabel = false;
    this.isComposing = false;
    this.inputValue = null;
    this.destroy$ = new Subject();
  }
  ngOnChanges(changes) {
    const {
      listOfTopItem,
      maxTagCount,
      customTemplate,
      maxTagPlaceholder
    } = changes;
    if (listOfTopItem) {
      this.updateTemplateVariable();
    }
    if (listOfTopItem || maxTagCount || customTemplate || maxTagPlaceholder) {
      const listOfSlicedItem = this.listOfTopItem.slice(0, this.maxTagCount).map((o) => ({
        nzLabel: o.nzLabel,
        nzValue: o.nzValue,
        nzDisabled: o.nzDisabled,
        contentTemplateOutlet: this.customTemplate,
        contentTemplateOutletContext: o
      }));
      if (this.listOfTopItem.length > this.maxTagCount) {
        const exceededLabel = `+ ${this.listOfTopItem.length - this.maxTagCount} ...`;
        const listOfSelectedValue = this.listOfTopItem.map((item) => item.nzValue);
        const exceededItem = {
          nzLabel: exceededLabel,
          nzValue: "$$__nz_exceeded_item",
          nzDisabled: true,
          contentTemplateOutlet: this.maxTagPlaceholder,
          contentTemplateOutletContext: listOfSelectedValue.slice(this.maxTagCount)
        };
        listOfSlicedItem.push(exceededItem);
      }
      this.listOfSlicedItem = listOfSlicedItem;
    }
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.elementRef.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        if (event.target !== this.nzSelectSearchComponent.inputElement.nativeElement) {
          this.nzSelectSearchComponent.focus();
        }
      });
      fromEvent(this.elementRef.nativeElement, "keydown").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        if (event.target instanceof HTMLInputElement) {
          const inputValue = event.target.value;
          if (event.keyCode === BACKSPACE && this.mode !== "default" && !inputValue && this.listOfTopItem.length > 0) {
            event.preventDefault();
            this.ngZone.run(() => this.onDeleteItem(this.listOfTopItem[this.listOfTopItem.length - 1]));
          }
        }
      });
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
};
_NzSelectTopControlComponent.\u0275fac = function NzSelectTopControlComponent_Factory(t) {
  return new (t || _NzSelectTopControlComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzSelectTopControlComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSelectTopControlComponent,
  selectors: [["nz-select-top-control"]],
  viewQuery: function NzSelectTopControlComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NzSelectSearchComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzSelectSearchComponent = _t.first);
    }
  },
  hostAttrs: [1, "ant-select-selector"],
  inputs: {
    nzId: "nzId",
    showSearch: "showSearch",
    placeHolder: "placeHolder",
    open: "open",
    maxTagCount: "maxTagCount",
    autofocus: "autofocus",
    disabled: "disabled",
    mode: "mode",
    customTemplate: "customTemplate",
    maxTagPlaceholder: "maxTagPlaceholder",
    removeIcon: "removeIcon",
    listOfTopItem: "listOfTopItem",
    tokenSeparators: "tokenSeparators"
  },
  outputs: {
    tokenize: "tokenize",
    inputValueChange: "inputValueChange",
    deleteItem: "deleteItem"
  },
  exportAs: ["nzSelectTopControl"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 4,
  vars: 3,
  consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "placeholder", 4, "ngIf"], [3, "nzId", "disabled", "value", "showInput", "mirrorSync", "autofocus", "focusTrigger", "isComposingChange", "valueChange"], [3, "deletable", "disabled", "removeIcon", "label", "contentTemplateOutlet", "contentTemplateOutletContext", 4, "ngIf"], [3, "deletable", "disabled", "removeIcon", "label", "contentTemplateOutlet", "contentTemplateOutletContext"], [3, "removeIcon", "label", "disabled", "contentTemplateOutlet", "deletable", "contentTemplateOutletContext", "delete", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "nzId", "disabled", "value", "autofocus", "showInput", "mirrorSync", "focusTrigger", "isComposingChange", "valueChange"], [3, "removeIcon", "label", "disabled", "contentTemplateOutlet", "deletable", "contentTemplateOutletContext", "delete"], [3, "placeholder"]],
  template: function NzSelectTopControlComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementContainerStart(0, 0);
      \u0275\u0275template(1, NzSelectTopControlComponent_ng_container_1_Template, 3, 8, "ng-container", 1)(2, NzSelectTopControlComponent_ng_container_2_Template, 3, 9, "ng-container", 2);
      \u0275\u0275elementContainerEnd();
      \u0275\u0275template(3, NzSelectTopControlComponent_nz_select_placeholder_3_Template, 1, 1, "nz-select-placeholder", 3);
    }
    if (rf & 2) {
      \u0275\u0275property("ngSwitch", ctx.mode);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "default");
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.isShowPlaceholder);
    }
  },
  dependencies: [NgSwitch, NzSelectSearchComponent, NgSwitchCase, NzSelectItemComponent, NgIf, NgSwitchDefault, NgForOf, NzSelectPlaceholderComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzSelectTopControlComponent = _NzSelectTopControlComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSelectTopControlComponent, [{
    type: Component,
    args: [{
      selector: "nz-select-top-control",
      exportAs: "nzSelectTopControl",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <!--single mode-->
    <ng-container [ngSwitch]="mode">
      <ng-container *ngSwitchCase="'default'">
        <nz-select-search
          [nzId]="nzId"
          [disabled]="disabled"
          [value]="inputValue!"
          [showInput]="showSearch"
          [mirrorSync]="false"
          [autofocus]="autofocus"
          [focusTrigger]="open"
          (isComposingChange)="isComposingChange($event)"
          (valueChange)="onInputValueChange($event)"
        ></nz-select-search>
        <nz-select-item
          *ngIf="isShowSingleLabel"
          [deletable]="false"
          [disabled]="false"
          [removeIcon]="removeIcon"
          [label]="listOfTopItem[0].nzLabel"
          [contentTemplateOutlet]="customTemplate"
          [contentTemplateOutletContext]="listOfTopItem[0]"
        ></nz-select-item>
      </ng-container>
      <ng-container *ngSwitchDefault>
        <!--multiple or tags mode-->
        <nz-select-item
          *ngFor="let item of listOfSlicedItem; trackBy: trackValue"
          [removeIcon]="removeIcon"
          [label]="item.nzLabel"
          [disabled]="item.nzDisabled || disabled"
          [contentTemplateOutlet]="item.contentTemplateOutlet"
          [deletable]="true"
          [contentTemplateOutletContext]="item.contentTemplateOutletContext"
          (delete)="onDeleteItem(item.contentTemplateOutletContext)"
        ></nz-select-item>
        <nz-select-search
          [nzId]="nzId"
          [disabled]="disabled"
          [value]="inputValue!"
          [autofocus]="autofocus"
          [showInput]="true"
          [mirrorSync]="true"
          [focusTrigger]="open"
          (isComposingChange)="isComposingChange($event)"
          (valueChange)="onInputValueChange($event)"
        ></nz-select-search>
      </ng-container>
    </ng-container>
    <nz-select-placeholder *ngIf="isShowPlaceholder" [placeholder]="placeHolder"></nz-select-placeholder>
  `,
      host: {
        class: "ant-select-selector"
      },
      imports: [NgSwitch, NzSelectSearchComponent, NgSwitchCase, NzSelectItemComponent, NgIf, NgSwitchDefault, NgForOf, NzSelectPlaceholderComponent],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    nzId: [{
      type: Input
    }],
    showSearch: [{
      type: Input
    }],
    placeHolder: [{
      type: Input
    }],
    open: [{
      type: Input
    }],
    maxTagCount: [{
      type: Input
    }],
    autofocus: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    customTemplate: [{
      type: Input
    }],
    maxTagPlaceholder: [{
      type: Input
    }],
    removeIcon: [{
      type: Input
    }],
    listOfTopItem: [{
      type: Input
    }],
    tokenSeparators: [{
      type: Input
    }],
    tokenize: [{
      type: Output
    }],
    inputValueChange: [{
      type: Output
    }],
    deleteItem: [{
      type: Output
    }],
    nzSelectSearchComponent: [{
      type: ViewChild,
      args: [NzSelectSearchComponent]
    }]
  });
})();
var defaultFilterOption = (searchValue, item) => {
  if (item && item.nzLabel) {
    return item.nzLabel.toString().toLowerCase().indexOf(searchValue.toLowerCase()) > -1;
  } else {
    return false;
  }
};
var NZ_CONFIG_MODULE_NAME6 = "select";
var _NzSelectComponent = class _NzSelectComponent {
  set nzShowArrow(value) {
    this._nzShowArrow = value;
  }
  get nzShowArrow() {
    return this._nzShowArrow === void 0 ? this.nzMode === "default" : this._nzShowArrow;
  }
  generateTagItem(value) {
    return {
      nzValue: value,
      nzLabel: value,
      type: "item"
    };
  }
  onItemClick(value) {
    this.activatedValue = value;
    if (this.nzMode === "default") {
      if (this.listOfValue.length === 0 || !this.compareWith(this.listOfValue[0], value)) {
        this.updateListOfValue([value]);
      }
      this.setOpenState(false);
    } else {
      const targetIndex = this.listOfValue.findIndex((o) => this.compareWith(o, value));
      if (targetIndex !== -1) {
        const listOfValueAfterRemoved = this.listOfValue.filter((_, i) => i !== targetIndex);
        this.updateListOfValue(listOfValueAfterRemoved);
      } else if (this.listOfValue.length < this.nzMaxMultipleCount) {
        const listOfValueAfterAdded = [...this.listOfValue, value];
        this.updateListOfValue(listOfValueAfterAdded);
      }
      this.focus();
      if (this.nzAutoClearSearchValue) {
        this.clearInput();
      }
    }
  }
  onItemDelete(item) {
    const listOfSelectedValue = this.listOfValue.filter((v) => !this.compareWith(v, item.nzValue));
    this.updateListOfValue(listOfSelectedValue);
    this.clearInput();
  }
  updateListOfContainerItem() {
    let listOfContainerItem = this.listOfTagAndTemplateItem.filter((item) => !item.nzHide).filter((item) => {
      if (!this.nzServerSearch && this.searchValue) {
        return this.nzFilterOption(this.searchValue, item);
      } else {
        return true;
      }
    });
    if (this.nzMode === "tags" && this.searchValue) {
      const matchedItem = this.listOfTagAndTemplateItem.find((item) => item.nzLabel === this.searchValue);
      if (!matchedItem) {
        const tagItem = this.generateTagItem(this.searchValue);
        listOfContainerItem = [tagItem, ...listOfContainerItem];
        this.activatedValue = tagItem.nzValue;
      } else {
        this.activatedValue = matchedItem.nzValue;
      }
    }
    const activatedItem = listOfContainerItem.find((item) => item.nzLabel === this.searchValue) || listOfContainerItem.find((item) => this.compareWith(item.nzValue, this.activatedValue)) || listOfContainerItem.find((item) => this.compareWith(item.nzValue, this.listOfValue[0])) || listOfContainerItem[0];
    this.activatedValue = activatedItem && activatedItem.nzValue || null;
    let listOfGroupLabel = [];
    if (this.isReactiveDriven) {
      listOfGroupLabel = [...new Set(this.nzOptions.filter((o) => o.groupLabel).map((o) => o.groupLabel))];
    } else {
      if (this.listOfNzOptionGroupComponent) {
        listOfGroupLabel = this.listOfNzOptionGroupComponent.map((o) => o.nzLabel);
      }
    }
    listOfGroupLabel.forEach((label) => {
      const index = listOfContainerItem.findIndex((item) => label === item.groupLabel);
      if (index > -1) {
        const groupItem = {
          groupLabel: label,
          type: "group",
          key: label
        };
        listOfContainerItem.splice(index, 0, groupItem);
      }
    });
    this.listOfContainerItem = [...listOfContainerItem];
    this.updateCdkConnectedOverlayPositions();
  }
  clearInput() {
    this.nzSelectTopControlComponent.clearInputValue();
  }
  updateListOfValue(listOfValue) {
    const covertListToModel = (list2, mode) => {
      if (mode === "default") {
        if (list2.length > 0) {
          return list2[0];
        } else {
          return null;
        }
      } else {
        return list2;
      }
    };
    const model = covertListToModel(listOfValue, this.nzMode);
    if (this.value !== model) {
      this.listOfValue = listOfValue;
      this.listOfValue$.next(listOfValue);
      this.value = model;
      this.onChange(this.value);
    }
  }
  onTokenSeparate(listOfLabel) {
    const listOfMatchedValue = this.listOfTagAndTemplateItem.filter((item) => listOfLabel.findIndex((label) => label === item.nzLabel) !== -1).map((item) => item.nzValue).filter((item) => this.listOfValue.findIndex((v) => this.compareWith(v, item)) === -1);
    if (this.nzMode === "multiple") {
      this.updateListOfValue([...this.listOfValue, ...listOfMatchedValue]);
    } else if (this.nzMode === "tags") {
      const listOfUnMatchedLabel = listOfLabel.filter((label) => this.listOfTagAndTemplateItem.findIndex((item) => item.nzLabel === label) === -1);
      this.updateListOfValue([...this.listOfValue, ...listOfMatchedValue, ...listOfUnMatchedLabel]);
    }
    this.clearInput();
  }
  onKeyDown(e) {
    if (this.nzDisabled) {
      return;
    }
    const listOfFilteredOptionNotDisabled = this.listOfContainerItem.filter((item) => item.type === "item").filter((item) => !item.nzDisabled);
    const activatedIndex = listOfFilteredOptionNotDisabled.findIndex((item) => this.compareWith(item.nzValue, this.activatedValue));
    switch (e.keyCode) {
      case UP_ARROW:
        e.preventDefault();
        if (this.nzOpen && listOfFilteredOptionNotDisabled.length > 0) {
          const preIndex = activatedIndex > 0 ? activatedIndex - 1 : listOfFilteredOptionNotDisabled.length - 1;
          this.activatedValue = listOfFilteredOptionNotDisabled[preIndex].nzValue;
        }
        break;
      case DOWN_ARROW:
        e.preventDefault();
        if (this.nzOpen && listOfFilteredOptionNotDisabled.length > 0) {
          const nextIndex = activatedIndex < listOfFilteredOptionNotDisabled.length - 1 ? activatedIndex + 1 : 0;
          this.activatedValue = listOfFilteredOptionNotDisabled[nextIndex].nzValue;
        } else {
          this.setOpenState(true);
        }
        break;
      case ENTER:
        e.preventDefault();
        if (this.nzOpen) {
          if (isNotNil(this.activatedValue) && activatedIndex !== -1) {
            this.onItemClick(this.activatedValue);
          }
        } else {
          this.setOpenState(true);
        }
        break;
      case SPACE:
        if (!this.nzOpen) {
          this.setOpenState(true);
          e.preventDefault();
        }
        break;
      case TAB:
        if (this.nzSelectOnTab) {
          if (this.nzOpen) {
            e.preventDefault();
            if (isNotNil(this.activatedValue)) {
              this.onItemClick(this.activatedValue);
            }
          }
        } else {
          this.setOpenState(false);
        }
        break;
      case ESCAPE:
        break;
      default:
        if (!this.nzOpen) {
          this.setOpenState(true);
        }
    }
  }
  setOpenState(value) {
    if (this.nzOpen !== value) {
      this.nzOpen = value;
      this.nzOpenChange.emit(value);
      this.onOpenChange();
      this.cdr.markForCheck();
    }
  }
  onOpenChange() {
    this.updateCdkConnectedOverlayStatus();
    if (this.nzAutoClearSearchValue) {
      this.clearInput();
    }
  }
  onInputValueChange(value) {
    this.searchValue = value;
    this.updateListOfContainerItem();
    this.nzOnSearch.emit(value);
    this.updateCdkConnectedOverlayPositions();
  }
  onClearSelection() {
    this.updateListOfValue([]);
  }
  onClickOutside(event) {
    if (!this.host.nativeElement.contains(event.target)) {
      this.setOpenState(false);
    }
  }
  focus() {
    this.nzSelectTopControlComponent.focus();
  }
  blur() {
    this.nzSelectTopControlComponent.blur();
  }
  onPositionChange(position) {
    const placement = getPlacementName(position);
    this.dropDownPosition = placement;
  }
  updateCdkConnectedOverlayStatus() {
    if (this.platform.isBrowser && this.originElement.nativeElement) {
      const triggerWidth = this.triggerWidth;
      cancelRequestAnimationFrame(this.requestId);
      this.requestId = reqAnimFrame(() => {
        this.triggerWidth = this.originElement.nativeElement.getBoundingClientRect().width;
        if (triggerWidth !== this.triggerWidth) {
          this.cdr.detectChanges();
        }
      });
    }
  }
  updateCdkConnectedOverlayPositions() {
    reqAnimFrame(() => {
      this.cdkConnectedOverlay?.overlayRef?.updatePosition();
    });
  }
  constructor(ngZone, destroy$, nzConfigService, cdr, host, renderer, platform, focusMonitor, directionality, noAnimation, nzFormStatusService, nzFormNoStatusService) {
    this.ngZone = ngZone;
    this.destroy$ = destroy$;
    this.nzConfigService = nzConfigService;
    this.cdr = cdr;
    this.host = host;
    this.renderer = renderer;
    this.platform = platform;
    this.focusMonitor = focusMonitor;
    this.directionality = directionality;
    this.noAnimation = noAnimation;
    this.nzFormStatusService = nzFormStatusService;
    this.nzFormNoStatusService = nzFormNoStatusService;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME6;
    this.nzId = null;
    this.nzSize = "default";
    this.nzStatus = "";
    this.nzOptionHeightPx = 32;
    this.nzOptionOverflowSize = 8;
    this.nzDropdownClassName = null;
    this.nzDropdownMatchSelectWidth = true;
    this.nzDropdownStyle = null;
    this.nzNotFoundContent = void 0;
    this.nzPlaceHolder = null;
    this.nzPlacement = null;
    this.nzMaxTagCount = Infinity;
    this.nzDropdownRender = null;
    this.nzCustomTemplate = null;
    this.nzSuffixIcon = null;
    this.nzClearIcon = null;
    this.nzRemoveIcon = null;
    this.nzMenuItemSelectedIcon = null;
    this.nzTokenSeparators = [];
    this.nzMaxTagPlaceholder = null;
    this.nzMaxMultipleCount = Infinity;
    this.nzMode = "default";
    this.nzFilterOption = defaultFilterOption;
    this.compareWith = (o1, o2) => o1 === o2;
    this.nzAllowClear = false;
    this.nzBorderless = false;
    this.nzShowSearch = false;
    this.nzLoading = false;
    this.nzAutoFocus = false;
    this.nzAutoClearSearchValue = true;
    this.nzServerSearch = false;
    this.nzDisabled = false;
    this.nzOpen = false;
    this.nzSelectOnTab = false;
    this.nzBackdrop = false;
    this.nzOptions = [];
    this.nzOnSearch = new EventEmitter();
    this.nzScrollToBottom = new EventEmitter();
    this.nzOpenChange = new EventEmitter();
    this.nzBlur = new EventEmitter();
    this.nzFocus = new EventEmitter();
    this.listOfValue$ = new BehaviorSubject([]);
    this.listOfTemplateItem$ = new BehaviorSubject([]);
    this.listOfTagAndTemplateItem = [];
    this.searchValue = "";
    this.isReactiveDriven = false;
    this.requestId = -1;
    this.isNzDisableFirstChange = true;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.dropDownPosition = "bottomLeft";
    this.triggerWidth = null;
    this.listOfContainerItem = [];
    this.listOfTopItem = [];
    this.activatedValue = null;
    this.listOfValue = [];
    this.focused = false;
    this.dir = "ltr";
    this.positions = [];
    this.prefixCls = "ant-select";
    this.statusCls = {};
    this.status = "";
    this.hasFeedback = false;
  }
  writeValue(modelValue) {
    if (this.value !== modelValue) {
      this.value = modelValue;
      const covertModelToList = (model, mode) => {
        if (model === null || model === void 0) {
          return [];
        } else if (mode === "default") {
          return [model];
        } else {
          return model;
        }
      };
      const listOfValue = covertModelToList(modelValue, this.nzMode);
      this.listOfValue = listOfValue;
      this.listOfValue$.next(listOfValue);
      this.cdr.markForCheck();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(disabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || disabled;
    this.isNzDisableFirstChange = false;
    if (this.nzDisabled) {
      this.setOpenState(false);
    }
    this.cdr.markForCheck();
  }
  ngOnChanges(changes) {
    const {
      nzOpen,
      nzDisabled,
      nzOptions,
      nzStatus,
      nzPlacement
    } = changes;
    if (nzOpen) {
      this.onOpenChange();
    }
    if (nzDisabled && this.nzDisabled) {
      this.setOpenState(false);
    }
    if (nzOptions) {
      this.isReactiveDriven = true;
      const listOfOptions = this.nzOptions || [];
      const listOfTransformedItem = listOfOptions.map((item) => {
        return {
          template: item.label instanceof TemplateRef ? item.label : null,
          nzTitle: this.getTitle(item.title, item.label),
          nzLabel: typeof item.label === "string" || typeof item.label === "number" ? item.label : null,
          nzValue: item.value,
          nzDisabled: item.disabled || false,
          nzHide: item.hide || false,
          nzCustomContent: item.label instanceof TemplateRef,
          groupLabel: item.groupLabel || null,
          type: "item",
          key: item.key === void 0 ? item.value : item.key
        };
      });
      this.listOfTemplateItem$.next(listOfTransformedItem);
    }
    if (nzStatus) {
      this.setStatusStyles(this.nzStatus, this.hasFeedback);
    }
    if (nzPlacement) {
      const {
        currentValue
      } = nzPlacement;
      this.dropDownPosition = currentValue;
      const listOfPlacement = ["bottomLeft", "topLeft", "bottomRight", "topRight"];
      if (currentValue && listOfPlacement.includes(currentValue)) {
        this.positions = [POSITION_MAP[currentValue]];
      } else {
        this.positions = listOfPlacement.map((e) => POSITION_MAP[e]);
      }
    }
  }
  ngOnInit() {
    this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {
      return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;
    }), withLatestFrom(this.nzFormNoStatusService ? this.nzFormNoStatusService.noFormStatus : of(false)), map(([{
      status,
      hasFeedback
    }, noStatus]) => ({
      status: noStatus ? "" : status,
      hasFeedback
    })), takeUntil(this.destroy$)).subscribe(({
      status,
      hasFeedback
    }) => {
      this.setStatusStyles(status, hasFeedback);
    });
    this.focusMonitor.monitor(this.host, true).pipe(takeUntil(this.destroy$)).subscribe((focusOrigin) => {
      if (!focusOrigin) {
        this.focused = false;
        this.cdr.markForCheck();
        this.nzBlur.emit();
        Promise.resolve().then(() => {
          this.onTouched();
        });
      } else {
        this.focused = true;
        this.cdr.markForCheck();
        this.nzFocus.emit();
      }
    });
    combineLatest([this.listOfValue$, this.listOfTemplateItem$]).pipe(takeUntil(this.destroy$)).subscribe(([listOfSelectedValue, listOfTemplateItem]) => {
      const listOfTagItem = listOfSelectedValue.filter(() => this.nzMode === "tags").filter((value) => listOfTemplateItem.findIndex((o) => this.compareWith(o.nzValue, value)) === -1).map((value) => this.listOfTopItem.find((o) => this.compareWith(o.nzValue, value)) || this.generateTagItem(value));
      this.listOfTagAndTemplateItem = [...listOfTemplateItem, ...listOfTagItem];
      this.listOfTopItem = this.listOfValue.map((v) => [...this.listOfTagAndTemplateItem, ...this.listOfTopItem].find((item) => this.compareWith(v, item.nzValue))).filter((item) => !!item);
      this.updateListOfContainerItem();
    });
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.nzConfigService.getConfigChangeEventForComponent("select").pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.cdr.markForCheck();
    });
    this.dir = this.directionality.value;
    this.ngZone.runOutsideAngular(() => fromEvent(this.host.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe(() => {
      if (this.nzOpen && this.nzShowSearch || this.nzDisabled) {
        return;
      }
      this.ngZone.run(() => this.setOpenState(!this.nzOpen));
    }));
    this.cdkConnectedOverlay.overlayKeydown.pipe(takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.setOpenState(false);
      }
    });
  }
  ngAfterContentInit() {
    if (!this.isReactiveDriven) {
      merge(this.listOfNzOptionGroupComponent.changes, this.listOfNzOptionComponent.changes).pipe(startWith(true), switchMap(() => merge(...[this.listOfNzOptionComponent.changes, this.listOfNzOptionGroupComponent.changes, ...this.listOfNzOptionComponent.map((option) => option.changes), ...this.listOfNzOptionGroupComponent.map((option) => option.changes)]).pipe(startWith(true))), takeUntil(this.destroy$)).subscribe(() => {
        const listOfOptionInterface = this.listOfNzOptionComponent.toArray().map((item) => {
          const {
            template,
            nzLabel,
            nzValue,
            nzKey,
            nzDisabled,
            nzHide,
            nzCustomContent,
            groupLabel
          } = item;
          return {
            template,
            nzLabel,
            nzValue,
            nzDisabled,
            nzHide,
            nzCustomContent,
            groupLabel,
            nzTitle: this.getTitle(item.nzTitle, item.nzLabel),
            type: "item",
            key: nzKey === void 0 ? nzValue : nzKey
          };
        });
        this.listOfTemplateItem$.next(listOfOptionInterface);
        this.cdr.markForCheck();
      });
    }
  }
  ngOnDestroy() {
    cancelRequestAnimationFrame(this.requestId);
    this.focusMonitor.stopMonitoring(this.host);
  }
  setStatusStyles(status, hasFeedback) {
    this.status = status;
    this.hasFeedback = hasFeedback;
    this.cdr.markForCheck();
    this.statusCls = getStatusClassNames(this.prefixCls, status, hasFeedback);
    Object.keys(this.statusCls).forEach((status2) => {
      if (this.statusCls[status2]) {
        this.renderer.addClass(this.host.nativeElement, status2);
      } else {
        this.renderer.removeClass(this.host.nativeElement, status2);
      }
    });
  }
  getTitle(title, label) {
    let rawTitle = void 0;
    if (title === void 0) {
      if (typeof label === "string" || typeof label === "number") {
        rawTitle = label.toString();
      }
    } else if (typeof title === "string" || typeof title === "number") {
      rawTitle = title.toString();
    }
    return rawTitle;
  }
};
_NzSelectComponent.\u0275fac = function NzSelectComponent_Factory(t) {
  return new (t || _NzSelectComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NzDestroyService), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(FocusMonitor), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9), \u0275\u0275directiveInject(NzFormStatusService, 8), \u0275\u0275directiveInject(NzFormNoStatusService, 8));
};
_NzSelectComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSelectComponent,
  selectors: [["nz-select"]],
  contentQueries: function NzSelectComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzOptionComponent, 5);
      \u0275\u0275contentQuery(dirIndex, NzOptionGroupComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzOptionComponent = _t);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzOptionGroupComponent = _t);
    }
  },
  viewQuery: function NzSelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(CdkOverlayOrigin, 7, ElementRef);
      \u0275\u0275viewQuery(CdkConnectedOverlay, 7);
      \u0275\u0275viewQuery(NzSelectTopControlComponent, 7);
      \u0275\u0275viewQuery(NzOptionGroupComponent, 7, ElementRef);
      \u0275\u0275viewQuery(NzSelectTopControlComponent, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.originElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.cdkConnectedOverlay = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzSelectTopControlComponent = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzOptionGroupComponentElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzSelectTopControlComponentElement = _t.first);
    }
  },
  hostAttrs: [1, "ant-select"],
  hostVars: 26,
  hostBindings: function NzSelectComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-select-in-form-item", !!ctx.nzFormStatusService)("ant-select-lg", ctx.nzSize === "large")("ant-select-sm", ctx.nzSize === "small")("ant-select-show-arrow", ctx.nzShowArrow)("ant-select-disabled", ctx.nzDisabled)("ant-select-show-search", (ctx.nzShowSearch || ctx.nzMode !== "default") && !ctx.nzDisabled)("ant-select-allow-clear", ctx.nzAllowClear)("ant-select-borderless", ctx.nzBorderless)("ant-select-open", ctx.nzOpen)("ant-select-focused", ctx.nzOpen || ctx.focused)("ant-select-single", ctx.nzMode === "default")("ant-select-multiple", ctx.nzMode !== "default")("ant-select-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzId: "nzId",
    nzSize: "nzSize",
    nzStatus: "nzStatus",
    nzOptionHeightPx: "nzOptionHeightPx",
    nzOptionOverflowSize: "nzOptionOverflowSize",
    nzDropdownClassName: "nzDropdownClassName",
    nzDropdownMatchSelectWidth: "nzDropdownMatchSelectWidth",
    nzDropdownStyle: "nzDropdownStyle",
    nzNotFoundContent: "nzNotFoundContent",
    nzPlaceHolder: "nzPlaceHolder",
    nzPlacement: "nzPlacement",
    nzMaxTagCount: "nzMaxTagCount",
    nzDropdownRender: "nzDropdownRender",
    nzCustomTemplate: "nzCustomTemplate",
    nzSuffixIcon: "nzSuffixIcon",
    nzClearIcon: "nzClearIcon",
    nzRemoveIcon: "nzRemoveIcon",
    nzMenuItemSelectedIcon: "nzMenuItemSelectedIcon",
    nzTokenSeparators: "nzTokenSeparators",
    nzMaxTagPlaceholder: "nzMaxTagPlaceholder",
    nzMaxMultipleCount: "nzMaxMultipleCount",
    nzMode: "nzMode",
    nzFilterOption: "nzFilterOption",
    compareWith: "compareWith",
    nzAllowClear: "nzAllowClear",
    nzBorderless: "nzBorderless",
    nzShowSearch: "nzShowSearch",
    nzLoading: "nzLoading",
    nzAutoFocus: "nzAutoFocus",
    nzAutoClearSearchValue: "nzAutoClearSearchValue",
    nzServerSearch: "nzServerSearch",
    nzDisabled: "nzDisabled",
    nzOpen: "nzOpen",
    nzSelectOnTab: "nzSelectOnTab",
    nzBackdrop: "nzBackdrop",
    nzOptions: "nzOptions",
    nzShowArrow: "nzShowArrow"
  },
  outputs: {
    nzOnSearch: "nzOnSearch",
    nzScrollToBottom: "nzScrollToBottom",
    nzOpenChange: "nzOpenChange",
    nzBlur: "nzBlur",
    nzFocus: "nzFocus"
  },
  exportAs: ["nzSelect"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService, {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NzSelectComponent),
    multi: true
  }]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 5,
  vars: 25,
  consts: [["cdkOverlayOrigin", "", 3, "nzId", "open", "disabled", "mode", "nzNoAnimation", "maxTagPlaceholder", "removeIcon", "placeHolder", "maxTagCount", "customTemplate", "tokenSeparators", "showSearch", "autofocus", "listOfTopItem", "inputValueChange", "tokenize", "deleteItem", "keydown"], ["origin", "cdkOverlayOrigin"], [3, "showArrow", "loading", "search", "suffixIcon", "feedbackIcon", 4, "ngIf"], [3, "clearIcon", "clear", 4, "ngIf"], ["cdkConnectedOverlay", "", "nzConnectedOverlay", "", 3, "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayWidth", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayTransformOriginOn", "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "overlayOutsideClick", "detach", "positionChange"], [3, "showArrow", "loading", "search", "suffixIcon", "feedbackIcon"], ["feedbackIconTpl", ""], [3, "status", 4, "ngIf"], [3, "status"], [3, "clearIcon", "clear"], [3, "ngStyle", "itemSize", "maxItemLength", "matchWidth", "nzNoAnimation", "listOfContainerItem", "menuItemSelectedIcon", "notFoundContent", "activatedValue", "listOfSelectedValue", "dropdownRender", "compareWith", "mode", "keydown", "itemClick", "scrollToBottom"]],
  template: function NzSelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nz-select-top-control", 0, 1);
      \u0275\u0275listener("inputValueChange", function NzSelectComponent_Template_nz_select_top_control_inputValueChange_0_listener($event) {
        return ctx.onInputValueChange($event);
      })("tokenize", function NzSelectComponent_Template_nz_select_top_control_tokenize_0_listener($event) {
        return ctx.onTokenSeparate($event);
      })("deleteItem", function NzSelectComponent_Template_nz_select_top_control_deleteItem_0_listener($event) {
        return ctx.onItemDelete($event);
      })("keydown", function NzSelectComponent_Template_nz_select_top_control_keydown_0_listener($event) {
        return ctx.onKeyDown($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(2, NzSelectComponent_nz_select_arrow_2_Template, 3, 5, "nz-select-arrow", 2)(3, NzSelectComponent_nz_select_clear_3_Template, 1, 1, "nz-select-clear", 3)(4, NzSelectComponent_ng_template_4_Template, 1, 23, "ng-template", 4);
      \u0275\u0275listener("overlayOutsideClick", function NzSelectComponent_Template_ng_template_overlayOutsideClick_4_listener($event) {
        return ctx.onClickOutside($event);
      })("detach", function NzSelectComponent_Template_ng_template_detach_4_listener() {
        return ctx.setOpenState(false);
      })("positionChange", function NzSelectComponent_Template_ng_template_positionChange_4_listener($event) {
        return ctx.onPositionChange($event);
      });
    }
    if (rf & 2) {
      const _r0 = \u0275\u0275reference(1);
      \u0275\u0275property("nzId", ctx.nzId)("open", ctx.nzOpen)("disabled", ctx.nzDisabled)("mode", ctx.nzMode)("@.disabled", !!(ctx.noAnimation == null ? null : ctx.noAnimation.nzNoAnimation))("nzNoAnimation", ctx.noAnimation == null ? null : ctx.noAnimation.nzNoAnimation)("maxTagPlaceholder", ctx.nzMaxTagPlaceholder)("removeIcon", ctx.nzRemoveIcon)("placeHolder", ctx.nzPlaceHolder)("maxTagCount", ctx.nzMaxTagCount)("customTemplate", ctx.nzCustomTemplate)("tokenSeparators", ctx.nzTokenSeparators)("showSearch", ctx.nzShowSearch)("autofocus", ctx.nzAutoFocus)("listOfTopItem", ctx.listOfTopItem);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.nzShowArrow || ctx.hasFeedback && !!ctx.status);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzAllowClear && !ctx.nzDisabled && ctx.listOfValue.length);
      \u0275\u0275advance(1);
      \u0275\u0275property("cdkConnectedOverlayHasBackdrop", ctx.nzBackdrop)("cdkConnectedOverlayMinWidth", ctx.nzDropdownMatchSelectWidth ? null : ctx.triggerWidth)("cdkConnectedOverlayWidth", ctx.nzDropdownMatchSelectWidth ? ctx.triggerWidth : null)("cdkConnectedOverlayOrigin", _r0)("cdkConnectedOverlayTransformOriginOn", ".ant-select-dropdown")("cdkConnectedOverlayPanelClass", ctx.nzDropdownClassName)("cdkConnectedOverlayOpen", ctx.nzOpen)("cdkConnectedOverlayPositions", ctx.positions);
    }
  },
  dependencies: [NzSelectTopControlComponent, CdkOverlayOrigin, NzNoAnimationDirective, NzSelectArrowComponent, NgIf, NzFormPatchModule, NzFormItemFeedbackIconComponent, NzSelectClearComponent, CdkConnectedOverlay, NzOverlayModule, NzConnectedOverlayDirective, NzOptionContainerComponent, NgStyle],
  encapsulation: 2,
  data: {
    animation: [slideMotion]
  },
  changeDetection: 0
});
var NzSelectComponent = _NzSelectComponent;
__decorate([WithConfig()], NzSelectComponent.prototype, "nzSuffixIcon", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzAllowClear", void 0);
__decorate([WithConfig(), InputBoolean()], NzSelectComponent.prototype, "nzBorderless", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzShowSearch", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzLoading", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzAutoFocus", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzAutoClearSearchValue", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzServerSearch", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzOpen", void 0);
__decorate([InputBoolean()], NzSelectComponent.prototype, "nzSelectOnTab", void 0);
__decorate([WithConfig(), InputBoolean()], NzSelectComponent.prototype, "nzBackdrop", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSelectComponent, [{
    type: Component,
    args: [{
      selector: "nz-select",
      exportAs: "nzSelect",
      preserveWhitespaces: false,
      providers: [NzDestroyService, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NzSelectComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      animations: [slideMotion],
      template: `
    <nz-select-top-control
      cdkOverlayOrigin
      #origin="cdkOverlayOrigin"
      [nzId]="nzId"
      [open]="nzOpen"
      [disabled]="nzDisabled"
      [mode]="nzMode"
      [@.disabled]="!!noAnimation?.nzNoAnimation"
      [nzNoAnimation]="noAnimation?.nzNoAnimation"
      [maxTagPlaceholder]="nzMaxTagPlaceholder"
      [removeIcon]="nzRemoveIcon"
      [placeHolder]="nzPlaceHolder"
      [maxTagCount]="nzMaxTagCount"
      [customTemplate]="nzCustomTemplate"
      [tokenSeparators]="nzTokenSeparators"
      [showSearch]="nzShowSearch"
      [autofocus]="nzAutoFocus"
      [listOfTopItem]="listOfTopItem"
      (inputValueChange)="onInputValueChange($event)"
      (tokenize)="onTokenSeparate($event)"
      (deleteItem)="onItemDelete($event)"
      (keydown)="onKeyDown($event)"
    ></nz-select-top-control>
    <nz-select-arrow
      *ngIf="nzShowArrow || (hasFeedback && !!status)"
      [showArrow]="nzShowArrow"
      [loading]="nzLoading"
      [search]="nzOpen && nzShowSearch"
      [suffixIcon]="nzSuffixIcon"
      [feedbackIcon]="feedbackIconTpl"
    >
      <ng-template #feedbackIconTpl>
        <nz-form-item-feedback-icon *ngIf="hasFeedback && !!status" [status]="status"></nz-form-item-feedback-icon>
      </ng-template>
    </nz-select-arrow>

    <nz-select-clear
      *ngIf="nzAllowClear && !nzDisabled && listOfValue.length"
      [clearIcon]="nzClearIcon"
      (clear)="onClearSelection()"
    ></nz-select-clear>
    <ng-template
      cdkConnectedOverlay
      nzConnectedOverlay
      [cdkConnectedOverlayHasBackdrop]="nzBackdrop"
      [cdkConnectedOverlayMinWidth]="$any(nzDropdownMatchSelectWidth ? null : triggerWidth)"
      [cdkConnectedOverlayWidth]="$any(nzDropdownMatchSelectWidth ? triggerWidth : null)"
      [cdkConnectedOverlayOrigin]="origin"
      [cdkConnectedOverlayTransformOriginOn]="'.ant-select-dropdown'"
      [cdkConnectedOverlayPanelClass]="nzDropdownClassName!"
      [cdkConnectedOverlayOpen]="nzOpen"
      [cdkConnectedOverlayPositions]="positions"
      (overlayOutsideClick)="onClickOutside($event)"
      (detach)="setOpenState(false)"
      (positionChange)="onPositionChange($event)"
    >
      <nz-option-container
        [ngStyle]="nzDropdownStyle"
        [itemSize]="nzOptionHeightPx"
        [maxItemLength]="nzOptionOverflowSize"
        [matchWidth]="nzDropdownMatchSelectWidth"
        [class.ant-select-dropdown-placement-bottomLeft]="dropDownPosition === 'bottomLeft'"
        [class.ant-select-dropdown-placement-topLeft]="dropDownPosition === 'topLeft'"
        [class.ant-select-dropdown-placement-bottomRight]="dropDownPosition === 'bottomRight'"
        [class.ant-select-dropdown-placement-topRight]="dropDownPosition === 'topRight'"
        [@slideMotion]="'enter'"
        [@.disabled]="!!noAnimation?.nzNoAnimation"
        [nzNoAnimation]="noAnimation?.nzNoAnimation"
        [listOfContainerItem]="listOfContainerItem"
        [menuItemSelectedIcon]="nzMenuItemSelectedIcon"
        [notFoundContent]="nzNotFoundContent"
        [activatedValue]="activatedValue"
        [listOfSelectedValue]="listOfValue"
        [dropdownRender]="nzDropdownRender"
        [compareWith]="compareWith"
        [mode]="nzMode"
        (keydown)="onKeyDown($event)"
        (itemClick)="onItemClick($event)"
        (scrollToBottom)="nzScrollToBottom.emit()"
      ></nz-option-container>
    </ng-template>
  `,
      host: {
        class: "ant-select",
        "[class.ant-select-in-form-item]": "!!nzFormStatusService",
        "[class.ant-select-lg]": 'nzSize === "large"',
        "[class.ant-select-sm]": 'nzSize === "small"',
        "[class.ant-select-show-arrow]": `nzShowArrow`,
        "[class.ant-select-disabled]": "nzDisabled",
        "[class.ant-select-show-search]": `(nzShowSearch || nzMode !== 'default') && !nzDisabled`,
        "[class.ant-select-allow-clear]": "nzAllowClear",
        "[class.ant-select-borderless]": "nzBorderless",
        "[class.ant-select-open]": "nzOpen",
        "[class.ant-select-focused]": "nzOpen || focused",
        "[class.ant-select-single]": `nzMode === 'default'`,
        "[class.ant-select-multiple]": `nzMode !== 'default'`,
        "[class.ant-select-rtl]": `dir === 'rtl'`
      },
      imports: [NzSelectTopControlComponent, CdkOverlayOrigin, NzNoAnimationDirective, NzSelectArrowComponent, NgIf, NzFormPatchModule, NzSelectClearComponent, CdkConnectedOverlay, NzOverlayModule, NzOptionContainerComponent, NgStyle],
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: NzDestroyService
  }, {
    type: NzConfigService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: Platform
  }, {
    type: FocusMonitor
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormNoStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    nzId: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzOptionHeightPx: [{
      type: Input
    }],
    nzOptionOverflowSize: [{
      type: Input
    }],
    nzDropdownClassName: [{
      type: Input
    }],
    nzDropdownMatchSelectWidth: [{
      type: Input
    }],
    nzDropdownStyle: [{
      type: Input
    }],
    nzNotFoundContent: [{
      type: Input
    }],
    nzPlaceHolder: [{
      type: Input
    }],
    nzPlacement: [{
      type: Input
    }],
    nzMaxTagCount: [{
      type: Input
    }],
    nzDropdownRender: [{
      type: Input
    }],
    nzCustomTemplate: [{
      type: Input
    }],
    nzSuffixIcon: [{
      type: Input
    }],
    nzClearIcon: [{
      type: Input
    }],
    nzRemoveIcon: [{
      type: Input
    }],
    nzMenuItemSelectedIcon: [{
      type: Input
    }],
    nzTokenSeparators: [{
      type: Input
    }],
    nzMaxTagPlaceholder: [{
      type: Input
    }],
    nzMaxMultipleCount: [{
      type: Input
    }],
    nzMode: [{
      type: Input
    }],
    nzFilterOption: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    nzAllowClear: [{
      type: Input
    }],
    nzBorderless: [{
      type: Input
    }],
    nzShowSearch: [{
      type: Input
    }],
    nzLoading: [{
      type: Input
    }],
    nzAutoFocus: [{
      type: Input
    }],
    nzAutoClearSearchValue: [{
      type: Input
    }],
    nzServerSearch: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzOpen: [{
      type: Input
    }],
    nzSelectOnTab: [{
      type: Input
    }],
    nzBackdrop: [{
      type: Input
    }],
    nzOptions: [{
      type: Input
    }],
    nzShowArrow: [{
      type: Input
    }],
    nzOnSearch: [{
      type: Output
    }],
    nzScrollToBottom: [{
      type: Output
    }],
    nzOpenChange: [{
      type: Output
    }],
    nzBlur: [{
      type: Output
    }],
    nzFocus: [{
      type: Output
    }],
    originElement: [{
      type: ViewChild,
      args: [CdkOverlayOrigin, {
        static: true,
        read: ElementRef
      }]
    }],
    cdkConnectedOverlay: [{
      type: ViewChild,
      args: [CdkConnectedOverlay, {
        static: true
      }]
    }],
    nzSelectTopControlComponent: [{
      type: ViewChild,
      args: [NzSelectTopControlComponent, {
        static: true
      }]
    }],
    listOfNzOptionComponent: [{
      type: ContentChildren,
      args: [NzOptionComponent, {
        descendants: true
      }]
    }],
    listOfNzOptionGroupComponent: [{
      type: ContentChildren,
      args: [NzOptionGroupComponent, {
        descendants: true
      }]
    }],
    nzOptionGroupComponentElement: [{
      type: ViewChild,
      args: [NzOptionGroupComponent, {
        static: true,
        read: ElementRef
      }]
    }],
    nzSelectTopControlComponentElement: [{
      type: ViewChild,
      args: [NzSelectTopControlComponent, {
        static: true,
        read: ElementRef
      }]
    }]
  });
})();
var _NzSelectModule = class _NzSelectModule {
};
_NzSelectModule.\u0275fac = function NzSelectModule_Factory(t) {
  return new (t || _NzSelectModule)();
};
_NzSelectModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzSelectModule
});
_NzSelectModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzSelectComponent, NzOptionContainerComponent, NzOptionItemComponent, NzSelectTopControlComponent, NzSelectSearchComponent, NzSelectItemComponent, NzSelectClearComponent, NzSelectArrowComponent, NzSelectPlaceholderComponent, NzOptionItemGroupComponent]
});
var NzSelectModule = _NzSelectModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSelectModule, [{
    type: NgModule,
    args: [{
      imports: [NzOptionComponent, NzSelectComponent, NzOptionContainerComponent, NzOptionGroupComponent, NzOptionItemComponent, NzSelectTopControlComponent, NzSelectSearchComponent, NzSelectItemComponent, NzSelectClearComponent, NzSelectArrowComponent, NzSelectPlaceholderComponent, NzOptionItemGroupComponent],
      exports: [NzOptionComponent, NzSelectComponent, NzOptionGroupComponent, NzSelectArrowComponent, NzSelectClearComponent, NzSelectItemComponent, NzSelectPlaceholderComponent, NzSelectSearchComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-pagination.mjs
var _c012 = ["nz-pagination-item", ""];
function NzPaginationItemComponent_ng_template_0_a_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const page_r4 = \u0275\u0275nextContext().page;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(page_r4);
  }
}
function NzPaginationItemComponent_ng_template_0_button_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 9);
  }
}
function NzPaginationItemComponent_ng_template_0_button_2_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 10);
  }
}
function NzPaginationItemComponent_ng_template_0_button_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 6);
    \u0275\u0275elementContainerStart(1, 2);
    \u0275\u0275template(2, NzPaginationItemComponent_ng_template_0_button_2_span_2_Template, 1, 0, "span", 7)(3, NzPaginationItemComponent_ng_template_0_button_2_span_3_Template, 1, 0, "span", 8);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(2);
    \u0275\u0275property("disabled", ctx_r6.disabled);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", ctx_r6.direction);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "rtl");
  }
}
function NzPaginationItemComponent_ng_template_0_button_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 10);
  }
}
function NzPaginationItemComponent_ng_template_0_button_3_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 9);
  }
}
function NzPaginationItemComponent_ng_template_0_button_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 6);
    \u0275\u0275elementContainerStart(1, 2);
    \u0275\u0275template(2, NzPaginationItemComponent_ng_template_0_button_3_span_2_Template, 1, 0, "span", 11)(3, NzPaginationItemComponent_ng_template_0_button_3_span_3_Template, 1, 0, "span", 12);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275property("disabled", ctx_r7.disabled);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", ctx_r7.direction);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "rtl");
  }
}
function NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 20);
  }
}
function NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 21);
  }
}
function NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 2);
    \u0275\u0275template(1, NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_2_span_1_Template, 1, 0, "span", 18)(2, NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_2_span_2_Template, 1, 0, "span", 19);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r15 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngSwitch", ctx_r15.direction);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "rtl");
  }
}
function NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_3_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 21);
  }
}
function NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 20);
  }
}
function NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 2);
    \u0275\u0275template(1, NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_3_span_1_Template, 1, 0, "span", 22)(2, NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_3_span_2_Template, 1, 0, "span", 23);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r16 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngSwitch", ctx_r16.direction);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "rtl");
  }
}
function NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275elementContainerStart(1, 2);
    \u0275\u0275template(2, NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_2_Template, 3, 2, "ng-container", 16)(3, NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_ng_container_3_Template, 3, 2, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementStart(4, "span", 17);
    \u0275\u0275text(5, "\u2022\u2022\u2022");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const type_r3 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", type_r3);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "prev_5");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "next_5");
  }
}
function NzPaginationItemComponent_ng_template_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "a", 13);
    \u0275\u0275template(2, NzPaginationItemComponent_ng_template_0_ng_container_4_div_2_Template, 6, 3, "div", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const type_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", type_r3);
  }
}
function NzPaginationItemComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 2);
    \u0275\u0275template(1, NzPaginationItemComponent_ng_template_0_a_1_Template, 2, 1, "a", 3)(2, NzPaginationItemComponent_ng_template_0_button_2_Template, 4, 3, "button", 4)(3, NzPaginationItemComponent_ng_template_0_button_3_Template, 4, 3, "button", 4)(4, NzPaginationItemComponent_ng_template_0_ng_container_4_Template, 3, 1, "ng-container", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const type_r3 = ctx.$implicit;
    \u0275\u0275property("ngSwitch", type_r3);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "page");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "prev");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "next");
  }
}
function NzPaginationItemComponent_ng_template_2_Template(rf, ctx) {
}
var _c17 = (a0, a1) => ({
  $implicit: a0,
  page: a1
});
var _c26 = ["nz-pagination-options", ""];
function NzPaginationOptionsComponent_nz_select_0_nz_option_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-option", 4);
  }
  if (rf & 2) {
    const option_r3 = ctx.$implicit;
    \u0275\u0275property("nzLabel", option_r3.label)("nzValue", option_r3.value);
  }
}
function NzPaginationOptionsComponent_nz_select_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-select", 2);
    \u0275\u0275listener("ngModelChange", function NzPaginationOptionsComponent_nz_select_0_Template_nz_select_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.onPageSizeChange($event));
    });
    \u0275\u0275template(1, NzPaginationOptionsComponent_nz_select_0_nz_option_1_Template, 1, 2, "nz-option", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzDisabled", ctx_r0.disabled)("nzSize", ctx_r0.nzSize)("ngModel", ctx_r0.pageSize);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.listOfPageSizeOption)("ngForTrackBy", ctx_r0.trackByOption);
  }
}
function NzPaginationOptionsComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275text(1);
    \u0275\u0275elementStart(2, "input", 6);
    \u0275\u0275listener("keydown.enter", function NzPaginationOptionsComponent_div_1_Template_input_keydown_enter_2_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.jumpToPageViaInput($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r1.locale.jump_to, " ");
    \u0275\u0275advance(1);
    \u0275\u0275property("disabled", ctx_r1.disabled);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r1.locale.page, " ");
  }
}
var _c33 = ["containerTemplate"];
function NzPaginationDefaultComponent_ng_template_0_li_1_ng_template_1_Template(rf, ctx) {
}
var _c42 = (a0, a1) => ({
  $implicit: a0,
  range: a1
});
function NzPaginationDefaultComponent_ng_template_0_li_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 4);
    \u0275\u0275template(1, NzPaginationDefaultComponent_ng_template_0_li_1_ng_template_1_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.showTotal)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c42, ctx_r2.total, ctx_r2.ranges));
  }
}
function NzPaginationDefaultComponent_ng_template_0_li_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 6);
    \u0275\u0275listener("gotoIndex", function NzPaginationDefaultComponent_ng_template_0_li_2_Template_li_gotoIndex_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r7 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r7.jumpPage($event));
    })("diffIndex", function NzPaginationDefaultComponent_ng_template_0_li_2_Template_li_diffIndex_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.jumpDiff($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const page_r6 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275property("locale", ctx_r3.locale)("type", page_r6.type)("index", page_r6.index)("disabled", !!page_r6.disabled)("itemRender", ctx_r3.itemRender)("active", ctx_r3.pageIndex === page_r6.index)("direction", ctx_r3.dir);
  }
}
function NzPaginationDefaultComponent_ng_template_0_li_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 7);
    \u0275\u0275listener("pageIndexChange", function NzPaginationDefaultComponent_ng_template_0_li_3_Template_li_pageIndexChange_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r10 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r10.onPageIndexChange($event));
    })("pageSizeChange", function NzPaginationDefaultComponent_ng_template_0_li_3_Template_li_pageSizeChange_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r12 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r12.onPageSizeChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275property("total", ctx_r4.total)("locale", ctx_r4.locale)("disabled", ctx_r4.disabled)("nzSize", ctx_r4.nzSize)("showSizeChanger", ctx_r4.showSizeChanger)("showQuickJumper", ctx_r4.showQuickJumper)("pageIndex", ctx_r4.pageIndex)("pageSize", ctx_r4.pageSize)("pageSizeOptions", ctx_r4.pageSizeOptions);
  }
}
function NzPaginationDefaultComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul");
    \u0275\u0275template(1, NzPaginationDefaultComponent_ng_template_0_li_1_Template, 2, 5, "li", 1)(2, NzPaginationDefaultComponent_ng_template_0_li_2_Template, 1, 7, "li", 2)(3, NzPaginationDefaultComponent_ng_template_0_li_3_Template, 1, 9, "li", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.showTotal);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.listOfPageItem)("ngForTrackBy", ctx_r0.trackByPageItem);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.showQuickJumper || ctx_r0.showSizeChanger);
  }
}
function NzPaginationSimpleComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ul")(1, "li", 1);
    \u0275\u0275listener("click", function NzPaginationSimpleComponent_ng_template_0_Template_li_click_1_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.prePage());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "li", 2)(3, "input", 3);
    \u0275\u0275listener("keydown.enter", function NzPaginationSimpleComponent_ng_template_0_Template_input_keydown_enter_3_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.jumpToPageViaInput($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "span", 4);
    \u0275\u0275text(5, "/");
    \u0275\u0275elementEnd();
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "li", 5);
    \u0275\u0275listener("click", function NzPaginationSimpleComponent_ng_template_0_Template_li_click_7_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r5 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r5.nextPage());
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("disabled", ctx_r0.isFirstIndex)("direction", ctx_r0.dir)("itemRender", ctx_r0.itemRender);
    \u0275\u0275attribute("title", ctx_r0.locale.prev_page);
    \u0275\u0275advance(1);
    \u0275\u0275attribute("title", ctx_r0.pageIndex + "/" + ctx_r0.lastIndex);
    \u0275\u0275advance(1);
    \u0275\u0275property("disabled", ctx_r0.disabled)("value", ctx_r0.pageIndex);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", ctx_r0.lastIndex, " ");
    \u0275\u0275advance(1);
    \u0275\u0275property("disabled", ctx_r0.isLastIndex)("direction", ctx_r0.dir)("itemRender", ctx_r0.itemRender);
    \u0275\u0275attribute("title", ctx_r0.locale == null ? null : ctx_r0.locale.next_page);
  }
}
function NzPaginationComponent_ng_container_0_ng_container_1_ng_template_1_Template(rf, ctx) {
}
function NzPaginationComponent_ng_container_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzPaginationComponent_ng_container_0_ng_container_1_ng_template_1_Template, 0, 0, "ng-template", 6);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1.template);
  }
}
function NzPaginationComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzPaginationComponent_ng_container_0_ng_container_1_Template, 2, 1, "ng-container", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const _r2 = \u0275\u0275reference(4);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzSimple)("ngIfElse", _r2.template);
  }
}
var _NzPaginationItemComponent = class _NzPaginationItemComponent {
  constructor() {
    this.active = false;
    this.index = null;
    this.disabled = false;
    this.direction = "ltr";
    this.type = null;
    this.itemRender = null;
    this.diffIndex = new EventEmitter();
    this.gotoIndex = new EventEmitter();
    this.title = null;
  }
  clickItem() {
    if (!this.disabled) {
      if (this.type === "page") {
        this.gotoIndex.emit(this.index);
      } else {
        this.diffIndex.emit({
          next: 1,
          prev: -1,
          prev_5: -5,
          next_5: 5
        }[this.type]);
      }
    }
  }
  ngOnChanges(changes) {
    const {
      locale: locale3,
      index,
      type
    } = changes;
    if (locale3 || index || type) {
      this.title = {
        page: `${this.index}`,
        next: this.locale?.next_page,
        prev: this.locale?.prev_page,
        prev_5: this.locale?.prev_5,
        next_5: this.locale?.next_5
      }[this.type];
    }
  }
};
_NzPaginationItemComponent.\u0275fac = function NzPaginationItemComponent_Factory(t) {
  return new (t || _NzPaginationItemComponent)();
};
_NzPaginationItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzPaginationItemComponent,
  selectors: [["li", "nz-pagination-item", ""]],
  hostVars: 19,
  hostBindings: function NzPaginationItemComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzPaginationItemComponent_click_HostBindingHandler() {
        return ctx.clickItem();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("title", ctx.title);
      \u0275\u0275classProp("ant-pagination-prev", ctx.type === "prev")("ant-pagination-next", ctx.type === "next")("ant-pagination-item", ctx.type === "page")("ant-pagination-jump-prev", ctx.type === "prev_5")("ant-pagination-jump-prev-custom-icon", ctx.type === "prev_5")("ant-pagination-jump-next", ctx.type === "next_5")("ant-pagination-jump-next-custom-icon", ctx.type === "next_5")("ant-pagination-disabled", ctx.disabled)("ant-pagination-item-active", ctx.active);
    }
  },
  inputs: {
    active: "active",
    locale: "locale",
    index: "index",
    disabled: "disabled",
    direction: "direction",
    type: "type",
    itemRender: "itemRender"
  },
  outputs: {
    diffIndex: "diffIndex",
    gotoIndex: "gotoIndex"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c012,
  decls: 3,
  vars: 5,
  consts: [["renderItemTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngSwitch"], [4, "ngSwitchCase"], ["type", "button", "class", "ant-pagination-item-link", 3, "disabled", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], ["type", "button", 1, "ant-pagination-item-link", 3, "disabled"], ["nz-icon", "", "nzType", "right", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "left", 4, "ngSwitchDefault"], ["nz-icon", "", "nzType", "right"], ["nz-icon", "", "nzType", "left"], ["nz-icon", "", "nzType", "left", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "right", 4, "ngSwitchDefault"], [1, "ant-pagination-item-link", 3, "ngSwitch"], ["class", "ant-pagination-item-container", 4, "ngSwitchDefault"], [1, "ant-pagination-item-container"], [3, "ngSwitch", 4, "ngSwitchCase"], [1, "ant-pagination-item-ellipsis"], ["nz-icon", "", "nzType", "double-right", "class", "ant-pagination-item-link-icon", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "double-left", "class", "ant-pagination-item-link-icon", 4, "ngSwitchDefault"], ["nz-icon", "", "nzType", "double-right", 1, "ant-pagination-item-link-icon"], ["nz-icon", "", "nzType", "double-left", 1, "ant-pagination-item-link-icon"], ["nz-icon", "", "nzType", "double-left", "class", "ant-pagination-item-link-icon", 4, "ngSwitchCase"], ["nz-icon", "", "nzType", "double-right", "class", "ant-pagination-item-link-icon", 4, "ngSwitchDefault"]],
  template: function NzPaginationItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzPaginationItemComponent_ng_template_0_Template, 5, 4, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, NzPaginationItemComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      const _r1 = \u0275\u0275reference(1);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngTemplateOutlet", ctx.itemRender || _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c17, ctx.type, ctx.index));
    }
  },
  dependencies: [NgSwitch, NgSwitchCase, NzIconModule, NzIconDirective, NgSwitchDefault, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzPaginationItemComponent = _NzPaginationItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPaginationItemComponent, [{
    type: Component,
    args: [{
      selector: "li[nz-pagination-item]",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-template #renderItemTemplate let-type let-page="page">
      <ng-container [ngSwitch]="type">
        <a *ngSwitchCase="'page'">{{ page }}</a>
        <button type="button" [disabled]="disabled" class="ant-pagination-item-link" *ngSwitchCase="'prev'">
          <ng-container [ngSwitch]="direction">
            <span *ngSwitchCase="'rtl'" nz-icon nzType="right"></span>
            <span *ngSwitchDefault nz-icon nzType="left"></span>
          </ng-container>
        </button>
        <button type="button" [disabled]="disabled" class="ant-pagination-item-link" *ngSwitchCase="'next'">
          <ng-container [ngSwitch]="direction">
            <span *ngSwitchCase="'rtl'" nz-icon nzType="left"></span>
            <span *ngSwitchDefault nz-icon nzType="right"></span>
          </ng-container>
        </button>
        <ng-container *ngSwitchDefault>
          <a class="ant-pagination-item-link" [ngSwitch]="type">
            <div class="ant-pagination-item-container" *ngSwitchDefault>
              <ng-container [ngSwitch]="type">
                <ng-container *ngSwitchCase="'prev_5'" [ngSwitch]="direction">
                  <span
                    *ngSwitchCase="'rtl'"
                    nz-icon
                    nzType="double-right"
                    class="ant-pagination-item-link-icon"
                  ></span>
                  <span *ngSwitchDefault nz-icon nzType="double-left" class="ant-pagination-item-link-icon"></span>
                </ng-container>
                <ng-container *ngSwitchCase="'next_5'" [ngSwitch]="direction">
                  <span *ngSwitchCase="'rtl'" nz-icon nzType="double-left" class="ant-pagination-item-link-icon"></span>
                  <span *ngSwitchDefault nz-icon nzType="double-right" class="ant-pagination-item-link-icon"></span>
                </ng-container>
              </ng-container>
              <span class="ant-pagination-item-ellipsis">\u2022\u2022\u2022</span>
            </div>
          </a>
        </ng-container>
      </ng-container>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="itemRender || renderItemTemplate"
      [ngTemplateOutletContext]="{ $implicit: type, page: index }"
    ></ng-template>
  `,
      host: {
        "[class.ant-pagination-prev]": `type === 'prev'`,
        "[class.ant-pagination-next]": `type === 'next'`,
        "[class.ant-pagination-item]": `type === 'page'`,
        "[class.ant-pagination-jump-prev]": `type === 'prev_5'`,
        "[class.ant-pagination-jump-prev-custom-icon]": `type === 'prev_5'`,
        "[class.ant-pagination-jump-next]": `type === 'next_5'`,
        "[class.ant-pagination-jump-next-custom-icon]": `type === 'next_5'`,
        "[class.ant-pagination-disabled]": "disabled",
        "[class.ant-pagination-item-active]": "active",
        "[attr.title]": "title",
        "(click)": "clickItem()"
      },
      imports: [NgSwitch, NgSwitchCase, NzIconModule, NgSwitchDefault, NgTemplateOutlet],
      standalone: true
    }]
  }], null, {
    active: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    direction: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    itemRender: [{
      type: Input
    }],
    diffIndex: [{
      type: Output
    }],
    gotoIndex: [{
      type: Output
    }]
  });
})();
var _NzPaginationOptionsComponent = class _NzPaginationOptionsComponent {
  constructor() {
    this.nzSize = "default";
    this.disabled = false;
    this.showSizeChanger = false;
    this.showQuickJumper = false;
    this.total = 0;
    this.pageIndex = 1;
    this.pageSize = 10;
    this.pageSizeOptions = [];
    this.pageIndexChange = new EventEmitter();
    this.pageSizeChange = new EventEmitter();
    this.listOfPageSizeOption = [];
  }
  onPageSizeChange(size) {
    if (this.pageSize !== size) {
      this.pageSizeChange.next(size);
    }
  }
  jumpToPageViaInput($event) {
    const target = $event.target;
    const index = Math.floor(toNumber(target.value, this.pageIndex));
    this.pageIndexChange.next(index);
    target.value = "";
  }
  trackByOption(_, option) {
    return option.value;
  }
  ngOnChanges(changes) {
    const {
      pageSize,
      pageSizeOptions,
      locale: locale3
    } = changes;
    if (pageSize || pageSizeOptions || locale3) {
      this.listOfPageSizeOption = [.../* @__PURE__ */ new Set([...this.pageSizeOptions, this.pageSize])].map((item) => ({
        value: item,
        label: `${item} ${this.locale.items_per_page}`
      }));
    }
  }
};
_NzPaginationOptionsComponent.\u0275fac = function NzPaginationOptionsComponent_Factory(t) {
  return new (t || _NzPaginationOptionsComponent)();
};
_NzPaginationOptionsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzPaginationOptionsComponent,
  selectors: [["li", "nz-pagination-options", ""]],
  hostAttrs: [1, "ant-pagination-options"],
  inputs: {
    nzSize: "nzSize",
    disabled: "disabled",
    showSizeChanger: "showSizeChanger",
    showQuickJumper: "showQuickJumper",
    locale: "locale",
    total: "total",
    pageIndex: "pageIndex",
    pageSize: "pageSize",
    pageSizeOptions: "pageSizeOptions"
  },
  outputs: {
    pageIndexChange: "pageIndexChange",
    pageSizeChange: "pageSizeChange"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c26,
  decls: 2,
  vars: 2,
  consts: [["class", "ant-pagination-options-size-changer", 3, "nzDisabled", "nzSize", "ngModel", "ngModelChange", 4, "ngIf"], ["class", "ant-pagination-options-quick-jumper", 4, "ngIf"], [1, "ant-pagination-options-size-changer", 3, "nzDisabled", "nzSize", "ngModel", "ngModelChange"], [3, "nzLabel", "nzValue", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "nzLabel", "nzValue"], [1, "ant-pagination-options-quick-jumper"], [3, "disabled", "keydown.enter"]],
  template: function NzPaginationOptionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzPaginationOptionsComponent_nz_select_0_Template, 2, 5, "nz-select", 0)(1, NzPaginationOptionsComponent_div_1_Template, 4, 3, "div", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.showSizeChanger);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.showQuickJumper);
    }
  },
  dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, NgIf, FormsModule, NgControlStatus, NgModel, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzPaginationOptionsComponent = _NzPaginationOptionsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPaginationOptionsComponent, [{
    type: Component,
    args: [{
      selector: "li[nz-pagination-options]",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <nz-select
      class="ant-pagination-options-size-changer"
      *ngIf="showSizeChanger"
      [nzDisabled]="disabled"
      [nzSize]="nzSize"
      [ngModel]="pageSize"
      (ngModelChange)="onPageSizeChange($event)"
    >
      <nz-option
        *ngFor="let option of listOfPageSizeOption; trackBy: trackByOption"
        [nzLabel]="option.label"
        [nzValue]="option.value"
      ></nz-option>
    </nz-select>
    <div class="ant-pagination-options-quick-jumper" *ngIf="showQuickJumper">
      {{ locale.jump_to }}
      <input [disabled]="disabled" (keydown.enter)="jumpToPageViaInput($event)" />
      {{ locale.page }}
    </div>
  `,
      host: {
        class: "ant-pagination-options"
      },
      imports: [NzSelectModule, NgIf, FormsModule, NgForOf],
      standalone: true
    }]
  }], () => [], {
    nzSize: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    showSizeChanger: [{
      type: Input
    }],
    showQuickJumper: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    pageIndex: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    pageSizeOptions: [{
      type: Input
    }],
    pageIndexChange: [{
      type: Output
    }],
    pageSizeChange: [{
      type: Output
    }]
  });
})();
var _NzPaginationDefaultComponent = class _NzPaginationDefaultComponent {
  constructor(cdr, renderer, elementRef, directionality) {
    this.cdr = cdr;
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.directionality = directionality;
    this.nzSize = "default";
    this.itemRender = null;
    this.showTotal = null;
    this.disabled = false;
    this.showSizeChanger = false;
    this.showQuickJumper = false;
    this.total = 0;
    this.pageIndex = 1;
    this.pageSize = 10;
    this.pageSizeOptions = [10, 20, 30, 40];
    this.pageIndexChange = new EventEmitter();
    this.pageSizeChange = new EventEmitter();
    this.ranges = [0, 0];
    this.listOfPageItem = [];
    this.dir = "ltr";
    this.destroy$ = new Subject();
    renderer.removeChild(renderer.parentNode(elementRef.nativeElement), elementRef.nativeElement);
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.updateRtlStyle();
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.updateRtlStyle();
  }
  updateRtlStyle() {
    if (this.dir === "rtl") {
      this.renderer.addClass(this.elementRef.nativeElement, "ant-pagination-rtl");
    } else {
      this.renderer.removeClass(this.elementRef.nativeElement, "ant-pagination-rtl");
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  jumpPage(index) {
    this.onPageIndexChange(index);
  }
  jumpDiff(diff) {
    this.jumpPage(this.pageIndex + diff);
  }
  trackByPageItem(_, value) {
    return `${value.type}-${value.index}`;
  }
  onPageIndexChange(index) {
    this.pageIndexChange.next(index);
  }
  onPageSizeChange(size) {
    this.pageSizeChange.next(size);
  }
  getLastIndex(total2, pageSize) {
    return Math.ceil(total2 / pageSize);
  }
  buildIndexes() {
    const lastIndex = this.getLastIndex(this.total, this.pageSize);
    this.listOfPageItem = this.getListOfPageItem(this.pageIndex, lastIndex);
  }
  getListOfPageItem(pageIndex, lastIndex) {
    const concatWithPrevNext = (listOfPage) => {
      const prevItem = {
        type: "prev",
        disabled: pageIndex === 1
      };
      const nextItem = {
        type: "next",
        disabled: pageIndex === lastIndex
      };
      return [prevItem, ...listOfPage, nextItem];
    };
    const generatePage = (start, end) => {
      const list2 = [];
      for (let i = start; i <= end; i++) {
        list2.push({
          index: i,
          type: "page"
        });
      }
      return list2;
    };
    if (lastIndex <= 9) {
      return concatWithPrevNext(generatePage(1, lastIndex));
    } else {
      const generateRangeItem = (selected, last) => {
        let listOfRange = [];
        const prevFiveItem = {
          type: "prev_5"
        };
        const nextFiveItem = {
          type: "next_5"
        };
        const firstPageItem = generatePage(1, 1);
        const lastPageItem = generatePage(lastIndex, lastIndex);
        if (selected < 5) {
          const maxLeft = selected === 4 ? 6 : 5;
          listOfRange = [...generatePage(2, maxLeft), nextFiveItem];
        } else if (selected < last - 3) {
          listOfRange = [prevFiveItem, ...generatePage(selected - 2, selected + 2), nextFiveItem];
        } else {
          const minRight = selected === last - 3 ? last - 5 : last - 4;
          listOfRange = [prevFiveItem, ...generatePage(minRight, last - 1)];
        }
        return [...firstPageItem, ...listOfRange, ...lastPageItem];
      };
      return concatWithPrevNext(generateRangeItem(pageIndex, lastIndex));
    }
  }
  ngOnChanges(changes) {
    const {
      pageIndex,
      pageSize,
      total: total2
    } = changes;
    if (pageIndex || pageSize || total2) {
      this.ranges = [(this.pageIndex - 1) * this.pageSize + 1, Math.min(this.pageIndex * this.pageSize, this.total)];
      this.buildIndexes();
    }
  }
};
_NzPaginationDefaultComponent.\u0275fac = function NzPaginationDefaultComponent_Factory(t) {
  return new (t || _NzPaginationDefaultComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzPaginationDefaultComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzPaginationDefaultComponent,
  selectors: [["nz-pagination-default"]],
  viewQuery: function NzPaginationDefaultComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c33, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.template = _t.first);
    }
  },
  inputs: {
    nzSize: "nzSize",
    itemRender: "itemRender",
    showTotal: "showTotal",
    disabled: "disabled",
    locale: "locale",
    showSizeChanger: "showSizeChanger",
    showQuickJumper: "showQuickJumper",
    total: "total",
    pageIndex: "pageIndex",
    pageSize: "pageSize",
    pageSizeOptions: "pageSizeOptions"
  },
  outputs: {
    pageIndexChange: "pageIndexChange",
    pageSizeChange: "pageSizeChange"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 0,
  consts: [["containerTemplate", ""], ["class", "ant-pagination-total-text", 4, "ngIf"], ["nz-pagination-item", "", 3, "locale", "type", "index", "disabled", "itemRender", "active", "direction", "gotoIndex", "diffIndex", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["nz-pagination-options", "", 3, "total", "locale", "disabled", "nzSize", "showSizeChanger", "showQuickJumper", "pageIndex", "pageSize", "pageSizeOptions", "pageIndexChange", "pageSizeChange", 4, "ngIf"], [1, "ant-pagination-total-text"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["nz-pagination-item", "", 3, "locale", "type", "index", "disabled", "itemRender", "active", "direction", "gotoIndex", "diffIndex"], ["nz-pagination-options", "", 3, "total", "locale", "disabled", "nzSize", "showSizeChanger", "showQuickJumper", "pageIndex", "pageSize", "pageSizeOptions", "pageIndexChange", "pageSizeChange"]],
  template: function NzPaginationDefaultComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzPaginationDefaultComponent_ng_template_0_Template, 4, 4, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
  },
  dependencies: [NgTemplateOutlet, NgForOf, NgIf, NzPaginationItemComponent, NzPaginationOptionsComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzPaginationDefaultComponent = _NzPaginationDefaultComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPaginationDefaultComponent, [{
    type: Component,
    args: [{
      selector: "nz-pagination-default",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-template #containerTemplate>
      <ul>
        <li class="ant-pagination-total-text" *ngIf="showTotal">
          <ng-template
            [ngTemplateOutlet]="showTotal"
            [ngTemplateOutletContext]="{ $implicit: total, range: ranges }"
          ></ng-template>
        </li>
        <li
          *ngFor="let page of listOfPageItem; trackBy: trackByPageItem"
          nz-pagination-item
          [locale]="locale"
          [type]="page.type"
          [index]="page.index"
          [disabled]="!!page.disabled"
          [itemRender]="itemRender"
          [active]="pageIndex === page.index"
          (gotoIndex)="jumpPage($event)"
          (diffIndex)="jumpDiff($event)"
          [direction]="dir"
        ></li>
        <li
          nz-pagination-options
          *ngIf="showQuickJumper || showSizeChanger"
          [total]="total"
          [locale]="locale"
          [disabled]="disabled"
          [nzSize]="nzSize"
          [showSizeChanger]="showSizeChanger"
          [showQuickJumper]="showQuickJumper"
          [pageIndex]="pageIndex"
          [pageSize]="pageSize"
          [pageSizeOptions]="pageSizeOptions"
          (pageIndexChange)="onPageIndexChange($event)"
          (pageSizeChange)="onPageSizeChange($event)"
        ></li>
      </ul>
    </ng-template>
  `,
      imports: [NgTemplateOutlet, NgForOf, NgIf, NzPaginationItemComponent, NzPaginationOptionsComponent],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    template: [{
      type: ViewChild,
      args: ["containerTemplate", {
        static: true
      }]
    }],
    nzSize: [{
      type: Input
    }],
    itemRender: [{
      type: Input
    }],
    showTotal: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    showSizeChanger: [{
      type: Input
    }],
    showQuickJumper: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    pageIndex: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    pageSizeOptions: [{
      type: Input
    }],
    pageIndexChange: [{
      type: Output
    }],
    pageSizeChange: [{
      type: Output
    }]
  });
})();
var _NzPaginationSimpleComponent = class _NzPaginationSimpleComponent {
  constructor(cdr, renderer, elementRef, directionality) {
    this.cdr = cdr;
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.directionality = directionality;
    this.itemRender = null;
    this.disabled = false;
    this.total = 0;
    this.pageIndex = 1;
    this.pageSize = 10;
    this.pageIndexChange = new EventEmitter();
    this.lastIndex = 0;
    this.isFirstIndex = false;
    this.isLastIndex = false;
    this.dir = "ltr";
    this.destroy$ = new Subject();
    renderer.removeChild(renderer.parentNode(elementRef.nativeElement), elementRef.nativeElement);
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.updateRtlStyle();
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.updateRtlStyle();
  }
  updateRtlStyle() {
    if (this.dir === "rtl") {
      this.renderer.addClass(this.elementRef.nativeElement, "ant-pagination-rtl");
    } else {
      this.renderer.removeClass(this.elementRef.nativeElement, "ant-pagination-rtl");
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  jumpToPageViaInput($event) {
    const target = $event.target;
    const index = toNumber(target.value, this.pageIndex);
    this.onPageIndexChange(index);
    target.value = `${this.pageIndex}`;
  }
  prePage() {
    this.onPageIndexChange(this.pageIndex - 1);
  }
  nextPage() {
    this.onPageIndexChange(this.pageIndex + 1);
  }
  onPageIndexChange(index) {
    this.pageIndexChange.next(index);
  }
  updateBindingValue() {
    this.lastIndex = Math.ceil(this.total / this.pageSize);
    this.isFirstIndex = this.pageIndex === 1;
    this.isLastIndex = this.pageIndex === this.lastIndex;
  }
  ngOnChanges(changes) {
    const {
      pageIndex,
      total: total2,
      pageSize
    } = changes;
    if (pageIndex || total2 || pageSize) {
      this.updateBindingValue();
    }
  }
};
_NzPaginationSimpleComponent.\u0275fac = function NzPaginationSimpleComponent_Factory(t) {
  return new (t || _NzPaginationSimpleComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzPaginationSimpleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzPaginationSimpleComponent,
  selectors: [["nz-pagination-simple"]],
  viewQuery: function NzPaginationSimpleComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c33, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.template = _t.first);
    }
  },
  inputs: {
    itemRender: "itemRender",
    disabled: "disabled",
    locale: "locale",
    total: "total",
    pageIndex: "pageIndex",
    pageSize: "pageSize"
  },
  outputs: {
    pageIndexChange: "pageIndexChange"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 0,
  consts: [["containerTemplate", ""], ["nz-pagination-item", "", "type", "prev", 3, "disabled", "direction", "itemRender", "click"], [1, "ant-pagination-simple-pager"], ["size", "3", 3, "disabled", "value", "keydown.enter"], [1, "ant-pagination-slash"], ["nz-pagination-item", "", "type", "next", 3, "disabled", "direction", "itemRender", "click"]],
  template: function NzPaginationSimpleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzPaginationSimpleComponent_ng_template_0_Template, 8, 12, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
  },
  dependencies: [NzPaginationItemComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzPaginationSimpleComponent = _NzPaginationSimpleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPaginationSimpleComponent, [{
    type: Component,
    args: [{
      selector: "nz-pagination-simple",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-template #containerTemplate>
      <ul>
        <li
          nz-pagination-item
          [attr.title]="locale.prev_page"
          [disabled]="isFirstIndex"
          [direction]="dir"
          (click)="prePage()"
          type="prev"
          [itemRender]="itemRender"
        ></li>
        <li [attr.title]="pageIndex + '/' + lastIndex" class="ant-pagination-simple-pager">
          <input [disabled]="disabled" [value]="pageIndex" (keydown.enter)="jumpToPageViaInput($event)" size="3" />
          <span class="ant-pagination-slash">/</span>
          {{ lastIndex }}
        </li>
        <li
          nz-pagination-item
          [attr.title]="locale?.next_page"
          [disabled]="isLastIndex"
          [direction]="dir"
          (click)="nextPage()"
          type="next"
          [itemRender]="itemRender"
        ></li>
      </ul>
    </ng-template>
  `,
      imports: [NzPaginationItemComponent],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    template: [{
      type: ViewChild,
      args: ["containerTemplate", {
        static: true
      }]
    }],
    itemRender: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    pageIndex: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    pageIndexChange: [{
      type: Output
    }]
  });
})();
var NZ_CONFIG_MODULE_NAME7 = "pagination";
var _NzPaginationComponent = class _NzPaginationComponent {
  validatePageIndex(value, lastIndex) {
    if (value > lastIndex) {
      return lastIndex;
    } else if (value < 1) {
      return 1;
    } else {
      return value;
    }
  }
  onPageIndexChange(index) {
    const lastIndex = this.getLastIndex(this.nzTotal, this.nzPageSize);
    const validIndex = this.validatePageIndex(index, lastIndex);
    if (validIndex !== this.nzPageIndex && !this.nzDisabled) {
      this.nzPageIndex = validIndex;
      this.nzPageIndexChange.emit(this.nzPageIndex);
    }
  }
  onPageSizeChange(size) {
    this.nzPageSize = size;
    this.nzPageSizeChange.emit(size);
    const lastIndex = this.getLastIndex(this.nzTotal, this.nzPageSize);
    if (this.nzPageIndex > lastIndex) {
      this.onPageIndexChange(lastIndex);
    }
  }
  onTotalChange(total2) {
    const lastIndex = this.getLastIndex(total2, this.nzPageSize);
    if (this.nzPageIndex > lastIndex) {
      Promise.resolve().then(() => {
        this.onPageIndexChange(lastIndex);
        this.cdr.markForCheck();
      });
    }
  }
  getLastIndex(total2, pageSize) {
    return Math.ceil(total2 / pageSize);
  }
  constructor(i18n, cdr, breakpointService, nzConfigService, directionality) {
    this.i18n = i18n;
    this.cdr = cdr;
    this.breakpointService = breakpointService;
    this.nzConfigService = nzConfigService;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME7;
    this.nzPageSizeChange = new EventEmitter();
    this.nzPageIndexChange = new EventEmitter();
    this.nzShowTotal = null;
    this.nzItemRender = null;
    this.nzSize = "default";
    this.nzPageSizeOptions = [10, 20, 30, 40];
    this.nzShowSizeChanger = false;
    this.nzShowQuickJumper = false;
    this.nzSimple = false;
    this.nzDisabled = false;
    this.nzResponsive = false;
    this.nzHideOnSinglePage = false;
    this.nzTotal = 0;
    this.nzPageIndex = 1;
    this.nzPageSize = 10;
    this.showPagination = true;
    this.size = "default";
    this.dir = "ltr";
    this.destroy$ = new Subject();
    this.total$ = new ReplaySubject(1);
  }
  ngOnInit() {
    this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.locale = this.i18n.getLocaleData("Pagination");
      this.cdr.markForCheck();
    });
    this.total$.pipe(takeUntil(this.destroy$)).subscribe((total2) => {
      this.onTotalChange(total2);
    });
    this.breakpointService.subscribe(gridResponsiveMap).pipe(takeUntil(this.destroy$)).subscribe((bp) => {
      if (this.nzResponsive) {
        this.size = bp === NzBreakpointEnum.xs ? "small" : "default";
        this.cdr.markForCheck();
      }
    });
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  ngOnChanges(changes) {
    const {
      nzHideOnSinglePage,
      nzTotal,
      nzPageSize,
      nzSize
    } = changes;
    if (nzTotal) {
      this.total$.next(this.nzTotal);
    }
    if (nzHideOnSinglePage || nzTotal || nzPageSize) {
      this.showPagination = this.nzHideOnSinglePage && this.nzTotal > this.nzPageSize || this.nzTotal > 0 && !this.nzHideOnSinglePage;
    }
    if (nzSize) {
      this.size = nzSize.currentValue;
    }
  }
};
_NzPaginationComponent.\u0275fac = function NzPaginationComponent_Factory(t) {
  return new (t || _NzPaginationComponent)(\u0275\u0275directiveInject(NzI18nService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzBreakpointService), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(Directionality, 8));
};
_NzPaginationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzPaginationComponent,
  selectors: [["nz-pagination"]],
  hostAttrs: [1, "ant-pagination"],
  hostVars: 8,
  hostBindings: function NzPaginationComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-pagination-simple", ctx.nzSimple)("ant-pagination-disabled", ctx.nzDisabled)("mini", !ctx.nzSimple && ctx.size === "small")("ant-pagination-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzShowTotal: "nzShowTotal",
    nzItemRender: "nzItemRender",
    nzSize: "nzSize",
    nzPageSizeOptions: "nzPageSizeOptions",
    nzShowSizeChanger: "nzShowSizeChanger",
    nzShowQuickJumper: "nzShowQuickJumper",
    nzSimple: "nzSimple",
    nzDisabled: "nzDisabled",
    nzResponsive: "nzResponsive",
    nzHideOnSinglePage: "nzHideOnSinglePage",
    nzTotal: "nzTotal",
    nzPageIndex: "nzPageIndex",
    nzPageSize: "nzPageSize"
  },
  outputs: {
    nzPageSizeChange: "nzPageSizeChange",
    nzPageIndexChange: "nzPageIndexChange"
  },
  exportAs: ["nzPagination"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 5,
  vars: 18,
  consts: [[4, "ngIf"], [3, "disabled", "itemRender", "locale", "pageSize", "total", "pageIndex", "pageIndexChange"], ["simplePagination", ""], [3, "nzSize", "itemRender", "showTotal", "disabled", "locale", "showSizeChanger", "showQuickJumper", "total", "pageIndex", "pageSize", "pageSizeOptions", "pageIndexChange", "pageSizeChange"], ["defaultPagination", ""], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"]],
  template: function NzPaginationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzPaginationComponent_ng_container_0_Template, 2, 2, "ng-container", 0);
      \u0275\u0275elementStart(1, "nz-pagination-simple", 1, 2);
      \u0275\u0275listener("pageIndexChange", function NzPaginationComponent_Template_nz_pagination_simple_pageIndexChange_1_listener($event) {
        return ctx.onPageIndexChange($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "nz-pagination-default", 3, 4);
      \u0275\u0275listener("pageIndexChange", function NzPaginationComponent_Template_nz_pagination_default_pageIndexChange_3_listener($event) {
        return ctx.onPageIndexChange($event);
      })("pageSizeChange", function NzPaginationComponent_Template_nz_pagination_default_pageSizeChange_3_listener($event) {
        return ctx.onPageSizeChange($event);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.showPagination);
      \u0275\u0275advance(1);
      \u0275\u0275property("disabled", ctx.nzDisabled)("itemRender", ctx.nzItemRender)("locale", ctx.locale)("pageSize", ctx.nzPageSize)("total", ctx.nzTotal)("pageIndex", ctx.nzPageIndex);
      \u0275\u0275advance(2);
      \u0275\u0275property("nzSize", ctx.size)("itemRender", ctx.nzItemRender)("showTotal", ctx.nzShowTotal)("disabled", ctx.nzDisabled)("locale", ctx.locale)("showSizeChanger", ctx.nzShowSizeChanger)("showQuickJumper", ctx.nzShowQuickJumper)("total", ctx.nzTotal)("pageIndex", ctx.nzPageIndex)("pageSize", ctx.nzPageSize)("pageSizeOptions", ctx.nzPageSizeOptions);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NzPaginationSimpleComponent, NzPaginationDefaultComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzPaginationComponent = _NzPaginationComponent;
__decorate([WithConfig()], NzPaginationComponent.prototype, "nzSize", void 0);
__decorate([WithConfig()], NzPaginationComponent.prototype, "nzPageSizeOptions", void 0);
__decorate([WithConfig(), InputBoolean()], NzPaginationComponent.prototype, "nzShowSizeChanger", void 0);
__decorate([WithConfig(), InputBoolean()], NzPaginationComponent.prototype, "nzShowQuickJumper", void 0);
__decorate([WithConfig(), InputBoolean()], NzPaginationComponent.prototype, "nzSimple", void 0);
__decorate([InputBoolean()], NzPaginationComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzPaginationComponent.prototype, "nzResponsive", void 0);
__decorate([InputBoolean()], NzPaginationComponent.prototype, "nzHideOnSinglePage", void 0);
__decorate([InputNumber()], NzPaginationComponent.prototype, "nzTotal", void 0);
__decorate([InputNumber()], NzPaginationComponent.prototype, "nzPageIndex", void 0);
__decorate([InputNumber()], NzPaginationComponent.prototype, "nzPageSize", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPaginationComponent, [{
    type: Component,
    args: [{
      selector: "nz-pagination",
      exportAs: "nzPagination",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-container *ngIf="showPagination">
      <ng-container *ngIf="nzSimple; else defaultPagination.template">
        <ng-template [ngTemplateOutlet]="simplePagination.template"></ng-template>
      </ng-container>
    </ng-container>
    <nz-pagination-simple
      #simplePagination
      [disabled]="nzDisabled"
      [itemRender]="nzItemRender"
      [locale]="locale"
      [pageSize]="nzPageSize"
      [total]="nzTotal"
      [pageIndex]="nzPageIndex"
      (pageIndexChange)="onPageIndexChange($event)"
    ></nz-pagination-simple>
    <nz-pagination-default
      #defaultPagination
      [nzSize]="size"
      [itemRender]="nzItemRender"
      [showTotal]="nzShowTotal"
      [disabled]="nzDisabled"
      [locale]="locale"
      [showSizeChanger]="nzShowSizeChanger"
      [showQuickJumper]="nzShowQuickJumper"
      [total]="nzTotal"
      [pageIndex]="nzPageIndex"
      [pageSize]="nzPageSize"
      [pageSizeOptions]="nzPageSizeOptions"
      (pageIndexChange)="onPageIndexChange($event)"
      (pageSizeChange)="onPageSizeChange($event)"
    ></nz-pagination-default>
  `,
      host: {
        class: "ant-pagination",
        "[class.ant-pagination-simple]": "nzSimple",
        "[class.ant-pagination-disabled]": "nzDisabled",
        "[class.mini]": `!nzSimple && size === 'small'`,
        "[class.ant-pagination-rtl]": `dir === 'rtl'`
      },
      imports: [NgIf, NgTemplateOutlet, NzPaginationSimpleComponent, NzPaginationDefaultComponent],
      standalone: true
    }]
  }], () => [{
    type: NzI18nService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzBreakpointService
  }, {
    type: NzConfigService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzPageSizeChange: [{
      type: Output
    }],
    nzPageIndexChange: [{
      type: Output
    }],
    nzShowTotal: [{
      type: Input
    }],
    nzItemRender: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzPageSizeOptions: [{
      type: Input
    }],
    nzShowSizeChanger: [{
      type: Input
    }],
    nzShowQuickJumper: [{
      type: Input
    }],
    nzSimple: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzResponsive: [{
      type: Input
    }],
    nzHideOnSinglePage: [{
      type: Input
    }],
    nzTotal: [{
      type: Input
    }],
    nzPageIndex: [{
      type: Input
    }],
    nzPageSize: [{
      type: Input
    }]
  });
})();
var _NzPaginationModule = class _NzPaginationModule {
};
_NzPaginationModule.\u0275fac = function NzPaginationModule_Factory(t) {
  return new (t || _NzPaginationModule)();
};
_NzPaginationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzPaginationModule
});
_NzPaginationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzPaginationComponent, NzPaginationSimpleComponent, NzPaginationOptionsComponent, NzPaginationItemComponent, NzPaginationDefaultComponent]
});
var NzPaginationModule = _NzPaginationModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPaginationModule, [{
    type: NgModule,
    args: [{
      imports: [NzPaginationComponent, NzPaginationSimpleComponent, NzPaginationOptionsComponent, NzPaginationItemComponent, NzPaginationDefaultComponent],
      exports: [NzPaginationComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-spin.mjs
function NzSpinComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 3);
    \u0275\u0275element(1, "i", 4)(2, "i", 4)(3, "i", 4)(4, "i", 4);
    \u0275\u0275elementEnd();
  }
}
function NzSpinComponent_div_2_ng_template_2_Template(rf, ctx) {
}
function NzSpinComponent_div_2_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r5.nzTip);
  }
}
function NzSpinComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div", 5);
    \u0275\u0275template(2, NzSpinComponent_div_2_ng_template_2_Template, 0, 0, "ng-template", 6)(3, NzSpinComponent_div_2_div_3_Template, 2, 1, "div", 7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275advance(1);
    \u0275\u0275classProp("ant-spin-rtl", ctx_r2.dir === "rtl")("ant-spin-spinning", ctx_r2.isLoading)("ant-spin-lg", ctx_r2.nzSize === "large")("ant-spin-sm", ctx_r2.nzSize === "small")("ant-spin-show-text", ctx_r2.nzTip);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.nzIndicator || _r1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.nzTip);
  }
}
function NzSpinComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275projection(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-spin-blur", ctx_r3.isLoading);
  }
}
var _c013 = ["*"];
var NZ_CONFIG_MODULE_NAME8 = "spin";
var _NzSpinComponent = class _NzSpinComponent {
  constructor(nzConfigService, cdr, directionality) {
    this.nzConfigService = nzConfigService;
    this.cdr = cdr;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME8;
    this.nzIndicator = null;
    this.nzSize = "default";
    this.nzTip = null;
    this.nzDelay = 0;
    this.nzSimple = false;
    this.nzSpinning = true;
    this.destroy$ = new Subject();
    this.spinning$ = new BehaviorSubject(this.nzSpinning);
    this.delay$ = new ReplaySubject(1);
    this.isLoading = false;
    this.dir = "ltr";
  }
  ngOnInit() {
    const loading$ = this.delay$.pipe(startWith(this.nzDelay), distinctUntilChanged(), switchMap((delay2) => {
      if (delay2 === 0) {
        return this.spinning$;
      }
      return this.spinning$.pipe(debounce((spinning) => timer(spinning ? delay2 : 0)));
    }), takeUntil(this.destroy$));
    loading$.subscribe((loading) => {
      this.isLoading = loading;
      this.cdr.markForCheck();
    });
    this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME8).pipe(takeUntil(this.destroy$)).subscribe(() => this.cdr.markForCheck());
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnChanges(changes) {
    const {
      nzSpinning,
      nzDelay
    } = changes;
    if (nzSpinning) {
      this.spinning$.next(this.nzSpinning);
    }
    if (nzDelay) {
      this.delay$.next(this.nzDelay);
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzSpinComponent.\u0275fac = function NzSpinComponent_Factory(t) {
  return new (t || _NzSpinComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzSpinComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSpinComponent,
  selectors: [["nz-spin"]],
  hostVars: 2,
  hostBindings: function NzSpinComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-spin-nested-loading", !ctx.nzSimple);
    }
  },
  inputs: {
    nzIndicator: "nzIndicator",
    nzSize: "nzSize",
    nzTip: "nzTip",
    nzDelay: "nzDelay",
    nzSimple: "nzSimple",
    nzSpinning: "nzSpinning"
  },
  exportAs: ["nzSpin"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c013,
  decls: 4,
  vars: 2,
  consts: [["defaultTemplate", ""], [4, "ngIf"], ["class", "ant-spin-container", 3, "ant-spin-blur", 4, "ngIf"], [1, "ant-spin-dot", "ant-spin-dot-spin"], [1, "ant-spin-dot-item"], [1, "ant-spin"], [3, "ngTemplateOutlet"], ["class", "ant-spin-text", 4, "ngIf"], [1, "ant-spin-text"], [1, "ant-spin-container"]],
  template: function NzSpinComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzSpinComponent_ng_template_0_Template, 5, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, NzSpinComponent_div_2_Template, 4, 12, "div", 1)(3, NzSpinComponent_div_3_Template, 2, 2, "div", 2);
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.isLoading);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.nzSimple);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
var NzSpinComponent = _NzSpinComponent;
__decorate([WithConfig()], NzSpinComponent.prototype, "nzIndicator", void 0);
__decorate([InputNumber()], NzSpinComponent.prototype, "nzDelay", void 0);
__decorate([InputBoolean()], NzSpinComponent.prototype, "nzSimple", void 0);
__decorate([InputBoolean()], NzSpinComponent.prototype, "nzSpinning", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSpinComponent, [{
    type: Component,
    args: [{
      selector: "nz-spin",
      exportAs: "nzSpin",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <ng-template #defaultTemplate>
      <span class="ant-spin-dot ant-spin-dot-spin">
        <i class="ant-spin-dot-item"></i>
        <i class="ant-spin-dot-item"></i>
        <i class="ant-spin-dot-item"></i>
        <i class="ant-spin-dot-item"></i>
      </span>
    </ng-template>
    <div *ngIf="isLoading">
      <div
        class="ant-spin"
        [class.ant-spin-rtl]="dir === 'rtl'"
        [class.ant-spin-spinning]="isLoading"
        [class.ant-spin-lg]="nzSize === 'large'"
        [class.ant-spin-sm]="nzSize === 'small'"
        [class.ant-spin-show-text]="nzTip"
      >
        <ng-template [ngTemplateOutlet]="nzIndicator || defaultTemplate"></ng-template>
        <div class="ant-spin-text" *ngIf="nzTip">{{ nzTip }}</div>
      </div>
    </div>
    <div *ngIf="!nzSimple" class="ant-spin-container" [class.ant-spin-blur]="isLoading">
      <ng-content></ng-content>
    </div>
  `,
      host: {
        "[class.ant-spin-nested-loading]": "!nzSimple"
      },
      imports: [NgIf, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzIndicator: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzTip: [{
      type: Input
    }],
    nzDelay: [{
      type: Input
    }],
    nzSimple: [{
      type: Input
    }],
    nzSpinning: [{
      type: Input
    }]
  });
})();
var _NzSpinModule = class _NzSpinModule {
};
_NzSpinModule.\u0275fac = function NzSpinModule_Factory(t) {
  return new (t || _NzSpinModule)();
};
_NzSpinModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzSpinModule
});
_NzSpinModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzSpinModule = _NzSpinModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSpinModule, [{
    type: NgModule,
    args: [{
      imports: [NzSpinComponent],
      exports: [NzSpinComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-cdk-resize-observer.mjs
var _NzResizeObserverFactory = class _NzResizeObserverFactory {
  create(callback) {
    return typeof ResizeObserver === "undefined" ? null : new ResizeObserver(callback);
  }
};
_NzResizeObserverFactory.\u0275fac = function NzResizeObserverFactory_Factory(t) {
  return new (t || _NzResizeObserverFactory)();
};
_NzResizeObserverFactory.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzResizeObserverFactory,
  factory: _NzResizeObserverFactory.\u0275fac,
  providedIn: "root"
});
var NzResizeObserverFactory = _NzResizeObserverFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizeObserverFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NzResizeObserver = class _NzResizeObserver {
  constructor(nzResizeObserverFactory) {
    this.nzResizeObserverFactory = nzResizeObserverFactory;
    this.observedElements = /* @__PURE__ */ new Map();
  }
  ngOnDestroy() {
    this.observedElements.forEach((_, element) => this.cleanupObserver(element));
  }
  observe(elementOrRef) {
    const element = coerceElement(elementOrRef);
    return new Observable((observer) => {
      const stream = this.observeElement(element);
      const subscription = stream.subscribe(observer);
      return () => {
        subscription.unsubscribe();
        this.unobserveElement(element);
      };
    });
  }
  /**
   * Observes the given element by using the existing ResizeObserver if available, or creating a
   * new one if not.
   */
  observeElement(element) {
    if (!this.observedElements.has(element)) {
      const stream = new Subject();
      const observer = this.nzResizeObserverFactory.create((mutations) => stream.next(mutations));
      if (observer) {
        observer.observe(element);
      }
      this.observedElements.set(element, {
        observer,
        stream,
        count: 1
      });
    } else {
      this.observedElements.get(element).count++;
    }
    return this.observedElements.get(element).stream;
  }
  /**
   * Un-observes the given element and cleans up the underlying ResizeObserver if nobody else is
   * observing this element.
   */
  unobserveElement(element) {
    if (this.observedElements.has(element)) {
      this.observedElements.get(element).count--;
      if (!this.observedElements.get(element).count) {
        this.cleanupObserver(element);
      }
    }
  }
  /** Clean up the underlying ResizeObserver for the specified element. */
  cleanupObserver(element) {
    if (this.observedElements.has(element)) {
      const {
        observer,
        stream
      } = this.observedElements.get(element);
      if (observer) {
        observer.disconnect();
      }
      stream.complete();
      this.observedElements.delete(element);
    }
  }
};
_NzResizeObserver.\u0275fac = function NzResizeObserver_Factory(t) {
  return new (t || _NzResizeObserver)(\u0275\u0275inject(NzResizeObserverFactory));
};
_NzResizeObserver.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzResizeObserver,
  factory: _NzResizeObserver.\u0275fac,
  providedIn: "root"
});
var NzResizeObserver = _NzResizeObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizeObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NzResizeObserverFactory
  }], null);
})();
var _NzResizeObserverDirective = class _NzResizeObserverDirective {
  subscribe() {
    this.unsubscribe();
    this.currentSubscription = this.nzResizeObserver.observe(this.elementRef).subscribe(this.nzResizeObserve);
  }
  unsubscribe() {
    this.currentSubscription?.unsubscribe();
  }
  constructor(nzResizeObserver, elementRef) {
    this.nzResizeObserver = nzResizeObserver;
    this.elementRef = elementRef;
    this.nzResizeObserve = new EventEmitter();
    this.nzResizeObserverDisabled = false;
    this.currentSubscription = null;
  }
  ngAfterContentInit() {
    if (!this.currentSubscription && !this.nzResizeObserverDisabled) {
      this.subscribe();
    }
  }
  ngOnDestroy() {
    this.unsubscribe();
  }
  ngOnChanges(changes) {
    const {
      nzResizeObserve
    } = changes;
    if (nzResizeObserve) {
      if (this.nzResizeObserverDisabled) {
        this.unsubscribe();
      } else {
        this.subscribe();
      }
    }
  }
};
_NzResizeObserverDirective.\u0275fac = function NzResizeObserverDirective_Factory(t) {
  return new (t || _NzResizeObserverDirective)(\u0275\u0275directiveInject(NzResizeObserver), \u0275\u0275directiveInject(ElementRef));
};
_NzResizeObserverDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzResizeObserverDirective,
  selectors: [["", "nzResizeObserver", ""]],
  inputs: {
    nzResizeObserverDisabled: "nzResizeObserverDisabled"
  },
  outputs: {
    nzResizeObserve: "nzResizeObserve"
  },
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzResizeObserverFactory]), \u0275\u0275NgOnChangesFeature]
});
var NzResizeObserverDirective = _NzResizeObserverDirective;
__decorate([InputBoolean()], NzResizeObserverDirective.prototype, "nzResizeObserverDisabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizeObserverDirective, [{
    type: Directive,
    args: [{
      selector: "[nzResizeObserver]",
      standalone: true,
      providers: [NzResizeObserverFactory]
    }]
  }], () => [{
    type: NzResizeObserver
  }, {
    type: ElementRef
  }], {
    nzResizeObserve: [{
      type: Output
    }],
    nzResizeObserverDisabled: [{
      type: Input
    }]
  });
})();
var _NzResizeObserverModule = class _NzResizeObserverModule {
};
_NzResizeObserverModule.\u0275fac = function NzResizeObserverModule_Factory(t) {
  return new (t || _NzResizeObserverModule)();
};
_NzResizeObserverModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzResizeObserverModule
});
_NzResizeObserverModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzResizeObserverModule = _NzResizeObserverModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizeObserverModule, [{
    type: NgModule,
    args: [{
      imports: [NzResizeObserverDirective],
      exports: [NzResizeObserverDirective]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-table.mjs
var _c014 = ["*"];
function NzTableFilterComponent_ng_template_1_Template(rf, ctx) {
}
function NzTableFilterComponent_ng_container_2_li_7_label_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 15);
    \u0275\u0275listener("ngModelChange", function NzTableFilterComponent_ng_container_2_li_7_label_1_Template_label_ngModelChange_0_listener() {
      \u0275\u0275restoreView(_r9);
      const f_r4 = \u0275\u0275nextContext().$implicit;
      const ctx_r7 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r7.check(f_r4));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const f_r4 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("ngModel", f_r4.checked);
  }
}
function NzTableFilterComponent_ng_container_2_li_7_label_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 16);
    \u0275\u0275listener("ngModelChange", function NzTableFilterComponent_ng_container_2_li_7_label_2_Template_label_ngModelChange_0_listener() {
      \u0275\u0275restoreView(_r13);
      const f_r4 = \u0275\u0275nextContext().$implicit;
      const ctx_r11 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r11.check(f_r4));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const f_r4 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("ngModel", f_r4.checked);
  }
}
function NzTableFilterComponent_ng_container_2_li_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 12);
    \u0275\u0275listener("click", function NzTableFilterComponent_ng_container_2_li_7_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r16);
      const f_r4 = restoredCtx.$implicit;
      const ctx_r15 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r15.check(f_r4));
    });
    \u0275\u0275template(1, NzTableFilterComponent_ng_container_2_li_7_label_1_Template, 1, 1, "label", 13)(2, NzTableFilterComponent_ng_container_2_li_7_label_2_Template, 1, 1, "label", 14);
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const f_r4 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzSelected", f_r4.checked);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r3.filterMultiple);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r3.filterMultiple);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(f_r4.text);
  }
}
function NzTableFilterComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "nz-filter-trigger", 3);
    \u0275\u0275listener("nzVisibleChange", function NzTableFilterComponent_ng_container_2_Template_nz_filter_trigger_nzVisibleChange_1_listener($event) {
      \u0275\u0275restoreView(_r18);
      const ctx_r17 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r17.onVisibleChange($event));
    });
    \u0275\u0275element(2, "span", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-dropdown-menu", null, 5)(5, "div", 6)(6, "ul", 7);
    \u0275\u0275template(7, NzTableFilterComponent_ng_container_2_li_7_Template, 5, 4, "li", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 9)(9, "button", 10);
    \u0275\u0275listener("click", function NzTableFilterComponent_ng_container_2_Template_button_click_9_listener() {
      \u0275\u0275restoreView(_r18);
      const ctx_r19 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r19.reset());
    });
    \u0275\u0275text(10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "button", 11);
    \u0275\u0275listener("click", function NzTableFilterComponent_ng_container_2_Template_button_click_11_listener() {
      \u0275\u0275restoreView(_r18);
      const ctx_r20 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r20.confirm());
    });
    \u0275\u0275text(12);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r2 = \u0275\u0275reference(4);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzVisible", ctx_r1.isVisible)("nzActive", ctx_r1.isChecked)("nzDropdownMenu", _r2);
    \u0275\u0275advance(6);
    \u0275\u0275property("ngForOf", ctx_r1.listOfParsedFilter)("ngForTrackBy", ctx_r1.trackByValue);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", !ctx_r1.isChecked);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r1.locale.filterReset, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.locale.filterConfirm);
  }
}
function NzTableSelectionComponent_label_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 2);
    \u0275\u0275listener("ngModelChange", function NzTableSelectionComponent_label_0_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCheckedChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-table-selection-select-all-custom", ctx_r0.showRowSelection);
    \u0275\u0275property("ngModel", ctx_r0.checked)("nzDisabled", ctx_r0.disabled)("nzIndeterminate", ctx_r0.indeterminate);
    \u0275\u0275attribute("aria-label", ctx_r0.label);
  }
}
function NzTableSelectionComponent_div_1_li_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 9);
    \u0275\u0275listener("click", function NzTableSelectionComponent_div_1_li_6_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r8);
      const selection_r6 = restoredCtx.$implicit;
      return \u0275\u0275resetView(selection_r6.onSelect());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const selection_r6 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", selection_r6.text, " ");
  }
}
function NzTableSelectionComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3)(1, "span", 4);
    \u0275\u0275element(2, "span", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-dropdown-menu", null, 6)(5, "ul", 7);
    \u0275\u0275template(6, NzTableSelectionComponent_div_1_li_6_Template, 2, 1, "li", 8);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const _r4 = \u0275\u0275reference(4);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzDropdownMenu", _r4);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngForOf", ctx_r1.listOfSelections);
  }
}
function NzTableSortersComponent_ng_template_1_Template(rf, ctx) {
}
function NzTableSortersComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 6);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r1.sortOrder === "ascend");
  }
}
function NzTableSortersComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r2.sortOrder === "descend");
  }
}
var _c18 = ["nzChecked", ""];
function NzTdAddOnComponent_ng_container_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 5);
    \u0275\u0275listener("expandChange", function NzTdAddOnComponent_ng_container_0_ng_template_2_Template_button_expandChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r5 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r5.onExpandChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("expand", ctx_r2.nzExpand)("spaceMode", !ctx_r2.nzShowExpand);
  }
}
function NzTdAddOnComponent_ng_container_0_ng_container_4_ng_template_1_Template(rf, ctx) {
}
function NzTdAddOnComponent_ng_container_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTdAddOnComponent_ng_container_0_ng_container_4_ng_template_1_Template, 0, 0, "ng-template", 6);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r4.nzExpandIcon);
  }
}
function NzTdAddOnComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "nz-row-indent", 2);
    \u0275\u0275template(2, NzTdAddOnComponent_ng_container_0_ng_template_2_Template, 1, 2, "ng-template", null, 3, \u0275\u0275templateRefExtractor)(4, NzTdAddOnComponent_ng_container_0_ng_container_4_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r3 = \u0275\u0275reference(3);
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("indentSize", ctx_r0.nzIndentSize);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r0.nzExpandIcon)("ngIfElse", _r3);
  }
}
function NzTdAddOnComponent_label_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 7);
    \u0275\u0275listener("ngModelChange", function NzTdAddOnComponent_label_1_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r8 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r8.onCheckedChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("nzDisabled", ctx_r1.nzDisabled)("ngModel", ctx_r1.nzChecked)("nzIndeterminate", ctx_r1.nzIndeterminate);
    \u0275\u0275attribute("aria-label", ctx_r1.nzLabel);
  }
}
var _c27 = ["nzColumnKey", ""];
function NzThAddOnComponent_nz_table_filter_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-table-filter", 5);
    \u0275\u0275listener("filterChange", function NzThAddOnComponent_nz_table_filter_0_Template_nz_table_filter_filterChange_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.onFilterValueChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const _r2 = \u0275\u0275reference(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275property("contentTemplate", _r2)("extraTemplate", _r4)("customFilter", ctx_r0.nzCustomFilter)("filterMultiple", ctx_r0.nzFilterMultiple)("listOfFilter", ctx_r0.nzFilters);
  }
}
function NzThAddOnComponent_ng_template_1_ng_template_0_Template(rf, ctx) {
}
function NzThAddOnComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzThAddOnComponent_ng_template_1_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    const _r8 = \u0275\u0275reference(8);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.nzShowSort ? _r6 : _r8);
  }
}
function NzThAddOnComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
    \u0275\u0275projection(1, 1);
  }
}
function NzThAddOnComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-table-sorters", 7);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    const _r8 = \u0275\u0275reference(8);
    \u0275\u0275property("sortOrder", ctx_r5.sortOrder)("sortDirections", ctx_r5.sortDirections)("contentTemplate", _r8);
  }
}
function NzThAddOnComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0, 2);
  }
}
var _c34 = [[["", "nz-th-extra", ""]], [["nz-filter-trigger"]], "*"];
var _c43 = ["[nz-th-extra]", "nz-filter-trigger", "*"];
var _c52 = ["nzSelections", ""];
var _c62 = ["nz-table-content", ""];
function NzTableContentComponent_col_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "col");
  }
  if (rf & 2) {
    const width_r3 = ctx.$implicit;
    \u0275\u0275styleProp("width", width_r3)("min-width", width_r3);
  }
}
function NzTableContentComponent_thead_1_ng_template_1_Template(rf, ctx) {
}
function NzTableContentComponent_thead_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "thead", 3);
    \u0275\u0275template(1, NzTableContentComponent_thead_1_ng_template_1_Template, 0, 0, "ng-template", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.theadTemplate);
  }
}
function NzTableContentComponent_ng_template_2_Template(rf, ctx) {
}
var _c72 = ["tdElement"];
var _c82 = ["nz-table-fixed-row", ""];
function NzTableFixedRowComponent_div_2_ng_template_2_Template(rf, ctx) {
}
function NzTableFixedRowComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275pipe(1, "async");
    \u0275\u0275template(2, NzTableFixedRowComponent_div_2_ng_template_2_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const _r3 = \u0275\u0275reference(5);
    \u0275\u0275styleProp("width", \u0275\u0275pipeBind1(1, 3, ctx_r1.hostWidth$), "px");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", _r3);
  }
}
function NzTableFixedRowComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c92 = ["tableHeaderElement"];
var _c102 = ["tableBodyElement"];
function NzTableInnerScrollComponent_ng_container_0_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7, 8);
    \u0275\u0275element(2, "table", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngStyle", ctx_r3.bodyStyleMap);
    \u0275\u0275advance(2);
    \u0275\u0275property("scrollX", ctx_r3.scrollX)("listOfColWidth", ctx_r3.listOfColWidth)("contentTemplate", ctx_r3.contentTemplate);
  }
}
function NzTableInnerScrollComponent_ng_container_0_cdk_virtual_scroll_viewport_5_ng_container_4_ng_template_1_Template(rf, ctx) {
}
var _c112 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
function NzTableInnerScrollComponent_ng_container_0_cdk_virtual_scroll_viewport_5_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTableInnerScrollComponent_ng_container_0_cdk_virtual_scroll_viewport_5_ng_container_4_ng_template_1_Template, 0, 0, "ng-template", 13);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r8 = ctx.$implicit;
    const i_r9 = ctx.index;
    const ctx_r7 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r7.virtualTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c112, item_r8, i_r9));
  }
}
function NzTableInnerScrollComponent_ng_container_0_cdk_virtual_scroll_viewport_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "cdk-virtual-scroll-viewport", 10, 8)(2, "table", 11)(3, "tbody");
    \u0275\u0275template(4, NzTableInnerScrollComponent_ng_container_0_cdk_virtual_scroll_viewport_5_ng_container_4_Template, 2, 5, "ng-container", 12);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("height", ctx_r4.data.length ? ctx_r4.scrollY : ctx_r4.noDateVirtualHeight);
    \u0275\u0275property("itemSize", ctx_r4.virtualItemSize)("maxBufferPx", ctx_r4.virtualMaxBufferPx)("minBufferPx", ctx_r4.virtualMinBufferPx);
    \u0275\u0275advance(2);
    \u0275\u0275property("scrollX", ctx_r4.scrollX)("listOfColWidth", ctx_r4.listOfColWidth);
    \u0275\u0275advance(2);
    \u0275\u0275property("cdkVirtualForOf", ctx_r4.data)("cdkVirtualForTrackBy", ctx_r4.virtualForTrackBy);
  }
}
function NzTableInnerScrollComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 2, 3);
    \u0275\u0275element(3, "table", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, NzTableInnerScrollComponent_ng_container_0_div_4_Template, 3, 4, "div", 5)(5, NzTableInnerScrollComponent_ng_container_0_cdk_virtual_scroll_viewport_5_Template, 5, 9, "cdk-virtual-scroll-viewport", 6);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngStyle", ctx_r0.headerStyleMap);
    \u0275\u0275advance(2);
    \u0275\u0275property("scrollX", ctx_r0.scrollX)("listOfColWidth", ctx_r0.listOfColWidth)("theadTemplate", ctx_r0.theadTemplate);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r0.virtualTemplate);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.virtualTemplate);
  }
}
function NzTableInnerScrollComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14, 8);
    \u0275\u0275element(2, "table", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngStyle", ctx_r1.bodyStyleMap);
    \u0275\u0275advance(2);
    \u0275\u0275property("scrollX", ctx_r1.scrollX)("listOfColWidth", ctx_r1.listOfColWidth)("theadTemplate", ctx_r1.theadTemplate)("contentTemplate", ctx_r1.contentTemplate);
  }
}
function NzTableTitleFooterComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r0.title);
  }
}
function NzTableTitleFooterComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r1.footer);
  }
}
function NzTableComponent_ng_container_1_ng_template_1_Template(rf, ctx) {
}
function NzTableComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTableComponent_ng_container_1_ng_template_1_Template, 0, 0, "ng-template", 10);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r9 = \u0275\u0275reference(11);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r9);
  }
}
function NzTableComponent_nz_table_title_footer_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-table-title-footer", 11);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("title", ctx_r2.nzTitle);
  }
}
function NzTableComponent_nz_table_inner_scroll_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-table-inner-scroll", 12);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const _r11 = \u0275\u0275reference(13);
    const _r1 = \u0275\u0275reference(3);
    \u0275\u0275property("data", ctx_r3.data)("scrollX", ctx_r3.scrollX)("scrollY", ctx_r3.scrollY)("contentTemplate", _r11)("listOfColWidth", ctx_r3.listOfAutoColWidth)("theadTemplate", ctx_r3.theadTemplate)("verticalScrollBarWidth", ctx_r3.verticalScrollBarWidth)("virtualTemplate", ctx_r3.nzVirtualScrollDirective ? ctx_r3.nzVirtualScrollDirective.templateRef : null)("virtualItemSize", ctx_r3.nzVirtualItemSize)("virtualMaxBufferPx", ctx_r3.nzVirtualMaxBufferPx)("virtualMinBufferPx", ctx_r3.nzVirtualMinBufferPx)("tableMainElement", _r1)("virtualForTrackBy", ctx_r3.nzVirtualForTrackBy);
  }
}
function NzTableComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-table-inner-default", 13);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    const _r11 = \u0275\u0275reference(13);
    \u0275\u0275property("tableLayout", ctx_r4.nzTableLayout)("listOfColWidth", ctx_r4.listOfManualColWidth)("theadTemplate", ctx_r4.theadTemplate)("contentTemplate", _r11);
  }
}
function NzTableComponent_nz_table_title_footer_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-table-title-footer", 14);
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275property("footer", ctx_r6.nzFooter);
  }
}
function NzTableComponent_ng_container_9_ng_template_1_Template(rf, ctx) {
}
function NzTableComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTableComponent_ng_container_9_ng_template_1_Template, 0, 0, "ng-template", 10);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r9 = \u0275\u0275reference(11);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r9);
  }
}
function NzTableComponent_ng_template_10_nz_pagination_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-pagination", 16);
    \u0275\u0275listener("nzPageSizeChange", function NzTableComponent_ng_template_10_nz_pagination_0_Template_nz_pagination_nzPageSizeChange_0_listener($event) {
      \u0275\u0275restoreView(_r16);
      const ctx_r15 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r15.onPageSizeChange($event));
    })("nzPageIndexChange", function NzTableComponent_ng_template_10_nz_pagination_0_Template_nz_pagination_nzPageIndexChange_0_listener($event) {
      \u0275\u0275restoreView(_r16);
      const ctx_r17 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r17.onPageIndexChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r14 = \u0275\u0275nextContext(2);
    \u0275\u0275property("hidden", !ctx_r14.showPagination)("nzShowSizeChanger", ctx_r14.nzShowSizeChanger)("nzPageSizeOptions", ctx_r14.nzPageSizeOptions)("nzItemRender", ctx_r14.nzItemRender)("nzShowQuickJumper", ctx_r14.nzShowQuickJumper)("nzHideOnSinglePage", ctx_r14.nzHideOnSinglePage)("nzShowTotal", ctx_r14.nzShowTotal)("nzSize", ctx_r14.nzPaginationType === "small" ? "small" : ctx_r14.nzSize === "default" ? "default" : "small")("nzPageSize", ctx_r14.nzPageSize)("nzTotal", ctx_r14.nzTotal)("nzSimple", ctx_r14.nzSimple)("nzPageIndex", ctx_r14.nzPageIndex);
  }
}
function NzTableComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzTableComponent_ng_template_10_nz_pagination_0_Template, 1, 12, "nz-pagination", 15);
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r8.nzShowPagination && ctx_r8.data.length);
  }
}
function NzTableComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c122 = ["nz-table-measure-row", ""];
function NzTrMeasureComponent_td_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "td", 1, 2);
  }
}
function NzTbodyComponent_ng_container_0_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr", 3);
    \u0275\u0275listener("listOfAutoWidth", function NzTbodyComponent_ng_container_0_tr_1_Template_tr_listOfAutoWidth_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onListOfAutoWidthChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const listOfMeasureColumn_r2 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275property("listOfMeasureColumn", listOfMeasureColumn_r2);
  }
}
function NzTbodyComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTbodyComponent_ng_container_0_tr_1_Template, 1, 1, "tr", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const listOfMeasureColumn_r2 = ctx.ngIf;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.isInsideTable && listOfMeasureColumn_r2.length);
  }
}
function NzTbodyComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 4);
    \u0275\u0275element(1, "nz-embed-empty", 5);
    \u0275\u0275pipe(2, "async");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("specificContent", \u0275\u0275pipeBind1(2, 1, ctx_r1.noResult$));
  }
}
var _c132 = ["contentTemplate"];
function NzTheadComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
function NzTheadComponent_ng_container_2_ng_template_1_Template(rf, ctx) {
}
function NzTheadComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTheadComponent_ng_container_2_ng_template_1_Template, 0, 0, "ng-template", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
var NZ_CONFIG_MODULE_NAME$12 = "filterTrigger";
var _NzFilterTriggerComponent = class _NzFilterTriggerComponent {
  onVisibleChange(visible) {
    this.nzVisible = visible;
    this.nzVisibleChange.next(visible);
  }
  hide() {
    this.nzVisible = false;
    this.cdr.markForCheck();
  }
  show() {
    this.nzVisible = true;
    this.cdr.markForCheck();
  }
  constructor(nzConfigService, ngZone, cdr, destroy$) {
    this.nzConfigService = nzConfigService;
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.destroy$ = destroy$;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME$12;
    this.nzActive = false;
    this.nzVisible = false;
    this.nzBackdrop = false;
    this.nzVisibleChange = new EventEmitter();
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.nzDropdown.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        event.stopPropagation();
      });
    });
  }
};
_NzFilterTriggerComponent.\u0275fac = function NzFilterTriggerComponent_Factory(t) {
  return new (t || _NzFilterTriggerComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzDestroyService));
};
_NzFilterTriggerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzFilterTriggerComponent,
  selectors: [["nz-filter-trigger"]],
  viewQuery: function NzFilterTriggerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NzDropDownDirective, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzDropdown = _t.first);
    }
  },
  inputs: {
    nzActive: "nzActive",
    nzDropdownMenu: "nzDropdownMenu",
    nzVisible: "nzVisible",
    nzBackdrop: "nzBackdrop"
  },
  outputs: {
    nzVisibleChange: "nzVisibleChange"
  },
  exportAs: ["nzFilterTrigger"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService]), \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c014,
  decls: 2,
  vars: 8,
  consts: [["nz-dropdown", "", "nzTrigger", "click", "nzPlacement", "bottomRight", 1, "ant-table-filter-trigger", 3, "nzBackdrop", "nzClickHide", "nzDropdownMenu", "nzVisible", "nzVisibleChange"]],
  template: function NzFilterTriggerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275listener("nzVisibleChange", function NzFilterTriggerComponent_Template_span_nzVisibleChange_0_listener($event) {
        return ctx.onVisibleChange($event);
      });
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("active", ctx.nzActive)("ant-table-filter-open", ctx.nzVisible);
      \u0275\u0275property("nzBackdrop", ctx.nzBackdrop)("nzClickHide", false)("nzDropdownMenu", ctx.nzDropdownMenu)("nzVisible", ctx.nzVisible);
    }
  },
  dependencies: [NzDropDownModule, NzDropDownDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzFilterTriggerComponent = _NzFilterTriggerComponent;
__decorate([WithConfig(), InputBoolean()], NzFilterTriggerComponent.prototype, "nzBackdrop", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFilterTriggerComponent, [{
    type: Component,
    args: [{
      selector: "nz-filter-trigger",
      exportAs: `nzFilterTrigger`,
      changeDetection: ChangeDetectionStrategy.OnPush,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <span
      nz-dropdown
      class="ant-table-filter-trigger"
      nzTrigger="click"
      nzPlacement="bottomRight"
      [nzBackdrop]="nzBackdrop"
      [nzClickHide]="false"
      [nzDropdownMenu]="nzDropdownMenu"
      [class.active]="nzActive"
      [class.ant-table-filter-open]="nzVisible"
      [nzVisible]="nzVisible"
      (nzVisibleChange)="onVisibleChange($event)"
    >
      <ng-content></ng-content>
    </span>
  `,
      providers: [NzDestroyService],
      imports: [NzDropDownModule],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzDestroyService
  }], {
    nzActive: [{
      type: Input
    }],
    nzDropdownMenu: [{
      type: Input
    }],
    nzVisible: [{
      type: Input
    }],
    nzBackdrop: [{
      type: Input
    }],
    nzVisibleChange: [{
      type: Output
    }],
    nzDropdown: [{
      type: ViewChild,
      args: [NzDropDownDirective, {
        static: true,
        read: ElementRef
      }]
    }]
  });
})();
var _NzTableFilterComponent = class _NzTableFilterComponent {
  trackByValue(_, item) {
    return item.value;
  }
  check(filter2) {
    if (this.filterMultiple) {
      this.listOfParsedFilter = this.listOfParsedFilter.map((item) => {
        if (item === filter2) {
          return __spreadProps(__spreadValues({}, item), {
            checked: !filter2.checked
          });
        } else {
          return item;
        }
      });
      filter2.checked = !filter2.checked;
    } else {
      this.listOfParsedFilter = this.listOfParsedFilter.map((item) => __spreadProps(__spreadValues({}, item), {
        checked: item === filter2
      }));
    }
    this.isChecked = this.getCheckedStatus(this.listOfParsedFilter);
  }
  confirm() {
    this.isVisible = false;
    this.emitFilterData();
  }
  reset() {
    this.isVisible = false;
    this.listOfParsedFilter = this.parseListOfFilter(this.listOfFilter, true);
    this.isChecked = this.getCheckedStatus(this.listOfParsedFilter);
    this.emitFilterData();
  }
  onVisibleChange(value) {
    this.isVisible = value;
    if (!value) {
      this.emitFilterData();
    } else {
      this.listOfChecked = this.listOfParsedFilter.filter((item) => item.checked).map((item) => item.value);
    }
  }
  emitFilterData() {
    const listOfChecked = this.listOfParsedFilter.filter((item) => item.checked).map((item) => item.value);
    if (!arraysEqual(this.listOfChecked, listOfChecked)) {
      if (this.filterMultiple) {
        this.filterChange.emit(listOfChecked);
      } else {
        this.filterChange.emit(listOfChecked.length > 0 ? listOfChecked[0] : null);
      }
    }
  }
  parseListOfFilter(listOfFilter, reset) {
    return listOfFilter.map((item) => {
      const checked = reset ? false : !!item.byDefault;
      return {
        text: item.text,
        value: item.value,
        checked
      };
    });
  }
  getCheckedStatus(listOfParsedFilter) {
    return listOfParsedFilter.some((item) => item.checked);
  }
  constructor(cdr, i18n) {
    this.cdr = cdr;
    this.i18n = i18n;
    this.contentTemplate = null;
    this.customFilter = false;
    this.extraTemplate = null;
    this.filterMultiple = true;
    this.listOfFilter = [];
    this.filterChange = new EventEmitter();
    this.destroy$ = new Subject();
    this.isChecked = false;
    this.isVisible = false;
    this.listOfParsedFilter = [];
    this.listOfChecked = [];
  }
  ngOnInit() {
    this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.locale = this.i18n.getLocaleData("Table");
      this.cdr.markForCheck();
    });
  }
  ngOnChanges(changes) {
    const {
      listOfFilter
    } = changes;
    if (listOfFilter && this.listOfFilter && this.listOfFilter.length) {
      this.listOfParsedFilter = this.parseListOfFilter(this.listOfFilter);
      this.isChecked = this.getCheckedStatus(this.listOfParsedFilter);
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzTableFilterComponent.\u0275fac = function NzTableFilterComponent_Factory(t) {
  return new (t || _NzTableFilterComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzI18nService));
};
_NzTableFilterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableFilterComponent,
  selectors: [["nz-table-filter"]],
  hostAttrs: [1, "ant-table-filter-column"],
  inputs: {
    contentTemplate: "contentTemplate",
    customFilter: "customFilter",
    extraTemplate: "extraTemplate",
    filterMultiple: "filterMultiple",
    listOfFilter: "listOfFilter"
  },
  outputs: {
    filterChange: "filterChange"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 3,
  vars: 3,
  consts: [[1, "ant-table-column-title"], [3, "ngTemplateOutlet"], [4, "ngIf", "ngIfElse"], [3, "nzVisible", "nzActive", "nzDropdownMenu", "nzVisibleChange"], ["nz-icon", "", "nzType", "filter", "nzTheme", "fill"], ["filterMenu", "nzDropdownMenu"], [1, "ant-table-filter-dropdown"], ["nz-menu", ""], ["nz-menu-item", "", 3, "nzSelected", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "ant-table-filter-dropdown-btns"], ["nz-button", "", "nzType", "link", "nzSize", "small", 3, "disabled", "click"], ["nz-button", "", "nzType", "primary", "nzSize", "small", 3, "click"], ["nz-menu-item", "", 3, "nzSelected", "click"], ["nz-radio", "", 3, "ngModel", "ngModelChange", 4, "ngIf"], ["nz-checkbox", "", 3, "ngModel", "ngModelChange", 4, "ngIf"], ["nz-radio", "", 3, "ngModel", "ngModelChange"], ["nz-checkbox", "", 3, "ngModel", "ngModelChange"]],
  template: function NzTableFilterComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275template(1, NzTableFilterComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275template(2, NzTableFilterComponent_ng_container_2_Template, 13, 8, "ng-container", 2);
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngTemplateOutlet", ctx.contentTemplate);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.customFilter)("ngIfElse", ctx.extraTemplate);
    }
  },
  dependencies: [NgTemplateOutlet, NgIf, NzFilterTriggerComponent, NzIconModule, NzIconDirective, NzDropDownModule, NzMenuDirective, NzMenuItemComponent, NzDropdownMenuComponent, NgForOf, NzRadioComponent, NzCheckboxModule, NzCheckboxComponent, FormsModule, NgControlStatus, NgModel, NzButtonModule, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableFilterComponent = _NzTableFilterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableFilterComponent, [{
    type: Component,
    args: [{
      selector: "nz-table-filter",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <span class="ant-table-column-title">
      <ng-template [ngTemplateOutlet]="contentTemplate"></ng-template>
    </span>
    <ng-container *ngIf="!customFilter; else extraTemplate">
      <nz-filter-trigger
        [nzVisible]="isVisible"
        [nzActive]="isChecked"
        [nzDropdownMenu]="filterMenu"
        (nzVisibleChange)="onVisibleChange($event)"
      >
        <span nz-icon nzType="filter" nzTheme="fill"></span>
      </nz-filter-trigger>
      <nz-dropdown-menu #filterMenu="nzDropdownMenu">
        <div class="ant-table-filter-dropdown">
          <ul nz-menu>
            <li
              nz-menu-item
              [nzSelected]="f.checked"
              *ngFor="let f of listOfParsedFilter; trackBy: trackByValue"
              (click)="check(f)"
            >
              <label nz-radio *ngIf="!filterMultiple" [ngModel]="f.checked" (ngModelChange)="check(f)"></label>
              <label nz-checkbox *ngIf="filterMultiple" [ngModel]="f.checked" (ngModelChange)="check(f)"></label>
              <span>{{ f.text }}</span>
            </li>
          </ul>
          <div class="ant-table-filter-dropdown-btns">
            <button nz-button nzType="link" nzSize="small" (click)="reset()" [disabled]="!isChecked">
              {{ locale.filterReset }}
            </button>
            <button nz-button nzType="primary" nzSize="small" (click)="confirm()">{{ locale.filterConfirm }}</button>
          </div>
        </div>
      </nz-dropdown-menu>
    </ng-container>
  `,
      host: {
        class: "ant-table-filter-column"
      },
      imports: [NgTemplateOutlet, NgIf, NzFilterTriggerComponent, NzIconModule, NzDropDownModule, NgForOf, NzRadioComponent, NzCheckboxModule, FormsModule, NzButtonModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzI18nService
  }], {
    contentTemplate: [{
      type: Input
    }],
    customFilter: [{
      type: Input
    }],
    extraTemplate: [{
      type: Input
    }],
    filterMultiple: [{
      type: Input
    }],
    listOfFilter: [{
      type: Input
    }],
    filterChange: [{
      type: Output
    }]
  });
})();
var _NzRowExpandButtonDirective = class _NzRowExpandButtonDirective {
  constructor() {
    this.expand = false;
    this.spaceMode = false;
    this.expandChange = new EventEmitter();
  }
  onHostClick() {
    if (!this.spaceMode) {
      this.expand = !this.expand;
      this.expandChange.next(this.expand);
    }
  }
};
_NzRowExpandButtonDirective.\u0275fac = function NzRowExpandButtonDirective_Factory(t) {
  return new (t || _NzRowExpandButtonDirective)();
};
_NzRowExpandButtonDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzRowExpandButtonDirective,
  selectors: [["button", "nz-row-expand-button", ""]],
  hostAttrs: [1, "ant-table-row-expand-icon"],
  hostVars: 7,
  hostBindings: function NzRowExpandButtonDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzRowExpandButtonDirective_click_HostBindingHandler() {
        return ctx.onHostClick();
      });
    }
    if (rf & 2) {
      \u0275\u0275hostProperty("type", "button");
      \u0275\u0275classProp("ant-table-row-expand-icon-expanded", !ctx.spaceMode && ctx.expand === true)("ant-table-row-expand-icon-collapsed", !ctx.spaceMode && ctx.expand === false)("ant-table-row-expand-icon-spaced", ctx.spaceMode);
    }
  },
  inputs: {
    expand: "expand",
    spaceMode: "spaceMode"
  },
  outputs: {
    expandChange: "expandChange"
  },
  standalone: true
});
var NzRowExpandButtonDirective = _NzRowExpandButtonDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRowExpandButtonDirective, [{
    type: Directive,
    args: [{
      selector: "button[nz-row-expand-button]",
      host: {
        class: "ant-table-row-expand-icon",
        "[type]": `'button'`,
        "[class.ant-table-row-expand-icon-expanded]": `!spaceMode && expand === true`,
        "[class.ant-table-row-expand-icon-collapsed]": `!spaceMode && expand === false`,
        "[class.ant-table-row-expand-icon-spaced]": "spaceMode",
        "(click)": "onHostClick()"
      },
      standalone: true
    }]
  }], () => [], {
    expand: [{
      type: Input
    }],
    spaceMode: [{
      type: Input
    }],
    expandChange: [{
      type: Output
    }]
  });
})();
var _NzRowIndentDirective = class _NzRowIndentDirective {
  constructor() {
    this.indentSize = 0;
  }
};
_NzRowIndentDirective.\u0275fac = function NzRowIndentDirective_Factory(t) {
  return new (t || _NzRowIndentDirective)();
};
_NzRowIndentDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzRowIndentDirective,
  selectors: [["nz-row-indent"]],
  hostAttrs: [1, "ant-table-row-indent"],
  hostVars: 2,
  hostBindings: function NzRowIndentDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("padding-left", ctx.indentSize, "px");
    }
  },
  inputs: {
    indentSize: "indentSize"
  },
  standalone: true
});
var NzRowIndentDirective = _NzRowIndentDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRowIndentDirective, [{
    type: Directive,
    args: [{
      selector: "nz-row-indent",
      host: {
        class: "ant-table-row-indent",
        "[style.padding-left.px]": "indentSize"
      },
      standalone: true
    }]
  }], () => [], {
    indentSize: [{
      type: Input
    }]
  });
})();
var _NzTableSelectionComponent = class _NzTableSelectionComponent {
  constructor() {
    this.listOfSelections = [];
    this.checked = false;
    this.disabled = false;
    this.indeterminate = false;
    this.label = null;
    this.showCheckbox = false;
    this.showRowSelection = false;
    this.checkedChange = new EventEmitter();
  }
  onCheckedChange(checked) {
    this.checked = checked;
    this.checkedChange.emit(checked);
  }
};
_NzTableSelectionComponent.\u0275fac = function NzTableSelectionComponent_Factory(t) {
  return new (t || _NzTableSelectionComponent)();
};
_NzTableSelectionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableSelectionComponent,
  selectors: [["nz-table-selection"]],
  hostAttrs: [1, "ant-table-selection"],
  inputs: {
    listOfSelections: "listOfSelections",
    checked: "checked",
    disabled: "disabled",
    indeterminate: "indeterminate",
    label: "label",
    showCheckbox: "showCheckbox",
    showRowSelection: "showRowSelection"
  },
  outputs: {
    checkedChange: "checkedChange"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 2,
  consts: [["nz-checkbox", "", 3, "ant-table-selection-select-all-custom", "ngModel", "nzDisabled", "nzIndeterminate", "ngModelChange", 4, "ngIf"], ["class", "ant-table-selection-extra", 4, "ngIf"], ["nz-checkbox", "", 3, "ngModel", "nzDisabled", "nzIndeterminate", "ngModelChange"], [1, "ant-table-selection-extra"], ["nz-dropdown", "", "nzPlacement", "bottomLeft", 1, "ant-table-selection-down", 3, "nzDropdownMenu"], ["nz-icon", "", "nzType", "down"], ["selectionMenu", "nzDropdownMenu"], ["nz-menu", "", 1, "ant-table-selection-menu"], ["nz-menu-item", "", 3, "click", 4, "ngFor", "ngForOf"], ["nz-menu-item", "", 3, "click"]],
  template: function NzTableSelectionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTableSelectionComponent_label_0_Template, 1, 6, "label", 0)(1, NzTableSelectionComponent_div_1_Template, 7, 2, "div", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.showCheckbox);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.showRowSelection);
    }
  },
  dependencies: [NgIf, FormsModule, NgControlStatus, NgModel, NzCheckboxModule, NzCheckboxComponent, NzDropDownModule, NzMenuDirective, NzMenuItemComponent, NzDropDownDirective, NzDropdownMenuComponent, NzIconModule, NzIconDirective, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableSelectionComponent = _NzTableSelectionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableSelectionComponent, [{
    type: Component,
    args: [{
      selector: "nz-table-selection",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <label
      *ngIf="showCheckbox"
      nz-checkbox
      [class.ant-table-selection-select-all-custom]="showRowSelection"
      [ngModel]="checked"
      [nzDisabled]="disabled"
      [nzIndeterminate]="indeterminate"
      [attr.aria-label]="label"
      (ngModelChange)="onCheckedChange($event)"
    ></label>
    <div class="ant-table-selection-extra" *ngIf="showRowSelection">
      <span nz-dropdown class="ant-table-selection-down" nzPlacement="bottomLeft" [nzDropdownMenu]="selectionMenu">
        <span nz-icon nzType="down"></span>
      </span>
      <nz-dropdown-menu #selectionMenu="nzDropdownMenu">
        <ul nz-menu class="ant-table-selection-menu">
          <li nz-menu-item *ngFor="let selection of listOfSelections" (click)="selection.onSelect()">
            {{ selection.text }}
          </li>
        </ul>
      </nz-dropdown-menu>
    </div>
  `,
      host: {
        class: "ant-table-selection"
      },
      imports: [NgIf, FormsModule, NzCheckboxModule, NzDropDownModule, NzIconModule, NgForOf],
      standalone: true
    }]
  }], () => [], {
    listOfSelections: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    showCheckbox: [{
      type: Input
    }],
    showRowSelection: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }]
  });
})();
var _NzTableSortersComponent = class _NzTableSortersComponent {
  constructor() {
    this.sortDirections = ["ascend", "descend", null];
    this.sortOrder = null;
    this.contentTemplate = null;
    this.isUp = false;
    this.isDown = false;
  }
  ngOnChanges(changes) {
    const {
      sortDirections
    } = changes;
    if (sortDirections) {
      this.isUp = this.sortDirections.indexOf("ascend") !== -1;
      this.isDown = this.sortDirections.indexOf("descend") !== -1;
    }
  }
};
_NzTableSortersComponent.\u0275fac = function NzTableSortersComponent_Factory(t) {
  return new (t || _NzTableSortersComponent)();
};
_NzTableSortersComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableSortersComponent,
  selectors: [["nz-table-sorters"]],
  hostAttrs: [1, "ant-table-column-sorters"],
  inputs: {
    sortDirections: "sortDirections",
    sortOrder: "sortOrder",
    contentTemplate: "contentTemplate"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 6,
  vars: 5,
  consts: [[1, "ant-table-column-title"], [3, "ngTemplateOutlet"], [1, "ant-table-column-sorter"], [1, "ant-table-column-sorter-inner"], ["nz-icon", "", "nzType", "caret-up", "class", "ant-table-column-sorter-up", 3, "active", 4, "ngIf"], ["nz-icon", "", "nzType", "caret-down", "class", "ant-table-column-sorter-down", 3, "active", 4, "ngIf"], ["nz-icon", "", "nzType", "caret-up", 1, "ant-table-column-sorter-up"], ["nz-icon", "", "nzType", "caret-down", 1, "ant-table-column-sorter-down"]],
  template: function NzTableSortersComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275template(1, NzTableSortersComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "span", 2)(3, "span", 3);
      \u0275\u0275template(4, NzTableSortersComponent_span_4_Template, 1, 2, "span", 4)(5, NzTableSortersComponent_span_5_Template, 1, 2, "span", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngTemplateOutlet", ctx.contentTemplate);
      \u0275\u0275advance(1);
      \u0275\u0275classProp("ant-table-column-sorter-full", ctx.isDown && ctx.isUp);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.isUp);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.isDown);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NgTemplateOutlet, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableSortersComponent = _NzTableSortersComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableSortersComponent, [{
    type: Component,
    args: [{
      selector: "nz-table-sorters",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <span class="ant-table-column-title"><ng-template [ngTemplateOutlet]="contentTemplate"></ng-template></span>
    <span class="ant-table-column-sorter" [class.ant-table-column-sorter-full]="isDown && isUp">
      <span class="ant-table-column-sorter-inner">
        <span
          nz-icon
          nzType="caret-up"
          *ngIf="isUp"
          class="ant-table-column-sorter-up"
          [class.active]="sortOrder === 'ascend'"
        ></span>
        <span
          nz-icon
          nzType="caret-down"
          *ngIf="isDown"
          class="ant-table-column-sorter-down"
          [class.active]="sortOrder === 'descend'"
        ></span>
      </span>
    </span>
  `,
      host: {
        class: "ant-table-column-sorters"
      },
      imports: [NzIconModule, NgTemplateOutlet, NgIf],
      standalone: true
    }]
  }], () => [], {
    sortDirections: [{
      type: Input
    }],
    sortOrder: [{
      type: Input
    }],
    contentTemplate: [{
      type: Input
    }]
  });
})();
var _NzCellFixedDirective = class _NzCellFixedDirective {
  setAutoLeftWidth(autoLeft) {
    this.renderer.setStyle(this.elementRef.nativeElement, "left", autoLeft);
  }
  setAutoRightWidth(autoRight) {
    this.renderer.setStyle(this.elementRef.nativeElement, "right", autoRight);
  }
  setIsFirstRight(isFirstRight) {
    this.setFixClass(isFirstRight, "ant-table-cell-fix-right-first");
  }
  setIsLastLeft(isLastLeft) {
    this.setFixClass(isLastLeft, "ant-table-cell-fix-left-last");
  }
  setFixClass(flag, className) {
    this.renderer.removeClass(this.elementRef.nativeElement, className);
    if (flag) {
      this.renderer.addClass(this.elementRef.nativeElement, className);
    }
  }
  constructor(renderer, elementRef) {
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.nzRight = false;
    this.nzLeft = false;
    this.colspan = null;
    this.colSpan = null;
    this.changes$ = new Subject();
    this.isAutoLeft = false;
    this.isAutoRight = false;
    this.isFixedLeft = false;
    this.isFixedRight = false;
    this.isFixed = false;
  }
  ngOnChanges() {
    this.setIsFirstRight(false);
    this.setIsLastLeft(false);
    this.isAutoLeft = this.nzLeft === "" || this.nzLeft === true;
    this.isAutoRight = this.nzRight === "" || this.nzRight === true;
    this.isFixedLeft = this.nzLeft !== false;
    this.isFixedRight = this.nzRight !== false;
    this.isFixed = this.isFixedLeft || this.isFixedRight;
    const validatePx = (value) => {
      if (typeof value === "string" && value !== "") {
        return value;
      } else {
        return null;
      }
    };
    this.setAutoLeftWidth(validatePx(this.nzLeft));
    this.setAutoRightWidth(validatePx(this.nzRight));
    this.changes$.next();
  }
};
_NzCellFixedDirective.\u0275fac = function NzCellFixedDirective_Factory(t) {
  return new (t || _NzCellFixedDirective)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_NzCellFixedDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzCellFixedDirective,
  selectors: [["td", "nzRight", ""], ["th", "nzRight", ""], ["td", "nzLeft", ""], ["th", "nzLeft", ""]],
  hostVars: 6,
  hostBindings: function NzCellFixedDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("position", ctx.isFixed ? "sticky" : null);
      \u0275\u0275classProp("ant-table-cell-fix-right", ctx.isFixedRight)("ant-table-cell-fix-left", ctx.isFixedLeft);
    }
  },
  inputs: {
    nzRight: "nzRight",
    nzLeft: "nzLeft",
    colspan: "colspan",
    colSpan: "colSpan"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzCellFixedDirective = _NzCellFixedDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCellFixedDirective, [{
    type: Directive,
    args: [{
      selector: "td[nzRight],th[nzRight],td[nzLeft],th[nzLeft]",
      host: {
        "[class.ant-table-cell-fix-right]": `isFixedRight`,
        "[class.ant-table-cell-fix-left]": `isFixedLeft`,
        "[style.position]": `isFixed? 'sticky' : null`
      },
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    nzRight: [{
      type: Input
    }],
    nzLeft: [{
      type: Input
    }],
    colspan: [{
      type: Input
    }],
    colSpan: [{
      type: Input
    }]
  });
})();
var _NzTableStyleService = class _NzTableStyleService {
  setTheadTemplate(template) {
    this.theadTemplate$.next(template);
  }
  setHasFixLeft(hasFixLeft) {
    this.hasFixLeft$.next(hasFixLeft);
  }
  setHasFixRight(hasFixRight) {
    this.hasFixRight$.next(hasFixRight);
  }
  setTableWidthConfig(widthConfig) {
    this.tableWidthConfigPx$.next(widthConfig);
  }
  setListOfTh(listOfTh) {
    let columnCount = 0;
    listOfTh.forEach((th) => {
      columnCount += th.colspan && +th.colspan || th.colSpan && +th.colSpan || 1;
    });
    const listOfThPx = listOfTh.map((item) => item.nzWidth);
    this.columnCount$.next(columnCount);
    this.listOfThWidthConfigPx$.next(listOfThPx);
  }
  setListOfMeasureColumn(listOfTh) {
    const listOfKeys = [];
    listOfTh.forEach((th) => {
      const length = th.colspan && +th.colspan || th.colSpan && +th.colSpan || 1;
      for (let i = 0; i < length; i++) {
        listOfKeys.push(`measure_key_${i}`);
      }
    });
    this.listOfMeasureColumn$.next(listOfKeys);
  }
  setListOfAutoWidth(listOfAutoWidth) {
    this.listOfAutoWidthPx$.next(listOfAutoWidth.map((width) => `${width}px`));
  }
  setShowEmpty(showEmpty) {
    this.showEmpty$.next(showEmpty);
  }
  setNoResult(noResult) {
    this.noResult$.next(noResult);
  }
  setScroll(scrollX, scrollY) {
    const enableAutoMeasure = !!(scrollX || scrollY);
    if (!enableAutoMeasure) {
      this.setListOfAutoWidth([]);
    }
    this.enableAutoMeasure$.next(enableAutoMeasure);
  }
  constructor() {
    this.theadTemplate$ = new ReplaySubject(1);
    this.hasFixLeft$ = new ReplaySubject(1);
    this.hasFixRight$ = new ReplaySubject(1);
    this.hostWidth$ = new ReplaySubject(1);
    this.columnCount$ = new ReplaySubject(1);
    this.showEmpty$ = new ReplaySubject(1);
    this.noResult$ = new ReplaySubject(1);
    this.listOfThWidthConfigPx$ = new BehaviorSubject([]);
    this.tableWidthConfigPx$ = new BehaviorSubject([]);
    this.manualWidthConfigPx$ = combineLatest([this.tableWidthConfigPx$, this.listOfThWidthConfigPx$]).pipe(map(([widthConfig, listOfWidth]) => widthConfig.length ? widthConfig : listOfWidth));
    this.listOfAutoWidthPx$ = new ReplaySubject(1);
    this.listOfListOfThWidthPx$ = merge(
      /** init with manual width **/
      this.manualWidthConfigPx$,
      combineLatest([this.listOfAutoWidthPx$, this.manualWidthConfigPx$]).pipe(map(([autoWidth, manualWidth]) => {
        if (autoWidth.length === manualWidth.length) {
          return autoWidth.map((width, index) => {
            if (width === "0px") {
              return manualWidth[index] || null;
            } else {
              return manualWidth[index] || width;
            }
          });
        } else {
          return manualWidth;
        }
      }))
    );
    this.listOfMeasureColumn$ = new ReplaySubject(1);
    this.listOfListOfThWidth$ = this.listOfAutoWidthPx$.pipe(map((list2) => list2.map((width) => parseInt(width, 10))));
    this.enableAutoMeasure$ = new ReplaySubject(1);
  }
};
_NzTableStyleService.\u0275fac = function NzTableStyleService_Factory(t) {
  return new (t || _NzTableStyleService)();
};
_NzTableStyleService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzTableStyleService,
  factory: _NzTableStyleService.\u0275fac
});
var NzTableStyleService = _NzTableStyleService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableStyleService, [{
    type: Injectable
  }], () => [], null);
})();
var _NzTableCellDirective = class _NzTableCellDirective {
  constructor(nzTableStyleService) {
    this.isInsideTable = false;
    this.isInsideTable = !!nzTableStyleService;
  }
};
_NzTableCellDirective.\u0275fac = function NzTableCellDirective_Factory(t) {
  return new (t || _NzTableCellDirective)(\u0275\u0275directiveInject(NzTableStyleService, 8));
};
_NzTableCellDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTableCellDirective,
  selectors: [["th", 9, "nz-disable-th", 3, "mat-cell", ""], ["td", 9, "nz-disable-td", 3, "mat-cell", ""]],
  hostVars: 2,
  hostBindings: function NzTableCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-cell", ctx.isInsideTable);
    }
  },
  standalone: true
});
var NzTableCellDirective = _NzTableCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableCellDirective, [{
    type: Directive,
    args: [{
      selector: "th:not(.nz-disable-th):not([mat-cell]), td:not(.nz-disable-td):not([mat-cell])",
      host: {
        "[class.ant-table-cell]": "isInsideTable"
      },
      standalone: true
    }]
  }], () => [{
    type: NzTableStyleService,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _NzTableDataService = class _NzTableDataService {
  updatePageSize(size) {
    this.pageSize$.next(size);
  }
  updateFrontPagination(pagination) {
    this.frontPagination$.next(pagination);
  }
  updatePageIndex(index) {
    this.pageIndex$.next(index);
  }
  updateListOfData(list2) {
    this.listOfData$.next(list2);
  }
  updateListOfCustomColumn(list2) {
    this.listOfCustomColumn$.next(list2);
  }
  constructor() {
    this.destroy$ = new Subject();
    this.pageIndex$ = new BehaviorSubject(1);
    this.frontPagination$ = new BehaviorSubject(true);
    this.pageSize$ = new BehaviorSubject(10);
    this.listOfData$ = new BehaviorSubject([]);
    this.listOfCustomColumn$ = new BehaviorSubject([]);
    this.pageIndexDistinct$ = this.pageIndex$.pipe(distinctUntilChanged());
    this.pageSizeDistinct$ = this.pageSize$.pipe(distinctUntilChanged());
    this.listOfCalcOperator$ = new BehaviorSubject([]);
    this.queryParams$ = combineLatest([this.pageIndexDistinct$, this.pageSizeDistinct$, this.listOfCalcOperator$]).pipe(debounceTime(0), skip(1), map(([pageIndex, pageSize, listOfCalc]) => ({
      pageIndex,
      pageSize,
      sort: listOfCalc.filter((item) => item.sortFn).map((item) => ({
        key: item.key,
        value: item.sortOrder
      })),
      filter: listOfCalc.filter((item) => item.filterFn).map((item) => ({
        key: item.key,
        value: item.filterValue
      }))
    })));
    this.listOfDataAfterCalc$ = combineLatest([this.listOfData$, this.listOfCalcOperator$]).pipe(map(([listOfData, listOfCalcOperator]) => {
      let listOfDataAfterCalc = [...listOfData];
      const listOfFilterOperator = listOfCalcOperator.filter((item) => {
        const {
          filterValue,
          filterFn
        } = item;
        const isReset = filterValue === null || filterValue === void 0 || Array.isArray(filterValue) && filterValue.length === 0;
        return !isReset && typeof filterFn === "function";
      });
      for (const item of listOfFilterOperator) {
        const {
          filterFn,
          filterValue
        } = item;
        listOfDataAfterCalc = listOfDataAfterCalc.filter((data) => filterFn(filterValue, data));
      }
      const listOfSortOperator = listOfCalcOperator.filter((item) => item.sortOrder !== null && typeof item.sortFn === "function").sort((a, b) => +b.sortPriority - +a.sortPriority);
      if (listOfCalcOperator.length) {
        listOfDataAfterCalc.sort((record1, record2) => {
          for (const item of listOfSortOperator) {
            const {
              sortFn,
              sortOrder
            } = item;
            if (sortFn && sortOrder) {
              const compareResult = sortFn(record1, record2, sortOrder);
              if (compareResult !== 0) {
                return sortOrder === "ascend" ? compareResult : -compareResult;
              }
            }
          }
          return 0;
        });
      }
      return listOfDataAfterCalc;
    }));
    this.listOfFrontEndCurrentPageData$ = combineLatest([this.pageIndexDistinct$, this.pageSizeDistinct$, this.listOfDataAfterCalc$]).pipe(takeUntil(this.destroy$), filter((value) => {
      const [pageIndex, pageSize, listOfData] = value;
      const maxPageIndex = Math.ceil(listOfData.length / pageSize) || 1;
      return pageIndex <= maxPageIndex;
    }), map(([pageIndex, pageSize, listOfData]) => listOfData.slice((pageIndex - 1) * pageSize, pageIndex * pageSize)));
    this.listOfCurrentPageData$ = this.frontPagination$.pipe(switchMap((pagination) => pagination ? this.listOfFrontEndCurrentPageData$ : this.listOfDataAfterCalc$));
    this.total$ = this.frontPagination$.pipe(switchMap((pagination) => pagination ? this.listOfDataAfterCalc$ : this.listOfData$), map((list2) => list2.length), distinctUntilChanged());
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzTableDataService.\u0275fac = function NzTableDataService_Factory(t) {
  return new (t || _NzTableDataService)();
};
_NzTableDataService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzTableDataService,
  factory: _NzTableDataService.\u0275fac
});
var NzTableDataService = _NzTableDataService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableDataService, [{
    type: Injectable
  }], () => [], null);
})();
var _NzCustomColumnDirective = class _NzCustomColumnDirective {
  constructor(el, renderer, nzTableDataService) {
    this.el = el;
    this.renderer = renderer;
    this.nzTableDataService = nzTableDataService;
    this.nzCellControl = null;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.nzTableDataService.listOfCustomColumn$.pipe(takeUntil(this.destroy$)).subscribe((item) => {
      if (item.length) {
        item.forEach((v, i) => {
          if (v.value === this.nzCellControl) {
            if (!v.default) {
              this.renderer.setStyle(this.el.nativeElement, "display", "none");
            } else {
              this.renderer.setStyle(this.el.nativeElement, "display", "block");
            }
            this.renderer.setStyle(this.el.nativeElement, "order", i);
            if (!v?.fixWidth) {
              this.renderer.setStyle(this.el.nativeElement, "flex", `1 1 ${v.width}px`);
            } else {
              this.renderer.setStyle(this.el.nativeElement, "flex", `1 0 ${v.width}px`);
            }
          }
        });
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzCustomColumnDirective.\u0275fac = function NzCustomColumnDirective_Factory(t) {
  return new (t || _NzCustomColumnDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzTableDataService));
};
_NzCustomColumnDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzCustomColumnDirective,
  selectors: [["td", "nzCellControl", ""], ["th", "nzCellControl", ""]],
  inputs: {
    nzCellControl: "nzCellControl"
  },
  standalone: true
});
var NzCustomColumnDirective = _NzCustomColumnDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCustomColumnDirective, [{
    type: Directive,
    args: [{
      selector: "td[nzCellControl],th[nzCellControl]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NzTableDataService
  }], {
    nzCellControl: [{
      type: Input
    }]
  });
})();
var _NzTdAddOnComponent = class _NzTdAddOnComponent {
  constructor() {
    this.nzChecked = false;
    this.nzDisabled = false;
    this.nzIndeterminate = false;
    this.nzLabel = null;
    this.nzIndentSize = 0;
    this.nzShowExpand = false;
    this.nzShowCheckbox = false;
    this.nzExpand = false;
    this.nzExpandIcon = null;
    this.nzCheckedChange = new EventEmitter();
    this.nzExpandChange = new EventEmitter();
    this.isNzShowExpandChanged = false;
    this.isNzShowCheckboxChanged = false;
  }
  onCheckedChange(checked) {
    this.nzChecked = checked;
    this.nzCheckedChange.emit(checked);
  }
  onExpandChange(expand) {
    this.nzExpand = expand;
    this.nzExpandChange.emit(expand);
  }
  ngOnChanges(changes) {
    const isFirstChange = (value) => value && value.firstChange && value.currentValue !== void 0;
    const {
      nzExpand,
      nzChecked,
      nzShowExpand,
      nzShowCheckbox
    } = changes;
    if (nzShowExpand) {
      this.isNzShowExpandChanged = true;
    }
    if (nzShowCheckbox) {
      this.isNzShowCheckboxChanged = true;
    }
    if (isFirstChange(nzExpand) && !this.isNzShowExpandChanged) {
      this.nzShowExpand = true;
    }
    if (isFirstChange(nzChecked) && !this.isNzShowCheckboxChanged) {
      this.nzShowCheckbox = true;
    }
  }
};
_NzTdAddOnComponent.\u0275fac = function NzTdAddOnComponent_Factory(t) {
  return new (t || _NzTdAddOnComponent)();
};
_NzTdAddOnComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTdAddOnComponent,
  selectors: [["td", "nzChecked", ""], ["td", "nzDisabled", ""], ["td", "nzIndeterminate", ""], ["td", "nzIndentSize", ""], ["td", "nzExpand", ""], ["td", "nzShowExpand", ""], ["td", "nzShowCheckbox", ""]],
  hostVars: 4,
  hostBindings: function NzTdAddOnComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-cell-with-append", ctx.nzShowExpand || ctx.nzIndentSize > 0)("ant-table-selection-column", ctx.nzShowCheckbox);
    }
  },
  inputs: {
    nzChecked: "nzChecked",
    nzDisabled: "nzDisabled",
    nzIndeterminate: "nzIndeterminate",
    nzLabel: "nzLabel",
    nzIndentSize: "nzIndentSize",
    nzShowExpand: "nzShowExpand",
    nzShowCheckbox: "nzShowCheckbox",
    nzExpand: "nzExpand",
    nzExpandIcon: "nzExpandIcon"
  },
  outputs: {
    nzCheckedChange: "nzCheckedChange",
    nzExpandChange: "nzExpandChange"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c18,
  ngContentSelectors: _c014,
  decls: 3,
  vars: 2,
  consts: [[4, "ngIf"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel", "nzIndeterminate", "ngModelChange", 4, "ngIf"], [3, "indentSize"], ["rowExpand", ""], [4, "ngIf", "ngIfElse"], ["nz-row-expand-button", "", 3, "expand", "spaceMode", "expandChange"], [3, "ngTemplateOutlet"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel", "nzIndeterminate", "ngModelChange"]],
  template: function NzTdAddOnComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzTdAddOnComponent_ng_container_0_Template, 5, 3, "ng-container", 0)(1, NzTdAddOnComponent_label_1_Template, 1, 4, "label", 1);
      \u0275\u0275projection(2);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.nzShowExpand || ctx.nzIndentSize > 0);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzShowCheckbox);
    }
  },
  dependencies: [NzRowIndentDirective, NzRowExpandButtonDirective, NgIf, NgTemplateOutlet, NzCheckboxModule, NzCheckboxComponent, FormsModule, NgControlStatus, NgModel],
  encapsulation: 2,
  changeDetection: 0
});
var NzTdAddOnComponent = _NzTdAddOnComponent;
__decorate([InputBoolean()], NzTdAddOnComponent.prototype, "nzShowExpand", void 0);
__decorate([InputBoolean()], NzTdAddOnComponent.prototype, "nzShowCheckbox", void 0);
__decorate([InputBoolean()], NzTdAddOnComponent.prototype, "nzExpand", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTdAddOnComponent, [{
    type: Component,
    args: [{
      selector: "td[nzChecked], td[nzDisabled], td[nzIndeterminate], td[nzIndentSize], td[nzExpand], td[nzShowExpand], td[nzShowCheckbox]",
      changeDetection: ChangeDetectionStrategy.OnPush,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <ng-container *ngIf="nzShowExpand || nzIndentSize > 0">
      <nz-row-indent [indentSize]="nzIndentSize"></nz-row-indent>
      <ng-template #rowExpand>
        <button
          nz-row-expand-button
          [expand]="nzExpand"
          (expandChange)="onExpandChange($event)"
          [spaceMode]="!nzShowExpand"
        ></button>
      </ng-template>
      <ng-container *ngIf="nzExpandIcon; else rowExpand">
        <ng-template [ngTemplateOutlet]="nzExpandIcon"></ng-template>
      </ng-container>
    </ng-container>
    <label
      nz-checkbox
      *ngIf="nzShowCheckbox"
      [nzDisabled]="nzDisabled"
      [ngModel]="nzChecked"
      [nzIndeterminate]="nzIndeterminate"
      [attr.aria-label]="nzLabel"
      (ngModelChange)="onCheckedChange($event)"
    ></label>
    <ng-content></ng-content>
  `,
      host: {
        "[class.ant-table-cell-with-append]": `nzShowExpand || nzIndentSize > 0`,
        "[class.ant-table-selection-column]": `nzShowCheckbox`
      },
      imports: [NzRowIndentDirective, NzRowExpandButtonDirective, NgIf, NgTemplateOutlet, NzCheckboxModule, FormsModule],
      standalone: true
    }]
  }], null, {
    nzChecked: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzIndeterminate: [{
      type: Input
    }],
    nzLabel: [{
      type: Input
    }],
    nzIndentSize: [{
      type: Input
    }],
    nzShowExpand: [{
      type: Input
    }],
    nzShowCheckbox: [{
      type: Input
    }],
    nzExpand: [{
      type: Input
    }],
    nzExpandIcon: [{
      type: Input
    }],
    nzCheckedChange: [{
      type: Output
    }],
    nzExpandChange: [{
      type: Output
    }]
  });
})();
var _NzThAddOnComponent = class _NzThAddOnComponent {
  getNextSortDirection(sortDirections, current) {
    const index = sortDirections.indexOf(current);
    if (index === sortDirections.length - 1) {
      return sortDirections[0];
    } else {
      return sortDirections[index + 1];
    }
  }
  setSortOrder(order) {
    this.sortOrderChange$.next(order);
  }
  clearSortOrder() {
    if (this.sortOrder !== null) {
      this.setSortOrder(null);
    }
  }
  onFilterValueChange(value) {
    this.nzFilterChange.emit(value);
    this.nzFilterValue = value;
    this.updateCalcOperator();
  }
  updateCalcOperator() {
    this.calcOperatorChange$.next();
  }
  constructor(host, cdr, ngZone, destroy$) {
    this.host = host;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.destroy$ = destroy$;
    this.manualClickOrder$ = new Subject();
    this.calcOperatorChange$ = new Subject();
    this.nzFilterValue = null;
    this.sortOrder = null;
    this.sortDirections = ["ascend", "descend", null];
    this.sortOrderChange$ = new Subject();
    this.isNzShowSortChanged = false;
    this.isNzShowFilterChanged = false;
    this.nzFilterMultiple = true;
    this.nzSortOrder = null;
    this.nzSortPriority = false;
    this.nzSortDirections = ["ascend", "descend", null];
    this.nzFilters = [];
    this.nzSortFn = null;
    this.nzFilterFn = null;
    this.nzShowSort = false;
    this.nzShowFilter = false;
    this.nzCustomFilter = false;
    this.nzCheckedChange = new EventEmitter();
    this.nzSortOrderChange = new EventEmitter();
    this.nzFilterChange = new EventEmitter();
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => fromEvent(this.host.nativeElement, "click").pipe(filter(() => this.nzShowSort), takeUntil(this.destroy$)).subscribe(() => {
      const nextOrder = this.getNextSortDirection(this.sortDirections, this.sortOrder);
      this.ngZone.run(() => {
        this.setSortOrder(nextOrder);
        this.manualClickOrder$.next(this);
      });
    }));
    this.sortOrderChange$.pipe(takeUntil(this.destroy$)).subscribe((order) => {
      if (this.sortOrder !== order) {
        this.sortOrder = order;
        this.nzSortOrderChange.emit(order);
      }
      this.updateCalcOperator();
      this.cdr.markForCheck();
    });
  }
  ngOnChanges(changes) {
    const {
      nzSortDirections,
      nzFilters,
      nzSortOrder,
      nzSortFn,
      nzFilterFn,
      nzSortPriority,
      nzFilterMultiple,
      nzShowSort,
      nzShowFilter
    } = changes;
    if (nzSortDirections) {
      if (this.nzSortDirections && this.nzSortDirections.length) {
        this.sortDirections = this.nzSortDirections;
      }
    }
    if (nzSortOrder) {
      this.sortOrder = this.nzSortOrder;
      this.setSortOrder(this.nzSortOrder);
    }
    if (nzShowSort) {
      this.isNzShowSortChanged = true;
    }
    if (nzShowFilter) {
      this.isNzShowFilterChanged = true;
    }
    const isFirstChange = (value) => value && value.firstChange && value.currentValue !== void 0;
    if ((isFirstChange(nzSortOrder) || isFirstChange(nzSortFn)) && !this.isNzShowSortChanged) {
      this.nzShowSort = true;
    }
    if (isFirstChange(nzFilters) && !this.isNzShowFilterChanged) {
      this.nzShowFilter = true;
    }
    if ((nzFilters || nzFilterMultiple) && this.nzShowFilter) {
      const listOfValue = this.nzFilters.filter((item) => item.byDefault).map((item) => item.value);
      this.nzFilterValue = this.nzFilterMultiple ? listOfValue : listOfValue[0] || null;
    }
    if (nzSortFn || nzFilterFn || nzSortPriority || nzFilters) {
      this.updateCalcOperator();
    }
  }
};
_NzThAddOnComponent.\u0275fac = function NzThAddOnComponent_Factory(t) {
  return new (t || _NzThAddOnComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NzDestroyService));
};
_NzThAddOnComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzThAddOnComponent,
  selectors: [["th", "nzColumnKey", ""], ["th", "nzSortFn", ""], ["th", "nzSortOrder", ""], ["th", "nzFilters", ""], ["th", "nzShowSort", ""], ["th", "nzShowFilter", ""], ["th", "nzCustomFilter", ""]],
  hostVars: 4,
  hostBindings: function NzThAddOnComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-column-has-sorters", ctx.nzShowSort)("ant-table-column-sort", ctx.sortOrder === "descend" || ctx.sortOrder === "ascend");
    }
  },
  inputs: {
    nzColumnKey: "nzColumnKey",
    nzFilterMultiple: "nzFilterMultiple",
    nzSortOrder: "nzSortOrder",
    nzSortPriority: "nzSortPriority",
    nzSortDirections: "nzSortDirections",
    nzFilters: "nzFilters",
    nzSortFn: "nzSortFn",
    nzFilterFn: "nzFilterFn",
    nzShowSort: "nzShowSort",
    nzShowFilter: "nzShowFilter",
    nzCustomFilter: "nzCustomFilter"
  },
  outputs: {
    nzCheckedChange: "nzCheckedChange",
    nzSortOrderChange: "nzSortOrderChange",
    nzFilterChange: "nzFilterChange"
  },
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c27,
  ngContentSelectors: _c43,
  decls: 9,
  vars: 2,
  consts: [[3, "contentTemplate", "extraTemplate", "customFilter", "filterMultiple", "listOfFilter", "filterChange", 4, "ngIf", "ngIfElse"], ["notFilterTemplate", ""], ["extraTemplate", ""], ["sortTemplate", ""], ["contentTemplate", ""], [3, "contentTemplate", "extraTemplate", "customFilter", "filterMultiple", "listOfFilter", "filterChange"], [3, "ngTemplateOutlet"], [3, "sortOrder", "sortDirections", "contentTemplate"]],
  template: function NzThAddOnComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c34);
      \u0275\u0275template(0, NzThAddOnComponent_nz_table_filter_0_Template, 1, 5, "nz-table-filter", 0)(1, NzThAddOnComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, NzThAddOnComponent_ng_template_3_Template, 2, 0, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(5, NzThAddOnComponent_ng_template_5_Template, 1, 3, "ng-template", null, 3, \u0275\u0275templateRefExtractor)(7, NzThAddOnComponent_ng_template_7_Template, 1, 0, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.nzShowFilter || ctx.nzCustomFilter)("ngIfElse", _r2);
    }
  },
  dependencies: [NzTableFilterComponent, NgIf, NgTemplateOutlet, NzTableSortersComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzThAddOnComponent = _NzThAddOnComponent;
__decorate([InputBoolean()], NzThAddOnComponent.prototype, "nzShowSort", void 0);
__decorate([InputBoolean()], NzThAddOnComponent.prototype, "nzShowFilter", void 0);
__decorate([InputBoolean()], NzThAddOnComponent.prototype, "nzCustomFilter", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzThAddOnComponent, [{
    type: Component,
    args: [{
      selector: "th[nzColumnKey], th[nzSortFn], th[nzSortOrder], th[nzFilters], th[nzShowSort], th[nzShowFilter], th[nzCustomFilter]",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <nz-table-filter
      *ngIf="nzShowFilter || nzCustomFilter; else notFilterTemplate"
      [contentTemplate]="notFilterTemplate"
      [extraTemplate]="extraTemplate"
      [customFilter]="nzCustomFilter"
      [filterMultiple]="nzFilterMultiple"
      [listOfFilter]="nzFilters"
      (filterChange)="onFilterValueChange($event)"
    ></nz-table-filter>
    <ng-template #notFilterTemplate>
      <ng-template [ngTemplateOutlet]="nzShowSort ? sortTemplate : contentTemplate"></ng-template>
    </ng-template>
    <ng-template #extraTemplate>
      <ng-content select="[nz-th-extra]"></ng-content>
      <ng-content select="nz-filter-trigger"></ng-content>
    </ng-template>
    <ng-template #sortTemplate>
      <nz-table-sorters
        [sortOrder]="sortOrder"
        [sortDirections]="sortDirections"
        [contentTemplate]="contentTemplate"
      ></nz-table-sorters>
    </ng-template>
    <ng-template #contentTemplate>
      <ng-content></ng-content>
    </ng-template>
  `,
      host: {
        "[class.ant-table-column-has-sorters]": "nzShowSort",
        "[class.ant-table-column-sort]": `sortOrder === 'descend' || sortOrder === 'ascend'`
      },
      providers: [NzDestroyService],
      imports: [NzTableFilterComponent, NgIf, NgTemplateOutlet, NzTableSortersComponent],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NzDestroyService
  }], {
    nzColumnKey: [{
      type: Input
    }],
    nzFilterMultiple: [{
      type: Input
    }],
    nzSortOrder: [{
      type: Input
    }],
    nzSortPriority: [{
      type: Input
    }],
    nzSortDirections: [{
      type: Input
    }],
    nzFilters: [{
      type: Input
    }],
    nzSortFn: [{
      type: Input
    }],
    nzFilterFn: [{
      type: Input
    }],
    nzShowSort: [{
      type: Input
    }],
    nzShowFilter: [{
      type: Input
    }],
    nzCustomFilter: [{
      type: Input
    }],
    nzCheckedChange: [{
      type: Output
    }],
    nzSortOrderChange: [{
      type: Output
    }],
    nzFilterChange: [{
      type: Output
    }]
  });
})();
var _NzThMeasureDirective = class _NzThMeasureDirective {
  constructor(renderer, elementRef) {
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.changes$ = new Subject();
    this.nzWidth = null;
    this.colspan = null;
    this.colSpan = null;
    this.rowspan = null;
    this.rowSpan = null;
  }
  ngOnChanges(changes) {
    const {
      nzWidth,
      colspan,
      rowspan,
      colSpan,
      rowSpan
    } = changes;
    if (colspan || colSpan) {
      const col = this.colspan || this.colSpan;
      if (!isNil(col)) {
        this.renderer.setAttribute(this.elementRef.nativeElement, "colspan", `${col}`);
      } else {
        this.renderer.removeAttribute(this.elementRef.nativeElement, "colspan");
      }
    }
    if (rowspan || rowSpan) {
      const row = this.rowspan || this.rowSpan;
      if (!isNil(row)) {
        this.renderer.setAttribute(this.elementRef.nativeElement, "rowspan", `${row}`);
      } else {
        this.renderer.removeAttribute(this.elementRef.nativeElement, "rowspan");
      }
    }
    if (nzWidth || colspan) {
      this.changes$.next();
    }
  }
};
_NzThMeasureDirective.\u0275fac = function NzThMeasureDirective_Factory(t) {
  return new (t || _NzThMeasureDirective)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_NzThMeasureDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzThMeasureDirective,
  selectors: [["th"]],
  inputs: {
    nzWidth: "nzWidth",
    colspan: "colspan",
    colSpan: "colSpan",
    rowspan: "rowspan",
    rowSpan: "rowSpan"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzThMeasureDirective = _NzThMeasureDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzThMeasureDirective, [{
    type: Directive,
    args: [{
      selector: "th",
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    nzWidth: [{
      type: Input
    }],
    colspan: [{
      type: Input
    }],
    colSpan: [{
      type: Input
    }],
    rowspan: [{
      type: Input
    }],
    rowSpan: [{
      type: Input
    }]
  });
})();
var _NzThSelectionComponent = class _NzThSelectionComponent {
  constructor() {
    this.nzSelections = [];
    this.nzChecked = false;
    this.nzDisabled = false;
    this.nzIndeterminate = false;
    this.nzLabel = null;
    this.nzShowCheckbox = false;
    this.nzShowRowSelection = false;
    this.nzCheckedChange = new EventEmitter();
    this.isNzShowExpandChanged = false;
    this.isNzShowCheckboxChanged = false;
  }
  onCheckedChange(checked) {
    this.nzChecked = checked;
    this.nzCheckedChange.emit(checked);
  }
  ngOnChanges(changes) {
    const isFirstChange = (value) => value && value.firstChange && value.currentValue !== void 0;
    const {
      nzChecked,
      nzSelections,
      nzShowExpand,
      nzShowCheckbox
    } = changes;
    if (nzShowExpand) {
      this.isNzShowExpandChanged = true;
    }
    if (nzShowCheckbox) {
      this.isNzShowCheckboxChanged = true;
    }
    if (isFirstChange(nzSelections) && !this.isNzShowExpandChanged) {
      this.nzShowRowSelection = true;
    }
    if (isFirstChange(nzChecked) && !this.isNzShowCheckboxChanged) {
      this.nzShowCheckbox = true;
    }
  }
};
_NzThSelectionComponent.\u0275fac = function NzThSelectionComponent_Factory(t) {
  return new (t || _NzThSelectionComponent)();
};
_NzThSelectionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzThSelectionComponent,
  selectors: [["th", "nzSelections", ""], ["th", "nzChecked", ""], ["th", "nzShowCheckbox", ""], ["th", "nzShowRowSelection", ""]],
  hostAttrs: [1, "ant-table-selection-column"],
  inputs: {
    nzSelections: "nzSelections",
    nzChecked: "nzChecked",
    nzDisabled: "nzDisabled",
    nzIndeterminate: "nzIndeterminate",
    nzLabel: "nzLabel",
    nzShowCheckbox: "nzShowCheckbox",
    nzShowRowSelection: "nzShowRowSelection"
  },
  outputs: {
    nzCheckedChange: "nzCheckedChange"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c52,
  ngContentSelectors: _c014,
  decls: 2,
  vars: 7,
  consts: [[3, "checked", "disabled", "indeterminate", "label", "listOfSelections", "showCheckbox", "showRowSelection", "checkedChange"]],
  template: function NzThSelectionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "nz-table-selection", 0);
      \u0275\u0275listener("checkedChange", function NzThSelectionComponent_Template_nz_table_selection_checkedChange_0_listener($event) {
        return ctx.onCheckedChange($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275projection(1);
    }
    if (rf & 2) {
      \u0275\u0275property("checked", ctx.nzChecked)("disabled", ctx.nzDisabled)("indeterminate", ctx.nzIndeterminate)("label", ctx.nzLabel)("listOfSelections", ctx.nzSelections)("showCheckbox", ctx.nzShowCheckbox)("showRowSelection", ctx.nzShowRowSelection);
    }
  },
  dependencies: [NzTableSelectionComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzThSelectionComponent = _NzThSelectionComponent;
__decorate([InputBoolean()], NzThSelectionComponent.prototype, "nzShowCheckbox", void 0);
__decorate([InputBoolean()], NzThSelectionComponent.prototype, "nzShowRowSelection", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzThSelectionComponent, [{
    type: Component,
    args: [{
      selector: "th[nzSelections],th[nzChecked],th[nzShowCheckbox],th[nzShowRowSelection]",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <nz-table-selection
      [checked]="nzChecked"
      [disabled]="nzDisabled"
      [indeterminate]="nzIndeterminate"
      [label]="nzLabel"
      [listOfSelections]="nzSelections"
      [showCheckbox]="nzShowCheckbox"
      [showRowSelection]="nzShowRowSelection"
      (checkedChange)="onCheckedChange($event)"
    ></nz-table-selection>
    <ng-content></ng-content>
  `,
      host: {
        class: "ant-table-selection-column"
      },
      imports: [NzTableSelectionComponent],
      standalone: true
    }]
  }], () => [], {
    nzSelections: [{
      type: Input
    }],
    nzChecked: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzIndeterminate: [{
      type: Input
    }],
    nzLabel: [{
      type: Input
    }],
    nzShowCheckbox: [{
      type: Input
    }],
    nzShowRowSelection: [{
      type: Input
    }],
    nzCheckedChange: [{
      type: Output
    }]
  });
})();
var _NzCellAlignDirective = class _NzCellAlignDirective {
  constructor() {
    this.nzAlign = null;
  }
};
_NzCellAlignDirective.\u0275fac = function NzCellAlignDirective_Factory(t) {
  return new (t || _NzCellAlignDirective)();
};
_NzCellAlignDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzCellAlignDirective,
  selectors: [["th", "nzAlign", ""], ["td", "nzAlign", ""]],
  hostVars: 2,
  hostBindings: function NzCellAlignDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("text-align", ctx.nzAlign);
    }
  },
  inputs: {
    nzAlign: "nzAlign"
  },
  standalone: true
});
var NzCellAlignDirective = _NzCellAlignDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCellAlignDirective, [{
    type: Directive,
    args: [{
      selector: "th[nzAlign],td[nzAlign]",
      host: {
        "[style.text-align]": "nzAlign"
      },
      standalone: true
    }]
  }], null, {
    nzAlign: [{
      type: Input
    }]
  });
})();
var _NzCellEllipsisDirective = class _NzCellEllipsisDirective {
  constructor() {
    this.nzEllipsis = true;
  }
};
_NzCellEllipsisDirective.\u0275fac = function NzCellEllipsisDirective_Factory(t) {
  return new (t || _NzCellEllipsisDirective)();
};
_NzCellEllipsisDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzCellEllipsisDirective,
  selectors: [["th", "nzEllipsis", ""], ["td", "nzEllipsis", ""]],
  hostVars: 2,
  hostBindings: function NzCellEllipsisDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-cell-ellipsis", ctx.nzEllipsis);
    }
  },
  inputs: {
    nzEllipsis: "nzEllipsis"
  },
  standalone: true
});
var NzCellEllipsisDirective = _NzCellEllipsisDirective;
__decorate([InputBoolean()], NzCellEllipsisDirective.prototype, "nzEllipsis", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCellEllipsisDirective, [{
    type: Directive,
    args: [{
      selector: "th[nzEllipsis],td[nzEllipsis]",
      host: {
        "[class.ant-table-cell-ellipsis]": "nzEllipsis"
      },
      standalone: true
    }]
  }], null, {
    nzEllipsis: [{
      type: Input
    }]
  });
})();
var _NzCellBreakWordDirective = class _NzCellBreakWordDirective {
  constructor() {
    this.nzBreakWord = true;
  }
};
_NzCellBreakWordDirective.\u0275fac = function NzCellBreakWordDirective_Factory(t) {
  return new (t || _NzCellBreakWordDirective)();
};
_NzCellBreakWordDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzCellBreakWordDirective,
  selectors: [["th", "nzBreakWord", ""], ["td", "nzBreakWord", ""]],
  hostVars: 2,
  hostBindings: function NzCellBreakWordDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("word-break", ctx.nzBreakWord ? "break-all" : "");
    }
  },
  inputs: {
    nzBreakWord: "nzBreakWord"
  },
  standalone: true
});
var NzCellBreakWordDirective = _NzCellBreakWordDirective;
__decorate([InputBoolean()], NzCellBreakWordDirective.prototype, "nzBreakWord", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCellBreakWordDirective, [{
    type: Directive,
    args: [{
      selector: "th[nzBreakWord],td[nzBreakWord]",
      host: {
        "[style.word-break]": `nzBreakWord ? 'break-all' : ''`
      },
      standalone: true
    }]
  }], null, {
    nzBreakWord: [{
      type: Input
    }]
  });
})();
var _NzTableContentComponent = class _NzTableContentComponent {
  constructor() {
    this.tableLayout = "auto";
    this.theadTemplate = null;
    this.contentTemplate = null;
    this.listOfColWidth = [];
    this.scrollX = null;
  }
};
_NzTableContentComponent.\u0275fac = function NzTableContentComponent_Factory(t) {
  return new (t || _NzTableContentComponent)();
};
_NzTableContentComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableContentComponent,
  selectors: [["table", "nz-table-content", ""]],
  hostVars: 8,
  hostBindings: function NzTableContentComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("table-layout", ctx.tableLayout)("width", ctx.scrollX)("min-width", ctx.scrollX ? "100%" : null);
      \u0275\u0275classProp("ant-table-fixed", ctx.scrollX);
    }
  },
  inputs: {
    tableLayout: "tableLayout",
    theadTemplate: "theadTemplate",
    contentTemplate: "contentTemplate",
    listOfColWidth: "listOfColWidth",
    scrollX: "scrollX"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c62,
  ngContentSelectors: _c014,
  decls: 4,
  vars: 3,
  consts: [[3, "width", "minWidth", 4, "ngFor", "ngForOf"], ["class", "ant-table-thead", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "ant-table-thead"]],
  template: function NzTableContentComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzTableContentComponent_col_0_Template, 1, 4, "col", 0)(1, NzTableContentComponent_thead_1_Template, 2, 1, "thead", 1)(2, NzTableContentComponent_ng_template_2_Template, 0, 0, "ng-template", 2);
      \u0275\u0275projection(3);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.listOfColWidth);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.theadTemplate);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngTemplateOutlet", ctx.contentTemplate);
    }
  },
  dependencies: [NgTemplateOutlet, NgIf, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableContentComponent = _NzTableContentComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableContentComponent, [{
    type: Component,
    args: [{
      selector: "table[nz-table-content]",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <col [style.width]="width" [style.minWidth]="width" *ngFor="let width of listOfColWidth" />
    <thead class="ant-table-thead" *ngIf="theadTemplate">
      <ng-template [ngTemplateOutlet]="theadTemplate"></ng-template>
    </thead>
    <ng-template [ngTemplateOutlet]="contentTemplate"></ng-template>
    <ng-content></ng-content>
  `,
      host: {
        "[style.table-layout]": "tableLayout",
        "[class.ant-table-fixed]": "scrollX",
        "[style.width]": "scrollX",
        "[style.min-width]": `scrollX ? '100%' : null`
      },
      imports: [NgTemplateOutlet, NgIf, NgForOf],
      standalone: true
    }]
  }], null, {
    tableLayout: [{
      type: Input
    }],
    theadTemplate: [{
      type: Input
    }],
    contentTemplate: [{
      type: Input
    }],
    listOfColWidth: [{
      type: Input
    }],
    scrollX: [{
      type: Input
    }]
  });
})();
var _NzTableFixedRowComponent = class _NzTableFixedRowComponent {
  constructor(nzTableStyleService, renderer) {
    this.nzTableStyleService = nzTableStyleService;
    this.renderer = renderer;
    this.hostWidth$ = new BehaviorSubject(null);
    this.enableAutoMeasure$ = new BehaviorSubject(false);
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    if (this.nzTableStyleService) {
      const {
        enableAutoMeasure$,
        hostWidth$
      } = this.nzTableStyleService;
      enableAutoMeasure$.pipe(takeUntil(this.destroy$)).subscribe(this.enableAutoMeasure$);
      hostWidth$.pipe(takeUntil(this.destroy$)).subscribe(this.hostWidth$);
    }
  }
  ngAfterViewInit() {
    this.nzTableStyleService.columnCount$.pipe(takeUntil(this.destroy$)).subscribe((count) => {
      this.renderer.setAttribute(this.tdElement.nativeElement, "colspan", `${count}`);
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzTableFixedRowComponent.\u0275fac = function NzTableFixedRowComponent_Factory(t) {
  return new (t || _NzTableFixedRowComponent)(\u0275\u0275directiveInject(NzTableStyleService), \u0275\u0275directiveInject(Renderer2));
};
_NzTableFixedRowComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableFixedRowComponent,
  selectors: [["tr", "nz-table-fixed-row", ""], ["tr", "nzExpand", ""]],
  viewQuery: function NzTableFixedRowComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c72, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tdElement = _t.first);
    }
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c82,
  ngContentSelectors: _c014,
  decls: 6,
  vars: 4,
  consts: [[1, "nz-disable-td", "ant-table-cell"], ["tdElement", ""], ["class", "ant-table-expanded-row-fixed", "style", "position: sticky; left: 0px; overflow: hidden;", 3, "width", 4, "ngIf", "ngIfElse"], ["contentTemplate", ""], [1, "ant-table-expanded-row-fixed", 2, "position", "sticky", "left", "0px", "overflow", "hidden"], [3, "ngTemplateOutlet"]],
  template: function NzTableFixedRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "td", 0, 1);
      \u0275\u0275template(2, NzTableFixedRowComponent_div_2_Template, 3, 5, "div", 2);
      \u0275\u0275pipe(3, "async");
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, NzTableFixedRowComponent_ng_template_4_Template, 1, 0, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r3 = \u0275\u0275reference(5);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(3, 2, ctx.enableAutoMeasure$))("ngIfElse", _r3);
    }
  },
  dependencies: [NgIf, AsyncPipe, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableFixedRowComponent = _NzTableFixedRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableFixedRowComponent, [{
    type: Component,
    args: [{
      selector: "tr[nz-table-fixed-row], tr[nzExpand]",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <td class="nz-disable-td ant-table-cell" #tdElement>
      <div
        class="ant-table-expanded-row-fixed"
        *ngIf="enableAutoMeasure$ | async; else contentTemplate"
        style="position: sticky; left: 0px; overflow: hidden;"
        [style.width.px]="hostWidth$ | async"
      >
        <ng-template [ngTemplateOutlet]="contentTemplate"></ng-template>
      </div>
    </td>
    <ng-template #contentTemplate>
      <ng-content></ng-content>
    </ng-template>
  `,
      imports: [NgIf, AsyncPipe, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: NzTableStyleService
  }, {
    type: Renderer2
  }], {
    tdElement: [{
      type: ViewChild,
      args: ["tdElement", {
        static: true
      }]
    }]
  });
})();
var _NzTableInnerDefaultComponent = class _NzTableInnerDefaultComponent {
  constructor() {
    this.tableLayout = "auto";
    this.listOfColWidth = [];
    this.theadTemplate = null;
    this.contentTemplate = null;
  }
};
_NzTableInnerDefaultComponent.\u0275fac = function NzTableInnerDefaultComponent_Factory(t) {
  return new (t || _NzTableInnerDefaultComponent)();
};
_NzTableInnerDefaultComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableInnerDefaultComponent,
  selectors: [["nz-table-inner-default"]],
  hostAttrs: [1, "ant-table-container"],
  inputs: {
    tableLayout: "tableLayout",
    listOfColWidth: "listOfColWidth",
    theadTemplate: "theadTemplate",
    contentTemplate: "contentTemplate"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 4,
  consts: [[1, "ant-table-content"], ["nz-table-content", "", 3, "contentTemplate", "tableLayout", "listOfColWidth", "theadTemplate"]],
  template: function NzTableInnerDefaultComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275element(1, "table", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("contentTemplate", ctx.contentTemplate)("tableLayout", ctx.tableLayout)("listOfColWidth", ctx.listOfColWidth)("theadTemplate", ctx.theadTemplate);
    }
  },
  dependencies: [NzTableContentComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableInnerDefaultComponent = _NzTableInnerDefaultComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableInnerDefaultComponent, [{
    type: Component,
    args: [{
      selector: "nz-table-inner-default",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <div class="ant-table-content">
      <table
        nz-table-content
        [contentTemplate]="contentTemplate"
        [tableLayout]="tableLayout"
        [listOfColWidth]="listOfColWidth"
        [theadTemplate]="theadTemplate"
      ></table>
    </div>
  `,
      host: {
        class: "ant-table-container"
      },
      imports: [NzTableContentComponent],
      standalone: true
    }]
  }], () => [], {
    tableLayout: [{
      type: Input
    }],
    listOfColWidth: [{
      type: Input
    }],
    theadTemplate: [{
      type: Input
    }],
    contentTemplate: [{
      type: Input
    }]
  });
})();
var _NzTableInnerScrollComponent = class _NzTableInnerScrollComponent {
  setScrollPositionClassName(clear = false) {
    const {
      scrollWidth,
      scrollLeft,
      clientWidth
    } = this.tableBodyElement.nativeElement;
    const leftClassName = "ant-table-ping-left";
    const rightClassName = "ant-table-ping-right";
    if (scrollWidth === clientWidth && scrollWidth !== 0 || clear) {
      this.renderer.removeClass(this.tableMainElement, leftClassName);
      this.renderer.removeClass(this.tableMainElement, rightClassName);
    } else if (scrollLeft === 0) {
      this.renderer.removeClass(this.tableMainElement, leftClassName);
      this.renderer.addClass(this.tableMainElement, rightClassName);
    } else if (scrollWidth === scrollLeft + clientWidth) {
      this.renderer.removeClass(this.tableMainElement, rightClassName);
      this.renderer.addClass(this.tableMainElement, leftClassName);
    } else {
      this.renderer.addClass(this.tableMainElement, leftClassName);
      this.renderer.addClass(this.tableMainElement, rightClassName);
    }
  }
  constructor(renderer, ngZone, platform, resizeService) {
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.platform = platform;
    this.resizeService = resizeService;
    this.data = [];
    this.scrollX = null;
    this.scrollY = null;
    this.contentTemplate = null;
    this.widthConfig = [];
    this.listOfColWidth = [];
    this.theadTemplate = null;
    this.virtualTemplate = null;
    this.virtualItemSize = 0;
    this.virtualMaxBufferPx = 200;
    this.virtualMinBufferPx = 100;
    this.virtualForTrackBy = (index) => index;
    this.headerStyleMap = {};
    this.bodyStyleMap = {};
    this.verticalScrollBarWidth = 0;
    this.noDateVirtualHeight = "182px";
    this.data$ = new Subject();
    this.scroll$ = new Subject();
    this.destroy$ = new Subject();
  }
  ngOnChanges(changes) {
    const {
      scrollX,
      scrollY,
      data
    } = changes;
    if (scrollX || scrollY) {
      const hasVerticalScrollBar = this.verticalScrollBarWidth !== 0;
      this.headerStyleMap = {
        overflowX: "hidden",
        overflowY: this.scrollY && hasVerticalScrollBar ? "scroll" : "hidden"
      };
      this.bodyStyleMap = {
        overflowY: this.scrollY ? "scroll" : "hidden",
        overflowX: this.scrollX ? "auto" : null,
        maxHeight: this.scrollY
      };
      this.ngZone.runOutsideAngular(() => this.scroll$.next());
    }
    if (data) {
      this.ngZone.runOutsideAngular(() => this.data$.next());
    }
  }
  ngAfterViewInit() {
    if (this.platform.isBrowser) {
      this.ngZone.runOutsideAngular(() => {
        const scrollEvent$ = this.scroll$.pipe(startWith(null), delay(0), switchMap(() => fromEvent(this.tableBodyElement.nativeElement, "scroll").pipe(startWith(true))), takeUntil(this.destroy$));
        const resize$ = this.resizeService.subscribe().pipe(takeUntil(this.destroy$));
        const data$ = this.data$.pipe(takeUntil(this.destroy$));
        const setClassName$ = merge(scrollEvent$, resize$, data$, this.scroll$).pipe(startWith(true), delay(0), takeUntil(this.destroy$));
        setClassName$.subscribe(() => this.setScrollPositionClassName());
        scrollEvent$.pipe(filter(() => !!this.scrollY)).subscribe(() => this.tableHeaderElement.nativeElement.scrollLeft = this.tableBodyElement.nativeElement.scrollLeft);
      });
    }
  }
  ngOnDestroy() {
    this.setScrollPositionClassName(true);
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzTableInnerScrollComponent.\u0275fac = function NzTableInnerScrollComponent_Factory(t) {
  return new (t || _NzTableInnerScrollComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(NzResizeService));
};
_NzTableInnerScrollComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableInnerScrollComponent,
  selectors: [["nz-table-inner-scroll"]],
  viewQuery: function NzTableInnerScrollComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c92, 5, ElementRef);
      \u0275\u0275viewQuery(_c102, 5, ElementRef);
      \u0275\u0275viewQuery(CdkVirtualScrollViewport, 5, CdkVirtualScrollViewport);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tableHeaderElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tableBodyElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.cdkVirtualScrollViewport = _t.first);
    }
  },
  hostAttrs: [1, "ant-table-container"],
  inputs: {
    data: "data",
    scrollX: "scrollX",
    scrollY: "scrollY",
    contentTemplate: "contentTemplate",
    widthConfig: "widthConfig",
    listOfColWidth: "listOfColWidth",
    theadTemplate: "theadTemplate",
    virtualTemplate: "virtualTemplate",
    virtualItemSize: "virtualItemSize",
    virtualMaxBufferPx: "virtualMaxBufferPx",
    virtualMinBufferPx: "virtualMinBufferPx",
    tableMainElement: "tableMainElement",
    virtualForTrackBy: "virtualForTrackBy",
    verticalScrollBarWidth: "verticalScrollBarWidth"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 2,
  consts: [[4, "ngIf"], ["class", "ant-table-content", 3, "ngStyle", 4, "ngIf"], [1, "ant-table-header", "nz-table-hide-scrollbar", 3, "ngStyle"], ["tableHeaderElement", ""], ["nz-table-content", "", "tableLayout", "fixed", 3, "scrollX", "listOfColWidth", "theadTemplate"], ["class", "ant-table-body", 3, "ngStyle", 4, "ngIf"], [3, "itemSize", "maxBufferPx", "minBufferPx", "height", 4, "ngIf"], [1, "ant-table-body", 3, "ngStyle"], ["tableBodyElement", ""], ["nz-table-content", "", "tableLayout", "fixed", 3, "scrollX", "listOfColWidth", "contentTemplate"], [3, "itemSize", "maxBufferPx", "minBufferPx"], ["nz-table-content", "", "tableLayout", "fixed", 3, "scrollX", "listOfColWidth"], [4, "cdkVirtualFor", "cdkVirtualForOf", "cdkVirtualForTrackBy"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "ant-table-content", 3, "ngStyle"], ["nz-table-content", "", "tableLayout", "fixed", 3, "scrollX", "listOfColWidth", "theadTemplate", "contentTemplate"]],
  template: function NzTableInnerScrollComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTableInnerScrollComponent_ng_container_0_Template, 6, 6, "ng-container", 0)(1, NzTableInnerScrollComponent_div_1_Template, 3, 5, "div", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.scrollY);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.scrollY);
    }
  },
  dependencies: [NzTableContentComponent, NgIf, NgStyle, ScrollingModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableInnerScrollComponent = _NzTableInnerScrollComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableInnerScrollComponent, [{
    type: Component,
    args: [{
      selector: "nz-table-inner-scroll",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <ng-container *ngIf="scrollY">
      <div #tableHeaderElement [ngStyle]="headerStyleMap" class="ant-table-header nz-table-hide-scrollbar">
        <table
          nz-table-content
          tableLayout="fixed"
          [scrollX]="scrollX"
          [listOfColWidth]="listOfColWidth"
          [theadTemplate]="theadTemplate"
        ></table>
      </div>
      <div #tableBodyElement *ngIf="!virtualTemplate" class="ant-table-body" [ngStyle]="bodyStyleMap">
        <table
          nz-table-content
          tableLayout="fixed"
          [scrollX]="scrollX"
          [listOfColWidth]="listOfColWidth"
          [contentTemplate]="contentTemplate"
        ></table>
      </div>
      <cdk-virtual-scroll-viewport
        #tableBodyElement
        *ngIf="virtualTemplate"
        [itemSize]="virtualItemSize"
        [maxBufferPx]="virtualMaxBufferPx"
        [minBufferPx]="virtualMinBufferPx"
        [style.height]="data.length ? scrollY : noDateVirtualHeight"
      >
        <table nz-table-content tableLayout="fixed" [scrollX]="scrollX" [listOfColWidth]="listOfColWidth">
          <tbody>
            <ng-container *cdkVirtualFor="let item of data; let i = index; trackBy: virtualForTrackBy">
              <ng-template
                [ngTemplateOutlet]="virtualTemplate"
                [ngTemplateOutletContext]="{ $implicit: item, index: i }"
              ></ng-template>
            </ng-container>
          </tbody>
        </table>
      </cdk-virtual-scroll-viewport>
    </ng-container>
    <div class="ant-table-content" #tableBodyElement *ngIf="!scrollY" [ngStyle]="bodyStyleMap">
      <table
        nz-table-content
        tableLayout="fixed"
        [scrollX]="scrollX"
        [listOfColWidth]="listOfColWidth"
        [theadTemplate]="theadTemplate"
        [contentTemplate]="contentTemplate"
      ></table>
    </div>
  `,
      host: {
        class: "ant-table-container"
      },
      imports: [NzTableContentComponent, NgIf, NgStyle, ScrollingModule, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: Platform
  }, {
    type: NzResizeService
  }], {
    data: [{
      type: Input
    }],
    scrollX: [{
      type: Input
    }],
    scrollY: [{
      type: Input
    }],
    contentTemplate: [{
      type: Input
    }],
    widthConfig: [{
      type: Input
    }],
    listOfColWidth: [{
      type: Input
    }],
    theadTemplate: [{
      type: Input
    }],
    virtualTemplate: [{
      type: Input
    }],
    virtualItemSize: [{
      type: Input
    }],
    virtualMaxBufferPx: [{
      type: Input
    }],
    virtualMinBufferPx: [{
      type: Input
    }],
    tableMainElement: [{
      type: Input
    }],
    virtualForTrackBy: [{
      type: Input
    }],
    tableHeaderElement: [{
      type: ViewChild,
      args: ["tableHeaderElement", {
        read: ElementRef
      }]
    }],
    tableBodyElement: [{
      type: ViewChild,
      args: ["tableBodyElement", {
        read: ElementRef
      }]
    }],
    cdkVirtualScrollViewport: [{
      type: ViewChild,
      args: [CdkVirtualScrollViewport, {
        read: CdkVirtualScrollViewport
      }]
    }],
    verticalScrollBarWidth: [{
      type: Input
    }]
  });
})();
var _NzTableVirtualScrollDirective = class _NzTableVirtualScrollDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ngTemplateContextGuard(_dir, _ctx) {
    return true;
  }
};
_NzTableVirtualScrollDirective.\u0275fac = function NzTableVirtualScrollDirective_Factory(t) {
  return new (t || _NzTableVirtualScrollDirective)(\u0275\u0275directiveInject(TemplateRef));
};
_NzTableVirtualScrollDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTableVirtualScrollDirective,
  selectors: [["", "nz-virtual-scroll", ""]],
  exportAs: ["nzVirtualScroll"],
  standalone: true
});
var NzTableVirtualScrollDirective = _NzTableVirtualScrollDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableVirtualScrollDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-virtual-scroll]",
      exportAs: "nzVirtualScroll",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NzTableTitleFooterComponent = class _NzTableTitleFooterComponent {
  constructor() {
    this.title = null;
    this.footer = null;
  }
};
_NzTableTitleFooterComponent.\u0275fac = function NzTableTitleFooterComponent_Factory(t) {
  return new (t || _NzTableTitleFooterComponent)();
};
_NzTableTitleFooterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableTitleFooterComponent,
  selectors: [["nz-table-title-footer"]],
  hostVars: 4,
  hostBindings: function NzTableTitleFooterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-title", ctx.title !== null)("ant-table-footer", ctx.footer !== null);
    }
  },
  inputs: {
    title: "title",
    footer: "footer"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 2,
  consts: [[4, "nzStringTemplateOutlet"]],
  template: function NzTableTitleFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTableTitleFooterComponent_ng_container_0_Template, 2, 1, "ng-container", 0)(1, NzTableTitleFooterComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("nzStringTemplateOutlet", ctx.title);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.footer);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableTitleFooterComponent = _NzTableTitleFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableTitleFooterComponent, [{
    type: Component,
    args: [{
      selector: "nz-table-title-footer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <ng-container *nzStringTemplateOutlet="title">{{ title }}</ng-container>
    <ng-container *nzStringTemplateOutlet="footer">{{ footer }}</ng-container>
  `,
      host: {
        "[class.ant-table-title]": `title !== null`,
        "[class.ant-table-footer]": `footer !== null`
      },
      imports: [NzOutletModule],
      standalone: true
    }]
  }], null, {
    title: [{
      type: Input
    }],
    footer: [{
      type: Input
    }]
  });
})();
var NZ_CONFIG_MODULE_NAME9 = "table";
var _NzTableComponent = class _NzTableComponent {
  onPageSizeChange(size) {
    this.nzTableDataService.updatePageSize(size);
  }
  onPageIndexChange(index) {
    this.nzTableDataService.updatePageIndex(index);
  }
  constructor(elementRef, nzResizeObserver, nzConfigService, cdr, nzTableStyleService, nzTableDataService, directionality) {
    this.elementRef = elementRef;
    this.nzResizeObserver = nzResizeObserver;
    this.nzConfigService = nzConfigService;
    this.cdr = cdr;
    this.nzTableStyleService = nzTableStyleService;
    this.nzTableDataService = nzTableDataService;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME9;
    this.nzTableLayout = "auto";
    this.nzShowTotal = null;
    this.nzItemRender = null;
    this.nzTitle = null;
    this.nzFooter = null;
    this.nzNoResult = void 0;
    this.nzPageSizeOptions = [10, 20, 30, 40, 50];
    this.nzVirtualItemSize = 0;
    this.nzVirtualMaxBufferPx = 200;
    this.nzVirtualMinBufferPx = 100;
    this.nzVirtualForTrackBy = (index) => index;
    this.nzLoadingDelay = 0;
    this.nzPageIndex = 1;
    this.nzPageSize = 10;
    this.nzTotal = 0;
    this.nzWidthConfig = [];
    this.nzData = [];
    this.nzCustomColumn = [];
    this.nzPaginationPosition = "bottom";
    this.nzScroll = {
      x: null,
      y: null
    };
    this.nzPaginationType = "default";
    this.nzFrontPagination = true;
    this.nzTemplateMode = false;
    this.nzShowPagination = true;
    this.nzLoading = false;
    this.nzOuterBordered = false;
    this.nzLoadingIndicator = null;
    this.nzBordered = false;
    this.nzSize = "default";
    this.nzShowSizeChanger = false;
    this.nzHideOnSinglePage = false;
    this.nzShowQuickJumper = false;
    this.nzSimple = false;
    this.nzPageSizeChange = new EventEmitter();
    this.nzPageIndexChange = new EventEmitter();
    this.nzQueryParams = new EventEmitter();
    this.nzCurrentPageDataChange = new EventEmitter();
    this.nzCustomColumnChange = new EventEmitter();
    this.data = [];
    this.scrollX = null;
    this.scrollY = null;
    this.theadTemplate = null;
    this.listOfAutoColWidth = [];
    this.listOfManualColWidth = [];
    this.hasFixLeft = false;
    this.hasFixRight = false;
    this.showPagination = true;
    this.destroy$ = new Subject();
    this.templateMode$ = new BehaviorSubject(false);
    this.dir = "ltr";
    this.verticalScrollBarWidth = 0;
    this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME9).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.cdr.markForCheck();
    });
  }
  ngOnInit() {
    const {
      pageIndexDistinct$,
      pageSizeDistinct$,
      listOfCurrentPageData$,
      total$,
      queryParams$,
      listOfCustomColumn$
    } = this.nzTableDataService;
    const {
      theadTemplate$,
      hasFixLeft$,
      hasFixRight$
    } = this.nzTableStyleService;
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    queryParams$.pipe(takeUntil(this.destroy$)).subscribe(this.nzQueryParams);
    pageIndexDistinct$.pipe(takeUntil(this.destroy$)).subscribe((pageIndex) => {
      if (pageIndex !== this.nzPageIndex) {
        this.nzPageIndex = pageIndex;
        this.nzPageIndexChange.next(pageIndex);
      }
    });
    pageSizeDistinct$.pipe(takeUntil(this.destroy$)).subscribe((pageSize) => {
      if (pageSize !== this.nzPageSize) {
        this.nzPageSize = pageSize;
        this.nzPageSizeChange.next(pageSize);
      }
    });
    total$.pipe(takeUntil(this.destroy$), filter(() => this.nzFrontPagination)).subscribe((total2) => {
      if (total2 !== this.nzTotal) {
        this.nzTotal = total2;
        this.cdr.markForCheck();
      }
    });
    listOfCurrentPageData$.pipe(takeUntil(this.destroy$)).subscribe((data) => {
      this.data = data;
      this.nzCurrentPageDataChange.next(data);
      this.cdr.markForCheck();
    });
    listOfCustomColumn$.pipe(takeUntil(this.destroy$)).subscribe((data) => {
      this.nzCustomColumn = data;
      this.nzCustomColumnChange.next(data);
      this.cdr.markForCheck();
    });
    theadTemplate$.pipe(takeUntil(this.destroy$)).subscribe((theadTemplate) => {
      this.theadTemplate = theadTemplate;
      this.cdr.markForCheck();
    });
    hasFixLeft$.pipe(takeUntil(this.destroy$)).subscribe((hasFixLeft) => {
      this.hasFixLeft = hasFixLeft;
      this.cdr.markForCheck();
    });
    hasFixRight$.pipe(takeUntil(this.destroy$)).subscribe((hasFixRight) => {
      this.hasFixRight = hasFixRight;
      this.cdr.markForCheck();
    });
    combineLatest([total$, this.templateMode$]).pipe(map(([total2, templateMode]) => total2 === 0 && !templateMode), takeUntil(this.destroy$)).subscribe((empty) => {
      this.nzTableStyleService.setShowEmpty(empty);
    });
    this.verticalScrollBarWidth = measureScrollbar("vertical");
    this.nzTableStyleService.listOfListOfThWidthPx$.pipe(takeUntil(this.destroy$)).subscribe((listOfWidth) => {
      this.listOfAutoColWidth = listOfWidth;
      this.cdr.markForCheck();
    });
    this.nzTableStyleService.manualWidthConfigPx$.pipe(takeUntil(this.destroy$)).subscribe((listOfWidth) => {
      this.listOfManualColWidth = listOfWidth;
      this.cdr.markForCheck();
    });
  }
  ngOnChanges(changes) {
    const {
      nzScroll,
      nzPageIndex,
      nzPageSize,
      nzFrontPagination,
      nzData,
      nzCustomColumn,
      nzWidthConfig,
      nzNoResult,
      nzTemplateMode
    } = changes;
    if (nzPageIndex) {
      this.nzTableDataService.updatePageIndex(this.nzPageIndex);
    }
    if (nzPageSize) {
      this.nzTableDataService.updatePageSize(this.nzPageSize);
    }
    if (nzData) {
      this.nzData = this.nzData || [];
      this.nzTableDataService.updateListOfData(this.nzData);
    }
    if (nzCustomColumn) {
      this.nzCustomColumn = this.nzCustomColumn || [];
      this.nzTableDataService.updateListOfCustomColumn(this.nzCustomColumn);
    }
    if (nzFrontPagination) {
      this.nzTableDataService.updateFrontPagination(this.nzFrontPagination);
    }
    if (nzScroll) {
      this.setScrollOnChanges();
    }
    if (nzWidthConfig) {
      this.nzTableStyleService.setTableWidthConfig(this.nzWidthConfig);
    }
    if (nzTemplateMode) {
      this.templateMode$.next(this.nzTemplateMode);
    }
    if (nzNoResult) {
      this.nzTableStyleService.setNoResult(this.nzNoResult);
    }
    this.updateShowPagination();
  }
  ngAfterViewInit() {
    this.nzResizeObserver.observe(this.elementRef).pipe(map(([entry]) => {
      const {
        width
      } = entry.target.getBoundingClientRect();
      const scrollBarWidth = this.scrollY ? this.verticalScrollBarWidth : 0;
      return Math.floor(width - scrollBarWidth);
    }), takeUntil(this.destroy$)).subscribe(this.nzTableStyleService.hostWidth$);
    if (this.nzTableInnerScrollComponent && this.nzTableInnerScrollComponent.cdkVirtualScrollViewport) {
      this.cdkVirtualScrollViewport = this.nzTableInnerScrollComponent.cdkVirtualScrollViewport;
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  setScrollOnChanges() {
    this.scrollX = this.nzScroll && this.nzScroll.x || null;
    this.scrollY = this.nzScroll && this.nzScroll.y || null;
    this.nzTableStyleService.setScroll(this.scrollX, this.scrollY);
  }
  updateShowPagination() {
    this.showPagination = this.nzHideOnSinglePage && this.nzData.length > this.nzPageSize || this.nzData.length > 0 && !this.nzHideOnSinglePage || !this.nzFrontPagination && this.nzTotal > this.nzPageSize;
  }
};
_NzTableComponent.\u0275fac = function NzTableComponent_Factory(t) {
  return new (t || _NzTableComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NzResizeObserver), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzTableStyleService), \u0275\u0275directiveInject(NzTableDataService), \u0275\u0275directiveInject(Directionality, 8));
};
_NzTableComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTableComponent,
  selectors: [["nz-table"]],
  contentQueries: function NzTableComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzTableVirtualScrollDirective, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzVirtualScrollDirective = _t.first);
    }
  },
  viewQuery: function NzTableComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NzTableInnerScrollComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzTableInnerScrollComponent = _t.first);
    }
  },
  hostAttrs: [1, "ant-table-wrapper"],
  hostVars: 4,
  hostBindings: function NzTableComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-wrapper-rtl", ctx.dir === "rtl")("ant-table-custom-column", ctx.nzCustomColumn.length);
    }
  },
  inputs: {
    nzTableLayout: "nzTableLayout",
    nzShowTotal: "nzShowTotal",
    nzItemRender: "nzItemRender",
    nzTitle: "nzTitle",
    nzFooter: "nzFooter",
    nzNoResult: "nzNoResult",
    nzPageSizeOptions: "nzPageSizeOptions",
    nzVirtualItemSize: "nzVirtualItemSize",
    nzVirtualMaxBufferPx: "nzVirtualMaxBufferPx",
    nzVirtualMinBufferPx: "nzVirtualMinBufferPx",
    nzVirtualForTrackBy: "nzVirtualForTrackBy",
    nzLoadingDelay: "nzLoadingDelay",
    nzPageIndex: "nzPageIndex",
    nzPageSize: "nzPageSize",
    nzTotal: "nzTotal",
    nzWidthConfig: "nzWidthConfig",
    nzData: "nzData",
    nzCustomColumn: "nzCustomColumn",
    nzPaginationPosition: "nzPaginationPosition",
    nzScroll: "nzScroll",
    nzPaginationType: "nzPaginationType",
    nzFrontPagination: "nzFrontPagination",
    nzTemplateMode: "nzTemplateMode",
    nzShowPagination: "nzShowPagination",
    nzLoading: "nzLoading",
    nzOuterBordered: "nzOuterBordered",
    nzLoadingIndicator: "nzLoadingIndicator",
    nzBordered: "nzBordered",
    nzSize: "nzSize",
    nzShowSizeChanger: "nzShowSizeChanger",
    nzHideOnSinglePage: "nzHideOnSinglePage",
    nzShowQuickJumper: "nzShowQuickJumper",
    nzSimple: "nzSimple"
  },
  outputs: {
    nzPageSizeChange: "nzPageSizeChange",
    nzPageIndexChange: "nzPageIndexChange",
    nzQueryParams: "nzQueryParams",
    nzCurrentPageDataChange: "nzCurrentPageDataChange",
    nzCustomColumnChange: "nzCustomColumnChange"
  },
  exportAs: ["nzTable"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzTableStyleService, NzTableDataService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c014,
  decls: 14,
  vars: 27,
  consts: [[3, "nzDelay", "nzSpinning", "nzIndicator"], [4, "ngIf"], [1, "ant-table"], ["tableMainElement", ""], [3, "title", 4, "ngIf"], [3, "data", "scrollX", "scrollY", "contentTemplate", "listOfColWidth", "theadTemplate", "verticalScrollBarWidth", "virtualTemplate", "virtualItemSize", "virtualMaxBufferPx", "virtualMinBufferPx", "tableMainElement", "virtualForTrackBy", 4, "ngIf", "ngIfElse"], ["defaultTemplate", ""], [3, "footer", 4, "ngIf"], ["paginationTemplate", ""], ["contentTemplate", ""], [3, "ngTemplateOutlet"], [3, "title"], [3, "data", "scrollX", "scrollY", "contentTemplate", "listOfColWidth", "theadTemplate", "verticalScrollBarWidth", "virtualTemplate", "virtualItemSize", "virtualMaxBufferPx", "virtualMinBufferPx", "tableMainElement", "virtualForTrackBy"], [3, "tableLayout", "listOfColWidth", "theadTemplate", "contentTemplate"], [3, "footer"], ["class", "ant-table-pagination ant-table-pagination-right", 3, "hidden", "nzShowSizeChanger", "nzPageSizeOptions", "nzItemRender", "nzShowQuickJumper", "nzHideOnSinglePage", "nzShowTotal", "nzSize", "nzPageSize", "nzTotal", "nzSimple", "nzPageIndex", "nzPageSizeChange", "nzPageIndexChange", 4, "ngIf"], [1, "ant-table-pagination", "ant-table-pagination-right", 3, "hidden", "nzShowSizeChanger", "nzPageSizeOptions", "nzItemRender", "nzShowQuickJumper", "nzHideOnSinglePage", "nzShowTotal", "nzSize", "nzPageSize", "nzTotal", "nzSimple", "nzPageIndex", "nzPageSizeChange", "nzPageIndexChange"]],
  template: function NzTableComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "nz-spin", 0);
      \u0275\u0275template(1, NzTableComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
      \u0275\u0275elementStart(2, "div", 2, 3);
      \u0275\u0275template(4, NzTableComponent_nz_table_title_footer_4_Template, 1, 1, "nz-table-title-footer", 4)(5, NzTableComponent_nz_table_inner_scroll_5_Template, 1, 13, "nz-table-inner-scroll", 5)(6, NzTableComponent_ng_template_6_Template, 1, 4, "ng-template", null, 6, \u0275\u0275templateRefExtractor)(8, NzTableComponent_nz_table_title_footer_8_Template, 1, 1, "nz-table-title-footer", 7);
      \u0275\u0275elementEnd();
      \u0275\u0275template(9, NzTableComponent_ng_container_9_Template, 2, 1, "ng-container", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275template(10, NzTableComponent_ng_template_10_Template, 1, 1, "ng-template", null, 8, \u0275\u0275templateRefExtractor)(12, NzTableComponent_ng_template_12_Template, 1, 0, "ng-template", null, 9, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r5 = \u0275\u0275reference(7);
      \u0275\u0275property("nzDelay", ctx.nzLoadingDelay)("nzSpinning", ctx.nzLoading)("nzIndicator", ctx.nzLoadingIndicator);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzPaginationPosition === "both" || ctx.nzPaginationPosition === "top");
      \u0275\u0275advance(1);
      \u0275\u0275classProp("ant-table-rtl", ctx.dir === "rtl")("ant-table-fixed-header", ctx.nzData.length && ctx.scrollY)("ant-table-fixed-column", ctx.scrollX)("ant-table-has-fix-left", ctx.hasFixLeft)("ant-table-has-fix-right", ctx.hasFixRight)("ant-table-bordered", ctx.nzBordered)("nz-table-out-bordered", ctx.nzOuterBordered && !ctx.nzBordered)("ant-table-middle", ctx.nzSize === "middle")("ant-table-small", ctx.nzSize === "small");
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.nzTitle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.scrollY || ctx.scrollX)("ngIfElse", _r5);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.nzFooter);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzPaginationPosition === "both" || ctx.nzPaginationPosition === "bottom");
    }
  },
  dependencies: [NzSpinComponent, NgIf, NgTemplateOutlet, NzTableTitleFooterComponent, NzTableInnerScrollComponent, NzTableInnerDefaultComponent, NzPaginationModule, NzPaginationComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzTableComponent = _NzTableComponent;
__decorate([InputBoolean()], NzTableComponent.prototype, "nzFrontPagination", void 0);
__decorate([InputBoolean()], NzTableComponent.prototype, "nzTemplateMode", void 0);
__decorate([InputBoolean()], NzTableComponent.prototype, "nzShowPagination", void 0);
__decorate([InputBoolean()], NzTableComponent.prototype, "nzLoading", void 0);
__decorate([InputBoolean()], NzTableComponent.prototype, "nzOuterBordered", void 0);
__decorate([WithConfig()], NzTableComponent.prototype, "nzLoadingIndicator", void 0);
__decorate([WithConfig(), InputBoolean()], NzTableComponent.prototype, "nzBordered", void 0);
__decorate([WithConfig()], NzTableComponent.prototype, "nzSize", void 0);
__decorate([WithConfig(), InputBoolean()], NzTableComponent.prototype, "nzShowSizeChanger", void 0);
__decorate([WithConfig(), InputBoolean()], NzTableComponent.prototype, "nzHideOnSinglePage", void 0);
__decorate([WithConfig(), InputBoolean()], NzTableComponent.prototype, "nzShowQuickJumper", void 0);
__decorate([WithConfig(), InputBoolean()], NzTableComponent.prototype, "nzSimple", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableComponent, [{
    type: Component,
    args: [{
      selector: "nz-table",
      exportAs: "nzTable",
      providers: [NzTableStyleService, NzTableDataService],
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <nz-spin [nzDelay]="nzLoadingDelay" [nzSpinning]="nzLoading" [nzIndicator]="nzLoadingIndicator">
      <ng-container *ngIf="nzPaginationPosition === 'both' || nzPaginationPosition === 'top'">
        <ng-template [ngTemplateOutlet]="paginationTemplate"></ng-template>
      </ng-container>
      <div
        #tableMainElement
        class="ant-table"
        [class.ant-table-rtl]="dir === 'rtl'"
        [class.ant-table-fixed-header]="nzData.length && scrollY"
        [class.ant-table-fixed-column]="scrollX"
        [class.ant-table-has-fix-left]="hasFixLeft"
        [class.ant-table-has-fix-right]="hasFixRight"
        [class.ant-table-bordered]="nzBordered"
        [class.nz-table-out-bordered]="nzOuterBordered && !nzBordered"
        [class.ant-table-middle]="nzSize === 'middle'"
        [class.ant-table-small]="nzSize === 'small'"
      >
        <nz-table-title-footer [title]="nzTitle" *ngIf="nzTitle"></nz-table-title-footer>
        <nz-table-inner-scroll
          *ngIf="scrollY || scrollX; else defaultTemplate"
          [data]="data"
          [scrollX]="scrollX"
          [scrollY]="scrollY"
          [contentTemplate]="contentTemplate"
          [listOfColWidth]="listOfAutoColWidth"
          [theadTemplate]="theadTemplate"
          [verticalScrollBarWidth]="verticalScrollBarWidth"
          [virtualTemplate]="nzVirtualScrollDirective ? nzVirtualScrollDirective.templateRef : null"
          [virtualItemSize]="nzVirtualItemSize"
          [virtualMaxBufferPx]="nzVirtualMaxBufferPx"
          [virtualMinBufferPx]="nzVirtualMinBufferPx"
          [tableMainElement]="tableMainElement"
          [virtualForTrackBy]="nzVirtualForTrackBy"
        ></nz-table-inner-scroll>
        <ng-template #defaultTemplate>
          <nz-table-inner-default
            [tableLayout]="nzTableLayout"
            [listOfColWidth]="listOfManualColWidth"
            [theadTemplate]="theadTemplate"
            [contentTemplate]="contentTemplate"
          ></nz-table-inner-default>
        </ng-template>
        <nz-table-title-footer [footer]="nzFooter" *ngIf="nzFooter"></nz-table-title-footer>
      </div>
      <ng-container *ngIf="nzPaginationPosition === 'both' || nzPaginationPosition === 'bottom'">
        <ng-template [ngTemplateOutlet]="paginationTemplate"></ng-template>
      </ng-container>
    </nz-spin>
    <ng-template #paginationTemplate>
      <nz-pagination
        *ngIf="nzShowPagination && data.length"
        [hidden]="!showPagination"
        class="ant-table-pagination ant-table-pagination-right"
        [nzShowSizeChanger]="nzShowSizeChanger"
        [nzPageSizeOptions]="nzPageSizeOptions"
        [nzItemRender]="nzItemRender!"
        [nzShowQuickJumper]="nzShowQuickJumper"
        [nzHideOnSinglePage]="nzHideOnSinglePage"
        [nzShowTotal]="nzShowTotal"
        [nzSize]="nzPaginationType === 'small' ? 'small' : nzSize === 'default' ? 'default' : 'small'"
        [nzPageSize]="nzPageSize"
        [nzTotal]="nzTotal"
        [nzSimple]="nzSimple"
        [nzPageIndex]="nzPageIndex"
        (nzPageSizeChange)="onPageSizeChange($event)"
        (nzPageIndexChange)="onPageIndexChange($event)"
      ></nz-pagination>
    </ng-template>
    <ng-template #contentTemplate>
      <ng-content></ng-content>
    </ng-template>
  `,
      host: {
        class: "ant-table-wrapper",
        "[class.ant-table-wrapper-rtl]": 'dir === "rtl"',
        "[class.ant-table-custom-column]": `nzCustomColumn.length`
      },
      imports: [NzSpinComponent, NgIf, NgTemplateOutlet, NzTableTitleFooterComponent, NzTableInnerScrollComponent, NzTableInnerDefaultComponent, NzPaginationModule],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NzResizeObserver
  }, {
    type: NzConfigService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzTableStyleService
  }, {
    type: NzTableDataService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzTableLayout: [{
      type: Input
    }],
    nzShowTotal: [{
      type: Input
    }],
    nzItemRender: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    nzFooter: [{
      type: Input
    }],
    nzNoResult: [{
      type: Input
    }],
    nzPageSizeOptions: [{
      type: Input
    }],
    nzVirtualItemSize: [{
      type: Input
    }],
    nzVirtualMaxBufferPx: [{
      type: Input
    }],
    nzVirtualMinBufferPx: [{
      type: Input
    }],
    nzVirtualForTrackBy: [{
      type: Input
    }],
    nzLoadingDelay: [{
      type: Input
    }],
    nzPageIndex: [{
      type: Input
    }],
    nzPageSize: [{
      type: Input
    }],
    nzTotal: [{
      type: Input
    }],
    nzWidthConfig: [{
      type: Input
    }],
    nzData: [{
      type: Input
    }],
    nzCustomColumn: [{
      type: Input
    }],
    nzPaginationPosition: [{
      type: Input
    }],
    nzScroll: [{
      type: Input
    }],
    nzPaginationType: [{
      type: Input
    }],
    nzFrontPagination: [{
      type: Input
    }],
    nzTemplateMode: [{
      type: Input
    }],
    nzShowPagination: [{
      type: Input
    }],
    nzLoading: [{
      type: Input
    }],
    nzOuterBordered: [{
      type: Input
    }],
    nzLoadingIndicator: [{
      type: Input
    }],
    nzBordered: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzShowSizeChanger: [{
      type: Input
    }],
    nzHideOnSinglePage: [{
      type: Input
    }],
    nzShowQuickJumper: [{
      type: Input
    }],
    nzSimple: [{
      type: Input
    }],
    nzPageSizeChange: [{
      type: Output
    }],
    nzPageIndexChange: [{
      type: Output
    }],
    nzQueryParams: [{
      type: Output
    }],
    nzCurrentPageDataChange: [{
      type: Output
    }],
    nzCustomColumnChange: [{
      type: Output
    }],
    nzVirtualScrollDirective: [{
      type: ContentChild,
      args: [NzTableVirtualScrollDirective, {
        static: false
      }]
    }],
    nzTableInnerScrollComponent: [{
      type: ViewChild,
      args: [NzTableInnerScrollComponent]
    }]
  });
})();
var _NzTrMeasureComponent = class _NzTrMeasureComponent {
  constructor(nzResizeObserver, ngZone) {
    this.nzResizeObserver = nzResizeObserver;
    this.ngZone = ngZone;
    this.listOfMeasureColumn = [];
    this.listOfAutoWidth = new EventEmitter();
    this.destroy$ = new Subject();
  }
  trackByFunc(_, key) {
    return key;
  }
  ngAfterViewInit() {
    this.listOfTdElement.changes.pipe(startWith(this.listOfTdElement)).pipe(switchMap((list2) => combineLatest(list2.toArray().map((item) => this.nzResizeObserver.observe(item).pipe(map(([entry]) => {
      const {
        width
      } = entry.target.getBoundingClientRect();
      return Math.floor(width);
    }))))), debounceTime(16), takeUntil(this.destroy$)).subscribe((data) => {
      if (this.ngZone instanceof NgZone && NgZone.isInAngularZone()) {
        this.listOfAutoWidth.next(data);
      } else {
        this.ngZone.run(() => this.listOfAutoWidth.next(data));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzTrMeasureComponent.\u0275fac = function NzTrMeasureComponent_Factory(t) {
  return new (t || _NzTrMeasureComponent)(\u0275\u0275directiveInject(NzResizeObserver), \u0275\u0275directiveInject(NgZone));
};
_NzTrMeasureComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTrMeasureComponent,
  selectors: [["tr", "nz-table-measure-row", ""]],
  viewQuery: function NzTrMeasureComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c72, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfTdElement = _t);
    }
  },
  hostAttrs: [1, "ant-table-measure-now"],
  inputs: {
    listOfMeasureColumn: "listOfMeasureColumn"
  },
  outputs: {
    listOfAutoWidth: "listOfAutoWidth"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c122,
  decls: 1,
  vars: 2,
  consts: [["class", "nz-disable-td", "style", "padding: 0px; border: 0px; height: 0px;", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "nz-disable-td", 2, "padding", "0px", "border", "0px", "height", "0px"], ["tdElement", ""]],
  template: function NzTrMeasureComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTrMeasureComponent_td_0_Template, 2, 0, "td", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.listOfMeasureColumn)("ngForTrackBy", ctx.trackByFunc);
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzTrMeasureComponent = _NzTrMeasureComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTrMeasureComponent, [{
    type: Component,
    args: [{
      selector: "tr[nz-table-measure-row]",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <td
      #tdElement
      class="nz-disable-td"
      style="padding: 0px; border: 0px; height: 0px;"
      *ngFor="let th of listOfMeasureColumn; trackBy: trackByFunc"
    ></td>
  `,
      host: {
        class: "ant-table-measure-now"
      },
      imports: [NgForOf],
      standalone: true
    }]
  }], () => [{
    type: NzResizeObserver
  }, {
    type: NgZone
  }], {
    listOfMeasureColumn: [{
      type: Input
    }],
    listOfAutoWidth: [{
      type: Output
    }],
    listOfTdElement: [{
      type: ViewChildren,
      args: ["tdElement"]
    }]
  });
})();
var _NzTbodyComponent = class _NzTbodyComponent {
  constructor(nzTableStyleService) {
    this.nzTableStyleService = nzTableStyleService;
    this.isInsideTable = false;
    this.showEmpty$ = new BehaviorSubject(false);
    this.noResult$ = new BehaviorSubject(void 0);
    this.listOfMeasureColumn$ = new BehaviorSubject([]);
    this.destroy$ = new Subject();
    this.isInsideTable = !!this.nzTableStyleService;
    if (this.nzTableStyleService) {
      const {
        showEmpty$,
        noResult$,
        listOfMeasureColumn$
      } = this.nzTableStyleService;
      noResult$.pipe(takeUntil(this.destroy$)).subscribe(this.noResult$);
      listOfMeasureColumn$.pipe(takeUntil(this.destroy$)).subscribe(this.listOfMeasureColumn$);
      showEmpty$.pipe(takeUntil(this.destroy$)).subscribe(this.showEmpty$);
    }
  }
  onListOfAutoWidthChange(listOfAutoWidth) {
    this.nzTableStyleService.setListOfAutoWidth(listOfAutoWidth);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzTbodyComponent.\u0275fac = function NzTbodyComponent_Factory(t) {
  return new (t || _NzTbodyComponent)(\u0275\u0275directiveInject(NzTableStyleService, 8));
};
_NzTbodyComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTbodyComponent,
  selectors: [["tbody"]],
  hostVars: 2,
  hostBindings: function NzTbodyComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-tbody", ctx.isInsideTable);
    }
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c014,
  decls: 5,
  vars: 6,
  consts: [[4, "ngIf"], ["class", "ant-table-placeholder", "nz-table-fixed-row", "", 4, "ngIf"], ["nz-table-measure-row", "", 3, "listOfMeasureColumn", "listOfAutoWidth", 4, "ngIf"], ["nz-table-measure-row", "", 3, "listOfMeasureColumn", "listOfAutoWidth"], ["nz-table-fixed-row", "", 1, "ant-table-placeholder"], ["nzComponentName", "table", 3, "specificContent"]],
  template: function NzTbodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzTbodyComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
      \u0275\u0275pipe(1, "async");
      \u0275\u0275projection(2);
      \u0275\u0275template(3, NzTbodyComponent_tr_3_Template, 3, 3, "tr", 1);
      \u0275\u0275pipe(4, "async");
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(1, 2, ctx.listOfMeasureColumn$));
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", \u0275\u0275pipeBind1(4, 4, ctx.showEmpty$));
    }
  },
  dependencies: [NgIf, AsyncPipe, NzTrMeasureComponent, NzTableFixedRowComponent, NzEmptyModule, NzEmbedEmptyComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzTbodyComponent = _NzTbodyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTbodyComponent, [{
    type: Component,
    args: [{
      selector: "tbody",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <ng-container *ngIf="listOfMeasureColumn$ | async as listOfMeasureColumn">
      <tr
        nz-table-measure-row
        *ngIf="isInsideTable && listOfMeasureColumn.length"
        [listOfMeasureColumn]="listOfMeasureColumn"
        (listOfAutoWidth)="onListOfAutoWidthChange($event)"
      ></tr>
    </ng-container>
    <ng-content></ng-content>
    <tr class="ant-table-placeholder" nz-table-fixed-row *ngIf="showEmpty$ | async">
      <nz-embed-empty nzComponentName="table" [specificContent]="(noResult$ | async)!"></nz-embed-empty>
    </tr>
  `,
      host: {
        "[class.ant-table-tbody]": "isInsideTable"
      },
      imports: [NgIf, AsyncPipe, NzTrMeasureComponent, NzTableFixedRowComponent, NzEmptyModule],
      standalone: true
    }]
  }], () => [{
    type: NzTableStyleService,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _NzTrDirective = class _NzTrDirective {
  constructor(nzTableStyleService) {
    this.nzTableStyleService = nzTableStyleService;
    this.destroy$ = new Subject();
    this.listOfFixedColumns$ = new ReplaySubject(1);
    this.listOfColumns$ = new ReplaySubject(1);
    this.listOfFixedColumnsChanges$ = this.listOfFixedColumns$.pipe(switchMap((list2) => merge(...[this.listOfFixedColumns$, ...list2.map((c) => c.changes$)]).pipe(mergeMap(() => this.listOfFixedColumns$))), takeUntil(this.destroy$));
    this.listOfFixedLeftColumnChanges$ = this.listOfFixedColumnsChanges$.pipe(map((list2) => list2.filter((item) => item.nzLeft !== false)));
    this.listOfFixedRightColumnChanges$ = this.listOfFixedColumnsChanges$.pipe(map((list2) => list2.filter((item) => item.nzRight !== false)));
    this.listOfColumnsChanges$ = this.listOfColumns$.pipe(switchMap((list2) => merge(...[this.listOfColumns$, ...list2.map((c) => c.changes$)]).pipe(mergeMap(() => this.listOfColumns$))), takeUntil(this.destroy$));
    this.isInsideTable = false;
    this.isInsideTable = !!nzTableStyleService;
  }
  ngAfterContentInit() {
    if (this.nzTableStyleService) {
      this.listOfCellFixedDirective.changes.pipe(startWith(this.listOfCellFixedDirective), takeUntil(this.destroy$)).subscribe(this.listOfFixedColumns$);
      this.listOfNzThDirective.changes.pipe(startWith(this.listOfNzThDirective), takeUntil(this.destroy$)).subscribe(this.listOfColumns$);
      this.listOfFixedLeftColumnChanges$.subscribe((listOfFixedLeft) => {
        listOfFixedLeft.forEach((cell) => cell.setIsLastLeft(cell === listOfFixedLeft[listOfFixedLeft.length - 1]));
      });
      this.listOfFixedRightColumnChanges$.subscribe((listOfFixedRight) => {
        listOfFixedRight.forEach((cell) => cell.setIsFirstRight(cell === listOfFixedRight[0]));
      });
      combineLatest([this.nzTableStyleService.listOfListOfThWidth$, this.listOfFixedLeftColumnChanges$]).pipe(takeUntil(this.destroy$)).subscribe(([listOfAutoWidth, listOfLeftCell]) => {
        listOfLeftCell.forEach((cell, index) => {
          if (cell.isAutoLeft) {
            const currentArray = listOfLeftCell.slice(0, index);
            const count = currentArray.reduce((pre, cur) => pre + (cur.colspan || cur.colSpan || 1), 0);
            const width = listOfAutoWidth.slice(0, count).reduce((pre, cur) => pre + cur, 0);
            cell.setAutoLeftWidth(`${width}px`);
          }
        });
      });
      combineLatest([this.nzTableStyleService.listOfListOfThWidth$, this.listOfFixedRightColumnChanges$]).pipe(takeUntil(this.destroy$)).subscribe(([listOfAutoWidth, listOfRightCell]) => {
        listOfRightCell.forEach((_, index) => {
          const cell = listOfRightCell[listOfRightCell.length - index - 1];
          if (cell.isAutoRight) {
            const currentArray = listOfRightCell.slice(listOfRightCell.length - index, listOfRightCell.length);
            const count = currentArray.reduce((pre, cur) => pre + (cur.colspan || cur.colSpan || 1), 0);
            const width = listOfAutoWidth.slice(listOfAutoWidth.length - count, listOfAutoWidth.length).reduce((pre, cur) => pre + cur, 0);
            cell.setAutoRightWidth(`${width}px`);
          }
        });
      });
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzTrDirective.\u0275fac = function NzTrDirective_Factory(t) {
  return new (t || _NzTrDirective)(\u0275\u0275directiveInject(NzTableStyleService, 8));
};
_NzTrDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTrDirective,
  selectors: [["tr", 3, "mat-row", "", 3, "mat-header-row", "", 3, "nz-table-measure-row", "", 3, "nzExpand", "", 3, "nz-table-fixed-row", ""]],
  contentQueries: function NzTrDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzThMeasureDirective, 4);
      \u0275\u0275contentQuery(dirIndex, NzCellFixedDirective, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzThDirective = _t);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfCellFixedDirective = _t);
    }
  },
  hostVars: 2,
  hostBindings: function NzTrDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-row", ctx.isInsideTable);
    }
  },
  standalone: true
});
var NzTrDirective = _NzTrDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTrDirective, [{
    type: Directive,
    args: [{
      selector: "tr:not([mat-row]):not([mat-header-row]):not([nz-table-measure-row]):not([nzExpand]):not([nz-table-fixed-row])",
      host: {
        "[class.ant-table-row]": "isInsideTable"
      },
      standalone: true
    }]
  }], () => [{
    type: NzTableStyleService,
    decorators: [{
      type: Optional
    }]
  }], {
    listOfNzThDirective: [{
      type: ContentChildren,
      args: [NzThMeasureDirective]
    }],
    listOfCellFixedDirective: [{
      type: ContentChildren,
      args: [NzCellFixedDirective]
    }]
  });
})();
var _NzTheadComponent = class _NzTheadComponent {
  constructor(elementRef, renderer, nzTableStyleService, nzTableDataService) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.nzTableStyleService = nzTableStyleService;
    this.nzTableDataService = nzTableDataService;
    this.destroy$ = new Subject();
    this.isInsideTable = false;
    this.nzSortOrderChange = new EventEmitter();
    this.isInsideTable = !!this.nzTableStyleService;
  }
  ngOnInit() {
    if (this.nzTableStyleService) {
      this.nzTableStyleService.setTheadTemplate(this.templateRef);
    }
  }
  ngAfterContentInit() {
    if (this.nzTableStyleService) {
      const firstTableRow$ = this.listOfNzTrDirective.changes.pipe(startWith(this.listOfNzTrDirective), map((item) => item && item.first));
      const listOfColumnsChanges$ = firstTableRow$.pipe(switchMap((firstTableRow) => firstTableRow ? firstTableRow.listOfColumnsChanges$ : EMPTY), takeUntil(this.destroy$));
      listOfColumnsChanges$.subscribe((data) => this.nzTableStyleService.setListOfTh(data));
      this.nzTableStyleService.enableAutoMeasure$.pipe(switchMap((enable) => enable ? listOfColumnsChanges$ : of([]))).pipe(takeUntil(this.destroy$)).subscribe((data) => this.nzTableStyleService.setListOfMeasureColumn(data));
      const listOfFixedLeftColumnChanges$ = firstTableRow$.pipe(switchMap((firstTr) => firstTr ? firstTr.listOfFixedLeftColumnChanges$ : EMPTY), takeUntil(this.destroy$));
      const listOfFixedRightColumnChanges$ = firstTableRow$.pipe(switchMap((firstTr) => firstTr ? firstTr.listOfFixedRightColumnChanges$ : EMPTY), takeUntil(this.destroy$));
      listOfFixedLeftColumnChanges$.subscribe((listOfFixedLeftColumn) => {
        this.nzTableStyleService.setHasFixLeft(listOfFixedLeftColumn.length !== 0);
      });
      listOfFixedRightColumnChanges$.subscribe((listOfFixedRightColumn) => {
        this.nzTableStyleService.setHasFixRight(listOfFixedRightColumn.length !== 0);
      });
    }
    if (this.nzTableDataService) {
      const listOfColumn$ = this.listOfNzThAddOnComponent.changes.pipe(startWith(this.listOfNzThAddOnComponent));
      const manualSort$ = listOfColumn$.pipe(switchMap(() => merge(...this.listOfNzThAddOnComponent.map((th) => th.manualClickOrder$))), takeUntil(this.destroy$));
      manualSort$.subscribe((data) => {
        const emitValue = {
          key: data.nzColumnKey,
          value: data.sortOrder
        };
        this.nzSortOrderChange.emit(emitValue);
        if (data.nzSortFn && data.nzSortPriority === false) {
          this.listOfNzThAddOnComponent.filter((th) => th !== data).forEach((th) => th.clearSortOrder());
        }
      });
      const listOfCalcOperator$ = listOfColumn$.pipe(
        switchMap((list2) => merge(...[listOfColumn$, ...list2.map((c) => c.calcOperatorChange$)]).pipe(mergeMap(() => listOfColumn$))),
        map((list2) => list2.filter((item) => !!item.nzSortFn || !!item.nzFilterFn).map((item) => {
          const {
            nzSortFn,
            sortOrder,
            nzFilterFn,
            nzFilterValue,
            nzSortPriority,
            nzColumnKey
          } = item;
          return {
            key: nzColumnKey,
            sortFn: nzSortFn,
            sortPriority: nzSortPriority,
            sortOrder,
            filterFn: nzFilterFn,
            filterValue: nzFilterValue
          };
        })),
        // TODO: after checked error here
        delay(0),
        takeUntil(this.destroy$)
      );
      listOfCalcOperator$.subscribe((list2) => {
        this.nzTableDataService.listOfCalcOperator$.next(list2);
      });
    }
  }
  ngAfterViewInit() {
    if (this.nzTableStyleService) {
      this.renderer.removeChild(this.renderer.parentNode(this.elementRef.nativeElement), this.elementRef.nativeElement);
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzTheadComponent.\u0275fac = function NzTheadComponent_Factory(t) {
  return new (t || _NzTheadComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzTableStyleService, 8), \u0275\u0275directiveInject(NzTableDataService, 8));
};
_NzTheadComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTheadComponent,
  selectors: [["thead", 9, "ant-table-thead"]],
  contentQueries: function NzTheadComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzTrDirective, 5);
      \u0275\u0275contentQuery(dirIndex, NzThAddOnComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzTrDirective = _t);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzThAddOnComponent = _t);
    }
  },
  viewQuery: function NzTheadComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c132, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  outputs: {
    nzSortOrderChange: "nzSortOrderChange"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c014,
  decls: 3,
  vars: 1,
  consts: [["contentTemplate", ""], [4, "ngIf"], [3, "ngTemplateOutlet"]],
  template: function NzTheadComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzTheadComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, NzTheadComponent_ng_container_2_Template, 2, 1, "ng-container", 1);
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", !ctx.isInsideTable);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzTheadComponent = _NzTheadComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTheadComponent, [{
    type: Component,
    args: [{
      selector: "thead:not(.ant-table-thead)",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <ng-template #contentTemplate>
      <ng-content></ng-content>
    </ng-template>
    <ng-container *ngIf="!isInsideTable">
      <ng-template [ngTemplateOutlet]="contentTemplate"></ng-template>
    </ng-container>
  `,
      imports: [NgIf, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NzTableStyleService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzTableDataService,
    decorators: [{
      type: Optional
    }]
  }], {
    templateRef: [{
      type: ViewChild,
      args: ["contentTemplate", {
        static: true
      }]
    }],
    listOfNzTrDirective: [{
      type: ContentChildren,
      args: [NzTrDirective, {
        descendants: true
      }]
    }],
    listOfNzThAddOnComponent: [{
      type: ContentChildren,
      args: [NzThAddOnComponent, {
        descendants: true
      }]
    }],
    nzSortOrderChange: [{
      type: Output
    }]
  });
})();
var _NzTrExpandDirective = class _NzTrExpandDirective {
  constructor() {
    this.nzExpand = true;
  }
};
_NzTrExpandDirective.\u0275fac = function NzTrExpandDirective_Factory(t) {
  return new (t || _NzTrExpandDirective)();
};
_NzTrExpandDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTrExpandDirective,
  selectors: [["tr", "nzExpand", ""]],
  hostAttrs: [1, "ant-table-expanded-row"],
  hostVars: 1,
  hostBindings: function NzTrExpandDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275hostProperty("hidden", !ctx.nzExpand);
    }
  },
  inputs: {
    nzExpand: "nzExpand"
  },
  standalone: true
});
var NzTrExpandDirective = _NzTrExpandDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTrExpandDirective, [{
    type: Directive,
    args: [{
      selector: "tr[nzExpand]",
      host: {
        class: "ant-table-expanded-row",
        "[hidden]": `!nzExpand`
      },
      standalone: true
    }]
  }], () => [], {
    nzExpand: [{
      type: Input
    }]
  });
})();
var _NzTableModule = class _NzTableModule {
};
_NzTableModule.\u0275fac = function NzTableModule_Factory(t) {
  return new (t || _NzTableModule)();
};
_NzTableModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzTableModule
});
_NzTableModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzTableComponent, NzThAddOnComponent, NzTdAddOnComponent, NzTbodyComponent, NzTableTitleFooterComponent, NzTableInnerScrollComponent, NzTableSortersComponent, NzTableFilterComponent, NzTableSelectionComponent, NzFilterTriggerComponent, NzThSelectionComponent]
});
var NzTableModule = _NzTableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTableModule, [{
    type: NgModule,
    args: [{
      imports: [NzTableComponent, NzThAddOnComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzTrExpandDirective, NzTableVirtualScrollDirective, NzCellFixedDirective, NzCustomColumnDirective, NzTableContentComponent, NzTableTitleFooterComponent, NzTableInnerDefaultComponent, NzTableInnerScrollComponent, NzTrMeasureComponent, NzRowIndentDirective, NzRowExpandButtonDirective, NzCellBreakWordDirective, NzCellAlignDirective, NzTableSortersComponent, NzTableFilterComponent, NzTableSelectionComponent, NzCellEllipsisDirective, NzFilterTriggerComponent, NzTableFixedRowComponent, NzThSelectionComponent],
      exports: [NzTableComponent, NzThAddOnComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzTableVirtualScrollDirective, NzCellFixedDirective, NzCustomColumnDirective, NzFilterTriggerComponent, NzTrExpandDirective, NzCellBreakWordDirective, NzCellAlignDirective, NzCellEllipsisDirective, NzTableFixedRowComponent, NzThSelectionComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-resizable.mjs
var _c015 = ["*"];
function NzResizeHandlesComponent_nz_resize_handle_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-resize-handle", 1);
  }
  if (rf & 2) {
    const option_r1 = ctx.$implicit;
    \u0275\u0275property("nzDirection", option_r1.direction)("nzCursorType", option_r1.cursorType);
  }
}
function getEventWithPoint(event) {
  return isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
}
var _NzResizableService = class _NzResizableService {
  constructor(ngZone, document2) {
    this.ngZone = ngZone;
    this.listeners = /* @__PURE__ */ new Map();
    this.handleMouseDownOutsideAngular$ = new Subject();
    this.documentMouseUpOutsideAngular$ = new Subject();
    this.documentMouseMoveOutsideAngular$ = new Subject();
    this.mouseEnteredOutsideAngular$ = new Subject();
    this.document = document2;
  }
  startResizing(event) {
    const _isTouchEvent = isTouchEvent(event);
    this.clearListeners();
    const moveEvent = _isTouchEvent ? "touchmove" : "mousemove";
    const upEvent = _isTouchEvent ? "touchend" : "mouseup";
    const moveEventHandler = (e) => {
      this.documentMouseMoveOutsideAngular$.next(e);
    };
    const upEventHandler = (e) => {
      this.documentMouseUpOutsideAngular$.next(e);
      this.clearListeners();
    };
    this.listeners.set(moveEvent, moveEventHandler);
    this.listeners.set(upEvent, upEventHandler);
    this.ngZone.runOutsideAngular(() => {
      this.listeners.forEach((handler, name) => {
        this.document.addEventListener(name, handler);
      });
    });
  }
  clearListeners() {
    this.listeners.forEach((handler, name) => {
      this.document.removeEventListener(name, handler);
    });
    this.listeners.clear();
  }
  ngOnDestroy() {
    this.handleMouseDownOutsideAngular$.complete();
    this.documentMouseUpOutsideAngular$.complete();
    this.documentMouseMoveOutsideAngular$.complete();
    this.mouseEnteredOutsideAngular$.complete();
    this.clearListeners();
  }
};
_NzResizableService.\u0275fac = function NzResizableService_Factory(t) {
  return new (t || _NzResizableService)(\u0275\u0275inject(NgZone), \u0275\u0275inject(DOCUMENT));
};
_NzResizableService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzResizableService,
  factory: _NzResizableService.\u0275fac
});
var NzResizableService = _NzResizableService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizableService, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _NzResizableDirective = class _NzResizableDirective {
  constructor(elementRef, renderer, nzResizableService, platform, ngZone, destroy$) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.nzResizableService = nzResizableService;
    this.platform = platform;
    this.ngZone = ngZone;
    this.destroy$ = destroy$;
    this.nzBounds = "parent";
    this.nzMinHeight = 40;
    this.nzMinWidth = 40;
    this.nzGridColumnCount = -1;
    this.nzMaxColumn = -1;
    this.nzMinColumn = -1;
    this.nzLockAspectRatio = false;
    this.nzPreview = false;
    this.nzDisabled = false;
    this.nzResize = new EventEmitter();
    this.nzResizeEnd = new EventEmitter();
    this.nzResizeStart = new EventEmitter();
    this.resizing = false;
    this.currentHandleEvent = null;
    this.ghostElement = null;
    this.sizeCache = null;
    this.nzResizableService.handleMouseDownOutsideAngular$.pipe(takeUntil(this.destroy$)).subscribe((event) => {
      if (this.nzDisabled) {
        return;
      }
      this.resizing = true;
      this.nzResizableService.startResizing(event.mouseEvent);
      this.currentHandleEvent = event;
      if (this.nzResizeStart.observers.length) {
        this.ngZone.run(() => this.nzResizeStart.emit({
          mouseEvent: event.mouseEvent,
          direction: event.direction
        }));
      }
      this.elRect = this.el.getBoundingClientRect();
    });
    this.nzResizableService.documentMouseUpOutsideAngular$.pipe(takeUntil(this.destroy$), filter(Boolean)).subscribe((event) => {
      if (this.resizing) {
        this.resizing = false;
        this.nzResizableService.documentMouseUpOutsideAngular$.next(null);
        this.endResize(event);
      }
    });
    this.nzResizableService.documentMouseMoveOutsideAngular$.pipe(takeUntil(this.destroy$)).subscribe((event) => {
      if (this.resizing) {
        this.resize(event);
      }
    });
  }
  setPosition() {
    const position = getComputedStyle(this.el).position;
    if (position === "static" || !position) {
      this.renderer.setStyle(this.el, "position", "relative");
    }
  }
  calcSize(width, height, ratio) {
    let newWidth;
    let newHeight;
    let maxWidth;
    let maxHeight;
    let col = 0;
    let spanWidth = 0;
    let minWidth = this.nzMinWidth;
    let boundWidth = Infinity;
    let boundHeight = Infinity;
    if (this.nzBounds === "parent") {
      const parent = this.renderer.parentNode(this.el);
      if (parent instanceof HTMLElement) {
        const parentRect = parent.getBoundingClientRect();
        boundWidth = parentRect.width;
        boundHeight = parentRect.height;
      }
    } else if (this.nzBounds === "window") {
      if (typeof window !== "undefined") {
        boundWidth = window.innerWidth;
        boundHeight = window.innerHeight;
      }
    } else if (this.nzBounds && this.nzBounds.nativeElement && this.nzBounds.nativeElement instanceof HTMLElement) {
      const boundsRect = this.nzBounds.nativeElement.getBoundingClientRect();
      boundWidth = boundsRect.width;
      boundHeight = boundsRect.height;
    }
    maxWidth = ensureInBounds(this.nzMaxWidth, boundWidth);
    maxHeight = ensureInBounds(this.nzMaxHeight, boundHeight);
    if (this.nzGridColumnCount !== -1) {
      spanWidth = maxWidth / this.nzGridColumnCount;
      minWidth = this.nzMinColumn !== -1 ? spanWidth * this.nzMinColumn : minWidth;
      maxWidth = this.nzMaxColumn !== -1 ? spanWidth * this.nzMaxColumn : maxWidth;
    }
    if (ratio !== -1) {
      if (/(left|right)/i.test(this.currentHandleEvent.direction)) {
        newWidth = Math.min(Math.max(width, minWidth), maxWidth);
        newHeight = Math.min(Math.max(newWidth / ratio, this.nzMinHeight), maxHeight);
        if (newHeight >= maxHeight || newHeight <= this.nzMinHeight) {
          newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);
        }
      } else {
        newHeight = Math.min(Math.max(height, this.nzMinHeight), maxHeight);
        newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);
        if (newWidth >= maxWidth || newWidth <= minWidth) {
          newHeight = Math.min(Math.max(newWidth / ratio, this.nzMinHeight), maxHeight);
        }
      }
    } else {
      newWidth = Math.min(Math.max(width, minWidth), maxWidth);
      newHeight = Math.min(Math.max(height, this.nzMinHeight), maxHeight);
    }
    if (this.nzGridColumnCount !== -1) {
      col = Math.round(newWidth / spanWidth);
      newWidth = col * spanWidth;
    }
    return {
      col,
      width: newWidth,
      height: newHeight
    };
  }
  resize(event) {
    const elRect = this.elRect;
    const resizeEvent = getEventWithPoint(event);
    const handleEvent = getEventWithPoint(this.currentHandleEvent.mouseEvent);
    let width = elRect.width;
    let height = elRect.height;
    const ratio = this.nzLockAspectRatio ? width / height : -1;
    switch (this.currentHandleEvent.direction) {
      case "bottomRight":
        width = resizeEvent.clientX - elRect.left;
        height = resizeEvent.clientY - elRect.top;
        break;
      case "bottomLeft":
        width = elRect.width + handleEvent.clientX - resizeEvent.clientX;
        height = resizeEvent.clientY - elRect.top;
        break;
      case "topRight":
        width = resizeEvent.clientX - elRect.left;
        height = elRect.height + handleEvent.clientY - resizeEvent.clientY;
        break;
      case "topLeft":
        width = elRect.width + handleEvent.clientX - resizeEvent.clientX;
        height = elRect.height + handleEvent.clientY - resizeEvent.clientY;
        break;
      case "top":
        height = elRect.height + handleEvent.clientY - resizeEvent.clientY;
        break;
      case "right":
        width = resizeEvent.clientX - elRect.left;
        break;
      case "bottom":
        height = resizeEvent.clientY - elRect.top;
        break;
      case "left":
        width = elRect.width + handleEvent.clientX - resizeEvent.clientX;
    }
    const size = this.calcSize(width, height, ratio);
    this.sizeCache = __spreadValues({}, size);
    if (this.nzResize.observers.length) {
      this.ngZone.run(() => {
        this.nzResize.emit(__spreadProps(__spreadValues({}, size), {
          mouseEvent: event,
          direction: this.currentHandleEvent.direction
        }));
      });
    }
    if (this.nzPreview) {
      this.previewResize(size);
    }
  }
  endResize(event) {
    this.removeGhostElement();
    const size = this.sizeCache ? __spreadValues({}, this.sizeCache) : {
      width: this.elRect.width,
      height: this.elRect.height
    };
    if (this.nzResizeEnd.observers.length) {
      this.ngZone.run(() => {
        this.nzResizeEnd.emit(__spreadProps(__spreadValues({}, size), {
          mouseEvent: event,
          direction: this.currentHandleEvent.direction
        }));
      });
    }
    this.sizeCache = null;
    this.currentHandleEvent = null;
  }
  previewResize({
    width,
    height
  }) {
    this.createGhostElement();
    this.renderer.setStyle(this.ghostElement, "width", `${width}px`);
    this.renderer.setStyle(this.ghostElement, "height", `${height}px`);
  }
  createGhostElement() {
    if (!this.ghostElement) {
      this.ghostElement = this.renderer.createElement("div");
      this.renderer.setAttribute(this.ghostElement, "class", "nz-resizable-preview");
    }
    this.renderer.appendChild(this.el, this.ghostElement);
  }
  removeGhostElement() {
    if (this.ghostElement) {
      this.renderer.removeChild(this.el, this.ghostElement);
    }
  }
  ngAfterViewInit() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.el = this.elementRef.nativeElement;
    this.setPosition();
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.el, "mouseenter").pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.nzResizableService.mouseEnteredOutsideAngular$.next(true);
      });
      fromEvent(this.el, "mouseleave").pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.nzResizableService.mouseEnteredOutsideAngular$.next(false);
      });
    });
  }
  ngOnDestroy() {
    this.ghostElement = null;
    this.sizeCache = null;
  }
};
_NzResizableDirective.\u0275fac = function NzResizableDirective_Factory(t) {
  return new (t || _NzResizableDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzResizableService), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NzDestroyService));
};
_NzResizableDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzResizableDirective,
  selectors: [["", "nz-resizable", ""]],
  hostAttrs: [1, "nz-resizable"],
  hostVars: 4,
  hostBindings: function NzResizableDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("nz-resizable-resizing", ctx.resizing)("nz-resizable-disabled", ctx.nzDisabled);
    }
  },
  inputs: {
    nzBounds: "nzBounds",
    nzMaxHeight: "nzMaxHeight",
    nzMaxWidth: "nzMaxWidth",
    nzMinHeight: "nzMinHeight",
    nzMinWidth: "nzMinWidth",
    nzGridColumnCount: "nzGridColumnCount",
    nzMaxColumn: "nzMaxColumn",
    nzMinColumn: "nzMinColumn",
    nzLockAspectRatio: "nzLockAspectRatio",
    nzPreview: "nzPreview",
    nzDisabled: "nzDisabled"
  },
  outputs: {
    nzResize: "nzResize",
    nzResizeEnd: "nzResizeEnd",
    nzResizeStart: "nzResizeStart"
  },
  exportAs: ["nzResizable"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzResizableService, NzDestroyService])]
});
var NzResizableDirective = _NzResizableDirective;
__decorate([InputBoolean()], NzResizableDirective.prototype, "nzLockAspectRatio", void 0);
__decorate([InputBoolean()], NzResizableDirective.prototype, "nzPreview", void 0);
__decorate([InputBoolean()], NzResizableDirective.prototype, "nzDisabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizableDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-resizable]",
      exportAs: "nzResizable",
      providers: [NzResizableService, NzDestroyService],
      host: {
        class: "nz-resizable",
        "[class.nz-resizable-resizing]": "resizing",
        "[class.nz-resizable-disabled]": "nzDisabled"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NzResizableService
  }, {
    type: Platform
  }, {
    type: NgZone
  }, {
    type: NzDestroyService
  }], {
    nzBounds: [{
      type: Input
    }],
    nzMaxHeight: [{
      type: Input
    }],
    nzMaxWidth: [{
      type: Input
    }],
    nzMinHeight: [{
      type: Input
    }],
    nzMinWidth: [{
      type: Input
    }],
    nzGridColumnCount: [{
      type: Input
    }],
    nzMaxColumn: [{
      type: Input
    }],
    nzMinColumn: [{
      type: Input
    }],
    nzLockAspectRatio: [{
      type: Input
    }],
    nzPreview: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzResize: [{
      type: Output
    }],
    nzResizeEnd: [{
      type: Output
    }],
    nzResizeStart: [{
      type: Output
    }]
  });
})();
var NzResizeHandleMouseDownEvent = class {
  constructor(direction, mouseEvent) {
    this.direction = direction;
    this.mouseEvent = mouseEvent;
  }
};
var passiveEventListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var _NzResizeHandleComponent = class _NzResizeHandleComponent {
  constructor(ngZone, nzResizableService, renderer, host, destroy$) {
    this.ngZone = ngZone;
    this.nzResizableService = nzResizableService;
    this.renderer = renderer;
    this.host = host;
    this.destroy$ = destroy$;
    this.nzDirection = "bottomRight";
    this.nzCursorType = "window";
    this.nzMouseDown = new EventEmitter();
  }
  ngOnInit() {
    this.nzResizableService.mouseEnteredOutsideAngular$.pipe(takeUntil(this.destroy$)).subscribe((entered) => {
      if (entered) {
        this.renderer.addClass(this.host.nativeElement, "nz-resizable-handle-box-hover");
      } else {
        this.renderer.removeClass(this.host.nativeElement, "nz-resizable-handle-box-hover");
      }
    });
    this.ngZone.runOutsideAngular(() => {
      merge(fromEvent(this.host.nativeElement, "mousedown", passiveEventListenerOptions), fromEvent(this.host.nativeElement, "touchstart", passiveEventListenerOptions)).pipe(takeUntil(this.destroy$)).subscribe((event) => {
        this.nzResizableService.handleMouseDownOutsideAngular$.next(new NzResizeHandleMouseDownEvent(this.nzDirection, event));
      });
    });
  }
  onPointerDown(event) {
    event.target.setPointerCapture(event.pointerId);
  }
  onPointerUp(event) {
    event.target.releasePointerCapture(event.pointerId);
  }
};
_NzResizeHandleComponent.\u0275fac = function NzResizeHandleComponent_Factory(t) {
  return new (t || _NzResizeHandleComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NzResizableService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NzDestroyService));
};
_NzResizeHandleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzResizeHandleComponent,
  selectors: [["nz-resize-handle"], ["", "nz-resize-handle", ""]],
  hostAttrs: [1, "nz-resizable-handle"],
  hostVars: 20,
  hostBindings: function NzResizeHandleComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("pointerdown", function NzResizeHandleComponent_pointerdown_HostBindingHandler($event) {
        return ctx.onPointerDown($event);
      })("pointerup", function NzResizeHandleComponent_pointerup_HostBindingHandler($event) {
        return ctx.onPointerUp($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("nz-resizable-handle-top", ctx.nzDirection === "top")("nz-resizable-handle-right", ctx.nzDirection === "right")("nz-resizable-handle-bottom", ctx.nzDirection === "bottom")("nz-resizable-handle-left", ctx.nzDirection === "left")("nz-resizable-handle-topRight", ctx.nzDirection === "topRight")("nz-resizable-handle-bottomRight", ctx.nzDirection === "bottomRight")("nz-resizable-handle-bottomLeft", ctx.nzDirection === "bottomLeft")("nz-resizable-handle-topLeft", ctx.nzDirection === "topLeft")("nz-resizable-handle-cursor-type-grid", ctx.nzCursorType === "grid")("nz-resizable-handle-cursor-type-window", ctx.nzCursorType === "window");
    }
  },
  inputs: {
    nzDirection: "nzDirection",
    nzCursorType: "nzCursorType"
  },
  outputs: {
    nzMouseDown: "nzMouseDown"
  },
  exportAs: ["nzResizeHandle"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService]), \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c015,
  decls: 1,
  vars: 0,
  template: function NzResizeHandleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzResizeHandleComponent = _NzResizeHandleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizeHandleComponent, [{
    type: Component,
    args: [{
      selector: "nz-resize-handle, [nz-resize-handle]",
      exportAs: "nzResizeHandle",
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "nz-resizable-handle",
        "[class.nz-resizable-handle-top]": `nzDirection === 'top'`,
        "[class.nz-resizable-handle-right]": `nzDirection === 'right'`,
        "[class.nz-resizable-handle-bottom]": `nzDirection === 'bottom'`,
        "[class.nz-resizable-handle-left]": `nzDirection === 'left'`,
        "[class.nz-resizable-handle-topRight]": `nzDirection === 'topRight'`,
        "[class.nz-resizable-handle-bottomRight]": `nzDirection === 'bottomRight'`,
        "[class.nz-resizable-handle-bottomLeft]": `nzDirection === 'bottomLeft'`,
        "[class.nz-resizable-handle-topLeft]": `nzDirection === 'topLeft'`,
        "[class.nz-resizable-handle-cursor-type-grid]": `nzCursorType === 'grid'`,
        "[class.nz-resizable-handle-cursor-type-window]": `nzCursorType === 'window'`
      },
      providers: [NzDestroyService],
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: NzResizableService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NzDestroyService
  }], {
    nzDirection: [{
      type: Input
    }],
    nzCursorType: [{
      type: Input
    }],
    nzMouseDown: [{
      type: Output
    }],
    onPointerDown: [{
      type: HostListener,
      args: ["pointerdown", ["$event"]]
    }],
    onPointerUp: [{
      type: HostListener,
      args: ["pointerup", ["$event"]]
    }]
  });
})();
var DEFAULT_RESIZE_DIRECTION = ["bottomRight", "topRight", "bottomLeft", "topLeft", "bottom", "right", "top", "left"];
function normalizeResizeHandleOptions(value) {
  return value.map((val) => {
    if (typeof val === "string") {
      return {
        direction: val,
        cursorType: "window"
      };
    }
    return val;
  });
}
var _NzResizeHandlesComponent = class _NzResizeHandlesComponent {
  constructor() {
    this.nzDirections = DEFAULT_RESIZE_DIRECTION;
    this.resizeHandleOptions = normalizeResizeHandleOptions(this.nzDirections);
  }
  ngOnChanges(changes) {
    if (changes.nzDirections) {
      this.resizeHandleOptions = normalizeResizeHandleOptions(changes.nzDirections.currentValue);
    }
  }
};
_NzResizeHandlesComponent.\u0275fac = function NzResizeHandlesComponent_Factory(t) {
  return new (t || _NzResizeHandlesComponent)();
};
_NzResizeHandlesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzResizeHandlesComponent,
  selectors: [["nz-resize-handles"]],
  inputs: {
    nzDirections: "nzDirections"
  },
  exportAs: ["nzResizeHandles"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 1,
  consts: [[3, "nzDirection", "nzCursorType", 4, "ngFor", "ngForOf"], [3, "nzDirection", "nzCursorType"]],
  template: function NzResizeHandlesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzResizeHandlesComponent_nz_resize_handle_0_Template, 1, 2, "nz-resize-handle", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.resizeHandleOptions);
    }
  },
  dependencies: [NzResizeHandleComponent, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzResizeHandlesComponent = _NzResizeHandlesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizeHandlesComponent, [{
    type: Component,
    args: [{
      selector: "nz-resize-handles",
      exportAs: "nzResizeHandles",
      template: `
    <nz-resize-handle
      *ngFor="let option of resizeHandleOptions"
      [nzDirection]="option.direction"
      [nzCursorType]="option.cursorType"
    ></nz-resize-handle>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [NzResizeHandleComponent, NgForOf],
      standalone: true
    }]
  }], null, {
    nzDirections: [{
      type: Input
    }]
  });
})();
var _NzResizableModule = class _NzResizableModule {
};
_NzResizableModule.\u0275fac = function NzResizableModule_Factory(t) {
  return new (t || _NzResizableModule)();
};
_NzResizableModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzResizableModule
});
_NzResizableModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzResizableModule = _NzResizableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzResizableModule, [{
    type: NgModule,
    args: [{
      imports: [NzResizableDirective, NzResizeHandleComponent, NzResizeHandlesComponent],
      exports: [NzResizableDirective, NzResizeHandleComponent, NzResizeHandlesComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-input.mjs
var _c016 = ["nz-input-group-slot", ""];
function NzInputGroupSlotComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzType", ctx_r0.icon);
  }
}
function NzInputGroupSlotComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r1.template);
  }
}
var _c19 = ["*"];
function NzInputGroupComponent_span_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r7.nzAddOnBeforeIcon)("template", ctx_r7.nzAddOnBefore);
  }
}
function NzInputGroupComponent_span_0_span_2_ng_template_1_Template(rf, ctx) {
}
function NzInputGroupComponent_span_0_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 8);
    \u0275\u0275template(1, NzInputGroupComponent_span_0_span_2_ng_template_1_Template, 0, 0, "ng-template", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275classProp("ant-input-affix-wrapper-disabled", ctx_r8.disabled)("ant-input-affix-wrapper-sm", ctx_r8.isSmall)("ant-input-affix-wrapper-lg", ctx_r8.isLarge)("ant-input-affix-wrapper-focused", ctx_r8.focused);
    \u0275\u0275property("ngClass", ctx_r8.affixInGroupStatusCls);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r4);
  }
}
function NzInputGroupComponent_span_0_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r9.nzAddOnAfterIcon)("template", ctx_r9.nzAddOnAfter);
  }
}
function NzInputGroupComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 4);
    \u0275\u0275template(1, NzInputGroupComponent_span_0_span_1_Template, 1, 2, "span", 5)(2, NzInputGroupComponent_span_0_span_2_Template, 2, 10, "span", 6)(3, NzInputGroupComponent_span_0_span_3_Template, 1, 2, "span", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzAddOnBefore || ctx_r0.nzAddOnBeforeIcon);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.isAffix || ctx_r0.hasFeedback)("ngIfElse", _r6);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzAddOnAfter || ctx_r0.nzAddOnAfterIcon);
  }
}
function NzInputGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template(rf, ctx) {
}
function NzInputGroupComponent_ng_template_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzInputGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275property("ngTemplateOutlet", _r4);
  }
}
function NzInputGroupComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzInputGroupComponent_ng_template_1_ng_template_0_Template, 1, 1, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275property("ngIf", ctx_r1.isAffix)("ngIfElse", _r6);
  }
}
function NzInputGroupComponent_ng_template_3_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 13);
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r13.nzPrefixIcon)("template", ctx_r13.nzPrefix);
  }
}
function NzInputGroupComponent_ng_template_3_ng_template_1_Template(rf, ctx) {
}
function NzInputGroupComponent_ng_template_3_span_2_nz_form_item_feedback_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-form-item-feedback-icon", 16);
  }
  if (rf & 2) {
    const ctx_r16 = \u0275\u0275nextContext(3);
    \u0275\u0275property("status", ctx_r16.status);
  }
}
function NzInputGroupComponent_ng_template_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275template(1, NzInputGroupComponent_ng_template_3_span_2_nz_form_item_feedback_icon_1_Template, 1, 1, "nz-form-item-feedback-icon", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r15 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r15.nzSuffixIcon)("template", ctx_r15.nzSuffix);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r15.isFeedback);
  }
}
function NzInputGroupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzInputGroupComponent_ng_template_3_span_0_Template, 1, 2, "span", 11)(1, NzInputGroupComponent_ng_template_3_ng_template_1_Template, 0, 0, "ng-template", 9)(2, NzInputGroupComponent_ng_template_3_span_2_Template, 2, 3, "span", 12);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275property("ngIf", ctx_r3.nzPrefix || ctx_r3.nzPrefixIcon);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r6);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r3.nzSuffix || ctx_r3.nzSuffixIcon || ctx_r3.isFeedback);
  }
}
function NzInputGroupComponent_ng_template_5_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275element(1, "nz-form-item-feedback-icon", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r17 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("status", ctx_r17.status);
  }
}
function NzInputGroupComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
    \u0275\u0275template(1, NzInputGroupComponent_ng_template_5_span_1_Template, 2, 1, "span", 17);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r5.isAddOn && !ctx_r5.isAffix && ctx_r5.isFeedback);
  }
}
var _c28 = [[["textarea", "nz-input", ""]]];
var _c35 = ["textarea[nz-input]"];
var _NzInputGroupSlotComponent = class _NzInputGroupSlotComponent {
  constructor() {
    this.icon = null;
    this.type = null;
    this.template = null;
  }
};
_NzInputGroupSlotComponent.\u0275fac = function NzInputGroupSlotComponent_Factory(t) {
  return new (t || _NzInputGroupSlotComponent)();
};
_NzInputGroupSlotComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzInputGroupSlotComponent,
  selectors: [["", "nz-input-group-slot", ""]],
  hostVars: 6,
  hostBindings: function NzInputGroupSlotComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-input-group-addon", ctx.type === "addon")("ant-input-prefix", ctx.type === "prefix")("ant-input-suffix", ctx.type === "suffix");
    }
  },
  inputs: {
    icon: "icon",
    type: "type",
    template: "template"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c016,
  ngContentSelectors: _c19,
  decls: 3,
  vars: 2,
  consts: [["nz-icon", "", 3, "nzType", 4, "ngIf"], [4, "nzStringTemplateOutlet"], ["nz-icon", "", 3, "nzType"]],
  template: function NzInputGroupSlotComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzInputGroupSlotComponent_span_0_Template, 1, 1, "span", 0)(1, NzInputGroupSlotComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
      \u0275\u0275projection(2);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.icon);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.template);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NgIf, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzInputGroupSlotComponent = _NzInputGroupSlotComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputGroupSlotComponent, [{
    type: Component,
    args: [{
      selector: "[nz-input-group-slot]",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span nz-icon [nzType]="icon" *ngIf="icon"></span>
    <ng-container *nzStringTemplateOutlet="template">{{ template }}</ng-container>
    <ng-content></ng-content>
  `,
      host: {
        "[class.ant-input-group-addon]": `type === 'addon'`,
        "[class.ant-input-prefix]": `type === 'prefix'`,
        "[class.ant-input-suffix]": `type === 'suffix'`
      },
      imports: [NzIconModule, NgIf, NzOutletModule],
      standalone: true
    }]
  }], null, {
    icon: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    template: [{
      type: Input
    }]
  });
})();
var _NzInputDirective = class _NzInputDirective {
  get disabled() {
    if (this.ngControl && this.ngControl.disabled !== null) {
      return this.ngControl.disabled;
    }
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value != null && `${value}` !== "false";
  }
  constructor(ngControl, renderer, elementRef, hostView, directionality, nzFormStatusService, nzFormNoStatusService) {
    this.ngControl = ngControl;
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.hostView = hostView;
    this.directionality = directionality;
    this.nzFormStatusService = nzFormStatusService;
    this.nzFormNoStatusService = nzFormNoStatusService;
    this.nzBorderless = false;
    this.nzSize = "default";
    this.nzStepperless = true;
    this.nzStatus = "";
    this._disabled = false;
    this.disabled$ = new Subject();
    this.dir = "ltr";
    this.prefixCls = "ant-input";
    this.status = "";
    this.statusCls = {};
    this.hasFeedback = false;
    this.feedbackRef = null;
    this.components = [];
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {
      return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;
    }), takeUntil(this.destroy$)).subscribe(({
      status,
      hasFeedback
    }) => {
      this.setStatusStyles(status, hasFeedback);
    });
    if (this.ngControl) {
      this.ngControl.statusChanges?.pipe(filter(() => this.ngControl.disabled !== null), takeUntil(this.destroy$)).subscribe(() => {
        this.disabled$.next(this.ngControl.disabled);
      });
    }
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngOnChanges(changes) {
    const {
      disabled,
      nzStatus
    } = changes;
    if (disabled) {
      this.disabled$.next(this.disabled);
    }
    if (nzStatus) {
      this.setStatusStyles(this.nzStatus, this.hasFeedback);
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  setStatusStyles(status, hasFeedback) {
    this.status = status;
    this.hasFeedback = hasFeedback;
    this.renderFeedbackIcon();
    this.statusCls = getStatusClassNames(this.prefixCls, status, hasFeedback);
    Object.keys(this.statusCls).forEach((status2) => {
      if (this.statusCls[status2]) {
        this.renderer.addClass(this.elementRef.nativeElement, status2);
      } else {
        this.renderer.removeClass(this.elementRef.nativeElement, status2);
      }
    });
  }
  renderFeedbackIcon() {
    if (!this.status || !this.hasFeedback || !!this.nzFormNoStatusService) {
      this.hostView.clear();
      this.feedbackRef = null;
      return;
    }
    this.feedbackRef = this.feedbackRef || this.hostView.createComponent(NzFormItemFeedbackIconComponent);
    this.feedbackRef.location.nativeElement.classList.add("ant-input-suffix");
    this.feedbackRef.instance.status = this.status;
    this.feedbackRef.instance.updateIcon();
  }
};
_NzInputDirective.\u0275fac = function NzInputDirective_Factory(t) {
  return new (t || _NzInputDirective)(\u0275\u0275directiveInject(NgControl, 10), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzFormStatusService, 8), \u0275\u0275directiveInject(NzFormNoStatusService, 8));
};
_NzInputDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzInputDirective,
  selectors: [["input", "nz-input", ""], ["textarea", "nz-input", ""]],
  hostAttrs: [1, "ant-input"],
  hostVars: 13,
  hostBindings: function NzInputDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("disabled", ctx.disabled || null);
      \u0275\u0275classProp("ant-input-disabled", ctx.disabled)("ant-input-borderless", ctx.nzBorderless)("ant-input-lg", ctx.nzSize === "large")("ant-input-sm", ctx.nzSize === "small")("ant-input-rtl", ctx.dir === "rtl")("ant-input-stepperless", ctx.nzStepperless);
    }
  },
  inputs: {
    nzBorderless: "nzBorderless",
    nzSize: "nzSize",
    nzStepperless: "nzStepperless",
    nzStatus: "nzStatus",
    disabled: "disabled"
  },
  exportAs: ["nzInput"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzInputDirective = _NzInputDirective;
__decorate([InputBoolean()], NzInputDirective.prototype, "nzBorderless", void 0);
__decorate([InputBoolean()], NzInputDirective.prototype, "nzStepperless", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nz-input],textarea[nz-input]",
      exportAs: "nzInput",
      host: {
        class: "ant-input",
        "[class.ant-input-disabled]": "disabled",
        "[class.ant-input-borderless]": "nzBorderless",
        "[class.ant-input-lg]": `nzSize === 'large'`,
        "[class.ant-input-sm]": `nzSize === 'small'`,
        "[attr.disabled]": "disabled || null",
        "[class.ant-input-rtl]": `dir=== 'rtl'`,
        "[class.ant-input-stepperless]": `nzStepperless`
      },
      standalone: true
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormNoStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    nzBorderless: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzStepperless: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var _NzInputGroupWhitSuffixOrPrefixDirective = class _NzInputGroupWhitSuffixOrPrefixDirective {
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
};
_NzInputGroupWhitSuffixOrPrefixDirective.\u0275fac = function NzInputGroupWhitSuffixOrPrefixDirective_Factory(t) {
  return new (t || _NzInputGroupWhitSuffixOrPrefixDirective)(\u0275\u0275directiveInject(ElementRef));
};
_NzInputGroupWhitSuffixOrPrefixDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzInputGroupWhitSuffixOrPrefixDirective,
  selectors: [["nz-input-group", "nzSuffix", ""], ["nz-input-group", "nzPrefix", ""]],
  standalone: true
});
var NzInputGroupWhitSuffixOrPrefixDirective = _NzInputGroupWhitSuffixOrPrefixDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputGroupWhitSuffixOrPrefixDirective, [{
    type: Directive,
    args: [{
      selector: `nz-input-group[nzSuffix], nz-input-group[nzPrefix]`,
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], null);
})();
var _NzInputGroupComponent = class _NzInputGroupComponent {
  constructor(focusMonitor, elementRef, renderer, cdr, directionality, nzFormStatusService, nzFormNoStatusService) {
    this.focusMonitor = focusMonitor;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.cdr = cdr;
    this.directionality = directionality;
    this.nzFormStatusService = nzFormStatusService;
    this.nzFormNoStatusService = nzFormNoStatusService;
    this.nzAddOnBeforeIcon = null;
    this.nzAddOnAfterIcon = null;
    this.nzPrefixIcon = null;
    this.nzSuffixIcon = null;
    this.nzStatus = "";
    this.nzSize = "default";
    this.nzSearch = false;
    this.nzCompact = false;
    this.isLarge = false;
    this.isSmall = false;
    this.isAffix = false;
    this.isAddOn = false;
    this.isFeedback = false;
    this.focused = false;
    this.disabled = false;
    this.dir = "ltr";
    this.prefixCls = "ant-input";
    this.affixStatusCls = {};
    this.groupStatusCls = {};
    this.affixInGroupStatusCls = {};
    this.status = "";
    this.hasFeedback = false;
    this.destroy$ = new Subject();
  }
  updateChildrenInputSize() {
    if (this.listOfNzInputDirective) {
      this.listOfNzInputDirective.forEach((item) => item.nzSize = this.nzSize);
    }
  }
  ngOnInit() {
    this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {
      return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;
    }), takeUntil(this.destroy$)).subscribe(({
      status,
      hasFeedback
    }) => {
      this.setStatusStyles(status, hasFeedback);
    });
    this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe((focusOrigin) => {
      this.focused = !!focusOrigin;
      this.cdr.markForCheck();
    });
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngAfterContentInit() {
    this.updateChildrenInputSize();
    const listOfInputChange$ = this.listOfNzInputDirective.changes.pipe(startWith(this.listOfNzInputDirective));
    listOfInputChange$.pipe(switchMap((list2) => merge(...[listOfInputChange$, ...list2.map((input) => input.disabled$)])), mergeMap(() => listOfInputChange$), map((list2) => list2.some((input) => input.disabled)), takeUntil(this.destroy$)).subscribe((disabled) => {
      this.disabled = disabled;
      this.cdr.markForCheck();
    });
  }
  ngOnChanges(changes) {
    const {
      nzSize,
      nzSuffix,
      nzPrefix,
      nzPrefixIcon,
      nzSuffixIcon,
      nzAddOnAfter,
      nzAddOnBefore,
      nzAddOnAfterIcon,
      nzAddOnBeforeIcon,
      nzStatus
    } = changes;
    if (nzSize) {
      this.updateChildrenInputSize();
      this.isLarge = this.nzSize === "large";
      this.isSmall = this.nzSize === "small";
    }
    if (nzSuffix || nzPrefix || nzPrefixIcon || nzSuffixIcon) {
      this.isAffix = !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);
    }
    if (nzAddOnAfter || nzAddOnBefore || nzAddOnAfterIcon || nzAddOnBeforeIcon) {
      this.isAddOn = !!(this.nzAddOnAfter || this.nzAddOnBefore || this.nzAddOnAfterIcon || this.nzAddOnBeforeIcon);
      this.nzFormNoStatusService?.noFormStatus?.next(this.isAddOn);
    }
    if (nzStatus) {
      this.setStatusStyles(this.nzStatus, this.hasFeedback);
    }
  }
  ngOnDestroy() {
    this.focusMonitor.stopMonitoring(this.elementRef);
    this.destroy$.next();
    this.destroy$.complete();
  }
  setStatusStyles(status, hasFeedback) {
    this.status = status;
    this.hasFeedback = hasFeedback;
    this.isFeedback = !!status && hasFeedback;
    const baseAffix = !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);
    this.isAffix = baseAffix || !this.isAddOn && hasFeedback;
    this.affixInGroupStatusCls = this.isAffix || this.isFeedback ? this.affixStatusCls = getStatusClassNames(`${this.prefixCls}-affix-wrapper`, status, hasFeedback) : {};
    this.cdr.markForCheck();
    this.affixStatusCls = getStatusClassNames(`${this.prefixCls}-affix-wrapper`, this.isAddOn ? "" : status, this.isAddOn ? false : hasFeedback);
    this.groupStatusCls = getStatusClassNames(`${this.prefixCls}-group-wrapper`, this.isAddOn ? status : "", this.isAddOn ? hasFeedback : false);
    const statusCls = __spreadValues(__spreadValues({}, this.affixStatusCls), this.groupStatusCls);
    Object.keys(statusCls).forEach((status2) => {
      if (statusCls[status2]) {
        this.renderer.addClass(this.elementRef.nativeElement, status2);
      } else {
        this.renderer.removeClass(this.elementRef.nativeElement, status2);
      }
    });
  }
};
_NzInputGroupComponent.\u0275fac = function NzInputGroupComponent_Factory(t) {
  return new (t || _NzInputGroupComponent)(\u0275\u0275directiveInject(FocusMonitor), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzFormStatusService, 8), \u0275\u0275directiveInject(NzFormNoStatusService, 8));
};
_NzInputGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzInputGroupComponent,
  selectors: [["nz-input-group"]],
  contentQueries: function NzInputGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzInputDirective, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzInputDirective = _t);
    }
  },
  hostVars: 40,
  hostBindings: function NzInputGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-input-group-compact", ctx.nzCompact)("ant-input-search-enter-button", ctx.nzSearch)("ant-input-search", ctx.nzSearch)("ant-input-search-rtl", ctx.dir === "rtl")("ant-input-search-sm", ctx.nzSearch && ctx.isSmall)("ant-input-search-large", ctx.nzSearch && ctx.isLarge)("ant-input-group-wrapper", ctx.isAddOn)("ant-input-group-wrapper-rtl", ctx.dir === "rtl")("ant-input-group-wrapper-lg", ctx.isAddOn && ctx.isLarge)("ant-input-group-wrapper-sm", ctx.isAddOn && ctx.isSmall)("ant-input-affix-wrapper", ctx.isAffix && !ctx.isAddOn)("ant-input-affix-wrapper-rtl", ctx.dir === "rtl")("ant-input-affix-wrapper-focused", ctx.isAffix && ctx.focused)("ant-input-affix-wrapper-disabled", ctx.isAffix && ctx.disabled)("ant-input-affix-wrapper-lg", ctx.isAffix && !ctx.isAddOn && ctx.isLarge)("ant-input-affix-wrapper-sm", ctx.isAffix && !ctx.isAddOn && ctx.isSmall)("ant-input-group", !ctx.isAffix && !ctx.isAddOn)("ant-input-group-rtl", ctx.dir === "rtl")("ant-input-group-lg", !ctx.isAffix && !ctx.isAddOn && ctx.isLarge)("ant-input-group-sm", !ctx.isAffix && !ctx.isAddOn && ctx.isSmall);
    }
  },
  inputs: {
    nzAddOnBeforeIcon: "nzAddOnBeforeIcon",
    nzAddOnAfterIcon: "nzAddOnAfterIcon",
    nzPrefixIcon: "nzPrefixIcon",
    nzSuffixIcon: "nzSuffixIcon",
    nzAddOnBefore: "nzAddOnBefore",
    nzAddOnAfter: "nzAddOnAfter",
    nzPrefix: "nzPrefix",
    nzStatus: "nzStatus",
    nzSuffix: "nzSuffix",
    nzSize: "nzSize",
    nzSearch: "nzSearch",
    nzCompact: "nzCompact"
  },
  exportAs: ["nzInputGroup"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzFormNoStatusService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c19,
  decls: 7,
  vars: 2,
  consts: [["class", "ant-input-wrapper ant-input-group", 4, "ngIf", "ngIfElse"], ["noAddOnTemplate", ""], ["affixTemplate", ""], ["contentTemplate", ""], [1, "ant-input-wrapper", "ant-input-group"], ["nz-input-group-slot", "", "type", "addon", 3, "icon", "template", 4, "ngIf"], ["class", "ant-input-affix-wrapper", 3, "ant-input-affix-wrapper-disabled", "ant-input-affix-wrapper-sm", "ant-input-affix-wrapper-lg", "ant-input-affix-wrapper-focused", "ngClass", 4, "ngIf", "ngIfElse"], ["nz-input-group-slot", "", "type", "addon", 3, "icon", "template"], [1, "ant-input-affix-wrapper", 3, "ngClass"], [3, "ngTemplateOutlet"], [3, "ngIf", "ngIfElse"], ["nz-input-group-slot", "", "type", "prefix", 3, "icon", "template", 4, "ngIf"], ["nz-input-group-slot", "", "type", "suffix", 3, "icon", "template", 4, "ngIf"], ["nz-input-group-slot", "", "type", "prefix", 3, "icon", "template"], ["nz-input-group-slot", "", "type", "suffix", 3, "icon", "template"], [3, "status", 4, "ngIf"], [3, "status"], ["nz-input-group-slot", "", "type", "suffix", 4, "ngIf"], ["nz-input-group-slot", "", "type", "suffix"]],
  template: function NzInputGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzInputGroupComponent_span_0_Template, 4, 4, "span", 0)(1, NzInputGroupComponent_ng_template_1_Template, 1, 2, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, NzInputGroupComponent_ng_template_3_Template, 3, 3, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(5, NzInputGroupComponent_ng_template_5_Template, 2, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.isAddOn)("ngIfElse", _r2);
    }
  },
  dependencies: [NgIf, NzInputGroupSlotComponent, NgClass, NgTemplateOutlet, NzFormPatchModule, NzFormItemFeedbackIconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzInputGroupComponent = _NzInputGroupComponent;
__decorate([InputBoolean()], NzInputGroupComponent.prototype, "nzSearch", void 0);
__decorate([InputBoolean()], NzInputGroupComponent.prototype, "nzCompact", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputGroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-input-group",
      exportAs: "nzInputGroup",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [NzFormNoStatusService],
      template: `
    <span class="ant-input-wrapper ant-input-group" *ngIf="isAddOn; else noAddOnTemplate">
      <span
        *ngIf="nzAddOnBefore || nzAddOnBeforeIcon"
        nz-input-group-slot
        type="addon"
        [icon]="nzAddOnBeforeIcon"
        [template]="nzAddOnBefore"
      ></span>
      <span
        *ngIf="isAffix || hasFeedback; else contentTemplate"
        class="ant-input-affix-wrapper"
        [class.ant-input-affix-wrapper-disabled]="disabled"
        [class.ant-input-affix-wrapper-sm]="isSmall"
        [class.ant-input-affix-wrapper-lg]="isLarge"
        [class.ant-input-affix-wrapper-focused]="focused"
        [ngClass]="affixInGroupStatusCls"
      >
        <ng-template [ngTemplateOutlet]="affixTemplate"></ng-template>
      </span>
      <span
        *ngIf="nzAddOnAfter || nzAddOnAfterIcon"
        nz-input-group-slot
        type="addon"
        [icon]="nzAddOnAfterIcon"
        [template]="nzAddOnAfter"
      ></span>
    </span>
    <ng-template #noAddOnTemplate>
      <ng-template [ngIf]="isAffix" [ngIfElse]="contentTemplate">
        <ng-template [ngTemplateOutlet]="affixTemplate"></ng-template>
      </ng-template>
    </ng-template>
    <ng-template #affixTemplate>
      <span
        *ngIf="nzPrefix || nzPrefixIcon"
        nz-input-group-slot
        type="prefix"
        [icon]="nzPrefixIcon"
        [template]="nzPrefix"
      ></span>
      <ng-template [ngTemplateOutlet]="contentTemplate"></ng-template>
      <span
        *ngIf="nzSuffix || nzSuffixIcon || isFeedback"
        nz-input-group-slot
        type="suffix"
        [icon]="nzSuffixIcon"
        [template]="nzSuffix"
      >
        <nz-form-item-feedback-icon *ngIf="isFeedback" [status]="status"></nz-form-item-feedback-icon>
      </span>
    </ng-template>
    <ng-template #contentTemplate>
      <ng-content></ng-content>
      <span *ngIf="!isAddOn && !isAffix && isFeedback" nz-input-group-slot type="suffix">
        <nz-form-item-feedback-icon [status]="status"></nz-form-item-feedback-icon>
      </span>
    </ng-template>
  `,
      host: {
        "[class.ant-input-group-compact]": `nzCompact`,
        "[class.ant-input-search-enter-button]": `nzSearch`,
        "[class.ant-input-search]": `nzSearch`,
        "[class.ant-input-search-rtl]": `dir === 'rtl'`,
        "[class.ant-input-search-sm]": `nzSearch && isSmall`,
        "[class.ant-input-search-large]": `nzSearch && isLarge`,
        "[class.ant-input-group-wrapper]": `isAddOn`,
        "[class.ant-input-group-wrapper-rtl]": `dir === 'rtl'`,
        "[class.ant-input-group-wrapper-lg]": `isAddOn && isLarge`,
        "[class.ant-input-group-wrapper-sm]": `isAddOn && isSmall`,
        "[class.ant-input-affix-wrapper]": `isAffix && !isAddOn`,
        "[class.ant-input-affix-wrapper-rtl]": `dir === 'rtl'`,
        "[class.ant-input-affix-wrapper-focused]": `isAffix && focused`,
        "[class.ant-input-affix-wrapper-disabled]": `isAffix && disabled`,
        "[class.ant-input-affix-wrapper-lg]": `isAffix && !isAddOn && isLarge`,
        "[class.ant-input-affix-wrapper-sm]": `isAffix && !isAddOn && isSmall`,
        "[class.ant-input-group]": `!isAffix && !isAddOn`,
        "[class.ant-input-group-rtl]": `dir === 'rtl'`,
        "[class.ant-input-group-lg]": `!isAffix && !isAddOn && isLarge`,
        "[class.ant-input-group-sm]": `!isAffix && !isAddOn && isSmall`
      },
      imports: [NgIf, NzInputGroupSlotComponent, NgClass, NgTemplateOutlet, NzFormPatchModule],
      standalone: true
    }]
  }], () => [{
    type: FocusMonitor
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormNoStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    listOfNzInputDirective: [{
      type: ContentChildren,
      args: [NzInputDirective]
    }],
    nzAddOnBeforeIcon: [{
      type: Input
    }],
    nzAddOnAfterIcon: [{
      type: Input
    }],
    nzPrefixIcon: [{
      type: Input
    }],
    nzSuffixIcon: [{
      type: Input
    }],
    nzAddOnBefore: [{
      type: Input
    }],
    nzAddOnAfter: [{
      type: Input
    }],
    nzPrefix: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzSuffix: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzSearch: [{
      type: Input
    }],
    nzCompact: [{
      type: Input
    }]
  });
})();
var _NzAutosizeDirective = class _NzAutosizeDirective {
  set nzAutosize(value) {
    const isAutoSizeType = (data) => typeof data !== "string" && typeof data !== "boolean" && (!!data.maxRows || !!data.minRows);
    if (typeof value === "string" || value === true) {
      this.autosize = true;
    } else if (isAutoSizeType(value)) {
      this.autosize = true;
      this.minRows = value.minRows;
      this.maxRows = value.maxRows;
      this.maxHeight = this.setMaxHeight();
      this.minHeight = this.setMinHeight();
    }
  }
  resizeToFitContent(force = false) {
    this.cacheTextareaLineHeight();
    if (!this.cachedLineHeight) {
      return;
    }
    const textarea = this.el;
    const value = textarea.value;
    if (!force && this.minRows === this.previousMinRows && value === this.previousValue) {
      return;
    }
    const placeholderText = textarea.placeholder;
    textarea.classList.add("nz-textarea-autosize-measuring");
    textarea.placeholder = "";
    let height = Math.round((textarea.scrollHeight - this.inputGap) / this.cachedLineHeight) * this.cachedLineHeight + this.inputGap;
    if (this.maxHeight !== null && height > this.maxHeight) {
      height = this.maxHeight;
    }
    if (this.minHeight !== null && height < this.minHeight) {
      height = this.minHeight;
    }
    textarea.style.height = `${height}px`;
    textarea.classList.remove("nz-textarea-autosize-measuring");
    textarea.placeholder = placeholderText;
    if (typeof requestAnimationFrame !== "undefined") {
      this.ngZone.runOutsideAngular(() => requestAnimationFrame(() => {
        const {
          selectionStart,
          selectionEnd
        } = textarea;
        if (!this.destroy$.isStopped && document.activeElement === textarea) {
          textarea.setSelectionRange(selectionStart, selectionEnd);
        }
      }));
    }
    this.previousValue = value;
    this.previousMinRows = this.minRows;
  }
  cacheTextareaLineHeight() {
    if (this.cachedLineHeight >= 0 || !this.el.parentNode) {
      return;
    }
    const textareaClone = this.el.cloneNode(false);
    textareaClone.rows = 1;
    textareaClone.style.position = "absolute";
    textareaClone.style.visibility = "hidden";
    textareaClone.style.border = "none";
    textareaClone.style.padding = "0";
    textareaClone.style.height = "";
    textareaClone.style.minHeight = "";
    textareaClone.style.maxHeight = "";
    textareaClone.style.overflow = "hidden";
    this.el.parentNode.appendChild(textareaClone);
    this.cachedLineHeight = textareaClone.clientHeight - this.inputGap;
    this.el.parentNode.removeChild(textareaClone);
    this.maxHeight = this.setMaxHeight();
    this.minHeight = this.setMinHeight();
  }
  setMinHeight() {
    const minHeight = this.minRows && this.cachedLineHeight ? this.minRows * this.cachedLineHeight + this.inputGap : null;
    if (minHeight !== null) {
      this.el.style.minHeight = `${minHeight}px`;
    }
    return minHeight;
  }
  setMaxHeight() {
    const maxHeight = this.maxRows && this.cachedLineHeight ? this.maxRows * this.cachedLineHeight + this.inputGap : null;
    if (maxHeight !== null) {
      this.el.style.maxHeight = `${maxHeight}px`;
    }
    return maxHeight;
  }
  noopInputHandler() {
  }
  constructor(elementRef, ngZone, platform, resizeService) {
    this.elementRef = elementRef;
    this.ngZone = ngZone;
    this.platform = platform;
    this.resizeService = resizeService;
    this.autosize = false;
    this.el = this.elementRef.nativeElement;
    this.maxHeight = null;
    this.minHeight = null;
    this.destroy$ = new Subject();
    this.inputGap = 10;
  }
  ngAfterViewInit() {
    if (this.autosize && this.platform.isBrowser) {
      this.resizeToFitContent();
      this.resizeService.subscribe().pipe(takeUntil(this.destroy$)).subscribe(() => this.resizeToFitContent(true));
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  ngDoCheck() {
    if (this.autosize && this.platform.isBrowser) {
      this.resizeToFitContent();
    }
  }
};
_NzAutosizeDirective.\u0275fac = function NzAutosizeDirective_Factory(t) {
  return new (t || _NzAutosizeDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(NzResizeService));
};
_NzAutosizeDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzAutosizeDirective,
  selectors: [["textarea", "nzAutosize", ""]],
  hostAttrs: ["rows", "1"],
  hostBindings: function NzAutosizeDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("input", function NzAutosizeDirective_input_HostBindingHandler() {
        return ctx.noopInputHandler();
      });
    }
  },
  inputs: {
    nzAutosize: "nzAutosize"
  },
  exportAs: ["nzAutosize"],
  standalone: true
});
var NzAutosizeDirective = _NzAutosizeDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAutosizeDirective, [{
    type: Directive,
    args: [{
      selector: "textarea[nzAutosize]",
      exportAs: "nzAutosize",
      host: {
        // Textarea elements that have the directive applied should have a single row by default.
        // Browsers normally show two rows by default and therefore this limits the minRows binding.
        rows: "1",
        "(input)": "noopInputHandler()"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: Platform
  }, {
    type: NzResizeService
  }], {
    nzAutosize: [{
      type: Input
    }]
  });
})();
var _NzTextareaCountComponent = class _NzTextareaCountComponent {
  constructor(renderer, elementRef) {
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.nzMaxCharacterCount = 0;
    this.nzComputeCharacterCount = (v) => v.length;
    this.nzFormatter = (c, m) => `${c}${m > 0 ? `/${m}` : ``}`;
    this.configChange$ = new Subject();
    this.destroy$ = new Subject();
  }
  ngAfterContentInit() {
    if (!this.nzInputDirective && isDevMode()) {
      throw new Error("[nz-textarea-count]: Could not find matching textarea[nz-input] child.");
    }
    if (this.nzInputDirective.ngControl) {
      const valueChanges = this.nzInputDirective.ngControl.valueChanges || EMPTY;
      merge(valueChanges, this.configChange$).pipe(takeUntil(this.destroy$), map(() => this.nzInputDirective.ngControl.value), startWith(this.nzInputDirective.ngControl.value)).subscribe((value) => {
        this.setDataCount(value);
      });
    }
  }
  setDataCount(value) {
    const inputValue = isNotNil(value) ? String(value) : "";
    const currentCount = this.nzComputeCharacterCount(inputValue);
    const dataCount = this.nzFormatter(currentCount, this.nzMaxCharacterCount);
    this.renderer.setAttribute(this.elementRef.nativeElement, "data-count", dataCount);
  }
  ngOnDestroy() {
    this.configChange$.complete();
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzTextareaCountComponent.\u0275fac = function NzTextareaCountComponent_Factory(t) {
  return new (t || _NzTextareaCountComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_NzTextareaCountComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTextareaCountComponent,
  selectors: [["nz-textarea-count"]],
  contentQueries: function NzTextareaCountComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzInputDirective, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzInputDirective = _t.first);
    }
  },
  hostAttrs: [1, "ant-input-textarea-show-count"],
  inputs: {
    nzMaxCharacterCount: "nzMaxCharacterCount",
    nzComputeCharacterCount: "nzComputeCharacterCount",
    nzFormatter: "nzFormatter"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c35,
  decls: 1,
  vars: 0,
  template: function NzTextareaCountComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c28);
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzTextareaCountComponent = _NzTextareaCountComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTextareaCountComponent, [{
    type: Component,
    args: [{
      selector: "nz-textarea-count",
      template: ` <ng-content select="textarea[nz-input]"></ng-content> `,
      host: {
        class: "ant-input-textarea-show-count"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    nzInputDirective: [{
      type: ContentChild,
      args: [NzInputDirective, {
        static: true
      }]
    }],
    nzMaxCharacterCount: [{
      type: Input
    }],
    nzComputeCharacterCount: [{
      type: Input
    }],
    nzFormatter: [{
      type: Input
    }]
  });
})();
var _NzInputModule = class _NzInputModule {
};
_NzInputModule.\u0275fac = function NzInputModule_Factory(t) {
  return new (t || _NzInputModule)();
};
_NzInputModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzInputModule
});
_NzInputModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzInputGroupComponent, NzInputGroupSlotComponent]
});
var NzInputModule = _NzInputModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputModule, [{
    type: NgModule,
    args: [{
      imports: [NzTextareaCountComponent, NzInputDirective, NzInputGroupComponent, NzAutosizeDirective, NzInputGroupSlotComponent, NzInputGroupWhitSuffixOrPrefixDirective],
      exports: [NzTextareaCountComponent, NzInputDirective, NzInputGroupComponent, NzAutosizeDirective, NzInputGroupWhitSuffixOrPrefixDirective]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-input-number.mjs
var _c017 = ["upHandler"];
var _c110 = ["downHandler"];
var _c29 = ["inputElement"];
function NzInputNumberComponent_nz_form_item_feedback_icon_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-form-item-feedback-icon", 11);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("status", ctx_r3.status);
  }
}
var _c36 = ["nz-input-number-group-slot", ""];
function NzInputNumberGroupSlotComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzType", ctx_r0.icon);
  }
}
function NzInputNumberGroupSlotComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r1.template);
  }
}
var _c44 = ["*"];
function NzInputNumberGroupComponent_span_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 7);
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r7.nzAddOnBeforeIcon)("template", ctx_r7.nzAddOnBefore);
  }
}
function NzInputNumberGroupComponent_span_0_div_2_ng_template_1_Template(rf, ctx) {
}
function NzInputNumberGroupComponent_span_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275template(1, NzInputNumberGroupComponent_span_0_div_2_ng_template_1_Template, 0, 0, "ng-template", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275classProp("ant-input-number-affix-wrapper-disabled", ctx_r8.disabled)("ant-input-number-affix-wrapper-sm", ctx_r8.isSmall)("ant-input-number-affix-wrapper-lg", ctx_r8.isLarge)("ant-input-number-affix-wrapper-focused", ctx_r8.focused);
    \u0275\u0275property("ngClass", ctx_r8.affixInGroupStatusCls);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r4);
  }
}
function NzInputNumberGroupComponent_span_0_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r9.nzAddOnAfterIcon)("template", ctx_r9.nzAddOnAfter);
  }
}
function NzInputNumberGroupComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 4);
    \u0275\u0275template(1, NzInputNumberGroupComponent_span_0_div_1_Template, 1, 2, "div", 5)(2, NzInputNumberGroupComponent_span_0_div_2_Template, 2, 10, "div", 6)(3, NzInputNumberGroupComponent_span_0_span_3_Template, 1, 2, "span", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzAddOnBefore || ctx_r0.nzAddOnBeforeIcon);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.isAffix || ctx_r0.hasFeedback)("ngIfElse", _r6);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzAddOnAfter || ctx_r0.nzAddOnAfterIcon);
  }
}
function NzInputNumberGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template(rf, ctx) {
}
function NzInputNumberGroupComponent_ng_template_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzInputNumberGroupComponent_ng_template_1_ng_template_0_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275property("ngTemplateOutlet", _r4);
  }
}
function NzInputNumberGroupComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzInputNumberGroupComponent_ng_template_1_ng_template_0_Template, 1, 1, "ng-template", 10);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275property("ngIf", ctx_r1.isAffix)("ngIfElse", _r6);
  }
}
function NzInputNumberGroupComponent_ng_template_3_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 13);
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r13.nzPrefixIcon)("template", ctx_r13.nzPrefix);
  }
}
function NzInputNumberGroupComponent_ng_template_3_ng_template_1_Template(rf, ctx) {
}
function NzInputNumberGroupComponent_ng_template_3_span_2_nz_form_item_feedback_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-form-item-feedback-icon", 16);
  }
  if (rf & 2) {
    const ctx_r16 = \u0275\u0275nextContext(3);
    \u0275\u0275property("status", ctx_r16.status);
  }
}
function NzInputNumberGroupComponent_ng_template_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275template(1, NzInputNumberGroupComponent_ng_template_3_span_2_nz_form_item_feedback_icon_1_Template, 1, 1, "nz-form-item-feedback-icon", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r15 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r15.nzSuffixIcon)("template", ctx_r15.nzSuffix);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r15.isFeedback);
  }
}
function NzInputNumberGroupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzInputNumberGroupComponent_ng_template_3_span_0_Template, 1, 2, "span", 11)(1, NzInputNumberGroupComponent_ng_template_3_ng_template_1_Template, 0, 0, "ng-template", 9)(2, NzInputNumberGroupComponent_ng_template_3_span_2_Template, 2, 3, "span", 12);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275property("ngIf", ctx_r3.nzPrefix || ctx_r3.nzPrefixIcon);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r6);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r3.nzSuffix || ctx_r3.nzSuffixIcon || ctx_r3.isFeedback);
  }
}
function NzInputNumberGroupComponent_ng_template_5_span_1_nz_form_item_feedback_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-form-item-feedback-icon", 16);
  }
  if (rf & 2) {
    const ctx_r18 = \u0275\u0275nextContext(3);
    \u0275\u0275property("status", ctx_r18.status);
  }
}
function NzInputNumberGroupComponent_ng_template_5_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275template(1, NzInputNumberGroupComponent_ng_template_5_span_1_nz_form_item_feedback_icon_1_Template, 1, 1, "nz-form-item-feedback-icon", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r17 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r17.isFeedback);
  }
}
function NzInputNumberGroupComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
    \u0275\u0275template(1, NzInputNumberGroupComponent_ng_template_5_span_1_Template, 2, 1, "span", 17);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r5.isAddOn && !ctx_r5.isAffix && ctx_r5.isFeedback);
  }
}
var _NzInputNumberComponent = class _NzInputNumberComponent {
  onModelChange(value) {
    this.parsedValue = this.nzParser(value);
    this.inputElement.nativeElement.value = `${this.parsedValue}`;
    const validValue = this.getCurrentValidValue(this.parsedValue);
    this.setValue(validValue);
  }
  getCurrentValidValue(value) {
    let val = value;
    if (val === "") {
      val = "";
    } else if (!this.isNotCompleteNumber(val)) {
      val = `${this.getValidValue(val)}`;
    } else {
      val = this.value;
    }
    return this.toNumber(val);
  }
  // '1.' '1x' 'xx' '' => are not complete numbers
  isNotCompleteNumber(num) {
    return isNaN(num) || num === "" || num === null || !!(num && num.toString().indexOf(".") === num.toString().length - 1);
  }
  getValidValue(value) {
    let val = parseFloat(value);
    if (isNaN(val)) {
      return value;
    }
    if (val < this.nzMin) {
      val = this.nzMin;
    }
    if (val > this.nzMax) {
      val = this.nzMax;
    }
    return val;
  }
  toNumber(num) {
    if (this.isNotCompleteNumber(num)) {
      return num;
    }
    const numStr = String(num);
    if (numStr.indexOf(".") >= 0 && isNotNil(this.nzPrecision)) {
      if (typeof this.nzPrecisionMode === "function") {
        return this.nzPrecisionMode(num, this.nzPrecision);
      } else if (this.nzPrecisionMode === "cut") {
        const numSplit = numStr.split(".");
        numSplit[1] = numSplit[1].slice(0, this.nzPrecision);
        return Number(numSplit.join("."));
      }
      return Number(Number(num).toFixed(this.nzPrecision));
    }
    return Number(num);
  }
  getRatio(e) {
    let ratio = 1;
    if (e.metaKey || e.ctrlKey) {
      ratio = 0.1;
    } else if (e.shiftKey) {
      ratio = 10;
    }
    return ratio;
  }
  down(e, ratio) {
    if (!this.isFocused) {
      this.focus();
    }
    this.step("down", e, ratio);
  }
  up(e, ratio) {
    if (!this.isFocused) {
      this.focus();
    }
    this.step("up", e, ratio);
  }
  getPrecision(value) {
    const valueString = value.toString();
    if (valueString.indexOf("e-") >= 0) {
      return parseInt(valueString.slice(valueString.indexOf("e-") + 2), 10);
    }
    let precision = 0;
    if (valueString.indexOf(".") >= 0) {
      precision = valueString.length - valueString.indexOf(".") - 1;
    }
    return precision;
  }
  // step={1.0} value={1.51}
  // press +
  // then value should be 2.51, rather than 2.5
  // if this.props.precision is undefined
  // https://github.com/react-component/input-number/issues/39
  getMaxPrecision(currentValue, ratio) {
    if (isNotNil(this.nzPrecision)) {
      return this.nzPrecision;
    }
    const ratioPrecision = this.getPrecision(ratio);
    const stepPrecision = this.getPrecision(this.nzStep);
    const currentValuePrecision = this.getPrecision(currentValue);
    if (!currentValue) {
      return ratioPrecision + stepPrecision;
    }
    return Math.max(currentValuePrecision, ratioPrecision + stepPrecision);
  }
  getPrecisionFactor(currentValue, ratio) {
    const precision = this.getMaxPrecision(currentValue, ratio);
    return Math.pow(10, precision);
  }
  upStep(val, rat) {
    const precisionFactor = this.getPrecisionFactor(val, rat);
    const precision = Math.abs(this.getMaxPrecision(val, rat));
    let result;
    if (typeof val === "number") {
      result = ((precisionFactor * val + precisionFactor * this.nzStep * rat) / precisionFactor).toFixed(precision);
    } else {
      result = this.nzMin === -Infinity ? this.nzStep : this.nzMin;
    }
    return this.toNumber(result);
  }
  downStep(val, rat) {
    const precisionFactor = this.getPrecisionFactor(val, rat);
    const precision = Math.abs(this.getMaxPrecision(val, rat));
    let result;
    if (typeof val === "number") {
      result = ((precisionFactor * val - precisionFactor * this.nzStep * rat) / precisionFactor).toFixed(precision);
    } else {
      result = this.nzMin === -Infinity ? -this.nzStep : this.nzMin;
    }
    return this.toNumber(result);
  }
  step(type, e, ratio = 1) {
    this.stop();
    e.preventDefault();
    if (this.nzDisabled) {
      return;
    }
    const value = this.getCurrentValidValue(this.parsedValue) || 0;
    let val = 0;
    if (type === "up") {
      val = this.upStep(value, ratio);
    } else if (type === "down") {
      val = this.downStep(value, ratio);
    }
    const outOfRange = val > this.nzMax || val < this.nzMin;
    if (val > this.nzMax) {
      val = this.nzMax;
    } else if (val < this.nzMin) {
      val = this.nzMin;
    }
    this.setValue(val);
    this.updateDisplayValue(val);
    this.isFocused = true;
    if (outOfRange) {
      return;
    }
    this.autoStepTimer = setTimeout(() => {
      this[type](e, ratio);
    }, 300);
  }
  stop() {
    if (this.autoStepTimer) {
      clearTimeout(this.autoStepTimer);
    }
  }
  setValue(value) {
    if (`${this.value}` !== `${value}`) {
      this.onChange(value);
    }
    this.value = value;
    this.parsedValue = value;
    this.disabledUp = this.disabledDown = false;
    if (value || value === 0) {
      const val = Number(value);
      if (val >= this.nzMax) {
        this.disabledUp = true;
      }
      if (val <= this.nzMin) {
        this.disabledDown = true;
      }
    }
  }
  updateDisplayValue(value) {
    const displayValue = isNotNil(this.nzFormatter(value)) ? this.nzFormatter(value) : "";
    this.displayValue = displayValue;
    this.inputElement.nativeElement.value = `${displayValue}`;
  }
  writeValue(value) {
    this.value = value;
    this.setValue(value);
    this.updateDisplayValue(value);
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(disabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || disabled;
    this.isNzDisableFirstChange = false;
    this.disabled$.next(this.nzDisabled);
    this.cdr.markForCheck();
  }
  focus() {
    this.focusMonitor.focusVia(this.inputElement, "keyboard");
  }
  blur() {
    this.inputElement.nativeElement.blur();
  }
  constructor(ngZone, elementRef, cdr, focusMonitor, renderer, directionality, destroy$, nzFormStatusService, nzFormNoStatusService) {
    this.ngZone = ngZone;
    this.elementRef = elementRef;
    this.cdr = cdr;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.directionality = directionality;
    this.destroy$ = destroy$;
    this.nzFormStatusService = nzFormStatusService;
    this.nzFormNoStatusService = nzFormNoStatusService;
    this.isNzDisableFirstChange = true;
    this.isFocused = false;
    this.disabled$ = new Subject();
    this.disabledUp = false;
    this.disabledDown = false;
    this.dir = "ltr";
    this.prefixCls = "ant-input-number";
    this.status = "";
    this.statusCls = {};
    this.hasFeedback = false;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.nzBlur = new EventEmitter();
    this.nzFocus = new EventEmitter();
    this.nzSize = "default";
    this.nzMin = -Infinity;
    this.nzMax = Infinity;
    this.nzParser = (value) => value.trim().replace(/。/g, ".").replace(/[^\w\.-]+/g, "");
    this.nzPrecisionMode = "toFixed";
    this.nzPlaceHolder = "";
    this.nzStatus = "";
    this.nzStep = 1;
    this.nzInputMode = "decimal";
    this.nzId = null;
    this.nzDisabled = false;
    this.nzReadOnly = false;
    this.nzAutoFocus = false;
    this.nzBorderless = false;
    this.nzFormatter = (value) => value;
  }
  ngOnInit() {
    this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {
      return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;
    }), takeUntil(this.destroy$)).subscribe(({
      status,
      hasFeedback
    }) => {
      this.setStatusStyles(status, hasFeedback);
    });
    this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe((focusOrigin) => {
      if (!focusOrigin) {
        this.isFocused = false;
        this.updateDisplayValue(this.value);
        this.nzBlur.emit();
        Promise.resolve().then(() => this.onTouched());
      } else {
        this.isFocused = true;
        this.nzFocus.emit();
      }
    });
    this.dir = this.directionality.value;
    this.directionality.change.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
    this.setupHandlersListeners();
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.inputElement.nativeElement, "keyup").pipe(takeUntil(this.destroy$)).subscribe(() => this.stop());
      fromEvent(this.inputElement.nativeElement, "keydown").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        const {
          keyCode
        } = event;
        if (keyCode !== UP_ARROW && keyCode !== DOWN_ARROW && keyCode !== ENTER) {
          return;
        }
        this.ngZone.run(() => {
          if (keyCode === UP_ARROW) {
            const ratio = this.getRatio(event);
            this.up(event, ratio);
            this.stop();
          } else if (keyCode === DOWN_ARROW) {
            const ratio = this.getRatio(event);
            this.down(event, ratio);
            this.stop();
          } else {
            this.updateDisplayValue(this.value);
          }
          this.cdr.markForCheck();
        });
      });
    });
  }
  ngOnChanges(changes) {
    const {
      nzStatus,
      nzDisabled
    } = changes;
    if (changes.nzFormatter && !changes.nzFormatter.isFirstChange()) {
      const validValue = this.getCurrentValidValue(this.parsedValue);
      this.setValue(validValue);
      this.updateDisplayValue(validValue);
    }
    if (nzDisabled) {
      this.disabled$.next(this.nzDisabled);
    }
    if (nzStatus) {
      this.setStatusStyles(this.nzStatus, this.hasFeedback);
    }
  }
  ngAfterViewInit() {
    if (this.nzAutoFocus) {
      this.focus();
    }
  }
  ngOnDestroy() {
    this.focusMonitor.stopMonitoring(this.elementRef);
  }
  setupHandlersListeners() {
    this.ngZone.runOutsideAngular(() => {
      merge(fromEvent(this.upHandler.nativeElement, "mouseup"), fromEvent(this.upHandler.nativeElement, "mouseleave"), fromEvent(this.downHandler.nativeElement, "mouseup"), fromEvent(this.downHandler.nativeElement, "mouseleave")).pipe(takeUntil(this.destroy$)).subscribe(() => this.stop());
    });
  }
  setStatusStyles(status, hasFeedback) {
    this.status = status;
    this.hasFeedback = hasFeedback;
    this.cdr.markForCheck();
    this.statusCls = getStatusClassNames(this.prefixCls, status, hasFeedback);
    Object.keys(this.statusCls).forEach((status2) => {
      if (this.statusCls[status2]) {
        this.renderer.addClass(this.elementRef.nativeElement, status2);
      } else {
        this.renderer.removeClass(this.elementRef.nativeElement, status2);
      }
    });
  }
};
_NzInputNumberComponent.\u0275fac = function NzInputNumberComponent_Factory(t) {
  return new (t || _NzInputNumberComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(FocusMonitor), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzDestroyService), \u0275\u0275directiveInject(NzFormStatusService, 8), \u0275\u0275directiveInject(NzFormNoStatusService, 8));
};
_NzInputNumberComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzInputNumberComponent,
  selectors: [["nz-input-number"]],
  viewQuery: function NzInputNumberComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c017, 7);
      \u0275\u0275viewQuery(_c110, 7);
      \u0275\u0275viewQuery(_c29, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.upHandler = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.downHandler = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inputElement = _t.first);
    }
  },
  hostAttrs: [1, "ant-input-number"],
  hostVars: 16,
  hostBindings: function NzInputNumberComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-input-number-in-form-item", !!ctx.nzFormStatusService)("ant-input-number-focused", ctx.isFocused)("ant-input-number-lg", ctx.nzSize === "large")("ant-input-number-sm", ctx.nzSize === "small")("ant-input-number-disabled", ctx.nzDisabled)("ant-input-number-readonly", ctx.nzReadOnly)("ant-input-number-rtl", ctx.dir === "rtl")("ant-input-number-borderless", ctx.nzBorderless);
    }
  },
  inputs: {
    nzSize: "nzSize",
    nzMin: "nzMin",
    nzMax: "nzMax",
    nzParser: "nzParser",
    nzPrecision: "nzPrecision",
    nzPrecisionMode: "nzPrecisionMode",
    nzPlaceHolder: "nzPlaceHolder",
    nzStatus: "nzStatus",
    nzStep: "nzStep",
    nzInputMode: "nzInputMode",
    nzId: "nzId",
    nzDisabled: "nzDisabled",
    nzReadOnly: "nzReadOnly",
    nzAutoFocus: "nzAutoFocus",
    nzBorderless: "nzBorderless",
    nzFormatter: "nzFormatter"
  },
  outputs: {
    nzBlur: "nzBlur",
    nzFocus: "nzFocus"
  },
  exportAs: ["nzInputNumber"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NzInputNumberComponent),
    multi: true
  }, NzDestroyService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 11,
  vars: 15,
  consts: [[1, "ant-input-number-handler-wrap"], ["unselectable", "unselectable", 1, "ant-input-number-handler", "ant-input-number-handler-up", 3, "mousedown"], ["upHandler", ""], ["nz-icon", "", "nzType", "up", 1, "ant-input-number-handler-up-inner"], ["unselectable", "unselectable", 1, "ant-input-number-handler", "ant-input-number-handler-down", 3, "mousedown"], ["downHandler", ""], ["nz-icon", "", "nzType", "down", 1, "ant-input-number-handler-down-inner"], [1, "ant-input-number-input-wrap"], ["autocomplete", "off", 1, "ant-input-number-input", 3, "disabled", "placeholder", "readOnly", "ngModel", "ngModelChange"], ["inputElement", ""], ["class", "ant-input-number-suffix", 3, "status", 4, "ngIf"], [1, "ant-input-number-suffix", 3, "status"]],
  template: function NzInputNumberComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "span", 1, 2);
      \u0275\u0275listener("mousedown", function NzInputNumberComponent_Template_span_mousedown_1_listener($event) {
        return ctx.up($event);
      });
      \u0275\u0275element(3, "span", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "span", 4, 5);
      \u0275\u0275listener("mousedown", function NzInputNumberComponent_Template_span_mousedown_4_listener($event) {
        return ctx.down($event);
      });
      \u0275\u0275element(6, "span", 6);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(7, "div", 7)(8, "input", 8, 9);
      \u0275\u0275listener("ngModelChange", function NzInputNumberComponent_Template_input_ngModelChange_8_listener($event) {
        return ctx.onModelChange($event);
      });
      \u0275\u0275elementEnd()();
      \u0275\u0275template(10, NzInputNumberComponent_nz_form_item_feedback_icon_10_Template, 1, 1, "nz-form-item-feedback-icon", 10);
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275classProp("ant-input-number-handler-up-disabled", ctx.disabledUp);
      \u0275\u0275advance(3);
      \u0275\u0275classProp("ant-input-number-handler-down-disabled", ctx.disabledDown);
      \u0275\u0275advance(4);
      \u0275\u0275property("disabled", ctx.nzDisabled)("placeholder", ctx.nzPlaceHolder)("readOnly", ctx.nzReadOnly)("ngModel", ctx.displayValue);
      \u0275\u0275attribute("id", ctx.nzId)("autofocus", ctx.nzAutoFocus ? "autofocus" : null)("min", ctx.nzMin)("max", ctx.nzMax)("step", ctx.nzStep)("inputmode", ctx.nzInputMode);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.hasFeedback && !!ctx.status && !ctx.nzFormNoStatusService);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, NzFormPatchModule, NzFormItemFeedbackIconComponent, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NzInputNumberComponent = _NzInputNumberComponent;
__decorate([InputBoolean()], NzInputNumberComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzInputNumberComponent.prototype, "nzReadOnly", void 0);
__decorate([InputBoolean()], NzInputNumberComponent.prototype, "nzAutoFocus", void 0);
__decorate([InputBoolean()], NzInputNumberComponent.prototype, "nzBorderless", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputNumberComponent, [{
    type: Component,
    args: [{
      selector: "nz-input-number",
      exportAs: "nzInputNumber",
      template: `
    <div class="ant-input-number-handler-wrap">
      <span
        #upHandler
        unselectable="unselectable"
        class="ant-input-number-handler ant-input-number-handler-up"
        (mousedown)="up($event)"
        [class.ant-input-number-handler-up-disabled]="disabledUp"
      >
        <span nz-icon nzType="up" class="ant-input-number-handler-up-inner"></span>
      </span>
      <span
        #downHandler
        unselectable="unselectable"
        class="ant-input-number-handler ant-input-number-handler-down"
        (mousedown)="down($event)"
        [class.ant-input-number-handler-down-disabled]="disabledDown"
      >
        <span nz-icon nzType="down" class="ant-input-number-handler-down-inner"></span>
      </span>
    </div>
    <div class="ant-input-number-input-wrap">
      <input
        #inputElement
        autocomplete="off"
        class="ant-input-number-input"
        [attr.id]="nzId"
        [attr.autofocus]="nzAutoFocus ? 'autofocus' : null"
        [disabled]="nzDisabled"
        [attr.min]="nzMin"
        [attr.max]="nzMax"
        [placeholder]="nzPlaceHolder"
        [attr.step]="nzStep"
        [readOnly]="nzReadOnly"
        [attr.inputmode]="nzInputMode"
        [ngModel]="displayValue"
        (ngModelChange)="onModelChange($event)"
      />
    </div>
    <nz-form-item-feedback-icon
      class="ant-input-number-suffix"
      *ngIf="hasFeedback && !!status && !nzFormNoStatusService"
      [status]="status"
    ></nz-form-item-feedback-icon>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NzInputNumberComponent),
        multi: true
      }, NzDestroyService],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      host: {
        class: "ant-input-number",
        "[class.ant-input-number-in-form-item]": "!!nzFormStatusService",
        "[class.ant-input-number-focused]": "isFocused",
        "[class.ant-input-number-lg]": `nzSize === 'large'`,
        "[class.ant-input-number-sm]": `nzSize === 'small'`,
        "[class.ant-input-number-disabled]": "nzDisabled",
        "[class.ant-input-number-readonly]": "nzReadOnly",
        "[class.ant-input-number-rtl]": `dir === 'rtl'`,
        "[class.ant-input-number-borderless]": `nzBorderless`
      },
      imports: [NzIconModule, FormsModule, NzFormPatchModule, NgIf],
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: FocusMonitor
  }, {
    type: Renderer2
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzDestroyService
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormNoStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    nzBlur: [{
      type: Output
    }],
    nzFocus: [{
      type: Output
    }],
    upHandler: [{
      type: ViewChild,
      args: ["upHandler", {
        static: true
      }]
    }],
    downHandler: [{
      type: ViewChild,
      args: ["downHandler", {
        static: true
      }]
    }],
    inputElement: [{
      type: ViewChild,
      args: ["inputElement", {
        static: true
      }]
    }],
    nzSize: [{
      type: Input
    }],
    nzMin: [{
      type: Input
    }],
    nzMax: [{
      type: Input
    }],
    nzParser: [{
      type: Input
    }],
    nzPrecision: [{
      type: Input
    }],
    nzPrecisionMode: [{
      type: Input
    }],
    nzPlaceHolder: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzStep: [{
      type: Input
    }],
    nzInputMode: [{
      type: Input
    }],
    nzId: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzReadOnly: [{
      type: Input
    }],
    nzAutoFocus: [{
      type: Input
    }],
    nzBorderless: [{
      type: Input
    }],
    nzFormatter: [{
      type: Input
    }]
  });
})();
var _NzInputNumberGroupSlotComponent = class _NzInputNumberGroupSlotComponent {
  constructor() {
    this.icon = null;
    this.type = null;
    this.template = null;
  }
};
_NzInputNumberGroupSlotComponent.\u0275fac = function NzInputNumberGroupSlotComponent_Factory(t) {
  return new (t || _NzInputNumberGroupSlotComponent)();
};
_NzInputNumberGroupSlotComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzInputNumberGroupSlotComponent,
  selectors: [["", "nz-input-number-group-slot", ""]],
  hostVars: 6,
  hostBindings: function NzInputNumberGroupSlotComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-input-number-group-addon", ctx.type === "addon")("ant-input-number-prefix", ctx.type === "prefix")("ant-input-number-suffix", ctx.type === "suffix");
    }
  },
  inputs: {
    icon: "icon",
    type: "type",
    template: "template"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c36,
  ngContentSelectors: _c44,
  decls: 3,
  vars: 2,
  consts: [["nz-icon", "", 3, "nzType", 4, "ngIf"], [4, "nzStringTemplateOutlet"], ["nz-icon", "", 3, "nzType"]],
  template: function NzInputNumberGroupSlotComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzInputNumberGroupSlotComponent_span_0_Template, 1, 1, "span", 0)(1, NzInputNumberGroupSlotComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
      \u0275\u0275projection(2);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.icon);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.template);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NgIf, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzInputNumberGroupSlotComponent = _NzInputNumberGroupSlotComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputNumberGroupSlotComponent, [{
    type: Component,
    args: [{
      selector: "[nz-input-number-group-slot]",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span nz-icon [nzType]="icon" *ngIf="icon"></span>
    <ng-container *nzStringTemplateOutlet="template">{{ template }}</ng-container>
    <ng-content></ng-content>
  `,
      host: {
        "[class.ant-input-number-group-addon]": `type === 'addon'`,
        "[class.ant-input-number-prefix]": `type === 'prefix'`,
        "[class.ant-input-number-suffix]": `type === 'suffix'`
      },
      imports: [NzIconModule, NgIf, NzOutletModule],
      standalone: true
    }]
  }], null, {
    icon: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    template: [{
      type: Input
    }]
  });
})();
var _NzInputNumberGroupWhitSuffixOrPrefixDirective = class _NzInputNumberGroupWhitSuffixOrPrefixDirective {
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
};
_NzInputNumberGroupWhitSuffixOrPrefixDirective.\u0275fac = function NzInputNumberGroupWhitSuffixOrPrefixDirective_Factory(t) {
  return new (t || _NzInputNumberGroupWhitSuffixOrPrefixDirective)(\u0275\u0275directiveInject(ElementRef));
};
_NzInputNumberGroupWhitSuffixOrPrefixDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzInputNumberGroupWhitSuffixOrPrefixDirective,
  selectors: [["nz-input-number-group", "nzSuffix", ""], ["nz-input-number-group", "nzPrefix", ""]],
  standalone: true
});
var NzInputNumberGroupWhitSuffixOrPrefixDirective = _NzInputNumberGroupWhitSuffixOrPrefixDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputNumberGroupWhitSuffixOrPrefixDirective, [{
    type: Directive,
    args: [{
      selector: `nz-input-number-group[nzSuffix], nz-input-number-group[nzPrefix]`,
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], null);
})();
var _NzInputNumberGroupComponent = class _NzInputNumberGroupComponent {
  constructor(focusMonitor, elementRef, renderer, cdr, directionality, nzFormStatusService, nzFormNoStatusService) {
    this.focusMonitor = focusMonitor;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.cdr = cdr;
    this.directionality = directionality;
    this.nzFormStatusService = nzFormStatusService;
    this.nzFormNoStatusService = nzFormNoStatusService;
    this.nzAddOnBeforeIcon = null;
    this.nzAddOnAfterIcon = null;
    this.nzPrefixIcon = null;
    this.nzSuffixIcon = null;
    this.nzStatus = "";
    this.nzSize = "default";
    this.nzCompact = false;
    this.isLarge = false;
    this.isSmall = false;
    this.isAffix = false;
    this.isAddOn = false;
    this.isFeedback = false;
    this.focused = false;
    this.disabled = false;
    this.dir = "ltr";
    this.prefixCls = "ant-input-number";
    this.affixStatusCls = {};
    this.groupStatusCls = {};
    this.affixInGroupStatusCls = {};
    this.status = "";
    this.hasFeedback = false;
    this.destroy$ = new Subject();
  }
  updateChildrenInputSize() {
    if (this.listOfNzInputNumberComponent) {
      this.listOfNzInputNumberComponent.forEach((item) => item.nzSize = this.nzSize);
    }
  }
  ngOnInit() {
    this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {
      return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;
    }), takeUntil(this.destroy$)).subscribe(({
      status,
      hasFeedback
    }) => {
      this.setStatusStyles(status, hasFeedback);
    });
    this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe((focusOrigin) => {
      this.focused = !!focusOrigin;
      this.cdr.markForCheck();
    });
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngAfterContentInit() {
    this.updateChildrenInputSize();
    const listOfInputChange$ = this.listOfNzInputNumberComponent.changes.pipe(startWith(this.listOfNzInputNumberComponent));
    listOfInputChange$.pipe(switchMap((list2) => merge(...[listOfInputChange$, ...list2.map((input) => input.disabled$)])), mergeMap(() => listOfInputChange$), map((list2) => list2.some((input) => input.nzDisabled)), takeUntil(this.destroy$)).subscribe((disabled) => {
      this.disabled = disabled;
      this.cdr.markForCheck();
    });
  }
  ngOnChanges(changes) {
    const {
      nzSize,
      nzSuffix,
      nzPrefix,
      nzPrefixIcon,
      nzSuffixIcon,
      nzAddOnAfter,
      nzAddOnBefore,
      nzAddOnAfterIcon,
      nzAddOnBeforeIcon,
      nzStatus
    } = changes;
    if (nzSize) {
      this.updateChildrenInputSize();
      this.isLarge = this.nzSize === "large";
      this.isSmall = this.nzSize === "small";
    }
    if (nzSuffix || nzPrefix || nzPrefixIcon || nzSuffixIcon) {
      this.isAffix = !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);
    }
    if (nzAddOnAfter || nzAddOnBefore || nzAddOnAfterIcon || nzAddOnBeforeIcon) {
      this.isAddOn = !!(this.nzAddOnAfter || this.nzAddOnBefore || this.nzAddOnAfterIcon || this.nzAddOnBeforeIcon);
      this.nzFormNoStatusService?.noFormStatus?.next(this.isAddOn);
    }
    if (nzStatus) {
      this.setStatusStyles(this.nzStatus, this.hasFeedback);
    }
  }
  ngOnDestroy() {
    this.focusMonitor.stopMonitoring(this.elementRef);
    this.destroy$.next();
    this.destroy$.complete();
  }
  setStatusStyles(status, hasFeedback) {
    this.status = status;
    this.hasFeedback = hasFeedback;
    this.isFeedback = !!status && hasFeedback;
    const baseAffix = !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);
    this.isAffix = baseAffix || !this.isAddOn && hasFeedback;
    this.affixInGroupStatusCls = this.isAffix || this.isFeedback ? this.affixStatusCls = getStatusClassNames(`${this.prefixCls}-affix-wrapper`, status, hasFeedback) : {};
    this.cdr.markForCheck();
    this.affixStatusCls = getStatusClassNames(`${this.prefixCls}-affix-wrapper`, this.isAddOn ? "" : status, this.isAddOn ? false : hasFeedback);
    this.groupStatusCls = getStatusClassNames(`${this.prefixCls}-group-wrapper`, this.isAddOn ? status : "", this.isAddOn ? hasFeedback : false);
    const statusCls = __spreadValues(__spreadValues({}, this.affixStatusCls), this.groupStatusCls);
    Object.keys(statusCls).forEach((status2) => {
      if (statusCls[status2]) {
        this.renderer.addClass(this.elementRef.nativeElement, status2);
      } else {
        this.renderer.removeClass(this.elementRef.nativeElement, status2);
      }
    });
  }
};
_NzInputNumberGroupComponent.\u0275fac = function NzInputNumberGroupComponent_Factory(t) {
  return new (t || _NzInputNumberGroupComponent)(\u0275\u0275directiveInject(FocusMonitor), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzFormStatusService, 8), \u0275\u0275directiveInject(NzFormNoStatusService, 8));
};
_NzInputNumberGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzInputNumberGroupComponent,
  selectors: [["nz-input-number-group"]],
  contentQueries: function NzInputNumberGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzInputNumberComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfNzInputNumberComponent = _t);
    }
  },
  hostVars: 24,
  hostBindings: function NzInputNumberGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-input-number-group", ctx.nzCompact)("ant-input-number-group-compact", ctx.nzCompact)("ant-input-number-group-wrapper", ctx.isAddOn)("ant-input-number-group-wrapper-rtl", ctx.isAddOn && ctx.dir === "rtl")("ant-input-number-group-wrapper-lg", ctx.isAddOn && ctx.isLarge)("ant-input-number-group-wrapper-sm", ctx.isAddOn && ctx.isSmall)("ant-input-number-affix-wrapper", !ctx.isAddOn && ctx.isAffix)("ant-input-number-affix-wrapper-rtl", !ctx.isAddOn && ctx.dir === "rtl")("ant-input-number-affix-wrapper-focused", !ctx.isAddOn && ctx.isAffix && ctx.focused)("ant-input-number-affix-wrapper-disabled", !ctx.isAddOn && ctx.isAffix && ctx.disabled)("ant-input-number-affix-wrapper-lg", !ctx.isAddOn && ctx.isAffix && ctx.isLarge)("ant-input-number-affix-wrapper-sm", !ctx.isAddOn && ctx.isAffix && ctx.isSmall);
    }
  },
  inputs: {
    nzAddOnBeforeIcon: "nzAddOnBeforeIcon",
    nzAddOnAfterIcon: "nzAddOnAfterIcon",
    nzPrefixIcon: "nzPrefixIcon",
    nzSuffixIcon: "nzSuffixIcon",
    nzAddOnBefore: "nzAddOnBefore",
    nzAddOnAfter: "nzAddOnAfter",
    nzPrefix: "nzPrefix",
    nzStatus: "nzStatus",
    nzSuffix: "nzSuffix",
    nzSize: "nzSize",
    nzCompact: "nzCompact"
  },
  exportAs: ["nzInputNumberGroup"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzFormNoStatusService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c44,
  decls: 7,
  vars: 2,
  consts: [["class", "ant-input-number-wrapper ant-input-number-group", 4, "ngIf", "ngIfElse"], ["noAddOnTemplate", ""], ["affixTemplate", ""], ["contentTemplate", ""], [1, "ant-input-number-wrapper", "ant-input-number-group"], ["nz-input-number-group-slot", "", "type", "addon", 3, "icon", "template", 4, "ngIf"], ["class", "ant-input-number-affix-wrapper", 3, "ant-input-number-affix-wrapper-disabled", "ant-input-number-affix-wrapper-sm", "ant-input-number-affix-wrapper-lg", "ant-input-number-affix-wrapper-focused", "ngClass", 4, "ngIf", "ngIfElse"], ["nz-input-number-group-slot", "", "type", "addon", 3, "icon", "template"], [1, "ant-input-number-affix-wrapper", 3, "ngClass"], [3, "ngTemplateOutlet"], [3, "ngIf", "ngIfElse"], ["nz-input-number-group-slot", "", "type", "prefix", 3, "icon", "template", 4, "ngIf"], ["nz-input-number-group-slot", "", "type", "suffix", 3, "icon", "template", 4, "ngIf"], ["nz-input-number-group-slot", "", "type", "prefix", 3, "icon", "template"], ["nz-input-number-group-slot", "", "type", "suffix", 3, "icon", "template"], [3, "status", 4, "ngIf"], [3, "status"], ["nz-input-number-group-slot", "", "type", "suffix", 4, "ngIf"], ["nz-input-number-group-slot", "", "type", "suffix"]],
  template: function NzInputNumberGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzInputNumberGroupComponent_span_0_Template, 4, 4, "span", 0)(1, NzInputNumberGroupComponent_ng_template_1_Template, 1, 2, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, NzInputNumberGroupComponent_ng_template_3_Template, 3, 3, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(5, NzInputNumberGroupComponent_ng_template_5_Template, 2, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.isAddOn)("ngIfElse", _r2);
    }
  },
  dependencies: [NgIf, NzInputNumberGroupSlotComponent, NgClass, NgTemplateOutlet, NzFormPatchModule, NzFormItemFeedbackIconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzInputNumberGroupComponent = _NzInputNumberGroupComponent;
__decorate([InputBoolean()], NzInputNumberGroupComponent.prototype, "nzCompact", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputNumberGroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-input-number-group",
      exportAs: "nzInputNumberGroup",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [NzFormNoStatusService],
      template: `
    <span class="ant-input-number-wrapper ant-input-number-group" *ngIf="isAddOn; else noAddOnTemplate">
      <div
        *ngIf="nzAddOnBefore || nzAddOnBeforeIcon"
        nz-input-number-group-slot
        type="addon"
        [icon]="nzAddOnBeforeIcon"
        [template]="nzAddOnBefore"
      ></div>
      <div
        *ngIf="isAffix || hasFeedback; else contentTemplate"
        class="ant-input-number-affix-wrapper"
        [class.ant-input-number-affix-wrapper-disabled]="disabled"
        [class.ant-input-number-affix-wrapper-sm]="isSmall"
        [class.ant-input-number-affix-wrapper-lg]="isLarge"
        [class.ant-input-number-affix-wrapper-focused]="focused"
        [ngClass]="affixInGroupStatusCls"
      >
        <ng-template [ngTemplateOutlet]="affixTemplate"></ng-template>
      </div>
      <span
        *ngIf="nzAddOnAfter || nzAddOnAfterIcon"
        nz-input-number-group-slot
        type="addon"
        [icon]="nzAddOnAfterIcon"
        [template]="nzAddOnAfter"
      ></span>
    </span>
    <ng-template #noAddOnTemplate>
      <ng-template [ngIf]="isAffix" [ngIfElse]="contentTemplate">
        <ng-template [ngTemplateOutlet]="affixTemplate"></ng-template>
      </ng-template>
    </ng-template>
    <ng-template #affixTemplate>
      <span
        *ngIf="nzPrefix || nzPrefixIcon"
        nz-input-number-group-slot
        type="prefix"
        [icon]="nzPrefixIcon"
        [template]="nzPrefix"
      ></span>
      <ng-template [ngTemplateOutlet]="contentTemplate"></ng-template>
      <span
        *ngIf="nzSuffix || nzSuffixIcon || isFeedback"
        nz-input-number-group-slot
        type="suffix"
        [icon]="nzSuffixIcon"
        [template]="nzSuffix"
      >
        <nz-form-item-feedback-icon *ngIf="isFeedback" [status]="status"></nz-form-item-feedback-icon>
      </span>
    </ng-template>
    <ng-template #contentTemplate>
      <ng-content></ng-content>
      <span *ngIf="!isAddOn && !isAffix && isFeedback" nz-input-number-group-slot type="suffix">
        <nz-form-item-feedback-icon *ngIf="isFeedback" [status]="status"></nz-form-item-feedback-icon>
      </span>
    </ng-template>
  `,
      host: {
        "[class.ant-input-number-group]": "nzCompact",
        "[class.ant-input-number-group-compact]": "nzCompact",
        "[class.ant-input-number-group-wrapper]": `isAddOn`,
        "[class.ant-input-number-group-wrapper-rtl]": `isAddOn && dir === 'rtl'`,
        "[class.ant-input-number-group-wrapper-lg]": `isAddOn && isLarge`,
        "[class.ant-input-number-group-wrapper-sm]": `isAddOn && isSmall`,
        "[class.ant-input-number-affix-wrapper]": `!isAddOn && isAffix`,
        "[class.ant-input-number-affix-wrapper-rtl]": `!isAddOn && dir === 'rtl'`,
        "[class.ant-input-number-affix-wrapper-focused]": `!isAddOn && isAffix && focused`,
        "[class.ant-input-number-affix-wrapper-disabled]": `!isAddOn && isAffix && disabled`,
        "[class.ant-input-number-affix-wrapper-lg]": `!isAddOn && isAffix && isLarge`,
        "[class.ant-input-number-affix-wrapper-sm]": `!isAddOn && isAffix && isSmall`
      },
      imports: [NgIf, NzInputNumberGroupSlotComponent, NgClass, NgTemplateOutlet, NzFormPatchModule],
      standalone: true
    }]
  }], () => [{
    type: FocusMonitor
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormNoStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    listOfNzInputNumberComponent: [{
      type: ContentChildren,
      args: [NzInputNumberComponent, {
        descendants: true
      }]
    }],
    nzAddOnBeforeIcon: [{
      type: Input
    }],
    nzAddOnAfterIcon: [{
      type: Input
    }],
    nzPrefixIcon: [{
      type: Input
    }],
    nzSuffixIcon: [{
      type: Input
    }],
    nzAddOnBefore: [{
      type: Input
    }],
    nzAddOnAfter: [{
      type: Input
    }],
    nzPrefix: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzSuffix: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzCompact: [{
      type: Input
    }]
  });
})();
var _NzInputNumberModule = class _NzInputNumberModule {
};
_NzInputNumberModule.\u0275fac = function NzInputNumberModule_Factory(t) {
  return new (t || _NzInputNumberModule)();
};
_NzInputNumberModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzInputNumberModule
});
_NzInputNumberModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzInputNumberComponent, NzInputNumberGroupComponent, NzInputNumberGroupSlotComponent]
});
var NzInputNumberModule = _NzInputNumberModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzInputNumberModule, [{
    type: NgModule,
    args: [{
      imports: [NzInputNumberComponent, NzInputNumberGroupComponent, NzInputNumberGroupWhitSuffixOrPrefixDirective, NzInputNumberGroupSlotComponent],
      exports: [NzInputNumberComponent, NzInputNumberGroupComponent, NzInputNumberGroupWhitSuffixOrPrefixDirective]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-time-picker.mjs
var _c018 = ["hourListElement"];
var _c111 = ["minuteListElement"];
var _c210 = ["secondListElement"];
var _c37 = ["use12HoursListElement"];
function NzTimePickerPanelComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.dateHelper.format(ctx_r0.time == null ? null : ctx_r0.time.value, ctx_r0.format) || "\xA0");
  }
}
function NzTimePickerPanelComponent_ul_2_ng_container_2_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 10);
    \u0275\u0275listener("click", function NzTimePickerPanelComponent_ul_2_ng_container_2_li_1_Template_li_click_0_listener() {
      \u0275\u0275restoreView(_r12);
      const hour_r8 = \u0275\u0275nextContext().$implicit;
      const ctx_r10 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r10.selectHour(hour_r8));
    });
    \u0275\u0275elementStart(1, "div", 11);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "number");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const hour_r8 = \u0275\u0275nextContext().$implicit;
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("ant-picker-time-panel-cell-selected", ctx_r9.isSelectedHour(hour_r8))("ant-picker-time-panel-cell-disabled", hour_r8.disabled);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(3, 5, hour_r8.index, "2.0-0"));
  }
}
function NzTimePickerPanelComponent_ul_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTimePickerPanelComponent_ul_2_ng_container_2_li_1_Template, 4, 8, "li", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const hour_r8 = ctx.$implicit;
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !(ctx_r7.nzHideDisabledOptions && hour_r8.disabled));
  }
}
function NzTimePickerPanelComponent_ul_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 6, 7);
    \u0275\u0275template(2, NzTimePickerPanelComponent_ul_2_ng_container_2_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.hourRange)("ngForTrackBy", ctx_r1.trackByFn);
  }
}
function NzTimePickerPanelComponent_ul_3_ng_container_2_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 10);
    \u0275\u0275listener("click", function NzTimePickerPanelComponent_ul_3_ng_container_2_li_1_Template_li_click_0_listener() {
      \u0275\u0275restoreView(_r20);
      const minute_r16 = \u0275\u0275nextContext().$implicit;
      const ctx_r18 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r18.selectMinute(minute_r16));
    });
    \u0275\u0275elementStart(1, "div", 11);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "number");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const minute_r16 = \u0275\u0275nextContext().$implicit;
    const ctx_r17 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("ant-picker-time-panel-cell-selected", ctx_r17.isSelectedMinute(minute_r16))("ant-picker-time-panel-cell-disabled", minute_r16.disabled);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(3, 5, minute_r16.index, "2.0-0"));
  }
}
function NzTimePickerPanelComponent_ul_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTimePickerPanelComponent_ul_3_ng_container_2_li_1_Template, 4, 8, "li", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const minute_r16 = ctx.$implicit;
    const ctx_r15 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !(ctx_r15.nzHideDisabledOptions && minute_r16.disabled));
  }
}
function NzTimePickerPanelComponent_ul_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 6, 12);
    \u0275\u0275template(2, NzTimePickerPanelComponent_ul_3_ng_container_2_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r2.minuteRange)("ngForTrackBy", ctx_r2.trackByFn);
  }
}
function NzTimePickerPanelComponent_ul_4_ng_container_2_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 10);
    \u0275\u0275listener("click", function NzTimePickerPanelComponent_ul_4_ng_container_2_li_1_Template_li_click_0_listener() {
      \u0275\u0275restoreView(_r28);
      const second_r24 = \u0275\u0275nextContext().$implicit;
      const ctx_r26 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r26.selectSecond(second_r24));
    });
    \u0275\u0275elementStart(1, "div", 11);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "number");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const second_r24 = \u0275\u0275nextContext().$implicit;
    const ctx_r25 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("ant-picker-time-panel-cell-selected", ctx_r25.isSelectedSecond(second_r24))("ant-picker-time-panel-cell-disabled", second_r24.disabled);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(3, 5, second_r24.index, "2.0-0"));
  }
}
function NzTimePickerPanelComponent_ul_4_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTimePickerPanelComponent_ul_4_ng_container_2_li_1_Template, 4, 8, "li", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const second_r24 = ctx.$implicit;
    const ctx_r23 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !(ctx_r23.nzHideDisabledOptions && second_r24.disabled));
  }
}
function NzTimePickerPanelComponent_ul_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 6, 13);
    \u0275\u0275template(2, NzTimePickerPanelComponent_ul_4_ng_container_2_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r3.secondRange)("ngForTrackBy", ctx_r3.trackByFn);
  }
}
function NzTimePickerPanelComponent_ul_5_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r34 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "li", 10);
    \u0275\u0275listener("click", function NzTimePickerPanelComponent_ul_5_ng_container_2_Template_li_click_1_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r34);
      const range_r32 = restoredCtx.$implicit;
      const ctx_r33 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r33.select12Hours(range_r32));
    });
    \u0275\u0275elementStart(2, "div", 11);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const range_r32 = ctx.$implicit;
    const ctx_r31 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classProp("ant-picker-time-panel-cell-selected", ctx_r31.isSelected12Hours(range_r32));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(range_r32.value);
  }
}
function NzTimePickerPanelComponent_ul_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 6, 14);
    \u0275\u0275template(2, NzTimePickerPanelComponent_ul_5_ng_container_2_Template, 4, 3, "ng-container", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r4.use12HoursRange);
  }
}
function NzTimePickerPanelComponent_div_6_div_1_ng_template_1_Template(rf, ctx) {
}
function NzTimePickerPanelComponent_div_6_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 23);
    \u0275\u0275template(1, NzTimePickerPanelComponent_div_6_div_1_ng_template_1_Template, 0, 0, "ng-template", 24);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r35 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r35.nzAddOn);
  }
}
function NzTimePickerPanelComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r38 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275template(1, NzTimePickerPanelComponent_div_6_div_1_Template, 2, 1, "div", 17);
    \u0275\u0275elementStart(2, "ul", 18)(3, "li", 19)(4, "a", 20);
    \u0275\u0275listener("click", function NzTimePickerPanelComponent_div_6_Template_a_click_4_listener() {
      \u0275\u0275restoreView(_r38);
      const ctx_r37 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r37.onClickNow());
    });
    \u0275\u0275text(5);
    \u0275\u0275pipe(6, "nzI18n");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "li", 21)(8, "button", 22);
    \u0275\u0275listener("click", function NzTimePickerPanelComponent_div_6_Template_button_click_8_listener() {
      \u0275\u0275restoreView(_r38);
      const ctx_r39 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r39.onClickOk());
    });
    \u0275\u0275text(9);
    \u0275\u0275pipe(10, "nzI18n");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r5.nzAddOn);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", ctx_r5.nzNowText || \u0275\u0275pipeBind1(6, 3, "Calendar.lang.now"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", ctx_r5.nzOkText || \u0275\u0275pipeBind1(10, 5, "Calendar.lang.ok"), " ");
  }
}
var _c45 = ["inputElement"];
function NzTimePickerComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 8);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const suffixIcon_r5 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", suffixIcon_r5);
  }
}
function NzTimePickerComponent_nz_form_item_feedback_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-form-item-feedback-icon", 9);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("status", ctx_r2.status);
  }
}
function NzTimePickerComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 10);
    \u0275\u0275listener("click", function NzTimePickerComponent_span_7_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.onClickClearBtn($event));
    });
    \u0275\u0275element(1, "span", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275attribute("aria-label", ctx_r3.nzClearText)("title", ctx_r3.nzClearText);
  }
}
function NzTimePickerComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 12)(1, "div", 13)(2, "div", 14)(3, "nz-time-picker-panel", 15);
    \u0275\u0275listener("ngModelChange", function NzTimePickerComponent_ng_template_8_Template_nz_time_picker_panel_ngModelChange_3_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r8 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r8.value = $event);
    })("ngModelChange", function NzTimePickerComponent_ng_template_8_Template_nz_time_picker_panel_ngModelChange_3_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r10 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r10.onPanelValueChange($event));
    })("closePanel", function NzTimePickerComponent_ng_template_8_Template_nz_time_picker_panel_closePanel_3_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11.closePanel());
    });
    \u0275\u0275pipe(4, "async");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275property("@slideMotion", "enter");
    \u0275\u0275advance(3);
    \u0275\u0275property("ngClass", ctx_r4.nzPopupClassName)("format", ctx_r4.nzFormat)("nzHourStep", ctx_r4.nzHourStep)("nzMinuteStep", ctx_r4.nzMinuteStep)("nzSecondStep", ctx_r4.nzSecondStep)("nzDisabledHours", ctx_r4.nzDisabledHours)("nzDisabledMinutes", ctx_r4.nzDisabledMinutes)("nzDisabledSeconds", ctx_r4.nzDisabledSeconds)("nzPlaceHolder", ctx_r4.nzPlaceHolder || \u0275\u0275pipeBind1(4, 19, ctx_r4.i18nPlaceHolder$))("nzHideDisabledOptions", ctx_r4.nzHideDisabledOptions)("nzUse12Hours", ctx_r4.nzUse12Hours)("nzDefaultOpenValue", ctx_r4.nzDefaultOpenValue)("nzAddOn", ctx_r4.nzAddOn)("nzClearText", ctx_r4.nzClearText)("nzNowText", ctx_r4.nzNowText)("nzOkText", ctx_r4.nzOkText)("nzAllowEmpty", ctx_r4.nzAllowEmpty)("ngModel", ctx_r4.value);
  }
}
var TimeHolder = class {
  setMinutes(value, disabled) {
    if (!disabled) {
      this.initValue();
      this.value.setMinutes(value);
      this.update();
    }
    return this;
  }
  setHours(value, disabled) {
    if (!disabled) {
      this.initValue();
      if (this._use12Hours) {
        if (this.selected12Hours === "PM" && value !== 12) {
          this.value.setHours(value + 12);
        } else if (this.selected12Hours === "AM" && value === 12) {
          this.value.setHours(0);
        } else {
          this.value.setHours(value);
        }
      } else {
        this.value.setHours(value);
      }
      this.update();
    }
    return this;
  }
  setSeconds(value, disabled) {
    if (!disabled) {
      this.initValue();
      this.value.setSeconds(value);
      this.update();
    }
    return this;
  }
  setUse12Hours(value) {
    this._use12Hours = value;
    return this;
  }
  get changes() {
    return this._changes.asObservable();
  }
  setValue(value, use12Hours) {
    if (isNotNil(use12Hours)) {
      this._use12Hours = use12Hours;
    }
    if (value !== this.value) {
      this._value = value;
      if (isNotNil(this.value)) {
        if (this._use12Hours && isNotNil(this.hours)) {
          this.selected12Hours = this.hours >= 12 ? "PM" : "AM";
        }
      } else {
        this._clear();
      }
    }
    return this;
  }
  initValue() {
    if (isNil(this.value)) {
      this.setValue(/* @__PURE__ */ new Date(), this._use12Hours);
    }
  }
  clear() {
    this._clear();
    this.update();
  }
  get isEmpty() {
    return !(isNotNil(this.hours) || isNotNil(this.minutes) || isNotNil(this.seconds));
  }
  _clear() {
    this._value = void 0;
    this.selected12Hours = void 0;
  }
  update() {
    if (this.isEmpty) {
      this._value = void 0;
    } else {
      if (isNotNil(this.hours)) {
        this.value.setHours(this.hours);
      }
      if (isNotNil(this.minutes)) {
        this.value.setMinutes(this.minutes);
      }
      if (isNotNil(this.seconds)) {
        this.value.setSeconds(this.seconds);
      }
      if (this._use12Hours) {
        if (this.selected12Hours === "PM" && this.hours < 12) {
          this.value.setHours(this.hours + 12);
        }
        if (this.selected12Hours === "AM" && this.hours >= 12) {
          this.value.setHours(this.hours - 12);
        }
      }
    }
    this.changed();
  }
  changed() {
    this._changes.next(this.value);
  }
  /**
   * @description
   * UI view hours
   * Get viewHours which is selected in `time-picker-panel` and its range is [12, 1, 2, ..., 11]
   */
  get viewHours() {
    return this._use12Hours && isNotNil(this.hours) ? this.calculateViewHour(this.hours) : this.hours;
  }
  setSelected12Hours(value) {
    if (value.toUpperCase() !== this.selected12Hours) {
      this.selected12Hours = value.toUpperCase();
      this.update();
    }
  }
  get value() {
    return this._value || this._defaultOpenValue;
  }
  get hours() {
    return this.value?.getHours();
  }
  get minutes() {
    return this.value?.getMinutes();
  }
  get seconds() {
    return this.value?.getSeconds();
  }
  setDefaultOpenValue(value) {
    this._defaultOpenValue = value;
    return this;
  }
  constructor() {
    this.selected12Hours = void 0;
    this._use12Hours = false;
    this._changes = new Subject();
  }
  calculateViewHour(value) {
    const selected12Hours = this.selected12Hours;
    if (selected12Hours === "PM" && value > 12) {
      return value - 12;
    }
    if (selected12Hours === "AM" && value === 0) {
      return 12;
    }
    return value;
  }
};
function makeRange(length, step = 1, start = 0) {
  return new Array(Math.ceil(length / step)).fill(0).map((_, i) => (i + start) * step);
}
var _NzTimePickerPanelComponent = class _NzTimePickerPanelComponent {
  set nzAllowEmpty(value) {
    if (isNotNil(value)) {
      this._allowEmpty = value;
    }
  }
  get nzAllowEmpty() {
    return this._allowEmpty;
  }
  set nzDisabledHours(value) {
    this._disabledHours = value;
    if (this._disabledHours) {
      this.buildHours();
    }
  }
  get nzDisabledHours() {
    return this._disabledHours;
  }
  set nzDisabledMinutes(value) {
    if (isNotNil(value)) {
      this._disabledMinutes = value;
      this.buildMinutes();
    }
  }
  get nzDisabledMinutes() {
    return this._disabledMinutes;
  }
  set nzDisabledSeconds(value) {
    if (isNotNil(value)) {
      this._disabledSeconds = value;
      this.buildSeconds();
    }
  }
  get nzDisabledSeconds() {
    return this._disabledSeconds;
  }
  set format(value) {
    if (isNotNil(value)) {
      this._format = value;
      this.enabledColumns = 0;
      const charSet = new Set(value);
      this.hourEnabled = charSet.has("H") || charSet.has("h");
      this.minuteEnabled = charSet.has("m");
      this.secondEnabled = charSet.has("s");
      if (this.hourEnabled) {
        this.enabledColumns++;
      }
      if (this.minuteEnabled) {
        this.enabledColumns++;
      }
      if (this.secondEnabled) {
        this.enabledColumns++;
      }
      if (this.nzUse12Hours) {
        this.build12Hours();
      }
    }
  }
  get format() {
    return this._format;
  }
  set nzHourStep(value) {
    if (isNotNil(value)) {
      this._nzHourStep = value;
      this.buildHours();
    }
  }
  get nzHourStep() {
    return this._nzHourStep;
  }
  set nzMinuteStep(value) {
    if (isNotNil(value)) {
      this._nzMinuteStep = value;
      this.buildMinutes();
    }
  }
  get nzMinuteStep() {
    return this._nzMinuteStep;
  }
  set nzSecondStep(value) {
    if (isNotNil(value)) {
      this._nzSecondStep = value;
      this.buildSeconds();
    }
  }
  get nzSecondStep() {
    return this._nzSecondStep;
  }
  trackByFn(index) {
    return index;
  }
  buildHours() {
    let hourRanges = 24;
    let disabledHours = this.nzDisabledHours?.();
    let startIndex = 0;
    if (this.nzUse12Hours) {
      hourRanges = 12;
      if (disabledHours) {
        if (this.time.selected12Hours === "PM") {
          disabledHours = disabledHours.filter((i) => i >= 12).map((i) => i > 12 ? i - 12 : i);
        } else {
          disabledHours = disabledHours.filter((i) => i < 12 || i === 24).map((i) => i === 24 || i === 0 ? 12 : i);
        }
      }
      startIndex = 1;
    }
    this.hourRange = makeRange(hourRanges, this.nzHourStep, startIndex).map((r) => ({
      index: r,
      disabled: !!disabledHours && disabledHours.indexOf(r) !== -1
    }));
    if (this.nzUse12Hours && this.hourRange[this.hourRange.length - 1].index === 12) {
      const temp = [...this.hourRange];
      temp.unshift(temp[temp.length - 1]);
      temp.splice(temp.length - 1, 1);
      this.hourRange = temp;
    }
  }
  buildMinutes() {
    this.minuteRange = makeRange(60, this.nzMinuteStep).map((r) => ({
      index: r,
      disabled: !!this.nzDisabledMinutes && this.nzDisabledMinutes(this.time.hours).indexOf(r) !== -1
    }));
  }
  buildSeconds() {
    this.secondRange = makeRange(60, this.nzSecondStep).map((r) => ({
      index: r,
      disabled: !!this.nzDisabledSeconds && this.nzDisabledSeconds(this.time.hours, this.time.minutes).indexOf(r) !== -1
    }));
  }
  build12Hours() {
    const isUpperFormat = this._format.includes("A");
    this.use12HoursRange = [{
      index: 0,
      value: isUpperFormat ? "AM" : "am"
    }, {
      index: 1,
      value: isUpperFormat ? "PM" : "pm"
    }];
  }
  buildTimes() {
    this.buildHours();
    this.buildMinutes();
    this.buildSeconds();
    this.build12Hours();
  }
  scrollToTime(delay2 = 0) {
    if (this.hourEnabled && this.hourListElement) {
      this.scrollToSelected(this.hourListElement.nativeElement, this.time.viewHours, delay2, "hour");
    }
    if (this.minuteEnabled && this.minuteListElement) {
      this.scrollToSelected(this.minuteListElement.nativeElement, this.time.minutes, delay2, "minute");
    }
    if (this.secondEnabled && this.secondListElement) {
      this.scrollToSelected(this.secondListElement.nativeElement, this.time.seconds, delay2, "second");
    }
    if (this.nzUse12Hours && this.use12HoursListElement) {
      const selectedHours = this.time.selected12Hours;
      const index = selectedHours === "AM" ? 0 : 1;
      this.scrollToSelected(this.use12HoursListElement.nativeElement, index, delay2, "12-hour");
    }
  }
  selectHour(hour) {
    this.time.setHours(hour.index, hour.disabled);
    if (this._disabledMinutes) {
      this.buildMinutes();
    }
    if (this._disabledSeconds || this._disabledMinutes) {
      this.buildSeconds();
    }
  }
  selectMinute(minute) {
    this.time.setMinutes(minute.index, minute.disabled);
    if (this._disabledSeconds) {
      this.buildSeconds();
    }
  }
  selectSecond(second) {
    this.time.setSeconds(second.index, second.disabled);
  }
  select12Hours(value) {
    this.time.setSelected12Hours(value.value);
    if (this._disabledHours) {
      this.buildHours();
    }
    if (this._disabledMinutes) {
      this.buildMinutes();
    }
    if (this._disabledSeconds) {
      this.buildSeconds();
    }
  }
  scrollToSelected(instance, index, duration = 0, unit) {
    if (!instance) {
      return;
    }
    const transIndex = this.translateIndex(index, unit);
    const currentOption = instance.children[transIndex] || instance.children[0];
    this.scrollTo(instance, currentOption.offsetTop, duration);
  }
  translateIndex(index, unit) {
    if (unit === "hour") {
      return this.calcIndex(this.nzDisabledHours?.(), this.hourRange.map((item) => item.index).indexOf(index));
    } else if (unit === "minute") {
      return this.calcIndex(this.nzDisabledMinutes?.(this.time.hours), this.minuteRange.map((item) => item.index).indexOf(index));
    } else if (unit === "second") {
      return this.calcIndex(this.nzDisabledSeconds?.(this.time.hours, this.time.minutes), this.secondRange.map((item) => item.index).indexOf(index));
    } else {
      return this.calcIndex([], this.use12HoursRange.map((item) => item.index).indexOf(index));
    }
  }
  scrollTo(element, to, duration) {
    if (duration <= 0) {
      element.scrollTop = to;
      return;
    }
    const difference = to - element.scrollTop;
    const perTick = difference / duration * 10;
    this.ngZone.runOutsideAngular(() => {
      reqAnimFrame(() => {
        element.scrollTop = element.scrollTop + perTick;
        if (element.scrollTop === to) {
          return;
        }
        this.scrollTo(element, to, duration - 10);
      });
    });
  }
  calcIndex(array, index) {
    if (array?.length && this.nzHideDisabledOptions) {
      return index - array.reduce((pre, value) => pre + (value < index ? 1 : 0), 0);
    } else {
      return index;
    }
  }
  changed() {
    if (this.onChange) {
      this.onChange(this.time.value);
    }
  }
  touched() {
    if (this.onTouch) {
      this.onTouch();
    }
  }
  timeDisabled(value) {
    const hour = value.getHours();
    const minute = value.getMinutes();
    const second = value.getSeconds();
    return (this.nzDisabledHours?.().indexOf(hour) ?? -1) > -1 || (this.nzDisabledMinutes?.(hour).indexOf(minute) ?? -1) > -1 || (this.nzDisabledSeconds?.(hour, minute).indexOf(second) ?? -1) > -1;
  }
  onClickNow() {
    const now = /* @__PURE__ */ new Date();
    if (this.timeDisabled(now)) {
      return;
    }
    this.time.setValue(now);
    this.changed();
    this.closePanel.emit();
  }
  onClickOk() {
    this.time.setValue(this.time.value, this.nzUse12Hours);
    this.changed();
    this.closePanel.emit();
  }
  isSelectedHour(hour) {
    return hour.index === this.time.viewHours;
  }
  isSelectedMinute(minute) {
    return minute.index === this.time.minutes;
  }
  isSelectedSecond(second) {
    return second.index === this.time.seconds;
  }
  isSelected12Hours(value) {
    return value.value.toUpperCase() === this.time.selected12Hours;
  }
  constructor(ngZone, cdr, dateHelper, elementRef) {
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.dateHelper = dateHelper;
    this.elementRef = elementRef;
    this._nzHourStep = 1;
    this._nzMinuteStep = 1;
    this._nzSecondStep = 1;
    this.unsubscribe$ = new Subject();
    this._format = "HH:mm:ss";
    this._disabledHours = () => [];
    this._disabledMinutes = () => [];
    this._disabledSeconds = () => [];
    this._allowEmpty = true;
    this.time = new TimeHolder();
    this.hourEnabled = true;
    this.minuteEnabled = true;
    this.secondEnabled = true;
    this.firstScrolled = false;
    this.enabledColumns = 3;
    this.nzInDatePicker = false;
    this.nzHideDisabledOptions = false;
    this.nzUse12Hours = false;
    this.closePanel = new EventEmitter();
  }
  ngOnInit() {
    this.time.changes.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
      this.changed();
      this.touched();
      this.scrollToTime(120);
    });
    this.buildTimes();
    this.ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        this.scrollToTime();
        this.firstScrolled = true;
      });
      fromEvent(this.elementRef.nativeElement, "mousedown").pipe(takeUntil(this.unsubscribe$)).subscribe((event) => {
        event.preventDefault();
      });
    });
  }
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
  ngOnChanges(changes) {
    const {
      nzUse12Hours,
      nzDefaultOpenValue
    } = changes;
    if (!nzUse12Hours?.previousValue && nzUse12Hours?.currentValue) {
      this.build12Hours();
      this.enabledColumns++;
    }
    if (nzDefaultOpenValue?.currentValue) {
      this.time.setDefaultOpenValue(this.nzDefaultOpenValue || /* @__PURE__ */ new Date());
    }
  }
  writeValue(value) {
    this.time.setValue(value, this.nzUse12Hours);
    this.buildTimes();
    if (value && this.firstScrolled) {
      this.scrollToTime(120);
    }
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouch = fn;
  }
};
_NzTimePickerPanelComponent.\u0275fac = function NzTimePickerPanelComponent_Factory(t) {
  return new (t || _NzTimePickerPanelComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(DateHelperService), \u0275\u0275directiveInject(ElementRef));
};
_NzTimePickerPanelComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTimePickerPanelComponent,
  selectors: [["nz-time-picker-panel"]],
  viewQuery: function NzTimePickerPanelComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c018, 5);
      \u0275\u0275viewQuery(_c111, 5);
      \u0275\u0275viewQuery(_c210, 5);
      \u0275\u0275viewQuery(_c37, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.hourListElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.minuteListElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.secondListElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.use12HoursListElement = _t.first);
    }
  },
  hostAttrs: [1, "ant-picker-time-panel"],
  hostVars: 12,
  hostBindings: function NzTimePickerPanelComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-picker-time-panel-column-0", ctx.enabledColumns === 0 && !ctx.nzInDatePicker)("ant-picker-time-panel-column-1", ctx.enabledColumns === 1 && !ctx.nzInDatePicker)("ant-picker-time-panel-column-2", ctx.enabledColumns === 2 && !ctx.nzInDatePicker)("ant-picker-time-panel-column-3", ctx.enabledColumns === 3 && !ctx.nzInDatePicker)("ant-picker-time-panel-narrow", ctx.enabledColumns < 3)("ant-picker-time-panel-placement-bottomLeft", !ctx.nzInDatePicker);
    }
  },
  inputs: {
    nzInDatePicker: "nzInDatePicker",
    nzAddOn: "nzAddOn",
    nzHideDisabledOptions: "nzHideDisabledOptions",
    nzClearText: "nzClearText",
    nzNowText: "nzNowText",
    nzOkText: "nzOkText",
    nzPlaceHolder: "nzPlaceHolder",
    nzUse12Hours: "nzUse12Hours",
    nzDefaultOpenValue: "nzDefaultOpenValue",
    nzAllowEmpty: "nzAllowEmpty",
    nzDisabledHours: "nzDisabledHours",
    nzDisabledMinutes: "nzDisabledMinutes",
    nzDisabledSeconds: "nzDisabledSeconds",
    format: "format",
    nzHourStep: "nzHourStep",
    nzMinuteStep: "nzMinuteStep",
    nzSecondStep: "nzSecondStep"
  },
  outputs: {
    closePanel: "closePanel"
  },
  exportAs: ["nzTimePickerPanel"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: _NzTimePickerPanelComponent,
    multi: true
  }]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 7,
  vars: 6,
  consts: [["class", "ant-picker-header", 4, "ngIf"], [1, "ant-picker-content"], ["class", "ant-picker-time-panel-column", "style", "position: relative;", 4, "ngIf"], ["class", "ant-picker-footer", 4, "ngIf"], [1, "ant-picker-header"], [1, "ant-picker-header-view"], [1, "ant-picker-time-panel-column", 2, "position", "relative"], ["hourListElement", ""], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "ant-picker-time-panel-cell", 3, "ant-picker-time-panel-cell-selected", "ant-picker-time-panel-cell-disabled", "click", 4, "ngIf"], [1, "ant-picker-time-panel-cell", 3, "click"], [1, "ant-picker-time-panel-cell-inner"], ["minuteListElement", ""], ["secondListElement", ""], ["use12HoursListElement", ""], [4, "ngFor", "ngForOf"], [1, "ant-picker-footer"], ["class", "ant-picker-footer-extra", 4, "ngIf"], [1, "ant-picker-ranges"], [1, "ant-picker-now"], [3, "click"], [1, "ant-picker-ok"], ["nz-button", "", "type", "button", "nzSize", "small", "nzType", "primary", 3, "click"], [1, "ant-picker-footer-extra"], [3, "ngTemplateOutlet"]],
  template: function NzTimePickerPanelComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTimePickerPanelComponent_div_0_Template, 3, 1, "div", 0);
      \u0275\u0275elementStart(1, "div", 1);
      \u0275\u0275template(2, NzTimePickerPanelComponent_ul_2_Template, 3, 2, "ul", 2)(3, NzTimePickerPanelComponent_ul_3_Template, 3, 2, "ul", 2)(4, NzTimePickerPanelComponent_ul_4_Template, 3, 2, "ul", 2)(5, NzTimePickerPanelComponent_ul_5_Template, 3, 1, "ul", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275template(6, NzTimePickerPanelComponent_div_6_Template, 11, 7, "div", 3);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.nzInDatePicker);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.hourEnabled);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.minuteEnabled);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.secondEnabled);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzUse12Hours);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.nzInDatePicker);
    }
  },
  dependencies: [NgIf, NgForOf, DecimalPipe, NgTemplateOutlet, NzI18nModule, NzI18nPipe, NzButtonModule, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzTimePickerPanelComponent = _NzTimePickerPanelComponent;
__decorate([InputBoolean()], NzTimePickerPanelComponent.prototype, "nzUse12Hours", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTimePickerPanelComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "nz-time-picker-panel",
      exportAs: "nzTimePickerPanel",
      template: `
    <div *ngIf="nzInDatePicker" class="ant-picker-header">
      <div class="ant-picker-header-view">{{ dateHelper.format($any(time?.value), format) || '&nbsp;' }}</div>
    </div>
    <div class="ant-picker-content">
      <ul *ngIf="hourEnabled" #hourListElement class="ant-picker-time-panel-column" style="position: relative;">
        <ng-container *ngFor="let hour of hourRange; trackBy: trackByFn">
          <li
            *ngIf="!(nzHideDisabledOptions && hour.disabled)"
            class="ant-picker-time-panel-cell"
            (click)="selectHour(hour)"
            [class.ant-picker-time-panel-cell-selected]="isSelectedHour(hour)"
            [class.ant-picker-time-panel-cell-disabled]="hour.disabled"
          >
            <div class="ant-picker-time-panel-cell-inner">{{ hour.index | number: '2.0-0' }}</div>
          </li>
        </ng-container>
      </ul>
      <ul *ngIf="minuteEnabled" #minuteListElement class="ant-picker-time-panel-column" style="position: relative;">
        <ng-container *ngFor="let minute of minuteRange; trackBy: trackByFn">
          <li
            *ngIf="!(nzHideDisabledOptions && minute.disabled)"
            class="ant-picker-time-panel-cell"
            (click)="selectMinute(minute)"
            [class.ant-picker-time-panel-cell-selected]="isSelectedMinute(minute)"
            [class.ant-picker-time-panel-cell-disabled]="minute.disabled"
          >
            <div class="ant-picker-time-panel-cell-inner">{{ minute.index | number: '2.0-0' }}</div>
          </li>
        </ng-container>
      </ul>
      <ul *ngIf="secondEnabled" #secondListElement class="ant-picker-time-panel-column" style="position: relative;">
        <ng-container *ngFor="let second of secondRange; trackBy: trackByFn">
          <li
            *ngIf="!(nzHideDisabledOptions && second.disabled)"
            class="ant-picker-time-panel-cell"
            (click)="selectSecond(second)"
            [class.ant-picker-time-panel-cell-selected]="isSelectedSecond(second)"
            [class.ant-picker-time-panel-cell-disabled]="second.disabled"
          >
            <div class="ant-picker-time-panel-cell-inner">{{ second.index | number: '2.0-0' }}</div>
          </li>
        </ng-container>
      </ul>
      <ul *ngIf="nzUse12Hours" #use12HoursListElement class="ant-picker-time-panel-column" style="position: relative;">
        <ng-container *ngFor="let range of use12HoursRange">
          <li
            (click)="select12Hours(range)"
            class="ant-picker-time-panel-cell"
            [class.ant-picker-time-panel-cell-selected]="isSelected12Hours(range)"
          >
            <div class="ant-picker-time-panel-cell-inner">{{ range.value }}</div>
          </li>
        </ng-container>
      </ul>
    </div>
    <div *ngIf="!nzInDatePicker" class="ant-picker-footer">
      <div *ngIf="nzAddOn" class="ant-picker-footer-extra">
        <ng-template [ngTemplateOutlet]="nzAddOn"></ng-template>
      </div>
      <ul class="ant-picker-ranges">
        <li class="ant-picker-now">
          <a (click)="onClickNow()">
            {{ nzNowText || ('Calendar.lang.now' | nzI18n) }}
          </a>
        </li>
        <li class="ant-picker-ok">
          <button nz-button type="button" nzSize="small" nzType="primary" (click)="onClickOk()">
            {{ nzOkText || ('Calendar.lang.ok' | nzI18n) }}
          </button>
        </li>
      </ul>
    </div>
  `,
      host: {
        class: "ant-picker-time-panel",
        "[class.ant-picker-time-panel-column-0]": `enabledColumns === 0 && !nzInDatePicker`,
        "[class.ant-picker-time-panel-column-1]": `enabledColumns === 1 && !nzInDatePicker`,
        "[class.ant-picker-time-panel-column-2]": `enabledColumns === 2 && !nzInDatePicker`,
        "[class.ant-picker-time-panel-column-3]": `enabledColumns === 3 && !nzInDatePicker`,
        "[class.ant-picker-time-panel-narrow]": `enabledColumns < 3`,
        "[class.ant-picker-time-panel-placement-bottomLeft]": `!nzInDatePicker`
      },
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: NzTimePickerPanelComponent,
        multi: true
      }],
      imports: [NgIf, NgForOf, DecimalPipe, NgTemplateOutlet, NzI18nModule, NzButtonModule],
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: DateHelperService
  }, {
    type: ElementRef
  }], {
    hourListElement: [{
      type: ViewChild,
      args: ["hourListElement", {
        static: false
      }]
    }],
    minuteListElement: [{
      type: ViewChild,
      args: ["minuteListElement", {
        static: false
      }]
    }],
    secondListElement: [{
      type: ViewChild,
      args: ["secondListElement", {
        static: false
      }]
    }],
    use12HoursListElement: [{
      type: ViewChild,
      args: ["use12HoursListElement", {
        static: false
      }]
    }],
    nzInDatePicker: [{
      type: Input
    }],
    nzAddOn: [{
      type: Input
    }],
    nzHideDisabledOptions: [{
      type: Input
    }],
    nzClearText: [{
      type: Input
    }],
    nzNowText: [{
      type: Input
    }],
    nzOkText: [{
      type: Input
    }],
    nzPlaceHolder: [{
      type: Input
    }],
    nzUse12Hours: [{
      type: Input
    }],
    nzDefaultOpenValue: [{
      type: Input
    }],
    closePanel: [{
      type: Output
    }],
    nzAllowEmpty: [{
      type: Input
    }],
    nzDisabledHours: [{
      type: Input
    }],
    nzDisabledMinutes: [{
      type: Input
    }],
    nzDisabledSeconds: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    nzHourStep: [{
      type: Input
    }],
    nzMinuteStep: [{
      type: Input
    }],
    nzSecondStep: [{
      type: Input
    }]
  });
})();
var NZ_CONFIG_MODULE_NAME10 = "timePicker";
var _NzTimePickerComponent = class _NzTimePickerComponent {
  emitValue(value) {
    this.setValue(value, true);
    if (this._onChange) {
      this._onChange(this.value);
    }
    if (this._onTouched) {
      this._onTouched();
    }
  }
  setValue(value, syncPreValue = false) {
    if (syncPreValue) {
      this.preValue = isValid(value) ? new Date(value) : null;
    }
    this.value = isValid(value) ? new Date(value) : null;
    this.inputValue = this.dateHelper.format(value, this.nzFormat);
    this.cdr.markForCheck();
  }
  open() {
    if (this.nzDisabled || this.nzOpen) {
      return;
    }
    this.focus();
    this.nzOpen = true;
    this.nzOpenChange.emit(this.nzOpen);
  }
  close() {
    this.nzOpen = false;
    this.cdr.markForCheck();
    this.nzOpenChange.emit(this.nzOpen);
  }
  updateAutoFocus() {
    if (this.isInit && !this.nzDisabled) {
      if (this.nzAutoFocus) {
        this.renderer.setAttribute(this.inputRef.nativeElement, "autofocus", "autofocus");
      } else {
        this.renderer.removeAttribute(this.inputRef.nativeElement, "autofocus");
      }
    }
  }
  onClickClearBtn(event) {
    event.stopPropagation();
    this.emitValue(null);
  }
  onClickOutside(event) {
    if (!this.element.nativeElement.contains(event.target)) {
      this.setCurrentValueAndClose();
    }
  }
  onFocus(value) {
    this.focused = value;
    if (!value) {
      if (this.checkTimeValid(this.value)) {
        this.setCurrentValueAndClose();
      } else {
        this.setValue(this.preValue);
        this.close();
      }
    }
  }
  focus() {
    if (this.inputRef.nativeElement) {
      this.inputRef.nativeElement.focus();
    }
  }
  blur() {
    if (this.inputRef.nativeElement) {
      this.inputRef.nativeElement.blur();
    }
  }
  onKeyupEsc() {
    this.setValue(this.preValue);
  }
  onKeyupEnter() {
    if (this.nzOpen && isValid(this.value)) {
      this.setCurrentValueAndClose();
    } else if (!this.nzOpen) {
      this.open();
    }
  }
  onInputChange(str) {
    if (!this.platform.TRIDENT && document.activeElement === this.inputRef.nativeElement) {
      this.open();
      this.parseTimeString(str);
    }
  }
  onPanelValueChange(value) {
    this.setValue(value);
    this.focus();
  }
  closePanel() {
    this.inputRef.nativeElement.blur();
  }
  setCurrentValueAndClose() {
    this.emitValue(this.value);
    this.close();
  }
  constructor(nzConfigService, i18n, element, renderer, cdr, dateHelper, platform, directionality, nzFormStatusService, nzFormNoStatusService) {
    this.nzConfigService = nzConfigService;
    this.i18n = i18n;
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
    this.dateHelper = dateHelper;
    this.platform = platform;
    this.directionality = directionality;
    this.nzFormStatusService = nzFormStatusService;
    this.nzFormNoStatusService = nzFormNoStatusService;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME10;
    this.destroy$ = new Subject();
    this.isNzDisableFirstChange = true;
    this.isInit = false;
    this.focused = false;
    this.inputValue = "";
    this.value = null;
    this.preValue = null;
    this.i18nPlaceHolder$ = of(void 0);
    this.overlayPositions = [{
      offsetY: 3,
      originX: "start",
      originY: "bottom",
      overlayX: "start",
      overlayY: "top"
    }, {
      offsetY: -3,
      originX: "start",
      originY: "top",
      overlayX: "start",
      overlayY: "bottom"
    }, {
      offsetY: 3,
      originX: "end",
      originY: "bottom",
      overlayX: "end",
      overlayY: "top"
    }, {
      offsetY: -3,
      originX: "end",
      originY: "top",
      overlayX: "end",
      overlayY: "bottom"
    }];
    this.dir = "ltr";
    this.prefixCls = "ant-picker";
    this.statusCls = {};
    this.status = "";
    this.hasFeedback = false;
    this.nzId = null;
    this.nzSize = null;
    this.nzStatus = "";
    this.nzHourStep = 1;
    this.nzMinuteStep = 1;
    this.nzSecondStep = 1;
    this.nzClearText = "clear";
    this.nzNowText = "";
    this.nzOkText = "";
    this.nzPopupClassName = "";
    this.nzPlaceHolder = "";
    this.nzFormat = "HH:mm:ss";
    this.nzOpen = false;
    this.nzUse12Hours = false;
    this.nzSuffixIcon = "clock-circle";
    this.nzOpenChange = new EventEmitter();
    this.nzHideDisabledOptions = false;
    this.nzAllowEmpty = true;
    this.nzDisabled = false;
    this.nzAutoFocus = false;
    this.nzBackdrop = false;
    this.nzBorderless = false;
    this.nzInputReadOnly = false;
  }
  ngOnInit() {
    this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {
      return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;
    }), withLatestFrom(this.nzFormNoStatusService ? this.nzFormNoStatusService.noFormStatus : of(false)), map(([{
      status,
      hasFeedback
    }, noStatus]) => ({
      status: noStatus ? "" : status,
      hasFeedback
    })), takeUntil(this.destroy$)).subscribe(({
      status,
      hasFeedback
    }) => {
      this.setStatusStyles(status, hasFeedback);
    });
    this.inputSize = Math.max(8, this.nzFormat.length) + 2;
    this.origin = new CdkOverlayOrigin(this.element);
    this.i18nPlaceHolder$ = this.i18n.localeChange.pipe(map((nzLocale) => nzLocale.TimePicker.placeholder));
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  ngOnChanges(changes) {
    const {
      nzUse12Hours,
      nzFormat,
      nzDisabled,
      nzAutoFocus,
      nzStatus
    } = changes;
    if (nzUse12Hours && !nzUse12Hours.previousValue && nzUse12Hours.currentValue && !nzFormat) {
      this.nzFormat = "h:mm:ss a";
    }
    if (nzDisabled) {
      const value = nzDisabled.currentValue;
      const input = this.inputRef.nativeElement;
      if (value) {
        this.renderer.setAttribute(input, "disabled", "");
      } else {
        this.renderer.removeAttribute(input, "disabled");
      }
    }
    if (nzAutoFocus) {
      this.updateAutoFocus();
    }
    if (nzStatus) {
      this.setStatusStyles(this.nzStatus, this.hasFeedback);
    }
  }
  parseTimeString(str) {
    const value = this.dateHelper.parseTime(str, this.nzFormat) || null;
    if (isValid(value)) {
      this.value = value;
      this.cdr.markForCheck();
    }
  }
  ngAfterViewInit() {
    this.isInit = true;
    this.updateAutoFocus();
  }
  writeValue(time) {
    let result;
    if (time instanceof Date) {
      result = time;
    } else if (isNil(time)) {
      result = null;
    } else {
      warn2('Non-Date type is not recommended for time-picker, use "Date" type.');
      result = new Date(time);
    }
    this.setValue(result, true);
  }
  registerOnChange(fn) {
    this._onChange = fn;
  }
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || isDisabled;
    this.isNzDisableFirstChange = false;
    this.cdr.markForCheck();
  }
  checkTimeValid(value) {
    if (!value) {
      return true;
    }
    const disabledHours = this.nzDisabledHours?.();
    const disabledMinutes = this.nzDisabledMinutes?.(value.getHours());
    const disabledSeconds = this.nzDisabledSeconds?.(value.getHours(), value.getMinutes());
    return !(disabledHours?.includes(value.getHours()) || disabledMinutes?.includes(value.getMinutes()) || disabledSeconds?.includes(value.getSeconds()));
  }
  setStatusStyles(status, hasFeedback) {
    this.status = status;
    this.hasFeedback = hasFeedback;
    this.cdr.markForCheck();
    this.statusCls = getStatusClassNames(this.prefixCls, status, hasFeedback);
    Object.keys(this.statusCls).forEach((status2) => {
      if (this.statusCls[status2]) {
        this.renderer.addClass(this.element.nativeElement, status2);
      } else {
        this.renderer.removeClass(this.element.nativeElement, status2);
      }
    });
  }
};
_NzTimePickerComponent.\u0275fac = function NzTimePickerComponent_Factory(t) {
  return new (t || _NzTimePickerComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(NzI18nService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(DateHelperService), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzFormStatusService, 8), \u0275\u0275directiveInject(NzFormNoStatusService, 8));
};
_NzTimePickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTimePickerComponent,
  selectors: [["nz-time-picker"]],
  viewQuery: function NzTimePickerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c45, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inputRef = _t.first);
    }
  },
  hostAttrs: [1, "ant-picker"],
  hostVars: 12,
  hostBindings: function NzTimePickerComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzTimePickerComponent_click_HostBindingHandler() {
        return ctx.open();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-picker-large", ctx.nzSize === "large")("ant-picker-small", ctx.nzSize === "small")("ant-picker-disabled", ctx.nzDisabled)("ant-picker-focused", ctx.focused)("ant-picker-rtl", ctx.dir === "rtl")("ant-picker-borderless", ctx.nzBorderless);
    }
  },
  inputs: {
    nzId: "nzId",
    nzSize: "nzSize",
    nzStatus: "nzStatus",
    nzHourStep: "nzHourStep",
    nzMinuteStep: "nzMinuteStep",
    nzSecondStep: "nzSecondStep",
    nzClearText: "nzClearText",
    nzNowText: "nzNowText",
    nzOkText: "nzOkText",
    nzPopupClassName: "nzPopupClassName",
    nzPlaceHolder: "nzPlaceHolder",
    nzAddOn: "nzAddOn",
    nzDefaultOpenValue: "nzDefaultOpenValue",
    nzDisabledHours: "nzDisabledHours",
    nzDisabledMinutes: "nzDisabledMinutes",
    nzDisabledSeconds: "nzDisabledSeconds",
    nzFormat: "nzFormat",
    nzOpen: "nzOpen",
    nzUse12Hours: "nzUse12Hours",
    nzSuffixIcon: "nzSuffixIcon",
    nzHideDisabledOptions: "nzHideDisabledOptions",
    nzAllowEmpty: "nzAllowEmpty",
    nzDisabled: "nzDisabled",
    nzAutoFocus: "nzAutoFocus",
    nzBackdrop: "nzBackdrop",
    nzBorderless: "nzBorderless",
    nzInputReadOnly: "nzInputReadOnly"
  },
  outputs: {
    nzOpenChange: "nzOpenChange"
  },
  exportAs: ["nzTimePicker"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: _NzTimePickerComponent,
    multi: true
  }]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 9,
  vars: 16,
  consts: [[1, "ant-picker-input"], ["type", "text", "autocomplete", "off", 3, "size", "placeholder", "ngModel", "disabled", "readOnly", "ngModelChange", "focus", "blur", "keyup.enter", "keyup.escape"], ["inputElement", ""], [1, "ant-picker-suffix"], [4, "nzStringTemplateOutlet"], [3, "status", 4, "ngIf"], ["class", "ant-picker-clear", 3, "click", 4, "ngIf"], ["cdkConnectedOverlay", "", "nzConnectedOverlay", "", 3, "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayPositions", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayTransformOriginOn", "detach", "overlayOutsideClick"], ["nz-icon", "", 3, "nzType"], [3, "status"], [1, "ant-picker-clear", 3, "click"], ["nz-icon", "", "nzType", "close-circle", "nzTheme", "fill"], [1, "ant-picker-dropdown", 2, "position", "relative"], [1, "ant-picker-panel-container"], ["tabindex", "-1", 1, "ant-picker-panel"], [3, "ngClass", "format", "nzHourStep", "nzMinuteStep", "nzSecondStep", "nzDisabledHours", "nzDisabledMinutes", "nzDisabledSeconds", "nzPlaceHolder", "nzHideDisabledOptions", "nzUse12Hours", "nzDefaultOpenValue", "nzAddOn", "nzClearText", "nzNowText", "nzOkText", "nzAllowEmpty", "ngModel", "ngModelChange", "closePanel"]],
  template: function NzTimePickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "input", 1, 2);
      \u0275\u0275listener("ngModelChange", function NzTimePickerComponent_Template_input_ngModelChange_1_listener($event) {
        return ctx.inputValue = $event;
      })("focus", function NzTimePickerComponent_Template_input_focus_1_listener() {
        return ctx.onFocus(true);
      })("blur", function NzTimePickerComponent_Template_input_blur_1_listener() {
        return ctx.onFocus(false);
      })("keyup.enter", function NzTimePickerComponent_Template_input_keyup_enter_1_listener() {
        return ctx.onKeyupEnter();
      })("keyup.escape", function NzTimePickerComponent_Template_input_keyup_escape_1_listener() {
        return ctx.onKeyupEsc();
      })("ngModelChange", function NzTimePickerComponent_Template_input_ngModelChange_1_listener($event) {
        return ctx.onInputChange($event);
      });
      \u0275\u0275pipe(3, "async");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "span", 3);
      \u0275\u0275template(5, NzTimePickerComponent_ng_container_5_Template, 2, 1, "ng-container", 4)(6, NzTimePickerComponent_nz_form_item_feedback_icon_6_Template, 1, 1, "nz-form-item-feedback-icon", 5);
      \u0275\u0275elementEnd();
      \u0275\u0275template(7, NzTimePickerComponent_span_7_Template, 2, 2, "span", 6);
      \u0275\u0275elementEnd();
      \u0275\u0275template(8, NzTimePickerComponent_ng_template_8_Template, 5, 21, "ng-template", 7);
      \u0275\u0275listener("detach", function NzTimePickerComponent_Template_ng_template_detach_8_listener() {
        return ctx.close();
      })("overlayOutsideClick", function NzTimePickerComponent_Template_ng_template_overlayOutsideClick_8_listener($event) {
        return ctx.onClickOutside($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("size", ctx.inputSize)("placeholder", ctx.nzPlaceHolder || \u0275\u0275pipeBind1(3, 14, ctx.i18nPlaceHolder$))("ngModel", ctx.inputValue)("disabled", ctx.nzDisabled)("readOnly", ctx.nzInputReadOnly);
      \u0275\u0275attribute("id", ctx.nzId);
      \u0275\u0275advance(4);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzSuffixIcon);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.hasFeedback && !!ctx.status);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzAllowEmpty && !ctx.nzDisabled && ctx.value);
      \u0275\u0275advance(1);
      \u0275\u0275property("cdkConnectedOverlayHasBackdrop", ctx.nzBackdrop)("cdkConnectedOverlayPositions", ctx.overlayPositions)("cdkConnectedOverlayOrigin", ctx.origin)("cdkConnectedOverlayOpen", ctx.nzOpen)("cdkConnectedOverlayTransformOriginOn", ".ant-picker-dropdown");
    }
  },
  dependencies: [AsyncPipe, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, NzOutletModule, NzStringTemplateOutletDirective, NzIconModule, NzIconDirective, NzFormPatchModule, NzFormItemFeedbackIconComponent, NgIf, NzTimePickerPanelComponent, NgClass, NzOverlayModule, NzConnectedOverlayDirective, OverlayModule, CdkConnectedOverlay],
  encapsulation: 2,
  data: {
    animation: [slideMotion]
  },
  changeDetection: 0
});
var NzTimePickerComponent = _NzTimePickerComponent;
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzHourStep", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzMinuteStep", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzSecondStep", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzClearText", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzNowText", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzOkText", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzPopupClassName", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzFormat", void 0);
__decorate([WithConfig(), InputBoolean()], NzTimePickerComponent.prototype, "nzUse12Hours", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzSuffixIcon", void 0);
__decorate([InputBoolean()], NzTimePickerComponent.prototype, "nzHideDisabledOptions", void 0);
__decorate([WithConfig(), InputBoolean()], NzTimePickerComponent.prototype, "nzAllowEmpty", void 0);
__decorate([InputBoolean()], NzTimePickerComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzTimePickerComponent.prototype, "nzAutoFocus", void 0);
__decorate([WithConfig()], NzTimePickerComponent.prototype, "nzBackdrop", void 0);
__decorate([InputBoolean()], NzTimePickerComponent.prototype, "nzBorderless", void 0);
__decorate([InputBoolean()], NzTimePickerComponent.prototype, "nzInputReadOnly", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTimePickerComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "nz-time-picker",
      exportAs: "nzTimePicker",
      template: `
    <div class="ant-picker-input">
      <input
        #inputElement
        [attr.id]="nzId"
        type="text"
        [size]="inputSize"
        autocomplete="off"
        [placeholder]="nzPlaceHolder || (i18nPlaceHolder$ | async)"
        [(ngModel)]="inputValue"
        [disabled]="nzDisabled"
        [readOnly]="nzInputReadOnly"
        (focus)="onFocus(true)"
        (blur)="onFocus(false)"
        (keyup.enter)="onKeyupEnter()"
        (keyup.escape)="onKeyupEsc()"
        (ngModelChange)="onInputChange($event)"
      />
      <span class="ant-picker-suffix">
        <ng-container *nzStringTemplateOutlet="nzSuffixIcon; let suffixIcon">
          <span nz-icon [nzType]="suffixIcon"></span>
        </ng-container>
        <nz-form-item-feedback-icon *ngIf="hasFeedback && !!status" [status]="status"></nz-form-item-feedback-icon>
      </span>
      <span *ngIf="nzAllowEmpty && !nzDisabled && value" class="ant-picker-clear" (click)="onClickClearBtn($event)">
        <span
          nz-icon
          nzType="close-circle"
          nzTheme="fill"
          [attr.aria-label]="nzClearText"
          [attr.title]="nzClearText"
        ></span>
      </span>
    </div>

    <ng-template
      cdkConnectedOverlay
      nzConnectedOverlay
      [cdkConnectedOverlayHasBackdrop]="nzBackdrop"
      [cdkConnectedOverlayPositions]="overlayPositions"
      [cdkConnectedOverlayOrigin]="origin"
      [cdkConnectedOverlayOpen]="nzOpen"
      [cdkConnectedOverlayTransformOriginOn]="'.ant-picker-dropdown'"
      (detach)="close()"
      (overlayOutsideClick)="onClickOutside($event)"
    >
      <div [@slideMotion]="'enter'" class="ant-picker-dropdown" style="position: relative">
        <div class="ant-picker-panel-container">
          <div tabindex="-1" class="ant-picker-panel">
            <nz-time-picker-panel
              [ngClass]="nzPopupClassName"
              [format]="nzFormat"
              [nzHourStep]="nzHourStep"
              [nzMinuteStep]="nzMinuteStep"
              [nzSecondStep]="nzSecondStep"
              [nzDisabledHours]="nzDisabledHours"
              [nzDisabledMinutes]="nzDisabledMinutes"
              [nzDisabledSeconds]="nzDisabledSeconds"
              [nzPlaceHolder]="nzPlaceHolder || (i18nPlaceHolder$ | async)"
              [nzHideDisabledOptions]="nzHideDisabledOptions"
              [nzUse12Hours]="nzUse12Hours"
              [nzDefaultOpenValue]="nzDefaultOpenValue"
              [nzAddOn]="nzAddOn"
              [nzClearText]="nzClearText"
              [nzNowText]="nzNowText"
              [nzOkText]="nzOkText"
              [nzAllowEmpty]="nzAllowEmpty"
              [(ngModel)]="value"
              (ngModelChange)="onPanelValueChange($event)"
              (closePanel)="closePanel()"
            ></nz-time-picker-panel>
          </div>
        </div>
      </div>
    </ng-template>
  `,
      host: {
        class: "ant-picker",
        "[class.ant-picker-large]": `nzSize === 'large'`,
        "[class.ant-picker-small]": `nzSize === 'small'`,
        "[class.ant-picker-disabled]": `nzDisabled`,
        "[class.ant-picker-focused]": `focused`,
        "[class.ant-picker-rtl]": `dir === 'rtl'`,
        "[class.ant-picker-borderless]": `nzBorderless`,
        "(click)": "open()"
      },
      animations: [slideMotion],
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: NzTimePickerComponent,
        multi: true
      }],
      imports: [AsyncPipe, FormsModule, NzOutletModule, NzIconModule, NzFormPatchModule, NgIf, NzTimePickerPanelComponent, NgClass, NzOverlayModule, OverlayModule],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: NzI18nService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: DateHelperService
  }, {
    type: Platform
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormNoStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    inputRef: [{
      type: ViewChild,
      args: ["inputElement", {
        static: true
      }]
    }],
    nzId: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzHourStep: [{
      type: Input
    }],
    nzMinuteStep: [{
      type: Input
    }],
    nzSecondStep: [{
      type: Input
    }],
    nzClearText: [{
      type: Input
    }],
    nzNowText: [{
      type: Input
    }],
    nzOkText: [{
      type: Input
    }],
    nzPopupClassName: [{
      type: Input
    }],
    nzPlaceHolder: [{
      type: Input
    }],
    nzAddOn: [{
      type: Input
    }],
    nzDefaultOpenValue: [{
      type: Input
    }],
    nzDisabledHours: [{
      type: Input
    }],
    nzDisabledMinutes: [{
      type: Input
    }],
    nzDisabledSeconds: [{
      type: Input
    }],
    nzFormat: [{
      type: Input
    }],
    nzOpen: [{
      type: Input
    }],
    nzUse12Hours: [{
      type: Input
    }],
    nzSuffixIcon: [{
      type: Input
    }],
    nzOpenChange: [{
      type: Output
    }],
    nzHideDisabledOptions: [{
      type: Input
    }],
    nzAllowEmpty: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzAutoFocus: [{
      type: Input
    }],
    nzBackdrop: [{
      type: Input
    }],
    nzBorderless: [{
      type: Input
    }],
    nzInputReadOnly: [{
      type: Input
    }]
  });
})();
var _NzTimePickerModule = class _NzTimePickerModule {
};
_NzTimePickerModule.\u0275fac = function NzTimePickerModule_Factory(t) {
  return new (t || _NzTimePickerModule)();
};
_NzTimePickerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzTimePickerModule
});
_NzTimePickerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzTimePickerComponent, NzTimePickerPanelComponent]
});
var NzTimePickerModule = _NzTimePickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTimePickerModule, [{
    type: NgModule,
    args: [{
      imports: [NzTimePickerComponent, NzTimePickerPanelComponent],
      exports: [NzTimePickerPanelComponent, NzTimePickerComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-date-picker.mjs
function CalendarFooterComponent_div_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function CalendarFooterComponent_div_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, CalendarFooterComponent_div_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 4);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.extraFooter);
  }
}
function CalendarFooterComponent_div_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r4.extraFooter, \u0275\u0275sanitizeHtml);
  }
}
function CalendarFooterComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275elementContainerStart(1, 2);
    \u0275\u0275template(2, CalendarFooterComponent_div_1_ng_container_2_Template, 2, 1, "ng-container", 3)(3, CalendarFooterComponent_div_1_ng_container_3_Template, 2, 1, "ng-container", 3);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("", ctx_r0.prefixCls, "-footer-extra");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r0.isTemplateRef(ctx_r0.extraFooter));
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r0.isNonEmptyString(ctx_r0.extraFooter));
  }
}
function CalendarFooterComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 6);
    \u0275\u0275listener("click", function CalendarFooterComponent_a_2_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.isTodayDisabled ? null : ctx_r6.onClickToday());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate2("", ctx_r1.prefixCls, "-today-btn ", ctx_r1.isTodayDisabled ? ctx_r1.prefixCls + "-today-btn-disabled" : "", "");
    \u0275\u0275propertyInterpolate("title", ctx_r1.todayTitle);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r1.locale.today, " ");
  }
}
function CalendarFooterComponent_ul_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function CalendarFooterComponent_ul_3_li_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li")(1, "a", 7);
    \u0275\u0275listener("click", function CalendarFooterComponent_ul_3_li_2_Template_a_click_1_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r11 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r11.isTodayDisabled ? null : ctx_r11.onClickToday());
    });
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275classMapInterpolate1("", ctx_r9.prefixCls, "-now");
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r9.prefixCls, "-now-btn");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r9.locale.now, " ");
  }
}
function CalendarFooterComponent_ul_3_li_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li")(1, "button", 8);
    \u0275\u0275listener("click", function CalendarFooterComponent_ul_3_li_3_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r14);
      const ctx_r13 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r13.okDisabled ? null : ctx_r13.clickOk.emit());
    });
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275classMapInterpolate1("", ctx_r10.prefixCls, "-ok");
    \u0275\u0275advance(1);
    \u0275\u0275property("disabled", ctx_r10.okDisabled);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r10.locale.ok, " ");
  }
}
function CalendarFooterComponent_ul_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul");
    \u0275\u0275template(1, CalendarFooterComponent_ul_3_ng_container_1_Template, 1, 0, "ng-container", 4)(2, CalendarFooterComponent_ul_3_li_2_Template, 3, 7, "li", 0)(3, CalendarFooterComponent_ul_3_li_3_Template, 3, 5, "li", 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("", ctx_r2.prefixCls, "-ranges");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.rangeQuickSelector);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.showNow);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.hasTimePicker);
  }
}
function DecadeHeaderComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 6);
    \u0275\u0275listener("click", function DecadeHeaderComponent_ng_container_6_Template_button_click_1_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const selector_r1 = restoredCtx.$implicit;
      return \u0275\u0275resetView(selector_r1.onClick());
    });
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const selector_r1 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275classMap(selector_r1.className);
    \u0275\u0275propertyInterpolate("title", selector_r1.title || null);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", selector_r1.label, " ");
  }
}
function DecadeTableComponent_thead_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "th", 6);
  }
}
function DecadeTableComponent_thead_1_th_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r4 = ctx.$implicit;
    \u0275\u0275propertyInterpolate("title", cell_r4.title);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", cell_r4.content, " ");
  }
}
function DecadeTableComponent_thead_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "thead")(1, "tr", 3);
    \u0275\u0275template(2, DecadeTableComponent_thead_1_th_2_Template, 1, 0, "th", 4)(3, DecadeTableComponent_thead_1_th_3_Template, 2, 2, "th", 5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.showWeek);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.headRow);
  }
}
function DecadeTableComponent_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 11);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("", ctx_r6.prefixCls, "-cell-week");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", row_r5.weekNum, " ");
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_2_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
var _c019 = (a0) => ({
  $implicit: a0
});
function DecadeTableComponent_tr_3_td_2_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, DecadeTableComponent_tr_3_td_2_ng_container_2_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.cellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c019, cell_r9.value));
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 17);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", cell_r9.cellRender, \u0275\u0275sanitizeHtml);
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r14 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r14.prefixCls, "-cell-inner");
    \u0275\u0275attribute("aria-selected", cell_r9.isSelected)("aria-disabled", cell_r9.isDisabled);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", cell_r9.content, " ");
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0)(1, 13);
    \u0275\u0275template(2, DecadeTableComponent_tr_3_td_2_ng_container_2_ng_container_2_Template, 2, 4, "ng-container", 14)(3, DecadeTableComponent_tr_3_td_2_ng_container_2_ng_container_3_Template, 2, 1, "ng-container", 14)(4, DecadeTableComponent_tr_3_td_2_ng_container_2_ng_container_4_Template, 3, 6, "ng-container", 15);
    \u0275\u0275elementContainerEnd()();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r10.isTemplateRef(cell_r9.cellRender));
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r10.isNonEmptyString(cell_r9.cellRender));
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_3_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, DecadeTableComponent_tr_3_td_2_ng_container_3_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.fullCellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c019, cell_r9.value));
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_3_ng_template_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_3_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div");
    \u0275\u0275template(3, DecadeTableComponent_tr_3_td_2_ng_container_3_ng_template_3_ng_container_3_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r21 = \u0275\u0275nextContext(2);
    \u0275\u0275classMapInterpolate1("", ctx_r21.prefixCls, "-date-value");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(cell_r9.content);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r21.prefixCls, "-date-content");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.cellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(9, _c019, cell_r9.value));
  }
}
function DecadeTableComponent_tr_3_td_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275template(2, DecadeTableComponent_tr_3_td_2_ng_container_3_ng_container_2_Template, 2, 4, "ng-container", 18)(3, DecadeTableComponent_tr_3_td_2_ng_container_3_ng_template_3_Template, 4, 11, "ng-template", null, 19, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r22 = \u0275\u0275reference(4);
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r11 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r11.prefixCls, "-date ant-picker-cell-inner");
    \u0275\u0275classProp("ant-picker-calendar-date-today", cell_r9.isToday);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", cell_r9.fullCellRender)("ngIfElse", _r22);
  }
}
function DecadeTableComponent_tr_3_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 12);
    \u0275\u0275listener("click", function DecadeTableComponent_tr_3_td_2_Template_td_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r29);
      const cell_r9 = restoredCtx.$implicit;
      return \u0275\u0275resetView(cell_r9.isDisabled ? null : cell_r9.onClick());
    })("mouseenter", function DecadeTableComponent_tr_3_td_2_Template_td_mouseenter_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r29);
      const cell_r9 = restoredCtx.$implicit;
      return \u0275\u0275resetView(cell_r9.onMouseEnter());
    });
    \u0275\u0275elementContainerStart(1, 13);
    \u0275\u0275template(2, DecadeTableComponent_tr_3_td_2_ng_container_2_Template, 5, 3, "ng-container", 14)(3, DecadeTableComponent_tr_3_td_2_ng_container_3_Template, 5, 7, "ng-container", 14);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = ctx.$implicit;
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275propertyInterpolate("title", cell_r9.title);
    \u0275\u0275property("ngClass", cell_r9.classMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", ctx_r7.prefixCls);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "ant-picker");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "ant-picker-calendar");
  }
}
function DecadeTableComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 8);
    \u0275\u0275template(1, DecadeTableComponent_tr_3_td_1_Template, 2, 4, "td", 9)(2, DecadeTableComponent_tr_3_td_2_Template, 4, 5, "td", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", row_r5.classMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", row_r5.weekNum);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", row_r5.dateCells)("ngForTrackBy", ctx_r1.trackByBodyColumn);
  }
}
function YearHeaderComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 6);
    \u0275\u0275listener("click", function YearHeaderComponent_ng_container_6_Template_button_click_1_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const selector_r1 = restoredCtx.$implicit;
      return \u0275\u0275resetView(selector_r1.onClick());
    });
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const selector_r1 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275classMap(selector_r1.className);
    \u0275\u0275propertyInterpolate("title", selector_r1.title || null);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", selector_r1.label, " ");
  }
}
function YearTableComponent_thead_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "th", 6);
  }
}
function YearTableComponent_thead_1_th_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r4 = ctx.$implicit;
    \u0275\u0275propertyInterpolate("title", cell_r4.title);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", cell_r4.content, " ");
  }
}
function YearTableComponent_thead_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "thead")(1, "tr", 3);
    \u0275\u0275template(2, YearTableComponent_thead_1_th_2_Template, 1, 0, "th", 4)(3, YearTableComponent_thead_1_th_3_Template, 2, 2, "th", 5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.showWeek);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.headRow);
  }
}
function YearTableComponent_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 11);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("", ctx_r6.prefixCls, "-cell-week");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", row_r5.weekNum, " ");
  }
}
function YearTableComponent_tr_3_td_2_ng_container_2_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function YearTableComponent_tr_3_td_2_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, YearTableComponent_tr_3_td_2_ng_container_2_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.cellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c019, cell_r9.value));
  }
}
function YearTableComponent_tr_3_td_2_ng_container_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 17);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", cell_r9.cellRender, \u0275\u0275sanitizeHtml);
  }
}
function YearTableComponent_tr_3_td_2_ng_container_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r14 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r14.prefixCls, "-cell-inner");
    \u0275\u0275attribute("aria-selected", cell_r9.isSelected)("aria-disabled", cell_r9.isDisabled);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", cell_r9.content, " ");
  }
}
function YearTableComponent_tr_3_td_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0)(1, 13);
    \u0275\u0275template(2, YearTableComponent_tr_3_td_2_ng_container_2_ng_container_2_Template, 2, 4, "ng-container", 14)(3, YearTableComponent_tr_3_td_2_ng_container_2_ng_container_3_Template, 2, 1, "ng-container", 14)(4, YearTableComponent_tr_3_td_2_ng_container_2_ng_container_4_Template, 3, 6, "ng-container", 15);
    \u0275\u0275elementContainerEnd()();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r10.isTemplateRef(cell_r9.cellRender));
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r10.isNonEmptyString(cell_r9.cellRender));
  }
}
function YearTableComponent_tr_3_td_2_ng_container_3_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function YearTableComponent_tr_3_td_2_ng_container_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, YearTableComponent_tr_3_td_2_ng_container_3_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.fullCellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c019, cell_r9.value));
  }
}
function YearTableComponent_tr_3_td_2_ng_container_3_ng_template_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function YearTableComponent_tr_3_td_2_ng_container_3_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div");
    \u0275\u0275template(3, YearTableComponent_tr_3_td_2_ng_container_3_ng_template_3_ng_container_3_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r21 = \u0275\u0275nextContext(2);
    \u0275\u0275classMapInterpolate1("", ctx_r21.prefixCls, "-date-value");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(cell_r9.content);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r21.prefixCls, "-date-content");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.cellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(9, _c019, cell_r9.value));
  }
}
function YearTableComponent_tr_3_td_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275template(2, YearTableComponent_tr_3_td_2_ng_container_3_ng_container_2_Template, 2, 4, "ng-container", 18)(3, YearTableComponent_tr_3_td_2_ng_container_3_ng_template_3_Template, 4, 11, "ng-template", null, 19, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r22 = \u0275\u0275reference(4);
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r11 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r11.prefixCls, "-date ant-picker-cell-inner");
    \u0275\u0275classProp("ant-picker-calendar-date-today", cell_r9.isToday);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", cell_r9.fullCellRender)("ngIfElse", _r22);
  }
}
function YearTableComponent_tr_3_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 12);
    \u0275\u0275listener("click", function YearTableComponent_tr_3_td_2_Template_td_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r29);
      const cell_r9 = restoredCtx.$implicit;
      return \u0275\u0275resetView(cell_r9.isDisabled ? null : cell_r9.onClick());
    })("mouseenter", function YearTableComponent_tr_3_td_2_Template_td_mouseenter_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r29);
      const cell_r9 = restoredCtx.$implicit;
      return \u0275\u0275resetView(cell_r9.onMouseEnter());
    });
    \u0275\u0275elementContainerStart(1, 13);
    \u0275\u0275template(2, YearTableComponent_tr_3_td_2_ng_container_2_Template, 5, 3, "ng-container", 14)(3, YearTableComponent_tr_3_td_2_ng_container_3_Template, 5, 7, "ng-container", 14);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = ctx.$implicit;
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275propertyInterpolate("title", cell_r9.title);
    \u0275\u0275property("ngClass", cell_r9.classMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", ctx_r7.prefixCls);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "ant-picker");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "ant-picker-calendar");
  }
}
function YearTableComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 8);
    \u0275\u0275template(1, YearTableComponent_tr_3_td_1_Template, 2, 4, "td", 9)(2, YearTableComponent_tr_3_td_2_Template, 4, 5, "td", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", row_r5.classMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", row_r5.weekNum);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", row_r5.dateCells)("ngForTrackBy", ctx_r1.trackByBodyColumn);
  }
}
function MonthHeaderComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 6);
    \u0275\u0275listener("click", function MonthHeaderComponent_ng_container_6_Template_button_click_1_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const selector_r1 = restoredCtx.$implicit;
      return \u0275\u0275resetView(selector_r1.onClick());
    });
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const selector_r1 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275classMap(selector_r1.className);
    \u0275\u0275propertyInterpolate("title", selector_r1.title || null);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", selector_r1.label, " ");
  }
}
function MonthTableComponent_thead_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "th", 6);
  }
}
function MonthTableComponent_thead_1_th_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r4 = ctx.$implicit;
    \u0275\u0275propertyInterpolate("title", cell_r4.title);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", cell_r4.content, " ");
  }
}
function MonthTableComponent_thead_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "thead")(1, "tr", 3);
    \u0275\u0275template(2, MonthTableComponent_thead_1_th_2_Template, 1, 0, "th", 4)(3, MonthTableComponent_thead_1_th_3_Template, 2, 2, "th", 5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.showWeek);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.headRow);
  }
}
function MonthTableComponent_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 11);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("", ctx_r6.prefixCls, "-cell-week");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", row_r5.weekNum, " ");
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_2_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, MonthTableComponent_tr_3_td_2_ng_container_2_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.cellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c019, cell_r9.value));
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 17);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", cell_r9.cellRender, \u0275\u0275sanitizeHtml);
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r14 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r14.prefixCls, "-cell-inner");
    \u0275\u0275attribute("aria-selected", cell_r9.isSelected)("aria-disabled", cell_r9.isDisabled);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", cell_r9.content, " ");
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0)(1, 13);
    \u0275\u0275template(2, MonthTableComponent_tr_3_td_2_ng_container_2_ng_container_2_Template, 2, 4, "ng-container", 14)(3, MonthTableComponent_tr_3_td_2_ng_container_2_ng_container_3_Template, 2, 1, "ng-container", 14)(4, MonthTableComponent_tr_3_td_2_ng_container_2_ng_container_4_Template, 3, 6, "ng-container", 15);
    \u0275\u0275elementContainerEnd()();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r10.isTemplateRef(cell_r9.cellRender));
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r10.isNonEmptyString(cell_r9.cellRender));
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_3_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, MonthTableComponent_tr_3_td_2_ng_container_3_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.fullCellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c019, cell_r9.value));
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_3_ng_template_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_3_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div");
    \u0275\u0275template(3, MonthTableComponent_tr_3_td_2_ng_container_3_ng_template_3_ng_container_3_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r21 = \u0275\u0275nextContext(2);
    \u0275\u0275classMapInterpolate1("", ctx_r21.prefixCls, "-date-value");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(cell_r9.content);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r21.prefixCls, "-date-content");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.cellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(9, _c019, cell_r9.value));
  }
}
function MonthTableComponent_tr_3_td_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275template(2, MonthTableComponent_tr_3_td_2_ng_container_3_ng_container_2_Template, 2, 4, "ng-container", 18)(3, MonthTableComponent_tr_3_td_2_ng_container_3_ng_template_3_Template, 4, 11, "ng-template", null, 19, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r22 = \u0275\u0275reference(4);
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r11 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r11.prefixCls, "-date ant-picker-cell-inner");
    \u0275\u0275classProp("ant-picker-calendar-date-today", cell_r9.isToday);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", cell_r9.fullCellRender)("ngIfElse", _r22);
  }
}
function MonthTableComponent_tr_3_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 12);
    \u0275\u0275listener("click", function MonthTableComponent_tr_3_td_2_Template_td_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r29);
      const cell_r9 = restoredCtx.$implicit;
      return \u0275\u0275resetView(cell_r9.isDisabled ? null : cell_r9.onClick());
    })("mouseenter", function MonthTableComponent_tr_3_td_2_Template_td_mouseenter_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r29);
      const cell_r9 = restoredCtx.$implicit;
      return \u0275\u0275resetView(cell_r9.onMouseEnter());
    });
    \u0275\u0275elementContainerStart(1, 13);
    \u0275\u0275template(2, MonthTableComponent_tr_3_td_2_ng_container_2_Template, 5, 3, "ng-container", 14)(3, MonthTableComponent_tr_3_td_2_ng_container_3_Template, 5, 7, "ng-container", 14);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = ctx.$implicit;
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275propertyInterpolate("title", cell_r9.title);
    \u0275\u0275property("ngClass", cell_r9.classMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", ctx_r7.prefixCls);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "ant-picker");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "ant-picker-calendar");
  }
}
function MonthTableComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 8);
    \u0275\u0275template(1, MonthTableComponent_tr_3_td_1_Template, 2, 4, "td", 9)(2, MonthTableComponent_tr_3_td_2_Template, 4, 5, "td", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", row_r5.classMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", row_r5.weekNum);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", row_r5.dateCells)("ngForTrackBy", ctx_r1.trackByBodyColumn);
  }
}
function DateHeaderComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 6);
    \u0275\u0275listener("click", function DateHeaderComponent_ng_container_6_Template_button_click_1_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const selector_r1 = restoredCtx.$implicit;
      return \u0275\u0275resetView(selector_r1.onClick());
    });
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const selector_r1 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275classMap(selector_r1.className);
    \u0275\u0275propertyInterpolate("title", selector_r1.title || null);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", selector_r1.label, " ");
  }
}
function DateTableComponent_thead_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "th", 6);
  }
}
function DateTableComponent_thead_1_th_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r4 = ctx.$implicit;
    \u0275\u0275propertyInterpolate("title", cell_r4.title);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", cell_r4.content, " ");
  }
}
function DateTableComponent_thead_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "thead")(1, "tr", 3);
    \u0275\u0275template(2, DateTableComponent_thead_1_th_2_Template, 1, 0, "th", 4)(3, DateTableComponent_thead_1_th_3_Template, 2, 2, "th", 5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.showWeek);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.headRow);
  }
}
function DateTableComponent_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 11);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("", ctx_r6.prefixCls, "-cell-week");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", row_r5.weekNum, " ");
  }
}
function DateTableComponent_tr_3_td_2_ng_container_2_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateTableComponent_tr_3_td_2_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, DateTableComponent_tr_3_td_2_ng_container_2_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.cellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c019, cell_r9.value));
  }
}
function DateTableComponent_tr_3_td_2_ng_container_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 17);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", cell_r9.cellRender, \u0275\u0275sanitizeHtml);
  }
}
function DateTableComponent_tr_3_td_2_ng_container_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r14 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r14.prefixCls, "-cell-inner");
    \u0275\u0275attribute("aria-selected", cell_r9.isSelected)("aria-disabled", cell_r9.isDisabled);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", cell_r9.content, " ");
  }
}
function DateTableComponent_tr_3_td_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0)(1, 13);
    \u0275\u0275template(2, DateTableComponent_tr_3_td_2_ng_container_2_ng_container_2_Template, 2, 4, "ng-container", 14)(3, DateTableComponent_tr_3_td_2_ng_container_2_ng_container_3_Template, 2, 1, "ng-container", 14)(4, DateTableComponent_tr_3_td_2_ng_container_2_ng_container_4_Template, 3, 6, "ng-container", 15);
    \u0275\u0275elementContainerEnd()();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r10.isTemplateRef(cell_r9.cellRender));
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", ctx_r10.isNonEmptyString(cell_r9.cellRender));
  }
}
function DateTableComponent_tr_3_td_2_ng_container_3_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateTableComponent_tr_3_td_2_ng_container_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, DateTableComponent_tr_3_td_2_ng_container_3_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.fullCellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c019, cell_r9.value));
  }
}
function DateTableComponent_tr_3_td_2_ng_container_3_ng_template_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateTableComponent_tr_3_td_2_ng_container_3_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div");
    \u0275\u0275template(3, DateTableComponent_tr_3_td_2_ng_container_3_ng_template_3_ng_container_3_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r21 = \u0275\u0275nextContext(2);
    \u0275\u0275classMapInterpolate1("", ctx_r21.prefixCls, "-date-value");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(cell_r9.content);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r21.prefixCls, "-date-content");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", cell_r9.cellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(9, _c019, cell_r9.value));
  }
}
function DateTableComponent_tr_3_td_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275template(2, DateTableComponent_tr_3_td_2_ng_container_3_ng_container_2_Template, 2, 4, "ng-container", 18)(3, DateTableComponent_tr_3_td_2_ng_container_3_ng_template_3_Template, 4, 11, "ng-template", null, 19, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r22 = \u0275\u0275reference(4);
    const cell_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r11 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r11.prefixCls, "-date ant-picker-cell-inner");
    \u0275\u0275classProp("ant-picker-calendar-date-today", cell_r9.isToday);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", cell_r9.fullCellRender)("ngIfElse", _r22);
  }
}
function DateTableComponent_tr_3_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 12);
    \u0275\u0275listener("click", function DateTableComponent_tr_3_td_2_Template_td_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r29);
      const cell_r9 = restoredCtx.$implicit;
      return \u0275\u0275resetView(cell_r9.isDisabled ? null : cell_r9.onClick());
    })("mouseenter", function DateTableComponent_tr_3_td_2_Template_td_mouseenter_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r29);
      const cell_r9 = restoredCtx.$implicit;
      return \u0275\u0275resetView(cell_r9.onMouseEnter());
    });
    \u0275\u0275elementContainerStart(1, 13);
    \u0275\u0275template(2, DateTableComponent_tr_3_td_2_ng_container_2_Template, 5, 3, "ng-container", 14)(3, DateTableComponent_tr_3_td_2_ng_container_3_Template, 5, 7, "ng-container", 14);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r9 = ctx.$implicit;
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275propertyInterpolate("title", cell_r9.title);
    \u0275\u0275property("ngClass", cell_r9.classMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitch", ctx_r7.prefixCls);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "ant-picker");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngSwitchCase", "ant-picker-calendar");
  }
}
function DateTableComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 8);
    \u0275\u0275template(1, DateTableComponent_tr_3_td_1_Template, 2, 4, "td", 9)(2, DateTableComponent_tr_3_td_2_Template, 4, 5, "td", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", row_r5.classMap);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", row_r5.weekNum);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", row_r5.dateCells)("ngForTrackBy", ctx_r1.trackByBodyColumn);
  }
}
function InnerPopupComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "decade-header", 4);
    \u0275\u0275listener("valueChange", function InnerPopupComponent_ng_container_3_Template_decade_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r5 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r5.activeDate = $event);
    })("panelModeChange", function InnerPopupComponent_ng_container_3_Template_decade_header_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.panelModeChange.emit($event));
    })("valueChange", function InnerPopupComponent_ng_container_3_Template_decade_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r8 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r8.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div")(3, "decade-table", 5);
    \u0275\u0275listener("valueChange", function InnerPopupComponent_ng_container_3_Template_decade_table_valueChange_3_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.onChooseDecade($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("value", ctx_r0.activeDate)("locale", ctx_r0.locale)("showSuperPreBtn", ctx_r0.enablePrevNext("prev", "decade"))("showSuperNextBtn", ctx_r0.enablePrevNext("next", "decade"))("showNextBtn", false)("showPreBtn", false);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r0.prefixCls, "-body");
    \u0275\u0275advance(1);
    \u0275\u0275property("activeDate", ctx_r0.activeDate)("value", ctx_r0.value)("locale", ctx_r0.locale)("disabledDate", ctx_r0.disabledDate);
  }
}
function InnerPopupComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "year-header", 4);
    \u0275\u0275listener("valueChange", function InnerPopupComponent_ng_container_4_Template_year_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r10 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r10.activeDate = $event);
    })("panelModeChange", function InnerPopupComponent_ng_container_4_Template_year_header_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r12 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r12.panelModeChange.emit($event));
    })("valueChange", function InnerPopupComponent_ng_container_4_Template_year_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r13 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r13.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div")(3, "year-table", 6);
    \u0275\u0275listener("valueChange", function InnerPopupComponent_ng_container_4_Template_year_table_valueChange_3_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r14 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r14.onChooseYear($event));
    })("cellHover", function InnerPopupComponent_ng_container_4_Template_year_table_cellHover_3_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r15 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r15.cellHover.emit($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("value", ctx_r1.activeDate)("locale", ctx_r1.locale)("showSuperPreBtn", ctx_r1.enablePrevNext("prev", "year"))("showSuperNextBtn", ctx_r1.enablePrevNext("next", "year"))("showNextBtn", false)("showPreBtn", false);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r1.prefixCls, "-body");
    \u0275\u0275advance(1);
    \u0275\u0275property("activeDate", ctx_r1.activeDate)("value", ctx_r1.value)("locale", ctx_r1.locale)("disabledDate", ctx_r1.disabledDate)("selectedValue", ctx_r1.selectedValue)("hoverValue", ctx_r1.hoverValue);
  }
}
function InnerPopupComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "month-header", 4);
    \u0275\u0275listener("valueChange", function InnerPopupComponent_ng_container_5_Template_month_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r16 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r16.activeDate = $event);
    })("panelModeChange", function InnerPopupComponent_ng_container_5_Template_month_header_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r18 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r18.panelModeChange.emit($event));
    })("valueChange", function InnerPopupComponent_ng_container_5_Template_month_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r19 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r19.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div")(3, "month-table", 7);
    \u0275\u0275listener("valueChange", function InnerPopupComponent_ng_container_5_Template_month_table_valueChange_3_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r20 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r20.onChooseMonth($event));
    })("cellHover", function InnerPopupComponent_ng_container_5_Template_month_table_cellHover_3_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r21 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r21.cellHover.emit($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("value", ctx_r2.activeDate)("locale", ctx_r2.locale)("showSuperPreBtn", ctx_r2.enablePrevNext("prev", "month"))("showSuperNextBtn", ctx_r2.enablePrevNext("next", "month"))("showNextBtn", false)("showPreBtn", false);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r2.prefixCls, "-body");
    \u0275\u0275advance(1);
    \u0275\u0275property("value", ctx_r2.value)("activeDate", ctx_r2.activeDate)("locale", ctx_r2.locale)("disabledDate", ctx_r2.disabledDate)("selectedValue", ctx_r2.selectedValue)("hoverValue", ctx_r2.hoverValue);
  }
}
function InnerPopupComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "date-header", 8);
    \u0275\u0275listener("valueChange", function InnerPopupComponent_ng_container_6_Template_date_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r22 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r22.activeDate = $event);
    })("panelModeChange", function InnerPopupComponent_ng_container_6_Template_date_header_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r24 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r24.panelModeChange.emit($event));
    })("valueChange", function InnerPopupComponent_ng_container_6_Template_date_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r25 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r25.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div")(3, "date-table", 9);
    \u0275\u0275listener("valueChange", function InnerPopupComponent_ng_container_6_Template_date_table_valueChange_3_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r26 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r26.onSelectDate($event));
    })("cellHover", function InnerPopupComponent_ng_container_6_Template_date_table_cellHover_3_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r27 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r27.cellHover.emit($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("value", ctx_r3.activeDate)("locale", ctx_r3.locale)("showSuperPreBtn", ctx_r3.panelMode === "week" ? ctx_r3.enablePrevNext("prev", "week") : ctx_r3.enablePrevNext("prev", "date"))("showSuperNextBtn", ctx_r3.panelMode === "week" ? ctx_r3.enablePrevNext("next", "week") : ctx_r3.enablePrevNext("next", "date"))("showPreBtn", ctx_r3.panelMode === "week" ? ctx_r3.enablePrevNext("prev", "week") : ctx_r3.enablePrevNext("prev", "date"))("showNextBtn", ctx_r3.panelMode === "week" ? ctx_r3.enablePrevNext("next", "week") : ctx_r3.enablePrevNext("next", "date"));
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r3.prefixCls, "-body");
    \u0275\u0275advance(1);
    \u0275\u0275property("locale", ctx_r3.locale)("showWeek", ctx_r3.showWeek)("value", ctx_r3.value)("activeDate", ctx_r3.activeDate)("disabledDate", ctx_r3.disabledDate)("cellRender", ctx_r3.dateRender)("selectedValue", ctx_r3.selectedValue)("hoverValue", ctx_r3.hoverValue)("canSelectWeek", ctx_r3.panelMode === "week");
  }
}
function InnerPopupComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "nz-time-picker-panel", 10);
    \u0275\u0275listener("ngModelChange", function InnerPopupComponent_ng_container_7_Template_nz_time_picker_panel_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r29);
      const ctx_r28 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r28.onSelectTime($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzInDatePicker", true)("ngModel", ctx_r4.value == null ? null : ctx_r4.value.nativeDate)("format", ctx_r4.timeOptions.nzFormat)("nzHourStep", ctx_r4.timeOptions.nzHourStep)("nzMinuteStep", ctx_r4.timeOptions.nzMinuteStep)("nzSecondStep", ctx_r4.timeOptions.nzSecondStep)("nzDisabledHours", ctx_r4.timeOptions.nzDisabledHours)("nzDisabledMinutes", ctx_r4.timeOptions.nzDisabledMinutes)("nzDisabledSeconds", ctx_r4.timeOptions.nzDisabledSeconds)("nzHideDisabledOptions", !!ctx_r4.timeOptions.nzHideDisabledOptions)("nzDefaultOpenValue", ctx_r4.timeOptions.nzDefaultOpenValue)("nzUse12Hours", !!ctx_r4.timeOptions.nzUse12Hours)("nzAddOn", ctx_r4.timeOptions.nzAddOn);
  }
}
function DateRangePopupComponent_ng_container_0_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
var _c113 = (a0) => ({
  partType: a0
});
function DateRangePopupComponent_ng_container_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, DateRangePopupComponent_ng_container_0_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 7);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r4)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c113, ctx_r9.datePickerService.activeInput));
  }
}
function DateRangePopupComponent_ng_container_0_ng_template_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateRangePopupComponent_ng_container_0_ng_template_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
var _c211 = () => ({
  partType: "left"
});
var _c38 = () => ({
  partType: "right"
});
function DateRangePopupComponent_ng_container_0_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DateRangePopupComponent_ng_container_0_ng_template_6_ng_container_0_Template, 1, 0, "ng-container", 7)(1, DateRangePopupComponent_ng_container_0_ng_template_6_ng_container_1_Template, 1, 0, "ng-container", 7);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275property("ngTemplateOutlet", _r4)("ngTemplateOutletContext", \u0275\u0275pureFunction0(4, _c211));
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r4)("ngTemplateOutletContext", \u0275\u0275pureFunction0(5, _c38));
  }
}
function DateRangePopupComponent_ng_container_0_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateRangePopupComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275element(2, "div");
    \u0275\u0275elementStart(3, "div")(4, "div");
    \u0275\u0275template(5, DateRangePopupComponent_ng_container_0_ng_container_5_Template, 2, 4, "ng-container", 0)(6, DateRangePopupComponent_ng_container_0_ng_template_6_Template, 2, 6, "ng-template", null, 5, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275template(8, DateRangePopupComponent_ng_container_0_ng_container_8_Template, 1, 0, "ng-container", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r11 = \u0275\u0275reference(7);
    const ctx_r0 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate2("", ctx_r0.prefixCls, "-range-wrapper ", ctx_r0.prefixCls, "-date-range-wrapper");
    \u0275\u0275advance(1);
    \u0275\u0275styleMap(ctx_r0.arrowPosition);
    \u0275\u0275classMapInterpolate1("", ctx_r0.prefixCls, "-range-arrow");
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate2("", ctx_r0.prefixCls, "-panel-container ", ctx_r0.showWeek ? ctx_r0.prefixCls + "-week-number" : "", "");
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r0.prefixCls, "-panels");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.hasTimePicker)("ngIfElse", _r11);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", _r6);
  }
}
function DateRangePopupComponent_ng_template_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateRangePopupComponent_ng_template_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateRangePopupComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div", 8);
    \u0275\u0275template(2, DateRangePopupComponent_ng_template_1_ng_container_2_Template, 1, 0, "ng-container", 6)(3, DateRangePopupComponent_ng_template_1_ng_container_3_Template, 1, 0, "ng-container", 6);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const _r4 = \u0275\u0275reference(4);
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275classMapInterpolate4("", ctx_r1.prefixCls, "-panel-container ", ctx_r1.showWeek ? ctx_r1.prefixCls + "-week-number" : "", " ", ctx_r1.hasTimePicker ? ctx_r1.prefixCls + "-time" : "", " ", ctx_r1.isRange ? ctx_r1.prefixCls + "-range" : "", "");
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r1.prefixCls, "-panel");
    \u0275\u0275classProp("ant-picker-panel-rtl", ctx_r1.dir === "rtl");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r4);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r6);
  }
}
function DateRangePopupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "inner-popup", 9);
    \u0275\u0275listener("panelModeChange", function DateRangePopupComponent_ng_template_3_Template_inner_popup_panelModeChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r20);
      const partType_r18 = restoredCtx.partType;
      const ctx_r19 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r19.onPanelModeChange($event, partType_r18));
    })("cellHover", function DateRangePopupComponent_ng_template_3_Template_inner_popup_cellHover_1_listener($event) {
      \u0275\u0275restoreView(_r20);
      const ctx_r21 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r21.onCellHover($event));
    })("selectDate", function DateRangePopupComponent_ng_template_3_Template_inner_popup_selectDate_1_listener($event) {
      \u0275\u0275restoreView(_r20);
      const ctx_r22 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r22.changeValueFromSelect($event, !ctx_r22.showTime));
    })("selectTime", function DateRangePopupComponent_ng_template_3_Template_inner_popup_selectTime_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r20);
      const partType_r18 = restoredCtx.partType;
      const ctx_r23 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r23.onSelectTime($event, partType_r18));
    })("headerChange", function DateRangePopupComponent_ng_template_3_Template_inner_popup_headerChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r20);
      const partType_r18 = restoredCtx.partType;
      const ctx_r24 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r24.onActiveDateChange($event, partType_r18));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const partType_r18 = ctx.partType;
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("", ctx_r3.prefixCls, "-panel");
    \u0275\u0275classProp("ant-picker-panel-rtl", ctx_r3.dir === "rtl");
    \u0275\u0275advance(1);
    \u0275\u0275property("showWeek", ctx_r3.showWeek)("endPanelMode", ctx_r3.getPanelMode(ctx_r3.endPanelMode, partType_r18))("partType", partType_r18)("locale", ctx_r3.locale)("showTimePicker", ctx_r3.hasTimePicker)("timeOptions", ctx_r3.getTimeOptions(partType_r18))("panelMode", ctx_r3.getPanelMode(ctx_r3.panelMode, partType_r18))("activeDate", ctx_r3.getActiveDate(partType_r18))("value", ctx_r3.getValue(partType_r18))("disabledDate", ctx_r3.disabledDate)("dateRender", ctx_r3.dateRender)("selectedValue", ctx_r3.datePickerService == null ? null : ctx_r3.datePickerService.value)("hoverValue", ctx_r3.hoverValue);
  }
}
function DateRangePopupComponent_ng_template_5_calendar_footer_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r27 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "calendar-footer", 11);
    \u0275\u0275listener("clickOk", function DateRangePopupComponent_ng_template_5_calendar_footer_0_Template_calendar_footer_clickOk_0_listener() {
      \u0275\u0275restoreView(_r27);
      const ctx_r26 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r26.onClickOk());
    })("clickToday", function DateRangePopupComponent_ng_template_5_calendar_footer_0_Template_calendar_footer_clickToday_0_listener($event) {
      \u0275\u0275restoreView(_r27);
      const ctx_r28 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r28.onClickToday($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r25 = \u0275\u0275nextContext(2);
    const _r8 = \u0275\u0275reference(8);
    \u0275\u0275property("locale", ctx_r25.locale)("isRange", ctx_r25.isRange)("showToday", ctx_r25.showToday)("showNow", ctx_r25.showNow)("hasTimePicker", ctx_r25.hasTimePicker)("okDisabled", !ctx_r25.isAllowed(ctx_r25.datePickerService == null ? null : ctx_r25.datePickerService.value))("extraFooter", ctx_r25.extraFooter)("rangeQuickSelector", ctx_r25.ranges ? _r8 : null);
  }
}
function DateRangePopupComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DateRangePopupComponent_ng_template_5_calendar_footer_0_Template, 1, 8, "calendar-footer", 10);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r5.hasFooter);
  }
}
function DateRangePopupComponent_ng_template_7_li_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r32 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 13);
    \u0275\u0275listener("click", function DateRangePopupComponent_ng_template_7_li_0_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r32);
      const name_r30 = restoredCtx.$implicit;
      const ctx_r31 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r31.onClickPresetRange(ctx_r31.ranges[name_r30]));
    })("mouseenter", function DateRangePopupComponent_ng_template_7_li_0_Template_li_mouseenter_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r32);
      const name_r30 = restoredCtx.$implicit;
      const ctx_r33 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r33.onHoverPresetRange(ctx_r33.ranges[name_r30]));
    })("mouseleave", function DateRangePopupComponent_ng_template_7_li_0_Template_li_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r32);
      const ctx_r34 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r34.onPresetRangeMouseLeave());
    });
    \u0275\u0275elementStart(1, "span", 14);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const name_r30 = ctx.$implicit;
    const ctx_r29 = \u0275\u0275nextContext(2);
    \u0275\u0275classMapInterpolate1("", ctx_r29.prefixCls, "-preset");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(name_r30);
  }
}
function DateRangePopupComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DateRangePopupComponent_ng_template_7_li_0_Template, 3, 4, "li", 12);
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext();
    \u0275\u0275property("ngForOf", ctx_r7.getObjectKeys(ctx_r7.ranges));
  }
}
var _c46 = ["separatorElement"];
var _c53 = ["pickerInput"];
var _c63 = ["rangePickerInput"];
function NzDatePickerComponent_ng_container_0_div_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NzDatePickerComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "input", 7, 8);
    \u0275\u0275listener("ngModelChange", function NzDatePickerComponent_ng_container_0_div_1_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r13);
      const ctx_r12 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r12.inputValue = $event);
    })("focus", function NzDatePickerComponent_ng_container_0_div_1_Template_input_focus_1_listener($event) {
      \u0275\u0275restoreView(_r13);
      const ctx_r14 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r14.onFocus($event));
    })("focusout", function NzDatePickerComponent_ng_container_0_div_1_Template_input_focusout_1_listener($event) {
      \u0275\u0275restoreView(_r13);
      const ctx_r15 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r15.onFocusout($event));
    })("ngModelChange", function NzDatePickerComponent_ng_container_0_div_1_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r13);
      const ctx_r16 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r16.onInputChange($event));
    })("keyup.enter", function NzDatePickerComponent_ng_container_0_div_1_Template_input_keyup_enter_1_listener($event) {
      \u0275\u0275restoreView(_r13);
      const ctx_r17 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r17.onKeyupEnter($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, NzDatePickerComponent_ng_container_0_div_1_ng_container_3_Template, 1, 0, "ng-container", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275classMapInterpolate1("", ctx_r8.prefixCls, "-input");
    \u0275\u0275advance(1);
    \u0275\u0275classProp("ant-input-disabled", ctx_r8.nzDisabled);
    \u0275\u0275propertyInterpolate("placeholder", ctx_r8.getPlaceholder());
    \u0275\u0275property("disabled", ctx_r8.nzDisabled)("readOnly", ctx_r8.nzInputReadOnly)("ngModel", ctx_r8.inputValue)("size", ctx_r8.inputSize);
    \u0275\u0275attribute("id", ctx_r8.nzId);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", _r4);
  }
}
function NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r24 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r24.nzSeparator);
  }
}
function NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_6_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 14);
  }
}
function NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_6_ng_container_1_Template, 2, 1, "ng-container", 0)(2, NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_6_ng_template_2_Template, 1, 0, "ng-template", null, 13, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const _r26 = \u0275\u0275reference(3);
    const ctx_r20 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r20.nzSeparator)("ngIfElse", _r26);
  }
}
function NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NzDatePickerComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div");
    \u0275\u0275template(2, NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_2_Template, 1, 0, "ng-container", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", null, 11)(5, "span");
    \u0275\u0275template(6, NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_6_Template, 4, 2, "ng-container", 12);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div");
    \u0275\u0275template(8, NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_8_Template, 1, 0, "ng-container", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275template(9, NzDatePickerComponent_ng_container_0_ng_container_2_ng_container_9_Template, 1, 0, "ng-container", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    const _r2 = \u0275\u0275reference(2);
    const _r4 = \u0275\u0275reference(4);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r9.prefixCls, "-input");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r2)("ngTemplateOutletContext", \u0275\u0275pureFunction0(18, _c211));
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r9.prefixCls, "-range-separator");
    \u0275\u0275advance(2);
    \u0275\u0275classMapInterpolate1("", ctx_r9.prefixCls, "-separator");
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r9.nzSeparator);
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r9.prefixCls, "-input");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r2)("ngTemplateOutletContext", \u0275\u0275pureFunction0(19, _c38));
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r4);
  }
}
function NzDatePickerComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzDatePickerComponent_ng_container_0_div_1_Template, 4, 12, "div", 5)(2, NzDatePickerComponent_ng_container_0_ng_container_2_Template, 10, 20, "ng-container", 6);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r0.isRange);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.isRange);
  }
}
function NzDatePickerComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r30 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 15, 16);
    \u0275\u0275listener("click", function NzDatePickerComponent_ng_template_1_Template_input_click_0_listener($event) {
      \u0275\u0275restoreView(_r30);
      const ctx_r29 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r29.onClickInputBox($event));
    })("focusout", function NzDatePickerComponent_ng_template_1_Template_input_focusout_0_listener($event) {
      \u0275\u0275restoreView(_r30);
      const ctx_r31 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r31.onFocusout($event));
    })("focus", function NzDatePickerComponent_ng_template_1_Template_input_focus_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r30);
      const partType_r27 = restoredCtx.partType;
      const ctx_r32 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r32.onFocus($event, partType_r27));
    })("keyup.enter", function NzDatePickerComponent_ng_template_1_Template_input_keyup_enter_0_listener($event) {
      \u0275\u0275restoreView(_r30);
      const ctx_r33 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r33.onKeyupEnter($event));
    })("ngModelChange", function NzDatePickerComponent_ng_template_1_Template_input_ngModelChange_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r30);
      const partType_r27 = restoredCtx.partType;
      const ctx_r34 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r34.inputValue[ctx_r34.datePickerService.getActiveIndex(partType_r27)] = $event);
    })("ngModelChange", function NzDatePickerComponent_ng_template_1_Template_input_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r30);
      const ctx_r35 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r35.onInputChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const partType_r27 = ctx.partType;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275propertyInterpolate("placeholder", ctx_r1.getPlaceholder(partType_r27));
    \u0275\u0275property("disabled", ctx_r1.nzDisabled)("readOnly", ctx_r1.nzInputReadOnly)("size", ctx_r1.inputSize)("ngModel", ctx_r1.inputValue[ctx_r1.datePickerService.getActiveIndex(partType_r27)]);
    \u0275\u0275attribute("id", ctx_r1.nzId);
  }
}
function NzDatePickerComponent_ng_template_3_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r40 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 20);
    \u0275\u0275listener("click", function NzDatePickerComponent_ng_template_3_span_1_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r40);
      const ctx_r39 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r39.onClickClear($event));
    });
    \u0275\u0275element(1, "span", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r36 = \u0275\u0275nextContext(2);
    \u0275\u0275classMapInterpolate1("", ctx_r36.prefixCls, "-clear");
  }
}
function NzDatePickerComponent_ng_template_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 22);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const suffixIcon_r41 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", suffixIcon_r41);
  }
}
function NzDatePickerComponent_ng_template_3_nz_form_item_feedback_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-form-item-feedback-icon", 23);
  }
  if (rf & 2) {
    const ctx_r38 = \u0275\u0275nextContext(2);
    \u0275\u0275property("status", ctx_r38.status);
  }
}
function NzDatePickerComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 17);
    \u0275\u0275template(1, NzDatePickerComponent_ng_template_3_span_1_Template, 2, 3, "span", 18);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275template(3, NzDatePickerComponent_ng_template_3_ng_container_3_Template, 2, 1, "ng-container", 12)(4, NzDatePickerComponent_ng_template_3_nz_form_item_feedback_icon_4_Template, 1, 1, "nz-form-item-feedback-icon", 19);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("", ctx_r3.prefixCls, "-active-bar");
    \u0275\u0275property("ngStyle", ctx_r3.activeBarStyle);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r3.showClear());
    \u0275\u0275advance(1);
    \u0275\u0275classMapInterpolate1("", ctx_r3.prefixCls, "-suffix");
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.nzSuffixIcon);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r3.hasFeedback && !!ctx_r3.status);
  }
}
function NzDatePickerComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r43 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 17)(1, "date-range-popup", 24);
    \u0275\u0275listener("panelModeChange", function NzDatePickerComponent_ng_template_5_Template_date_range_popup_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r43);
      const ctx_r42 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r42.onPanelModeChange($event));
    })("calendarChange", function NzDatePickerComponent_ng_template_5_Template_date_range_popup_calendarChange_1_listener($event) {
      \u0275\u0275restoreView(_r43);
      const ctx_r44 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r44.onCalendarChange($event));
    })("resultOk", function NzDatePickerComponent_ng_template_5_Template_date_range_popup_resultOk_1_listener() {
      \u0275\u0275restoreView(_r43);
      const ctx_r45 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r45.onResultOk());
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate2("", ctx_r5.prefixCls, "-dropdown ", ctx_r5.nzDropdownClassName, "");
    \u0275\u0275classProp("ant-picker-dropdown-rtl", ctx_r5.dir === "rtl")("ant-picker-dropdown-placement-bottomLeft", ctx_r5.currentPositionY === "bottom" && ctx_r5.currentPositionX === "start")("ant-picker-dropdown-placement-topLeft", ctx_r5.currentPositionY === "top" && ctx_r5.currentPositionX === "start")("ant-picker-dropdown-placement-bottomRight", ctx_r5.currentPositionY === "bottom" && ctx_r5.currentPositionX === "end")("ant-picker-dropdown-placement-topRight", ctx_r5.currentPositionY === "top" && ctx_r5.currentPositionX === "end")("ant-picker-dropdown-range", ctx_r5.isRange)("ant-picker-active-left", ctx_r5.datePickerService.activeInput === "left")("ant-picker-active-right", ctx_r5.datePickerService.activeInput === "right");
    \u0275\u0275property("ngStyle", ctx_r5.nzPopupStyle);
    \u0275\u0275advance(1);
    \u0275\u0275property("isRange", ctx_r5.isRange)("inline", ctx_r5.nzInline)("defaultPickerValue", ctx_r5.nzDefaultPickerValue)("showWeek", ctx_r5.nzShowWeekNumber || ctx_r5.nzMode === "week")("panelMode", ctx_r5.panelMode)("locale", ctx_r5.nzLocale == null ? null : ctx_r5.nzLocale.lang)("showToday", ctx_r5.nzMode === "date" && ctx_r5.nzShowToday && !ctx_r5.isRange && !ctx_r5.nzShowTime)("showNow", ctx_r5.nzMode === "date" && ctx_r5.nzShowNow && !ctx_r5.isRange && !!ctx_r5.nzShowTime)("showTime", ctx_r5.nzShowTime)("dateRender", ctx_r5.nzDateRender)("disabledDate", ctx_r5.nzDisabledDate)("disabledTime", ctx_r5.nzDisabledTime)("extraFooter", ctx_r5.extraFooter)("ranges", ctx_r5.nzRanges)("dir", ctx_r5.dir);
  }
}
function NzDatePickerComponent_ng_template_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NzDatePickerComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 25);
    \u0275\u0275template(1, NzDatePickerComponent_ng_template_7_ng_container_1_Template, 1, 0, "ng-container", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext();
    const _r6 = \u0275\u0275reference(6);
    \u0275\u0275property("nzNoAnimation", !!(ctx_r7.noAnimation == null ? null : ctx_r7.noAnimation.nzNoAnimation))("@slideMotion", "enter");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r6);
  }
}
var PREFIX_CLASS = "ant-picker";
var defaultDisabledTime = {
  nzDisabledHours() {
    return [];
  },
  nzDisabledMinutes() {
    return [];
  },
  nzDisabledSeconds() {
    return [];
  }
};
function getTimeConfig(value, disabledTime) {
  let disabledTimeConfig = disabledTime ? disabledTime(value && value.nativeDate) : {};
  disabledTimeConfig = __spreadValues(__spreadValues({}, defaultDisabledTime), disabledTimeConfig);
  return disabledTimeConfig;
}
function isTimeValidByConfig(value, disabledTimeConfig) {
  let invalidTime = false;
  if (value) {
    const hour = value.getHours();
    const minutes = value.getMinutes();
    const seconds = value.getSeconds();
    const disabledHours = disabledTimeConfig.nzDisabledHours();
    if (disabledHours.indexOf(hour) === -1) {
      const disabledMinutes = disabledTimeConfig.nzDisabledMinutes(hour);
      if (disabledMinutes.indexOf(minutes) === -1) {
        const disabledSeconds = disabledTimeConfig.nzDisabledSeconds(hour, minutes);
        invalidTime = disabledSeconds.indexOf(seconds) !== -1;
      } else {
        invalidTime = true;
      }
    } else {
      invalidTime = true;
    }
  }
  return !invalidTime;
}
function isTimeValid(value, disabledTime) {
  const disabledTimeConfig = getTimeConfig(value, disabledTime);
  return isTimeValidByConfig(value, disabledTimeConfig);
}
function isAllowedDate(value, disabledDate, disabledTime) {
  if (!value) {
    return false;
  }
  if (disabledDate) {
    if (disabledDate(value.nativeDate)) {
      return false;
    }
  }
  if (disabledTime) {
    if (!isTimeValid(value, disabledTime)) {
      return false;
    }
  }
  return true;
}
function transCompatFormat(format2) {
  return format2 && format2.replace(/Y/g, "y").replace(/D/g, "d");
}
var _CalendarFooterComponent = class _CalendarFooterComponent {
  constructor(dateHelper) {
    this.dateHelper = dateHelper;
    this.showToday = false;
    this.showNow = false;
    this.hasTimePicker = false;
    this.isRange = false;
    this.okDisabled = false;
    this.rangeQuickSelector = null;
    this.clickOk = new EventEmitter();
    this.clickToday = new EventEmitter();
    this.prefixCls = PREFIX_CLASS;
    this.isTemplateRef = isTemplateRef;
    this.isNonEmptyString = isNonEmptyString;
    this.isTodayDisabled = false;
    this.todayTitle = "";
  }
  ngOnChanges(changes) {
    const now = /* @__PURE__ */ new Date();
    if (changes.disabledDate) {
      this.isTodayDisabled = !!(this.disabledDate && this.disabledDate(now));
    }
    if (changes.locale) {
      const dateFormat = transCompatFormat(this.locale.dateFormat);
      this.todayTitle = this.dateHelper.format(now, dateFormat);
    }
  }
  onClickToday() {
    const now = new CandyDate();
    this.clickToday.emit(now.clone());
  }
};
_CalendarFooterComponent.\u0275fac = function CalendarFooterComponent_Factory(t) {
  return new (t || _CalendarFooterComponent)(\u0275\u0275directiveInject(DateHelperService));
};
_CalendarFooterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CalendarFooterComponent,
  selectors: [["calendar-footer"]],
  inputs: {
    locale: "locale",
    showToday: "showToday",
    showNow: "showNow",
    hasTimePicker: "hasTimePicker",
    isRange: "isRange",
    okDisabled: "okDisabled",
    disabledDate: "disabledDate",
    extraFooter: "extraFooter",
    rangeQuickSelector: "rangeQuickSelector"
  },
  outputs: {
    clickOk: "clickOk",
    clickToday: "clickToday"
  },
  exportAs: ["calendarFooter"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 4,
  vars: 6,
  consts: [[3, "class", 4, "ngIf"], ["role", "button", 3, "class", "title", "click", 4, "ngIf"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngTemplateOutlet"], [3, "innerHTML"], ["role", "button", 3, "title", "click"], [3, "click"], ["nz-button", "", "type", "button", "nzType", "primary", "nzSize", "small", 3, "disabled", "click"]],
  template: function CalendarFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div");
      \u0275\u0275template(1, CalendarFooterComponent_div_1_Template, 4, 6, "div", 0)(2, CalendarFooterComponent_a_2_Template, 2, 6, "a", 1)(3, CalendarFooterComponent_ul_3_Template, 4, 6, "ul", 0);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-footer");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.extraFooter);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.showToday);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.hasTimePicker || ctx.rangeQuickSelector);
    }
  },
  dependencies: [NgIf, NgSwitch, NgSwitchCase, NgTemplateOutlet, NzButtonModule, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective],
  encapsulation: 2,
  changeDetection: 0
});
var CalendarFooterComponent = _CalendarFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarFooterComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "calendar-footer",
      exportAs: "calendarFooter",
      template: `
    <div class="{{ prefixCls }}-footer">
      <div *ngIf="extraFooter" class="{{ prefixCls }}-footer-extra">
        <ng-container [ngSwitch]="true">
          <ng-container *ngSwitchCase="isTemplateRef(extraFooter)">
            <ng-container *ngTemplateOutlet="$any(extraFooter)"></ng-container>
          </ng-container>
          <ng-container *ngSwitchCase="isNonEmptyString(extraFooter)">
            <span [innerHTML]="extraFooter"></span>
          </ng-container>
        </ng-container>
      </div>
      <a
        *ngIf="showToday"
        class="{{ prefixCls }}-today-btn {{ isTodayDisabled ? prefixCls + '-today-btn-disabled' : '' }}"
        role="button"
        (click)="isTodayDisabled ? null : onClickToday()"
        title="{{ todayTitle }}"
      >
        {{ locale.today }}
      </a>
      <ul *ngIf="hasTimePicker || rangeQuickSelector" class="{{ prefixCls }}-ranges">
        <ng-container *ngTemplateOutlet="rangeQuickSelector"></ng-container>
        <li *ngIf="showNow" class="{{ prefixCls }}-now">
          <a class="{{ prefixCls }}-now-btn" (click)="isTodayDisabled ? null : onClickToday()">
            {{ locale.now }}
          </a>
        </li>
        <li *ngIf="hasTimePicker" class="{{ prefixCls }}-ok">
          <button
            nz-button
            type="button"
            nzType="primary"
            nzSize="small"
            [disabled]="okDisabled"
            (click)="okDisabled ? null : clickOk.emit()"
          >
            {{ locale.ok }}
          </button>
        </li>
      </ul>
    </div>
  `,
      imports: [NgIf, NgSwitch, NgSwitchCase, NgTemplateOutlet, NzButtonModule],
      standalone: true
    }]
  }], () => [{
    type: DateHelperService
  }], {
    locale: [{
      type: Input
    }],
    showToday: [{
      type: Input
    }],
    showNow: [{
      type: Input
    }],
    hasTimePicker: [{
      type: Input
    }],
    isRange: [{
      type: Input
    }],
    okDisabled: [{
      type: Input
    }],
    disabledDate: [{
      type: Input
    }],
    extraFooter: [{
      type: Input
    }],
    rangeQuickSelector: [{
      type: Input
    }],
    clickOk: [{
      type: Output
    }],
    clickToday: [{
      type: Output
    }]
  });
})();
var _DatePickerService = class _DatePickerService {
  constructor() {
    this.activeInput = "left";
    this.arrowLeft = 0;
    this.isRange = false;
    this.valueChange$ = new ReplaySubject(1);
    this.emitValue$ = new Subject();
    this.inputPartChange$ = new Subject();
  }
  initValue(reset = false) {
    if (reset) {
      this.initialValue = this.isRange ? [] : null;
    }
    this.setValue(this.initialValue);
  }
  hasValue(value = this.value) {
    if (Array.isArray(value)) {
      return !!value[0] || !!value[1];
    } else {
      return !!value;
    }
  }
  makeValue(value) {
    if (this.isRange) {
      return value ? value.map((val) => new CandyDate(val)) : [];
    } else {
      return value ? new CandyDate(value) : null;
    }
  }
  setActiveDate(value, hasTimePicker = false, mode = "month") {
    const parentPanels = {
      date: "month",
      month: "year",
      year: "decade"
    };
    if (this.isRange) {
      this.activeDate = normalizeRangeValue(value, hasTimePicker, parentPanels[mode], this.activeInput);
    } else {
      this.activeDate = cloneDate(value);
    }
  }
  setValue(value) {
    this.value = value;
    this.valueChange$.next(this.value);
  }
  getActiveIndex(part = this.activeInput) {
    return {
      left: 0,
      right: 1
    }[part];
  }
  ngOnDestroy() {
    this.valueChange$.complete();
    this.emitValue$.complete();
    this.inputPartChange$.complete();
  }
};
_DatePickerService.\u0275fac = function DatePickerService_Factory(t) {
  return new (t || _DatePickerService)();
};
_DatePickerService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DatePickerService,
  factory: _DatePickerService.\u0275fac
});
var DatePickerService = _DatePickerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerService, [{
    type: Injectable
  }], null, null);
})();
var _AbstractPanelHeader = class _AbstractPanelHeader {
  constructor() {
    this.prefixCls = `ant-picker-header`;
    this.selectors = [];
    this.showSuperPreBtn = true;
    this.showSuperNextBtn = true;
    this.showPreBtn = true;
    this.showNextBtn = true;
    this.panelModeChange = new EventEmitter();
    this.valueChange = new EventEmitter();
  }
  superPreviousTitle() {
    return this.locale.previousYear;
  }
  previousTitle() {
    return this.locale.previousMonth;
  }
  superNextTitle() {
    return this.locale.nextYear;
  }
  nextTitle() {
    return this.locale.nextMonth;
  }
  superPrevious() {
    this.changeValue(this.value.addYears(-1));
  }
  superNext() {
    this.changeValue(this.value.addYears(1));
  }
  previous() {
    this.changeValue(this.value.addMonths(-1));
  }
  next() {
    this.changeValue(this.value.addMonths(1));
  }
  changeValue(value) {
    if (this.value !== value) {
      this.value = value;
      this.valueChange.emit(this.value);
      this.render();
    }
  }
  changeMode(mode) {
    this.panelModeChange.emit(mode);
  }
  render() {
    if (this.value) {
      this.selectors = this.getSelectors();
    }
  }
  ngOnInit() {
    if (!this.value) {
      this.value = new CandyDate();
    }
    this.selectors = this.getSelectors();
  }
  ngOnChanges(changes) {
    if (changes.value || changes.locale) {
      this.render();
    }
  }
};
_AbstractPanelHeader.\u0275fac = function AbstractPanelHeader_Factory(t) {
  return new (t || _AbstractPanelHeader)();
};
_AbstractPanelHeader.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AbstractPanelHeader,
  inputs: {
    value: "value",
    locale: "locale",
    showSuperPreBtn: "showSuperPreBtn",
    showSuperNextBtn: "showSuperNextBtn",
    showPreBtn: "showPreBtn",
    showNextBtn: "showNextBtn"
  },
  outputs: {
    panelModeChange: "panelModeChange",
    valueChange: "valueChange"
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var AbstractPanelHeader = _AbstractPanelHeader;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractPanelHeader, [{
    type: Directive
  }], null, {
    value: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    showSuperPreBtn: [{
      type: Input
    }],
    showSuperNextBtn: [{
      type: Input
    }],
    showPreBtn: [{
      type: Input
    }],
    showNextBtn: [{
      type: Input
    }],
    panelModeChange: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var _DecadeHeaderComponent = class _DecadeHeaderComponent extends AbstractPanelHeader {
  previous() {
  }
  next() {
  }
  get startYear() {
    return parseInt(`${this.value.getYear() / 100}`, 10) * 100;
  }
  get endYear() {
    return this.startYear + 99;
  }
  superPrevious() {
    this.changeValue(this.value.addYears(-100));
  }
  superNext() {
    this.changeValue(this.value.addYears(100));
  }
  getSelectors() {
    return [{
      className: `${this.prefixCls}-decade-btn`,
      title: "",
      onClick: () => {
      },
      label: `${this.startYear}-${this.endYear}`
    }];
  }
};
_DecadeHeaderComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275DecadeHeaderComponent_BaseFactory;
  return function DecadeHeaderComponent_Factory(t) {
    return (\u0275DecadeHeaderComponent_BaseFactory || (\u0275DecadeHeaderComponent_BaseFactory = \u0275\u0275getInheritedFactory(_DecadeHeaderComponent)))(t || _DecadeHeaderComponent);
  };
})();
_DecadeHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _DecadeHeaderComponent,
  selectors: [["decade-header"]],
  exportAs: ["decadeHeader"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 11,
  vars: 31,
  consts: [["role", "button", "type", "button", "tabindex", "-1", 3, "title", "click"], [1, "ant-picker-super-prev-icon"], [1, "ant-picker-prev-icon"], [4, "ngFor", "ngForOf"], [1, "ant-picker-next-icon"], [1, "ant-picker-super-next-icon"], ["role", "button", "type", "button", 3, "title", "click"]],
  template: function DecadeHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div")(1, "button", 0);
      \u0275\u0275listener("click", function DecadeHeaderComponent_Template_button_click_1_listener() {
        return ctx.superPrevious();
      });
      \u0275\u0275element(2, "span", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "button", 0);
      \u0275\u0275listener("click", function DecadeHeaderComponent_Template_button_click_3_listener() {
        return ctx.previous();
      });
      \u0275\u0275element(4, "span", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "div");
      \u0275\u0275template(6, DecadeHeaderComponent_ng_container_6_Template, 3, 5, "ng-container", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(7, "button", 0);
      \u0275\u0275listener("click", function DecadeHeaderComponent_Template_button_click_7_listener() {
        return ctx.next();
      });
      \u0275\u0275element(8, "span", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(9, "button", 0);
      \u0275\u0275listener("click", function DecadeHeaderComponent_Template_button_click_9_listener() {
        return ctx.superNext();
      });
      \u0275\u0275element(10, "span", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275classMap(ctx.prefixCls);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-super-prev-btn");
      \u0275\u0275styleProp("visibility", ctx.showSuperPreBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.superPreviousTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-prev-btn");
      \u0275\u0275styleProp("visibility", ctx.showPreBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.previousTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-view");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.selectors);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-next-btn");
      \u0275\u0275styleProp("visibility", ctx.showNextBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.nextTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-super-next-btn");
      \u0275\u0275styleProp("visibility", ctx.showSuperNextBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.superNextTitle());
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var DecadeHeaderComponent = _DecadeHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeHeaderComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "decade-header",
      exportAs: "decadeHeader",
      imports: [NgForOf, NgIf, NgClass],
      standalone: true,
      template: `<div class="{{ prefixCls }}">
  <button
    [style.visibility]="showSuperPreBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-super-prev-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ superPreviousTitle() }}"
    (click)="superPrevious()"
  >
    <span class="ant-picker-super-prev-icon"></span>
  </button>
  <button
    [style.visibility]="showPreBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-prev-btn"
    role="button"
    type="button"
    title="{{ previousTitle() }}"
    tabindex="-1"
    (click)="previous()"
  >
    <span class="ant-picker-prev-icon"></span>
  </button>

  <div class="{{ prefixCls }}-view">
    <ng-container *ngFor="let selector of selectors">
      <button
        class="{{ selector.className }}"
        role="button"
        type="button"
        title="{{ selector.title || null }}"
        (click)="selector.onClick()"
      >
        {{ selector.label }}
      </button>
    </ng-container>
  </div>
  <button
    [style.visibility]="showNextBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-next-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ nextTitle() }}"
    (click)="next()"
  >
    <span class="ant-picker-next-icon"></span>
  </button>
  <button
    [style.visibility]="showSuperNextBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-super-next-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ superNextTitle() }}"
    (click)="superNext()"
  >
    <span class="ant-picker-super-next-icon"></span>
  </button>
</div>
`
    }]
  }], null, null);
})();
var _AbstractTable = class _AbstractTable {
  constructor() {
    this.isTemplateRef = isTemplateRef;
    this.isNonEmptyString = isNonEmptyString;
    this.headRow = [];
    this.bodyRows = [];
    this.MAX_ROW = 6;
    this.MAX_COL = 7;
    this.prefixCls = "ant-picker";
    this.activeDate = new CandyDate();
    this.showWeek = false;
    this.selectedValue = [];
    this.hoverValue = [];
    this.canSelectWeek = false;
    this.valueChange = new EventEmitter();
    this.cellHover = new EventEmitter();
  }
  render() {
    if (this.activeDate) {
      this.headRow = this.makeHeadRow();
      this.bodyRows = this.makeBodyRows();
    }
  }
  trackByBodyRow(_index, item) {
    return item.trackByIndex;
  }
  trackByBodyColumn(_index, item) {
    return item.trackByIndex;
  }
  hasRangeValue() {
    return this.selectedValue?.length > 0 || this.hoverValue?.length > 0;
  }
  getClassMap(cell) {
    return {
      [`ant-picker-cell`]: true,
      [`ant-picker-cell-in-view`]: true,
      [`ant-picker-cell-selected`]: cell.isSelected,
      [`ant-picker-cell-disabled`]: cell.isDisabled,
      [`ant-picker-cell-in-range`]: !!cell.isInSelectedRange,
      [`ant-picker-cell-range-start`]: !!cell.isSelectedStart,
      [`ant-picker-cell-range-end`]: !!cell.isSelectedEnd,
      [`ant-picker-cell-range-start-single`]: !!cell.isStartSingle,
      [`ant-picker-cell-range-end-single`]: !!cell.isEndSingle,
      [`ant-picker-cell-range-hover`]: !!cell.isInHoverRange,
      [`ant-picker-cell-range-hover-start`]: !!cell.isHoverStart,
      [`ant-picker-cell-range-hover-end`]: !!cell.isHoverEnd,
      [`ant-picker-cell-range-hover-edge-start`]: !!cell.isFirstCellInPanel,
      [`ant-picker-cell-range-hover-edge-end`]: !!cell.isLastCellInPanel,
      [`ant-picker-cell-range-start-near-hover`]: !!cell.isRangeStartNearHover,
      [`ant-picker-cell-range-end-near-hover`]: !!cell.isRangeEndNearHover
    };
  }
  ngOnInit() {
    this.render();
  }
  ngOnChanges(changes) {
    if (changes.activeDate && !changes.activeDate.currentValue) {
      this.activeDate = new CandyDate();
    }
    if (changes.disabledDate || changes.locale || changes.showWeek || changes.selectWeek || this.isDateRealChange(changes.activeDate) || this.isDateRealChange(changes.value) || this.isDateRealChange(changes.selectedValue) || this.isDateRealChange(changes.hoverValue)) {
      this.render();
    }
  }
  isDateRealChange(change) {
    if (change) {
      const previousValue = change.previousValue;
      const currentValue = change.currentValue;
      if (Array.isArray(currentValue)) {
        return !Array.isArray(previousValue) || currentValue.length !== previousValue.length || currentValue.some((value, index) => {
          const previousCandyDate = previousValue[index];
          return previousCandyDate instanceof CandyDate ? previousCandyDate.isSameDay(value) : previousCandyDate !== value;
        });
      } else {
        return !this.isSameDate(previousValue, currentValue);
      }
    }
    return false;
  }
  isSameDate(left, right) {
    return !left && !right || left && right && right.isSameDay(left);
  }
};
_AbstractTable.\u0275fac = function AbstractTable_Factory(t) {
  return new (t || _AbstractTable)();
};
_AbstractTable.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _AbstractTable,
  inputs: {
    prefixCls: "prefixCls",
    value: "value",
    locale: "locale",
    activeDate: "activeDate",
    showWeek: "showWeek",
    selectedValue: "selectedValue",
    hoverValue: "hoverValue",
    disabledDate: "disabledDate",
    cellRender: "cellRender",
    fullCellRender: "fullCellRender",
    canSelectWeek: "canSelectWeek"
  },
  outputs: {
    valueChange: "valueChange",
    cellHover: "cellHover"
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var AbstractTable = _AbstractTable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractTable, [{
    type: Directive
  }], null, {
    prefixCls: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    activeDate: [{
      type: Input
    }],
    showWeek: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    hoverValue: [{
      type: Input
    }],
    disabledDate: [{
      type: Input
    }],
    cellRender: [{
      type: Input
    }],
    fullCellRender: [{
      type: Input
    }],
    canSelectWeek: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    cellHover: [{
      type: Output
    }]
  });
})();
var MAX_ROW = 4;
var MAX_COL = 3;
var _DecadeTableComponent = class _DecadeTableComponent extends AbstractTable {
  get startYear() {
    return parseInt(`${this.activeDate.getYear() / 100}`, 10) * 100;
  }
  get endYear() {
    return this.startYear + 99;
  }
  makeHeadRow() {
    return [];
  }
  makeBodyRows() {
    const decades = [];
    const currentYear = this.value && this.value.getYear();
    const startYear = this.startYear;
    const endYear = this.endYear;
    const previousYear = startYear - 10;
    let index = 0;
    for (let rowIndex = 0; rowIndex < MAX_ROW; rowIndex++) {
      const row = {
        dateCells: [],
        trackByIndex: rowIndex
      };
      for (let colIndex = 0; colIndex < MAX_COL; colIndex++) {
        const start = previousYear + index * 10;
        const end = previousYear + index * 10 + 9;
        const content = `${start}-${end}`;
        const cell = {
          trackByIndex: colIndex,
          value: this.activeDate.setYear(start).nativeDate,
          content,
          title: content,
          isDisabled: false,
          isSelected: currentYear >= start && currentYear <= end,
          isLowerThanStart: end < startYear,
          isBiggerThanEnd: start > endYear,
          classMap: {},
          onClick() {
          },
          onMouseEnter() {
          }
        };
        cell.classMap = this.getClassMap(cell);
        cell.onClick = () => this.chooseDecade(start);
        index++;
        row.dateCells.push(cell);
      }
      decades.push(row);
    }
    return decades;
  }
  getClassMap(cell) {
    return {
      [`${this.prefixCls}-cell`]: true,
      [`${this.prefixCls}-cell-in-view`]: !cell.isBiggerThanEnd && !cell.isLowerThanStart,
      [`${this.prefixCls}-cell-selected`]: cell.isSelected,
      [`${this.prefixCls}-cell-disabled`]: cell.isDisabled
    };
  }
  chooseDecade(year) {
    this.value = this.activeDate.setYear(year);
    this.valueChange.emit(this.value);
  }
};
_DecadeTableComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275DecadeTableComponent_BaseFactory;
  return function DecadeTableComponent_Factory(t) {
    return (\u0275DecadeTableComponent_BaseFactory || (\u0275DecadeTableComponent_BaseFactory = \u0275\u0275getInheritedFactory(_DecadeTableComponent)))(t || _DecadeTableComponent);
  };
})();
_DecadeTableComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _DecadeTableComponent,
  selectors: [["decade-table"]],
  exportAs: ["decadeTable"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 4,
  vars: 3,
  consts: [["cellspacing", "0", "role", "grid", 1, "ant-picker-content"], [4, "ngIf"], ["role", "row", 3, "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "row"], ["role", "columnheader", 4, "ngIf"], ["role", "columnheader", 3, "title", 4, "ngFor", "ngForOf"], ["role", "columnheader"], ["role", "columnheader", 3, "title"], ["role", "row", 3, "ngClass"], ["role", "gridcell", 3, "class", 4, "ngIf"], ["role", "gridcell", 3, "title", "ngClass", "click", "mouseenter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "gridcell"], ["role", "gridcell", 3, "title", "ngClass", "click", "mouseenter"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"], [4, "ngIf", "ngIfElse"], ["defaultCell", ""]],
  template: function DecadeTableComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "table", 0);
      \u0275\u0275template(1, DecadeTableComponent_thead_1_Template, 4, 2, "thead", 1);
      \u0275\u0275elementStart(2, "tbody");
      \u0275\u0275template(3, DecadeTableComponent_tr_3_Template, 3, 4, "tr", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.headRow && ctx.headRow.length > 0);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.bodyRows)("ngForTrackBy", ctx.trackByBodyRow);
    }
  },
  dependencies: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
  encapsulation: 2,
  changeDetection: 0
});
var DecadeTableComponent = _DecadeTableComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeTableComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "decade-table",
      exportAs: "decadeTable",
      standalone: true,
      imports: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
      template: `<table class="ant-picker-content" cellspacing="0" role="grid">
  <thead *ngIf="headRow && headRow.length > 0">
    <tr role="row">
      <th *ngIf="showWeek" role="columnheader"></th>
      <th *ngFor="let cell of headRow" role="columnheader" title="{{ cell.title }}"> {{ cell.content }} </th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let row of bodyRows; trackBy: trackByBodyRow" [ngClass]="row.classMap!" role="row">
      <td *ngIf="row.weekNum" role="gridcell" class="{{ prefixCls }}-cell-week"> {{ row.weekNum }} </td>
      <td
        *ngFor="let cell of row.dateCells; trackBy: trackByBodyColumn"
        title="{{ cell.title }}"
        role="gridcell"
        [ngClass]="cell.classMap!"
        (click)="cell.isDisabled ? null : cell.onClick()"
        (mouseenter)="cell.onMouseEnter()"
      >
        <ng-container [ngSwitch]="prefixCls">
          <ng-container *ngSwitchCase="'ant-picker'">
            <ng-container [ngSwitch]="true">
              <ng-container *ngSwitchCase="isTemplateRef(cell.cellRender)">
                <!--           *ngSwitchCase not has type assertion support, the cellRender type here is TemplateRef -->
                <ng-container
                  *ngTemplateOutlet="$any(cell.cellRender); context: { $implicit: cell.value }"
                ></ng-container>
              </ng-container>
              <ng-container *ngSwitchCase="isNonEmptyString(cell.cellRender)">
                <span [innerHTML]="cell.cellRender"></span>
              </ng-container>
              <ng-container *ngSwitchDefault>
                <div
                  class="{{ prefixCls }}-cell-inner"
                  [attr.aria-selected]="cell.isSelected"
                  [attr.aria-disabled]="cell.isDisabled"
                >
                  {{ cell.content }}
                </div>
              </ng-container>
            </ng-container>
          </ng-container>
          <ng-container *ngSwitchCase="'ant-picker-calendar'">
            <div
              class="{{ prefixCls }}-date ant-picker-cell-inner"
              [class.ant-picker-calendar-date-today]="cell.isToday"
            >
              <ng-container *ngIf="cell.fullCellRender; else defaultCell">
                <ng-container *ngTemplateOutlet="$any(cell.fullCellRender); context: { $implicit: cell.value }">
                </ng-container>
              </ng-container>
              <ng-template #defaultCell>
                <div class="{{ prefixCls }}-date-value">{{ cell.content }}</div>
                <div class="{{ prefixCls }}-date-content">
                  <ng-container *ngTemplateOutlet="$any(cell.cellRender); context: { $implicit: cell.value }">
                  </ng-container>
                </div>
              </ng-template>
            </div>
          </ng-container>
        </ng-container>
      </td>
    </tr>
  </tbody>
</table>
`
    }]
  }], null, null);
})();
var _YearHeaderComponent = class _YearHeaderComponent extends AbstractPanelHeader {
  get startYear() {
    return parseInt(`${this.value.getYear() / 10}`, 10) * 10;
  }
  get endYear() {
    return this.startYear + 9;
  }
  superPrevious() {
    this.changeValue(this.value.addYears(-10));
  }
  superNext() {
    this.changeValue(this.value.addYears(10));
  }
  getSelectors() {
    return [{
      className: `${this.prefixCls}-year-btn`,
      title: "",
      onClick: () => this.changeMode("decade"),
      label: `${this.startYear}-${this.endYear}`
    }];
  }
};
_YearHeaderComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275YearHeaderComponent_BaseFactory;
  return function YearHeaderComponent_Factory(t) {
    return (\u0275YearHeaderComponent_BaseFactory || (\u0275YearHeaderComponent_BaseFactory = \u0275\u0275getInheritedFactory(_YearHeaderComponent)))(t || _YearHeaderComponent);
  };
})();
_YearHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _YearHeaderComponent,
  selectors: [["year-header"]],
  exportAs: ["yearHeader"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 11,
  vars: 31,
  consts: [["role", "button", "type", "button", "tabindex", "-1", 3, "title", "click"], [1, "ant-picker-super-prev-icon"], [1, "ant-picker-prev-icon"], [4, "ngFor", "ngForOf"], [1, "ant-picker-next-icon"], [1, "ant-picker-super-next-icon"], ["role", "button", "type", "button", 3, "title", "click"]],
  template: function YearHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div")(1, "button", 0);
      \u0275\u0275listener("click", function YearHeaderComponent_Template_button_click_1_listener() {
        return ctx.superPrevious();
      });
      \u0275\u0275element(2, "span", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "button", 0);
      \u0275\u0275listener("click", function YearHeaderComponent_Template_button_click_3_listener() {
        return ctx.previous();
      });
      \u0275\u0275element(4, "span", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "div");
      \u0275\u0275template(6, YearHeaderComponent_ng_container_6_Template, 3, 5, "ng-container", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(7, "button", 0);
      \u0275\u0275listener("click", function YearHeaderComponent_Template_button_click_7_listener() {
        return ctx.next();
      });
      \u0275\u0275element(8, "span", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(9, "button", 0);
      \u0275\u0275listener("click", function YearHeaderComponent_Template_button_click_9_listener() {
        return ctx.superNext();
      });
      \u0275\u0275element(10, "span", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275classMap(ctx.prefixCls);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-super-prev-btn");
      \u0275\u0275styleProp("visibility", ctx.showSuperPreBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.superPreviousTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-prev-btn");
      \u0275\u0275styleProp("visibility", ctx.showPreBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.previousTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-view");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.selectors);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-next-btn");
      \u0275\u0275styleProp("visibility", ctx.showNextBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.nextTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-super-next-btn");
      \u0275\u0275styleProp("visibility", ctx.showSuperNextBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.superNextTitle());
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var YearHeaderComponent = _YearHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearHeaderComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "year-header",
      exportAs: "yearHeader",
      standalone: true,
      imports: [NgForOf, NgIf, NgClass],
      template: `<div class="{{ prefixCls }}">
  <button
    [style.visibility]="showSuperPreBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-super-prev-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ superPreviousTitle() }}"
    (click)="superPrevious()"
  >
    <span class="ant-picker-super-prev-icon"></span>
  </button>
  <button
    [style.visibility]="showPreBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-prev-btn"
    role="button"
    type="button"
    title="{{ previousTitle() }}"
    tabindex="-1"
    (click)="previous()"
  >
    <span class="ant-picker-prev-icon"></span>
  </button>

  <div class="{{ prefixCls }}-view">
    <ng-container *ngFor="let selector of selectors">
      <button
        class="{{ selector.className }}"
        role="button"
        type="button"
        title="{{ selector.title || null }}"
        (click)="selector.onClick()"
      >
        {{ selector.label }}
      </button>
    </ng-container>
  </div>
  <button
    [style.visibility]="showNextBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-next-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ nextTitle() }}"
    (click)="next()"
  >
    <span class="ant-picker-next-icon"></span>
  </button>
  <button
    [style.visibility]="showSuperNextBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-super-next-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ superNextTitle() }}"
    (click)="superNext()"
  >
    <span class="ant-picker-super-next-icon"></span>
  </button>
</div>
`
    }]
  }], null, null);
})();
var _YearTableComponent = class _YearTableComponent extends AbstractTable {
  constructor(dateHelper) {
    super();
    this.dateHelper = dateHelper;
    this.MAX_ROW = 4;
    this.MAX_COL = 3;
  }
  makeHeadRow() {
    return [];
  }
  makeBodyRows() {
    const currentYear = this.activeDate && this.activeDate.getYear();
    const startYear = parseInt(`${currentYear / 10}`, 10) * 10;
    const endYear = startYear + 9;
    const previousYear = startYear - 1;
    const years = [];
    let yearValue = 0;
    for (let rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
      const row = {
        dateCells: [],
        trackByIndex: rowIndex
      };
      for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
        const yearNum = previousYear + yearValue;
        const year = this.activeDate.setYear(yearNum);
        const content = this.dateHelper.format(year.nativeDate, "yyyy");
        const isDisabled = this.isDisabledYear(year);
        const cell = {
          trackByIndex: colIndex,
          value: year.nativeDate,
          isDisabled,
          isSameDecade: yearNum >= startYear && yearNum <= endYear,
          isSelected: yearNum === (this.value && this.value.getYear()),
          content,
          title: content,
          classMap: {},
          isLastCellInPanel: year.getYear() === endYear,
          isFirstCellInPanel: year.getYear() === startYear,
          cellRender: valueFunctionProp(this.cellRender, year),
          fullCellRender: valueFunctionProp(this.fullCellRender, year),
          onClick: () => this.chooseYear(cell.value.getFullYear()),
          onMouseEnter: () => this.cellHover.emit(year)
        };
        this.addCellProperty(cell, year);
        row.dateCells.push(cell);
        yearValue++;
      }
      years.push(row);
    }
    return years;
  }
  getClassMap(cell) {
    return __spreadProps(__spreadValues({}, super.getClassMap(cell)), {
      [`ant-picker-cell-in-view`]: !!cell.isSameDecade
    });
  }
  isDisabledYear(year) {
    if (!this.disabledDate) {
      return false;
    }
    const firstOfMonth = year.setMonth(0).setDate(1);
    for (let date = firstOfMonth; date.getYear() === year.getYear(); date = date.addDays(1)) {
      if (!this.disabledDate(date.nativeDate)) {
        return false;
      }
    }
    return true;
  }
  addCellProperty(cell, year) {
    if (this.hasRangeValue()) {
      const [startHover, endHover] = this.hoverValue;
      const [startSelected, endSelected] = this.selectedValue;
      if (startSelected?.isSameYear(year)) {
        cell.isSelectedStart = true;
        cell.isSelected = true;
      }
      if (endSelected?.isSameYear(year)) {
        cell.isSelectedEnd = true;
        cell.isSelected = true;
      }
      if (startHover && endHover) {
        cell.isHoverStart = startHover.isSameYear(year);
        cell.isHoverEnd = endHover.isSameYear(year);
        cell.isInHoverRange = startHover.isBeforeYear(year) && year.isBeforeYear(endHover);
      }
      cell.isStartSingle = startSelected && !endSelected;
      cell.isEndSingle = !startSelected && endSelected;
      cell.isInSelectedRange = startSelected?.isBeforeYear(year) && year?.isBeforeYear(endSelected);
      cell.isRangeStartNearHover = startSelected && cell.isInHoverRange;
      cell.isRangeEndNearHover = endSelected && cell.isInHoverRange;
    } else if (year.isSameYear(this.value)) {
      cell.isSelected = true;
    }
    cell.classMap = this.getClassMap(cell);
  }
  chooseYear(year) {
    this.value = this.activeDate.setYear(year);
    this.valueChange.emit(this.value);
    this.render();
  }
};
_YearTableComponent.\u0275fac = function YearTableComponent_Factory(t) {
  return new (t || _YearTableComponent)(\u0275\u0275directiveInject(DateHelperService));
};
_YearTableComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _YearTableComponent,
  selectors: [["year-table"]],
  exportAs: ["yearTable"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 4,
  vars: 3,
  consts: [["cellspacing", "0", "role", "grid", 1, "ant-picker-content"], [4, "ngIf"], ["role", "row", 3, "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "row"], ["role", "columnheader", 4, "ngIf"], ["role", "columnheader", 3, "title", 4, "ngFor", "ngForOf"], ["role", "columnheader"], ["role", "columnheader", 3, "title"], ["role", "row", 3, "ngClass"], ["role", "gridcell", 3, "class", 4, "ngIf"], ["role", "gridcell", 3, "title", "ngClass", "click", "mouseenter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "gridcell"], ["role", "gridcell", 3, "title", "ngClass", "click", "mouseenter"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"], [4, "ngIf", "ngIfElse"], ["defaultCell", ""]],
  template: function YearTableComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "table", 0);
      \u0275\u0275template(1, YearTableComponent_thead_1_Template, 4, 2, "thead", 1);
      \u0275\u0275elementStart(2, "tbody");
      \u0275\u0275template(3, YearTableComponent_tr_3_Template, 3, 4, "tr", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.headRow && ctx.headRow.length > 0);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.bodyRows)("ngForTrackBy", ctx.trackByBodyRow);
    }
  },
  dependencies: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
  encapsulation: 2,
  changeDetection: 0
});
var YearTableComponent = _YearTableComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearTableComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "year-table",
      exportAs: "yearTable",
      imports: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
      standalone: true,
      template: `<table class="ant-picker-content" cellspacing="0" role="grid">
  <thead *ngIf="headRow && headRow.length > 0">
    <tr role="row">
      <th *ngIf="showWeek" role="columnheader"></th>
      <th *ngFor="let cell of headRow" role="columnheader" title="{{ cell.title }}"> {{ cell.content }} </th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let row of bodyRows; trackBy: trackByBodyRow" [ngClass]="row.classMap!" role="row">
      <td *ngIf="row.weekNum" role="gridcell" class="{{ prefixCls }}-cell-week"> {{ row.weekNum }} </td>
      <td
        *ngFor="let cell of row.dateCells; trackBy: trackByBodyColumn"
        title="{{ cell.title }}"
        role="gridcell"
        [ngClass]="cell.classMap!"
        (click)="cell.isDisabled ? null : cell.onClick()"
        (mouseenter)="cell.onMouseEnter()"
      >
        <ng-container [ngSwitch]="prefixCls">
          <ng-container *ngSwitchCase="'ant-picker'">
            <ng-container [ngSwitch]="true">
              <ng-container *ngSwitchCase="isTemplateRef(cell.cellRender)">
                <!--           *ngSwitchCase not has type assertion support, the cellRender type here is TemplateRef -->
                <ng-container
                  *ngTemplateOutlet="$any(cell.cellRender); context: { $implicit: cell.value }"
                ></ng-container>
              </ng-container>
              <ng-container *ngSwitchCase="isNonEmptyString(cell.cellRender)">
                <span [innerHTML]="cell.cellRender"></span>
              </ng-container>
              <ng-container *ngSwitchDefault>
                <div
                  class="{{ prefixCls }}-cell-inner"
                  [attr.aria-selected]="cell.isSelected"
                  [attr.aria-disabled]="cell.isDisabled"
                >
                  {{ cell.content }}
                </div>
              </ng-container>
            </ng-container>
          </ng-container>
          <ng-container *ngSwitchCase="'ant-picker-calendar'">
            <div
              class="{{ prefixCls }}-date ant-picker-cell-inner"
              [class.ant-picker-calendar-date-today]="cell.isToday"
            >
              <ng-container *ngIf="cell.fullCellRender; else defaultCell">
                <ng-container *ngTemplateOutlet="$any(cell.fullCellRender); context: { $implicit: cell.value }">
                </ng-container>
              </ng-container>
              <ng-template #defaultCell>
                <div class="{{ prefixCls }}-date-value">{{ cell.content }}</div>
                <div class="{{ prefixCls }}-date-content">
                  <ng-container *ngTemplateOutlet="$any(cell.cellRender); context: { $implicit: cell.value }">
                  </ng-container>
                </div>
              </ng-template>
            </div>
          </ng-container>
        </ng-container>
      </td>
    </tr>
  </tbody>
</table>
`
    }]
  }], () => [{
    type: DateHelperService
  }], null);
})();
var _MonthHeaderComponent = class _MonthHeaderComponent extends AbstractPanelHeader {
  constructor(dateHelper) {
    super();
    this.dateHelper = dateHelper;
  }
  getSelectors() {
    return [{
      className: `${this.prefixCls}-month-btn`,
      title: this.locale.yearSelect,
      onClick: () => this.changeMode("year"),
      label: this.dateHelper.format(this.value.nativeDate, transCompatFormat(this.locale.yearFormat))
    }];
  }
};
_MonthHeaderComponent.\u0275fac = function MonthHeaderComponent_Factory(t) {
  return new (t || _MonthHeaderComponent)(\u0275\u0275directiveInject(DateHelperService));
};
_MonthHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MonthHeaderComponent,
  selectors: [["month-header"]],
  exportAs: ["monthHeader"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 11,
  vars: 31,
  consts: [["role", "button", "type", "button", "tabindex", "-1", 3, "title", "click"], [1, "ant-picker-super-prev-icon"], [1, "ant-picker-prev-icon"], [4, "ngFor", "ngForOf"], [1, "ant-picker-next-icon"], [1, "ant-picker-super-next-icon"], ["role", "button", "type", "button", 3, "title", "click"]],
  template: function MonthHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div")(1, "button", 0);
      \u0275\u0275listener("click", function MonthHeaderComponent_Template_button_click_1_listener() {
        return ctx.superPrevious();
      });
      \u0275\u0275element(2, "span", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "button", 0);
      \u0275\u0275listener("click", function MonthHeaderComponent_Template_button_click_3_listener() {
        return ctx.previous();
      });
      \u0275\u0275element(4, "span", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "div");
      \u0275\u0275template(6, MonthHeaderComponent_ng_container_6_Template, 3, 5, "ng-container", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(7, "button", 0);
      \u0275\u0275listener("click", function MonthHeaderComponent_Template_button_click_7_listener() {
        return ctx.next();
      });
      \u0275\u0275element(8, "span", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(9, "button", 0);
      \u0275\u0275listener("click", function MonthHeaderComponent_Template_button_click_9_listener() {
        return ctx.superNext();
      });
      \u0275\u0275element(10, "span", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275classMap(ctx.prefixCls);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-super-prev-btn");
      \u0275\u0275styleProp("visibility", ctx.showSuperPreBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.superPreviousTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-prev-btn");
      \u0275\u0275styleProp("visibility", ctx.showPreBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.previousTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-view");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.selectors);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-next-btn");
      \u0275\u0275styleProp("visibility", ctx.showNextBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.nextTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-super-next-btn");
      \u0275\u0275styleProp("visibility", ctx.showSuperNextBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.superNextTitle());
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var MonthHeaderComponent = _MonthHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthHeaderComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "month-header",
      exportAs: "monthHeader",
      standalone: true,
      imports: [NgForOf, NgIf, NgClass],
      template: `<div class="{{ prefixCls }}">
  <button
    [style.visibility]="showSuperPreBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-super-prev-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ superPreviousTitle() }}"
    (click)="superPrevious()"
  >
    <span class="ant-picker-super-prev-icon"></span>
  </button>
  <button
    [style.visibility]="showPreBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-prev-btn"
    role="button"
    type="button"
    title="{{ previousTitle() }}"
    tabindex="-1"
    (click)="previous()"
  >
    <span class="ant-picker-prev-icon"></span>
  </button>

  <div class="{{ prefixCls }}-view">
    <ng-container *ngFor="let selector of selectors">
      <button
        class="{{ selector.className }}"
        role="button"
        type="button"
        title="{{ selector.title || null }}"
        (click)="selector.onClick()"
      >
        {{ selector.label }}
      </button>
    </ng-container>
  </div>
  <button
    [style.visibility]="showNextBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-next-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ nextTitle() }}"
    (click)="next()"
  >
    <span class="ant-picker-next-icon"></span>
  </button>
  <button
    [style.visibility]="showSuperNextBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-super-next-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ superNextTitle() }}"
    (click)="superNext()"
  >
    <span class="ant-picker-super-next-icon"></span>
  </button>
</div>
`
    }]
  }], () => [{
    type: DateHelperService
  }], null);
})();
var _MonthTableComponent = class _MonthTableComponent extends AbstractTable {
  constructor(dateHelper) {
    super();
    this.dateHelper = dateHelper;
    this.MAX_ROW = 4;
    this.MAX_COL = 3;
  }
  makeHeadRow() {
    return [];
  }
  makeBodyRows() {
    const months = [];
    let monthValue = 0;
    for (let rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
      const row = {
        dateCells: [],
        trackByIndex: rowIndex
      };
      for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
        const month = this.activeDate.setMonth(monthValue);
        const isDisabled = this.isDisabledMonth(month);
        const content = this.dateHelper.format(month.nativeDate, "MMM");
        const cell = {
          trackByIndex: colIndex,
          value: month.nativeDate,
          isDisabled,
          isSelected: month.isSameMonth(this.value),
          content,
          title: content,
          classMap: {},
          cellRender: valueFunctionProp(this.cellRender, month),
          fullCellRender: valueFunctionProp(this.fullCellRender, month),
          onClick: () => this.chooseMonth(cell.value.getMonth()),
          onMouseEnter: () => this.cellHover.emit(month)
        };
        this.addCellProperty(cell, month);
        row.dateCells.push(cell);
        monthValue++;
      }
      months.push(row);
    }
    return months;
  }
  isDisabledMonth(month) {
    if (!this.disabledDate) {
      return false;
    }
    const firstOfMonth = month.setDate(1);
    for (let date = firstOfMonth; date.getMonth() === month.getMonth(); date = date.addDays(1)) {
      if (!this.disabledDate(date.nativeDate)) {
        return false;
      }
    }
    return true;
  }
  addCellProperty(cell, month) {
    if (this.hasRangeValue()) {
      const [startHover, endHover] = this.hoverValue;
      const [startSelected, endSelected] = this.selectedValue;
      if (startSelected?.isSameMonth(month)) {
        cell.isSelectedStart = true;
        cell.isSelected = true;
      }
      if (endSelected?.isSameMonth(month)) {
        cell.isSelectedEnd = true;
        cell.isSelected = true;
      }
      if (startHover && endHover) {
        cell.isHoverStart = startHover.isSameMonth(month);
        cell.isHoverEnd = endHover.isSameMonth(month);
        cell.isLastCellInPanel = month.getMonth() === 11;
        cell.isFirstCellInPanel = month.getMonth() === 0;
        cell.isInHoverRange = startHover.isBeforeMonth(month) && month.isBeforeMonth(endHover);
      }
      cell.isStartSingle = startSelected && !endSelected;
      cell.isEndSingle = !startSelected && endSelected;
      cell.isInSelectedRange = startSelected?.isBeforeMonth(month) && month?.isBeforeMonth(endSelected);
      cell.isRangeStartNearHover = startSelected && cell.isInHoverRange;
      cell.isRangeEndNearHover = endSelected && cell.isInHoverRange;
    } else if (month.isSameMonth(this.value)) {
      cell.isSelected = true;
    }
    cell.classMap = this.getClassMap(cell);
  }
  chooseMonth(month) {
    this.value = this.activeDate.setMonth(month);
    this.valueChange.emit(this.value);
  }
};
_MonthTableComponent.\u0275fac = function MonthTableComponent_Factory(t) {
  return new (t || _MonthTableComponent)(\u0275\u0275directiveInject(DateHelperService));
};
_MonthTableComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _MonthTableComponent,
  selectors: [["month-table"]],
  exportAs: ["monthTable"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 4,
  vars: 3,
  consts: [["cellspacing", "0", "role", "grid", 1, "ant-picker-content"], [4, "ngIf"], ["role", "row", 3, "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "row"], ["role", "columnheader", 4, "ngIf"], ["role", "columnheader", 3, "title", 4, "ngFor", "ngForOf"], ["role", "columnheader"], ["role", "columnheader", 3, "title"], ["role", "row", 3, "ngClass"], ["role", "gridcell", 3, "class", 4, "ngIf"], ["role", "gridcell", 3, "title", "ngClass", "click", "mouseenter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "gridcell"], ["role", "gridcell", 3, "title", "ngClass", "click", "mouseenter"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"], [4, "ngIf", "ngIfElse"], ["defaultCell", ""]],
  template: function MonthTableComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "table", 0);
      \u0275\u0275template(1, MonthTableComponent_thead_1_Template, 4, 2, "thead", 1);
      \u0275\u0275elementStart(2, "tbody");
      \u0275\u0275template(3, MonthTableComponent_tr_3_Template, 3, 4, "tr", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.headRow && ctx.headRow.length > 0);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.bodyRows)("ngForTrackBy", ctx.trackByBodyRow);
    }
  },
  dependencies: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
  encapsulation: 2,
  changeDetection: 0
});
var MonthTableComponent = _MonthTableComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthTableComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "month-table",
      exportAs: "monthTable",
      standalone: true,
      imports: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
      template: `<table class="ant-picker-content" cellspacing="0" role="grid">
  <thead *ngIf="headRow && headRow.length > 0">
    <tr role="row">
      <th *ngIf="showWeek" role="columnheader"></th>
      <th *ngFor="let cell of headRow" role="columnheader" title="{{ cell.title }}"> {{ cell.content }} </th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let row of bodyRows; trackBy: trackByBodyRow" [ngClass]="row.classMap!" role="row">
      <td *ngIf="row.weekNum" role="gridcell" class="{{ prefixCls }}-cell-week"> {{ row.weekNum }} </td>
      <td
        *ngFor="let cell of row.dateCells; trackBy: trackByBodyColumn"
        title="{{ cell.title }}"
        role="gridcell"
        [ngClass]="cell.classMap!"
        (click)="cell.isDisabled ? null : cell.onClick()"
        (mouseenter)="cell.onMouseEnter()"
      >
        <ng-container [ngSwitch]="prefixCls">
          <ng-container *ngSwitchCase="'ant-picker'">
            <ng-container [ngSwitch]="true">
              <ng-container *ngSwitchCase="isTemplateRef(cell.cellRender)">
                <!--           *ngSwitchCase not has type assertion support, the cellRender type here is TemplateRef -->
                <ng-container
                  *ngTemplateOutlet="$any(cell.cellRender); context: { $implicit: cell.value }"
                ></ng-container>
              </ng-container>
              <ng-container *ngSwitchCase="isNonEmptyString(cell.cellRender)">
                <span [innerHTML]="cell.cellRender"></span>
              </ng-container>
              <ng-container *ngSwitchDefault>
                <div
                  class="{{ prefixCls }}-cell-inner"
                  [attr.aria-selected]="cell.isSelected"
                  [attr.aria-disabled]="cell.isDisabled"
                >
                  {{ cell.content }}
                </div>
              </ng-container>
            </ng-container>
          </ng-container>
          <ng-container *ngSwitchCase="'ant-picker-calendar'">
            <div
              class="{{ prefixCls }}-date ant-picker-cell-inner"
              [class.ant-picker-calendar-date-today]="cell.isToday"
            >
              <ng-container *ngIf="cell.fullCellRender; else defaultCell">
                <ng-container *ngTemplateOutlet="$any(cell.fullCellRender); context: { $implicit: cell.value }">
                </ng-container>
              </ng-container>
              <ng-template #defaultCell>
                <div class="{{ prefixCls }}-date-value">{{ cell.content }}</div>
                <div class="{{ prefixCls }}-date-content">
                  <ng-container *ngTemplateOutlet="$any(cell.cellRender); context: { $implicit: cell.value }">
                  </ng-container>
                </div>
              </ng-template>
            </div>
          </ng-container>
        </ng-container>
      </td>
    </tr>
  </tbody>
</table>
`
    }]
  }], () => [{
    type: DateHelperService
  }], null);
})();
var _DateHeaderComponent = class _DateHeaderComponent extends AbstractPanelHeader {
  constructor(dateHelper) {
    super();
    this.dateHelper = dateHelper;
  }
  getSelectors() {
    return [{
      className: `${this.prefixCls}-year-btn`,
      title: this.locale.yearSelect,
      onClick: () => this.changeMode("year"),
      label: this.dateHelper.format(this.value.nativeDate, transCompatFormat(this.locale.yearFormat))
    }, {
      className: `${this.prefixCls}-month-btn`,
      title: this.locale.monthSelect,
      onClick: () => this.changeMode("month"),
      label: this.dateHelper.format(this.value.nativeDate, this.locale.monthFormat || "MMM")
    }];
  }
};
_DateHeaderComponent.\u0275fac = function DateHeaderComponent_Factory(t) {
  return new (t || _DateHeaderComponent)(\u0275\u0275directiveInject(DateHelperService));
};
_DateHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _DateHeaderComponent,
  selectors: [["date-header"]],
  exportAs: ["dateHeader"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 11,
  vars: 31,
  consts: [["role", "button", "type", "button", "tabindex", "-1", 3, "title", "click"], [1, "ant-picker-super-prev-icon"], [1, "ant-picker-prev-icon"], [4, "ngFor", "ngForOf"], [1, "ant-picker-next-icon"], [1, "ant-picker-super-next-icon"], ["role", "button", "type", "button", 3, "title", "click"]],
  template: function DateHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div")(1, "button", 0);
      \u0275\u0275listener("click", function DateHeaderComponent_Template_button_click_1_listener() {
        return ctx.superPrevious();
      });
      \u0275\u0275element(2, "span", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "button", 0);
      \u0275\u0275listener("click", function DateHeaderComponent_Template_button_click_3_listener() {
        return ctx.previous();
      });
      \u0275\u0275element(4, "span", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "div");
      \u0275\u0275template(6, DateHeaderComponent_ng_container_6_Template, 3, 5, "ng-container", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(7, "button", 0);
      \u0275\u0275listener("click", function DateHeaderComponent_Template_button_click_7_listener() {
        return ctx.next();
      });
      \u0275\u0275element(8, "span", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(9, "button", 0);
      \u0275\u0275listener("click", function DateHeaderComponent_Template_button_click_9_listener() {
        return ctx.superNext();
      });
      \u0275\u0275element(10, "span", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275classMap(ctx.prefixCls);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-super-prev-btn");
      \u0275\u0275styleProp("visibility", ctx.showSuperPreBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.superPreviousTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-prev-btn");
      \u0275\u0275styleProp("visibility", ctx.showPreBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.previousTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-view");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.selectors);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-next-btn");
      \u0275\u0275styleProp("visibility", ctx.showNextBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.nextTitle());
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("", ctx.prefixCls, "-super-next-btn");
      \u0275\u0275styleProp("visibility", ctx.showSuperNextBtn ? "visible" : "hidden");
      \u0275\u0275propertyInterpolate("title", ctx.superNextTitle());
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var DateHeaderComponent = _DateHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateHeaderComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "date-header",
      exportAs: "dateHeader",
      standalone: true,
      imports: [NgForOf, NgIf, NgClass],
      template: `<div class="{{ prefixCls }}">
  <button
    [style.visibility]="showSuperPreBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-super-prev-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ superPreviousTitle() }}"
    (click)="superPrevious()"
  >
    <span class="ant-picker-super-prev-icon"></span>
  </button>
  <button
    [style.visibility]="showPreBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-prev-btn"
    role="button"
    type="button"
    title="{{ previousTitle() }}"
    tabindex="-1"
    (click)="previous()"
  >
    <span class="ant-picker-prev-icon"></span>
  </button>

  <div class="{{ prefixCls }}-view">
    <ng-container *ngFor="let selector of selectors">
      <button
        class="{{ selector.className }}"
        role="button"
        type="button"
        title="{{ selector.title || null }}"
        (click)="selector.onClick()"
      >
        {{ selector.label }}
      </button>
    </ng-container>
  </div>
  <button
    [style.visibility]="showNextBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-next-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ nextTitle() }}"
    (click)="next()"
  >
    <span class="ant-picker-next-icon"></span>
  </button>
  <button
    [style.visibility]="showSuperNextBtn ? 'visible' : 'hidden'"
    class="{{ prefixCls }}-super-next-btn"
    role="button"
    type="button"
    tabindex="-1"
    title="{{ superNextTitle() }}"
    (click)="superNext()"
  >
    <span class="ant-picker-super-next-icon"></span>
  </button>
</div>
`
    }]
  }], () => [{
    type: DateHelperService
  }], null);
})();
var _DateTableComponent = class _DateTableComponent extends AbstractTable {
  constructor(i18n, dateHelper) {
    super();
    this.i18n = i18n;
    this.dateHelper = dateHelper;
  }
  changeValueFromInside(value) {
    this.activeDate = this.activeDate.setYear(value.getYear()).setMonth(value.getMonth()).setDate(value.getDate());
    this.valueChange.emit(this.activeDate);
    if (!this.activeDate.isSameMonth(this.value)) {
      this.render();
    }
  }
  makeHeadRow() {
    const weekDays = [];
    const start = this.activeDate.calendarStart({
      weekStartsOn: this.dateHelper.getFirstDayOfWeek()
    });
    for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
      const day = start.addDays(colIndex);
      weekDays.push({
        trackByIndex: null,
        value: day.nativeDate,
        title: this.dateHelper.format(day.nativeDate, "E"),
        content: this.dateHelper.format(day.nativeDate, this.getVeryShortWeekFormat()),
        isSelected: false,
        isDisabled: false,
        onClick() {
        },
        onMouseEnter() {
        }
      });
    }
    return weekDays;
  }
  getVeryShortWeekFormat() {
    return this.i18n.getLocaleId().toLowerCase().indexOf("zh") === 0 ? "EEEEE" : "EEEEEE";
  }
  makeBodyRows() {
    const weekRows = [];
    const firstDayOfMonth = this.activeDate.calendarStart({
      weekStartsOn: this.dateHelper.getFirstDayOfWeek()
    });
    for (let week = 0; week < this.MAX_ROW; week++) {
      const weekStart = firstDayOfMonth.addDays(week * 7);
      const row = {
        isActive: false,
        dateCells: [],
        trackByIndex: week
      };
      for (let day = 0; day < 7; day++) {
        const date = weekStart.addDays(day);
        const dateFormat = transCompatFormat(this.i18n.getLocaleData("DatePicker.lang.dateFormat", "YYYY-MM-DD"));
        const title = this.dateHelper.format(date.nativeDate, dateFormat);
        const label = this.dateHelper.format(date.nativeDate, "dd");
        const cell = {
          trackByIndex: day,
          value: date.nativeDate,
          label,
          isSelected: false,
          isDisabled: false,
          isToday: false,
          title,
          cellRender: valueFunctionProp(this.cellRender, date),
          fullCellRender: valueFunctionProp(this.fullCellRender, date),
          content: `${date.getDate()}`,
          onClick: () => this.changeValueFromInside(date),
          onMouseEnter: () => this.cellHover.emit(date)
        };
        this.addCellProperty(cell, date);
        if (this.showWeek && !row.weekNum) {
          row.weekNum = this.dateHelper.getISOWeek(date.nativeDate);
        }
        if (date.isSameDay(this.value)) {
          row.isActive = date.isSameDay(this.value);
        }
        row.dateCells.push(cell);
      }
      row.classMap = {
        [`ant-picker-week-panel-row`]: this.canSelectWeek,
        [`ant-picker-week-panel-row-selected`]: this.canSelectWeek && row.isActive
      };
      weekRows.push(row);
    }
    return weekRows;
  }
  addCellProperty(cell, date) {
    if (this.hasRangeValue() && !this.canSelectWeek) {
      const [startHover, endHover] = this.hoverValue;
      const [startSelected, endSelected] = this.selectedValue;
      if (startSelected?.isSameDay(date)) {
        cell.isSelectedStart = true;
        cell.isSelected = true;
      }
      if (endSelected?.isSameDay(date)) {
        cell.isSelectedEnd = true;
        cell.isSelected = true;
      }
      if (startHover && endHover) {
        cell.isHoverStart = startHover.isSameDay(date);
        cell.isHoverEnd = endHover.isSameDay(date);
        cell.isLastCellInPanel = date.isLastDayOfMonth();
        cell.isFirstCellInPanel = date.isFirstDayOfMonth();
        cell.isInHoverRange = startHover.isBeforeDay(date) && date.isBeforeDay(endHover);
      }
      cell.isStartSingle = startSelected && !endSelected;
      cell.isEndSingle = !startSelected && endSelected;
      cell.isInSelectedRange = startSelected?.isBeforeDay(date) && date.isBeforeDay(endSelected);
      cell.isRangeStartNearHover = startSelected && cell.isInHoverRange;
      cell.isRangeEndNearHover = endSelected && cell.isInHoverRange;
    }
    cell.isToday = date.isToday();
    cell.isSelected = date.isSameDay(this.value);
    cell.isDisabled = !!this.disabledDate?.(date.nativeDate);
    cell.classMap = this.getClassMap(cell);
  }
  getClassMap(cell) {
    const date = new CandyDate(cell.value);
    return __spreadProps(__spreadValues({}, super.getClassMap(cell)), {
      [`ant-picker-cell-today`]: !!cell.isToday,
      [`ant-picker-cell-in-view`]: date.isSameMonth(this.activeDate)
    });
  }
};
_DateTableComponent.\u0275fac = function DateTableComponent_Factory(t) {
  return new (t || _DateTableComponent)(\u0275\u0275directiveInject(NzI18nService), \u0275\u0275directiveInject(DateHelperService));
};
_DateTableComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _DateTableComponent,
  selectors: [["date-table"]],
  inputs: {
    locale: "locale"
  },
  exportAs: ["dateTable"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 4,
  vars: 3,
  consts: [["cellspacing", "0", "role", "grid", 1, "ant-picker-content"], [4, "ngIf"], ["role", "row", 3, "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "row"], ["role", "columnheader", 4, "ngIf"], ["role", "columnheader", 3, "title", 4, "ngFor", "ngForOf"], ["role", "columnheader"], ["role", "columnheader", 3, "title"], ["role", "row", 3, "ngClass"], ["role", "gridcell", 3, "class", 4, "ngIf"], ["role", "gridcell", 3, "title", "ngClass", "click", "mouseenter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "gridcell"], ["role", "gridcell", 3, "title", "ngClass", "click", "mouseenter"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"], [4, "ngIf", "ngIfElse"], ["defaultCell", ""]],
  template: function DateTableComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "table", 0);
      \u0275\u0275template(1, DateTableComponent_thead_1_Template, 4, 2, "thead", 1);
      \u0275\u0275elementStart(2, "tbody");
      \u0275\u0275template(3, DateTableComponent_tr_3_Template, 3, 4, "tr", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.headRow && ctx.headRow.length > 0);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.bodyRows)("ngForTrackBy", ctx.trackByBodyRow);
    }
  },
  dependencies: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
  encapsulation: 2,
  changeDetection: 0
});
var DateTableComponent = _DateTableComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTableComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "date-table",
      exportAs: "dateTable",
      standalone: true,
      imports: [NgIf, NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
      template: `<table class="ant-picker-content" cellspacing="0" role="grid">
  <thead *ngIf="headRow && headRow.length > 0">
    <tr role="row">
      <th *ngIf="showWeek" role="columnheader"></th>
      <th *ngFor="let cell of headRow" role="columnheader" title="{{ cell.title }}"> {{ cell.content }} </th>
    </tr>
  </thead>
  <tbody>
    <tr *ngFor="let row of bodyRows; trackBy: trackByBodyRow" [ngClass]="row.classMap!" role="row">
      <td *ngIf="row.weekNum" role="gridcell" class="{{ prefixCls }}-cell-week"> {{ row.weekNum }} </td>
      <td
        *ngFor="let cell of row.dateCells; trackBy: trackByBodyColumn"
        title="{{ cell.title }}"
        role="gridcell"
        [ngClass]="cell.classMap!"
        (click)="cell.isDisabled ? null : cell.onClick()"
        (mouseenter)="cell.onMouseEnter()"
      >
        <ng-container [ngSwitch]="prefixCls">
          <ng-container *ngSwitchCase="'ant-picker'">
            <ng-container [ngSwitch]="true">
              <ng-container *ngSwitchCase="isTemplateRef(cell.cellRender)">
                <!--           *ngSwitchCase not has type assertion support, the cellRender type here is TemplateRef -->
                <ng-container
                  *ngTemplateOutlet="$any(cell.cellRender); context: { $implicit: cell.value }"
                ></ng-container>
              </ng-container>
              <ng-container *ngSwitchCase="isNonEmptyString(cell.cellRender)">
                <span [innerHTML]="cell.cellRender"></span>
              </ng-container>
              <ng-container *ngSwitchDefault>
                <div
                  class="{{ prefixCls }}-cell-inner"
                  [attr.aria-selected]="cell.isSelected"
                  [attr.aria-disabled]="cell.isDisabled"
                >
                  {{ cell.content }}
                </div>
              </ng-container>
            </ng-container>
          </ng-container>
          <ng-container *ngSwitchCase="'ant-picker-calendar'">
            <div
              class="{{ prefixCls }}-date ant-picker-cell-inner"
              [class.ant-picker-calendar-date-today]="cell.isToday"
            >
              <ng-container *ngIf="cell.fullCellRender; else defaultCell">
                <ng-container *ngTemplateOutlet="$any(cell.fullCellRender); context: { $implicit: cell.value }">
                </ng-container>
              </ng-container>
              <ng-template #defaultCell>
                <div class="{{ prefixCls }}-date-value">{{ cell.content }}</div>
                <div class="{{ prefixCls }}-date-content">
                  <ng-container *ngTemplateOutlet="$any(cell.cellRender); context: { $implicit: cell.value }">
                  </ng-container>
                </div>
              </ng-template>
            </div>
          </ng-container>
        </ng-container>
      </td>
    </tr>
  </tbody>
</table>
`
    }]
  }], () => [{
    type: NzI18nService
  }, {
    type: DateHelperService
  }], {
    locale: [{
      type: Input
    }]
  });
})();
var _LibPackerModule = class _LibPackerModule {
};
_LibPackerModule.\u0275fac = function LibPackerModule_Factory(t) {
  return new (t || _LibPackerModule)();
};
_LibPackerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LibPackerModule
});
_LibPackerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var LibPackerModule = _LibPackerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LibPackerModule, [{
    type: NgModule,
    args: [{
      imports: [DateHeaderComponent, DateTableComponent, DecadeHeaderComponent, DecadeTableComponent, MonthHeaderComponent, MonthTableComponent, YearHeaderComponent, YearTableComponent],
      exports: [DateHeaderComponent, DateTableComponent, DecadeHeaderComponent, DecadeTableComponent, MonthHeaderComponent, MonthTableComponent, YearHeaderComponent, YearTableComponent]
    }]
  }], null, null);
})();
var _InnerPopupComponent = class _InnerPopupComponent {
  constructor() {
    this.panelModeChange = new EventEmitter();
    this.headerChange = new EventEmitter();
    this.selectDate = new EventEmitter();
    this.selectTime = new EventEmitter();
    this.cellHover = new EventEmitter();
    this.prefixCls = PREFIX_CLASS;
  }
  /**
   * Hide "next" arrow in left panel,
   * hide "prev" arrow in right panel
   *
   * @param direction
   * @param panelMode
   */
  enablePrevNext(direction, panelMode) {
    return !(!this.showTimePicker && panelMode === this.endPanelMode && (this.partType === "left" && direction === "next" || this.partType === "right" && direction === "prev"));
  }
  onSelectTime(date) {
    this.selectTime.emit(new CandyDate(date));
  }
  // The value real changed to outside
  onSelectDate(date) {
    const value = date instanceof CandyDate ? date : new CandyDate(date);
    const timeValue = this.timeOptions && this.timeOptions.nzDefaultOpenValue;
    if (!this.value && timeValue) {
      value.setHms(timeValue.getHours(), timeValue.getMinutes(), timeValue.getSeconds());
    }
    this.selectDate.emit(value);
  }
  onChooseMonth(value) {
    this.activeDate = this.activeDate.setMonth(value.getMonth());
    if (this.endPanelMode === "month") {
      this.value = value;
      this.selectDate.emit(value);
    } else {
      this.headerChange.emit(value);
      this.panelModeChange.emit(this.endPanelMode);
    }
  }
  onChooseYear(value) {
    this.activeDate = this.activeDate.setYear(value.getYear());
    if (this.endPanelMode === "year") {
      this.value = value;
      this.selectDate.emit(value);
    } else {
      this.headerChange.emit(value);
      this.panelModeChange.emit(this.endPanelMode);
    }
  }
  onChooseDecade(value) {
    this.activeDate = this.activeDate.setYear(value.getYear());
    if (this.endPanelMode === "decade") {
      this.value = value;
      this.selectDate.emit(value);
    } else {
      this.headerChange.emit(value);
      this.panelModeChange.emit("year");
    }
  }
  ngOnChanges(changes) {
    if (changes.activeDate && !changes.activeDate.currentValue) {
      this.activeDate = new CandyDate();
    }
    if (changes.panelMode && changes.panelMode.currentValue === "time") {
      this.panelMode = "date";
    }
  }
};
_InnerPopupComponent.\u0275fac = function InnerPopupComponent_Factory(t) {
  return new (t || _InnerPopupComponent)();
};
_InnerPopupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _InnerPopupComponent,
  selectors: [["inner-popup"]],
  inputs: {
    activeDate: "activeDate",
    endPanelMode: "endPanelMode",
    panelMode: "panelMode",
    showWeek: "showWeek",
    locale: "locale",
    showTimePicker: "showTimePicker",
    timeOptions: "timeOptions",
    disabledDate: "disabledDate",
    dateRender: "dateRender",
    selectedValue: "selectedValue",
    hoverValue: "hoverValue",
    value: "value",
    partType: "partType"
  },
  outputs: {
    panelModeChange: "panelModeChange",
    headerChange: "headerChange",
    selectDate: "selectDate",
    selectTime: "selectTime",
    cellHover: "cellHover"
  },
  exportAs: ["innerPopup"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 8,
  vars: 11,
  consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], [4, "ngIf"], [3, "value", "locale", "showSuperPreBtn", "showSuperNextBtn", "showNextBtn", "showPreBtn", "valueChange", "panelModeChange"], [3, "activeDate", "value", "locale", "disabledDate", "valueChange"], [3, "activeDate", "value", "locale", "disabledDate", "selectedValue", "hoverValue", "valueChange", "cellHover"], [3, "value", "activeDate", "locale", "disabledDate", "selectedValue", "hoverValue", "valueChange", "cellHover"], [3, "value", "locale", "showSuperPreBtn", "showSuperNextBtn", "showPreBtn", "showNextBtn", "valueChange", "panelModeChange"], [3, "locale", "showWeek", "value", "activeDate", "disabledDate", "cellRender", "selectedValue", "hoverValue", "canSelectWeek", "valueChange", "cellHover"], [3, "nzInDatePicker", "ngModel", "format", "nzHourStep", "nzMinuteStep", "nzSecondStep", "nzDisabledHours", "nzDisabledMinutes", "nzDisabledSeconds", "nzHideDisabledOptions", "nzDefaultOpenValue", "nzUse12Hours", "nzAddOn", "ngModelChange"]],
  template: function InnerPopupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div")(1, "div");
      \u0275\u0275elementContainerStart(2, 0);
      \u0275\u0275template(3, InnerPopupComponent_ng_container_3_Template, 4, 13, "ng-container", 1)(4, InnerPopupComponent_ng_container_4_Template, 4, 15, "ng-container", 1)(5, InnerPopupComponent_ng_container_5_Template, 4, 15, "ng-container", 1)(6, InnerPopupComponent_ng_container_6_Template, 4, 18, "ng-container", 2);
      \u0275\u0275elementContainerEnd();
      \u0275\u0275elementEnd();
      \u0275\u0275template(7, InnerPopupComponent_ng_container_7_Template, 2, 13, "ng-container", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-picker-datetime-panel", ctx.showTimePicker);
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate2("", ctx.prefixCls, "-", ctx.panelMode, "-panel");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitch", ctx.panelMode);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "decade");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "year");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngSwitchCase", "month");
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.showTimePicker && ctx.timeOptions);
    }
  },
  dependencies: [NgSwitch, NgSwitchCase, LibPackerModule, DateHeaderComponent, DateTableComponent, DecadeHeaderComponent, DecadeTableComponent, MonthHeaderComponent, MonthTableComponent, YearHeaderComponent, YearTableComponent, NgSwitchDefault, NgIf, NzTimePickerModule, NzTimePickerPanelComponent, FormsModule, NgControlStatus, NgModel],
  encapsulation: 2,
  changeDetection: 0
});
var InnerPopupComponent = _InnerPopupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InnerPopupComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "inner-popup",
      exportAs: "innerPopup",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <div [class.ant-picker-datetime-panel]="showTimePicker">
      <div class="{{ prefixCls }}-{{ panelMode }}-panel">
        <ng-container [ngSwitch]="panelMode">
          <ng-container *ngSwitchCase="'decade'">
            <decade-header
              [(value)]="activeDate"
              [locale]="locale"
              [showSuperPreBtn]="enablePrevNext('prev', 'decade')"
              [showSuperNextBtn]="enablePrevNext('next', 'decade')"
              [showNextBtn]="false"
              [showPreBtn]="false"
              (panelModeChange)="panelModeChange.emit($event)"
              (valueChange)="headerChange.emit($event)"
            ></decade-header>
            <div class="{{ prefixCls }}-body">
              <decade-table
                [activeDate]="activeDate"
                [value]="value"
                [locale]="locale"
                (valueChange)="onChooseDecade($event)"
                [disabledDate]="disabledDate"
              ></decade-table>
            </div>
          </ng-container>
          <ng-container *ngSwitchCase="'year'">
            <year-header
              [(value)]="activeDate"
              [locale]="locale"
              [showSuperPreBtn]="enablePrevNext('prev', 'year')"
              [showSuperNextBtn]="enablePrevNext('next', 'year')"
              [showNextBtn]="false"
              [showPreBtn]="false"
              (panelModeChange)="panelModeChange.emit($event)"
              (valueChange)="headerChange.emit($event)"
            ></year-header>
            <div class="{{ prefixCls }}-body">
              <year-table
                [activeDate]="activeDate"
                [value]="value"
                [locale]="locale"
                [disabledDate]="disabledDate"
                [selectedValue]="selectedValue"
                [hoverValue]="hoverValue"
                (valueChange)="onChooseYear($event)"
                (cellHover)="cellHover.emit($event)"
              ></year-table>
            </div>
          </ng-container>
          <ng-container *ngSwitchCase="'month'">
            <month-header
              [(value)]="activeDate"
              [locale]="locale"
              [showSuperPreBtn]="enablePrevNext('prev', 'month')"
              [showSuperNextBtn]="enablePrevNext('next', 'month')"
              [showNextBtn]="false"
              [showPreBtn]="false"
              (panelModeChange)="panelModeChange.emit($event)"
              (valueChange)="headerChange.emit($event)"
            ></month-header>
            <div class="{{ prefixCls }}-body">
              <month-table
                [value]="value"
                [activeDate]="activeDate"
                [locale]="locale"
                [disabledDate]="disabledDate"
                [selectedValue]="selectedValue"
                [hoverValue]="hoverValue"
                (valueChange)="onChooseMonth($event)"
                (cellHover)="cellHover.emit($event)"
              ></month-table>
            </div>
          </ng-container>

          <ng-container *ngSwitchDefault>
            <date-header
              [(value)]="activeDate"
              [locale]="locale"
              [showSuperPreBtn]="panelMode === 'week' ? enablePrevNext('prev', 'week') : enablePrevNext('prev', 'date')"
              [showSuperNextBtn]="
                panelMode === 'week' ? enablePrevNext('next', 'week') : enablePrevNext('next', 'date')
              "
              [showPreBtn]="panelMode === 'week' ? enablePrevNext('prev', 'week') : enablePrevNext('prev', 'date')"
              [showNextBtn]="panelMode === 'week' ? enablePrevNext('next', 'week') : enablePrevNext('next', 'date')"
              (panelModeChange)="panelModeChange.emit($event)"
              (valueChange)="headerChange.emit($event)"
            ></date-header>
            <div class="{{ prefixCls }}-body">
              <date-table
                [locale]="locale"
                [showWeek]="showWeek"
                [value]="value"
                [activeDate]="activeDate"
                [disabledDate]="disabledDate"
                [cellRender]="dateRender"
                [selectedValue]="selectedValue"
                [hoverValue]="hoverValue"
                [canSelectWeek]="panelMode === 'week'"
                (valueChange)="onSelectDate($event)"
                (cellHover)="cellHover.emit($event)"
              ></date-table>
            </div>
          </ng-container>
        </ng-container>
      </div>
      <ng-container *ngIf="showTimePicker && timeOptions">
        <nz-time-picker-panel
          [nzInDatePicker]="true"
          [ngModel]="value?.nativeDate"
          (ngModelChange)="onSelectTime($event)"
          [format]="$any(timeOptions.nzFormat)"
          [nzHourStep]="$any(timeOptions.nzHourStep)"
          [nzMinuteStep]="$any(timeOptions.nzMinuteStep)"
          [nzSecondStep]="$any(timeOptions.nzSecondStep)"
          [nzDisabledHours]="$any(timeOptions.nzDisabledHours)"
          [nzDisabledMinutes]="$any(timeOptions.nzDisabledMinutes)"
          [nzDisabledSeconds]="$any(timeOptions.nzDisabledSeconds)"
          [nzHideDisabledOptions]="!!timeOptions.nzHideDisabledOptions"
          [nzDefaultOpenValue]="$any(timeOptions.nzDefaultOpenValue)"
          [nzUse12Hours]="!!timeOptions.nzUse12Hours"
          [nzAddOn]="$any(timeOptions.nzAddOn)"
        ></nz-time-picker-panel>
        <!-- use [opened] to trigger time panel 'initPosition()' -->
      </ng-container>
    </div>
  `,
      imports: [NgSwitch, NgSwitchCase, LibPackerModule, NgSwitchDefault, NgIf, NzTimePickerModule, FormsModule],
      standalone: true
    }]
  }], null, {
    activeDate: [{
      type: Input
    }],
    endPanelMode: [{
      type: Input
    }],
    panelMode: [{
      type: Input
    }],
    showWeek: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    showTimePicker: [{
      type: Input
    }],
    timeOptions: [{
      type: Input
    }],
    disabledDate: [{
      type: Input
    }],
    dateRender: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    hoverValue: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    partType: [{
      type: Input
    }],
    panelModeChange: [{
      type: Output
    }],
    headerChange: [{
      type: Output
    }],
    selectDate: [{
      type: Output
    }],
    selectTime: [{
      type: Output
    }],
    cellHover: [{
      type: Output
    }]
  });
})();
var _DateRangePopupComponent = class _DateRangePopupComponent {
  get hasTimePicker() {
    return !!this.showTime;
  }
  get hasFooter() {
    return this.showToday || this.hasTimePicker || !!this.extraFooter || !!this.ranges;
  }
  get arrowPosition() {
    return this.dir === "rtl" ? {
      right: `${this.datePickerService?.arrowLeft}px`
    } : {
      left: `${this.datePickerService?.arrowLeft}px`
    };
  }
  constructor(datePickerService, cdr, ngZone, host) {
    this.datePickerService = datePickerService;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.host = host;
    this.inline = false;
    this.dir = "ltr";
    this.panelModeChange = new EventEmitter();
    this.calendarChange = new EventEmitter();
    this.resultOk = new EventEmitter();
    this.prefixCls = PREFIX_CLASS;
    this.endPanelMode = "date";
    this.timeOptions = null;
    this.hoverValue = [];
    this.checkedPartArr = [false, false];
    this.destroy$ = new Subject();
    this.disabledStartTime = (value) => this.disabledTime && this.disabledTime(value, "start");
    this.disabledEndTime = (value) => this.disabledTime && this.disabledTime(value, "end");
  }
  ngOnInit() {
    merge(this.datePickerService.valueChange$, this.datePickerService.inputPartChange$).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.updateActiveDate();
      this.cdr.markForCheck();
    });
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.host.nativeElement, "mousedown").pipe(takeUntil(this.destroy$)).subscribe((event) => event.preventDefault());
    });
  }
  ngOnChanges(changes) {
    if (changes.showTime || changes.disabledTime) {
      if (this.showTime) {
        this.buildTimeOptions();
      }
    }
    if (changes.panelMode) {
      this.endPanelMode = this.panelMode;
    }
    if (changes.defaultPickerValue) {
      this.updateActiveDate();
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  updateActiveDate() {
    const activeDate = this.datePickerService.hasValue() ? this.datePickerService.value : this.datePickerService.makeValue(this.defaultPickerValue);
    this.datePickerService.setActiveDate(activeDate, this.hasTimePicker, this.getPanelMode(this.endPanelMode));
  }
  onClickOk() {
    const inputIndex = {
      left: 0,
      right: 1
    }[this.datePickerService.activeInput];
    const value = this.isRange ? this.datePickerService.value[inputIndex] : this.datePickerService.value;
    this.changeValueFromSelect(value);
    this.resultOk.emit();
  }
  onClickToday(value) {
    this.changeValueFromSelect(value, !this.showTime);
  }
  onCellHover(value) {
    if (!this.isRange) {
      return;
    }
    const otherInputIndex = {
      left: 1,
      right: 0
    }[this.datePickerService.activeInput];
    const base = this.datePickerService.value[otherInputIndex];
    if (base) {
      if (base.isBeforeDay(value)) {
        this.hoverValue = [base, value];
      } else {
        this.hoverValue = [value, base];
      }
    }
  }
  onPanelModeChange(mode, partType) {
    if (this.isRange) {
      const index = this.datePickerService.getActiveIndex(partType);
      if (index === 0) {
        this.panelMode = [mode, this.panelMode[1]];
      } else {
        this.panelMode = [this.panelMode[0], mode];
      }
    } else {
      this.panelMode = mode;
    }
    this.panelModeChange.emit(this.panelMode);
  }
  onActiveDateChange(value, partType) {
    if (this.isRange) {
      const activeDate = [];
      activeDate[this.datePickerService.getActiveIndex(partType)] = value;
      this.datePickerService.setActiveDate(activeDate, this.hasTimePicker, this.getPanelMode(this.endPanelMode, partType));
    } else {
      this.datePickerService.setActiveDate(value);
    }
  }
  onSelectTime(value, partType) {
    if (this.isRange) {
      const newValue = cloneDate(this.datePickerService.value);
      const index = this.datePickerService.getActiveIndex(partType);
      newValue[index] = this.overrideHms(value, newValue[index]);
      this.datePickerService.setValue(newValue);
    } else {
      const newValue = this.overrideHms(value, this.datePickerService.value);
      this.datePickerService.setValue(newValue);
    }
    this.datePickerService.inputPartChange$.next(null);
    this.buildTimeOptions();
  }
  changeValueFromSelect(value, emitValue = true) {
    if (this.isRange) {
      const selectedValue = cloneDate(this.datePickerService.value);
      const checkedPart = this.datePickerService.activeInput;
      let nextPart = checkedPart;
      selectedValue[this.datePickerService.getActiveIndex(checkedPart)] = value;
      this.checkedPartArr[this.datePickerService.getActiveIndex(checkedPart)] = true;
      this.hoverValue = selectedValue;
      if (emitValue) {
        if (this.inline) {
          nextPart = this.reversedPart(checkedPart);
          if (nextPart === "right") {
            selectedValue[this.datePickerService.getActiveIndex(nextPart)] = null;
            this.checkedPartArr[this.datePickerService.getActiveIndex(nextPart)] = false;
          }
          this.datePickerService.setValue(selectedValue);
          this.calendarChange.emit(selectedValue);
          if (this.isBothAllowed(selectedValue) && this.checkedPartArr[0] && this.checkedPartArr[1]) {
            this.clearHoverValue();
            this.datePickerService.emitValue$.next();
          }
        } else {
          if (wrongSortOrder(selectedValue)) {
            nextPart = this.reversedPart(checkedPart);
            selectedValue[this.datePickerService.getActiveIndex(nextPart)] = null;
            this.checkedPartArr[this.datePickerService.getActiveIndex(nextPart)] = false;
          }
          this.datePickerService.setValue(selectedValue);
          if (this.isBothAllowed(selectedValue) && this.checkedPartArr[0] && this.checkedPartArr[1]) {
            this.calendarChange.emit(selectedValue);
            this.clearHoverValue();
            this.datePickerService.emitValue$.next();
          } else if (this.isAllowed(selectedValue)) {
            nextPart = this.reversedPart(checkedPart);
            this.calendarChange.emit([value.clone()]);
          }
        }
      } else {
        this.datePickerService.setValue(selectedValue);
      }
      this.datePickerService.inputPartChange$.next(nextPart);
    } else {
      this.datePickerService.setValue(value);
      this.datePickerService.inputPartChange$.next(null);
      if (emitValue && this.isAllowed(value)) {
        this.datePickerService.emitValue$.next();
      }
    }
    this.buildTimeOptions();
  }
  reversedPart(part) {
    return part === "left" ? "right" : "left";
  }
  getPanelMode(panelMode, partType) {
    if (this.isRange) {
      return panelMode[this.datePickerService.getActiveIndex(partType)];
    } else {
      return panelMode;
    }
  }
  // Get single value or part value of a range
  getValue(partType) {
    if (this.isRange) {
      return (this.datePickerService.value || [])[this.datePickerService.getActiveIndex(partType)];
    } else {
      return this.datePickerService.value;
    }
  }
  getActiveDate(partType) {
    if (this.isRange) {
      return this.datePickerService.activeDate[this.datePickerService.getActiveIndex(partType)];
    } else {
      return this.datePickerService.activeDate;
    }
  }
  isOneAllowed(selectedValue) {
    const index = this.datePickerService.getActiveIndex();
    const disabledTimeArr = [this.disabledStartTime, this.disabledEndTime];
    return isAllowedDate(selectedValue[index], this.disabledDate, disabledTimeArr[index]);
  }
  isBothAllowed(selectedValue) {
    return isAllowedDate(selectedValue[0], this.disabledDate, this.disabledStartTime) && isAllowedDate(selectedValue[1], this.disabledDate, this.disabledEndTime);
  }
  isAllowed(value, isBoth = false) {
    if (this.isRange) {
      return isBoth ? this.isBothAllowed(value) : this.isOneAllowed(value);
    } else {
      return isAllowedDate(value, this.disabledDate, this.disabledTime);
    }
  }
  getTimeOptions(partType) {
    if (this.showTime && this.timeOptions) {
      return this.timeOptions instanceof Array ? this.timeOptions[this.datePickerService.getActiveIndex(partType)] : this.timeOptions;
    }
    return null;
  }
  onClickPresetRange(val) {
    const value = typeof val === "function" ? val() : val;
    if (value) {
      this.datePickerService.setValue([new CandyDate(value[0]), new CandyDate(value[1])]);
      this.datePickerService.emitValue$.next();
    }
  }
  onPresetRangeMouseLeave() {
    this.clearHoverValue();
  }
  onHoverPresetRange(val) {
    if (typeof val !== "function") {
      this.hoverValue = [new CandyDate(val[0]), new CandyDate(val[1])];
    }
  }
  getObjectKeys(obj) {
    return obj ? Object.keys(obj) : [];
  }
  show(partType) {
    const hide = this.showTime && this.isRange && this.datePickerService.activeInput !== partType;
    return !hide;
  }
  clearHoverValue() {
    this.hoverValue = [];
  }
  buildTimeOptions() {
    if (this.showTime) {
      const showTime = typeof this.showTime === "object" ? this.showTime : {};
      if (this.isRange) {
        const value = this.datePickerService.value;
        this.timeOptions = [this.overrideTimeOptions(showTime, value[0], "start"), this.overrideTimeOptions(showTime, value[1], "end")];
      } else {
        this.timeOptions = this.overrideTimeOptions(showTime, this.datePickerService.value);
      }
    } else {
      this.timeOptions = null;
    }
  }
  overrideTimeOptions(origin, value, partial) {
    let disabledTimeFn;
    if (partial) {
      disabledTimeFn = partial === "start" ? this.disabledStartTime : this.disabledEndTime;
    } else {
      disabledTimeFn = this.disabledTime;
    }
    return __spreadValues(__spreadValues({}, origin), getTimeConfig(value, disabledTimeFn));
  }
  overrideHms(newValue, oldValue) {
    newValue = newValue || new CandyDate();
    oldValue = oldValue || new CandyDate();
    return oldValue.setHms(newValue.getHours(), newValue.getMinutes(), newValue.getSeconds());
  }
};
_DateRangePopupComponent.\u0275fac = function DateRangePopupComponent_Factory(t) {
  return new (t || _DateRangePopupComponent)(\u0275\u0275directiveInject(DatePickerService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef));
};
_DateRangePopupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _DateRangePopupComponent,
  selectors: [["date-range-popup"]],
  inputs: {
    isRange: "isRange",
    inline: "inline",
    showWeek: "showWeek",
    locale: "locale",
    disabledDate: "disabledDate",
    disabledTime: "disabledTime",
    showToday: "showToday",
    showNow: "showNow",
    showTime: "showTime",
    extraFooter: "extraFooter",
    ranges: "ranges",
    dateRender: "dateRender",
    panelMode: "panelMode",
    defaultPickerValue: "defaultPickerValue",
    dir: "dir"
  },
  outputs: {
    panelModeChange: "panelModeChange",
    calendarChange: "calendarChange",
    resultOk: "resultOk"
  },
  exportAs: ["dateRangePopup"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 9,
  vars: 2,
  consts: [[4, "ngIf", "ngIfElse"], ["singlePanel", ""], ["tplInnerPopup", ""], ["tplFooter", ""], ["tplRangeQuickSelector", ""], ["noTimePicker", ""], [4, "ngTemplateOutlet"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["tabindex", "-1"], [3, "showWeek", "endPanelMode", "partType", "locale", "showTimePicker", "timeOptions", "panelMode", "activeDate", "value", "disabledDate", "dateRender", "selectedValue", "hoverValue", "panelModeChange", "cellHover", "selectDate", "selectTime", "headerChange"], [3, "locale", "isRange", "showToday", "showNow", "hasTimePicker", "okDisabled", "extraFooter", "rangeQuickSelector", "clickOk", "clickToday", 4, "ngIf"], [3, "locale", "isRange", "showToday", "showNow", "hasTimePicker", "okDisabled", "extraFooter", "rangeQuickSelector", "clickOk", "clickToday"], [3, "class", "click", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf"], [3, "click", "mouseenter", "mouseleave"], [1, "ant-tag", "ant-tag-blue"]],
  template: function DateRangePopupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, DateRangePopupComponent_ng_container_0_Template, 9, 19, "ng-container", 0)(1, DateRangePopupComponent_ng_template_1_Template, 4, 13, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, DateRangePopupComponent_ng_template_3_Template, 2, 18, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(5, DateRangePopupComponent_ng_template_5_Template, 1, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor)(7, DateRangePopupComponent_ng_template_7_Template, 1, 1, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", ctx.isRange)("ngIfElse", _r2);
    }
  },
  dependencies: [InnerPopupComponent, NgTemplateOutlet, NgIf, CalendarFooterComponent, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var DateRangePopupComponent = _DateRangePopupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "date-range-popup",
      exportAs: "dateRangePopup",
      template: `
    <ng-container *ngIf="isRange; else singlePanel">
      <div class="{{ prefixCls }}-range-wrapper {{ prefixCls }}-date-range-wrapper">
        <div class="{{ prefixCls }}-range-arrow" [style]="arrowPosition"></div>
        <div class="{{ prefixCls }}-panel-container {{ showWeek ? prefixCls + '-week-number' : '' }}">
          <div class="{{ prefixCls }}-panels">
            <ng-container *ngIf="hasTimePicker; else noTimePicker">
              <ng-container
                *ngTemplateOutlet="tplInnerPopup; context: { partType: datePickerService.activeInput }"
              ></ng-container>
            </ng-container>
            <ng-template #noTimePicker>
              <ng-container *ngTemplateOutlet="tplInnerPopup; context: { partType: 'left' }"></ng-container>
              <ng-container *ngTemplateOutlet="tplInnerPopup; context: { partType: 'right' }"></ng-container>
            </ng-template>
          </div>
          <ng-container *ngTemplateOutlet="tplFooter"></ng-container>
        </div>
      </div>
    </ng-container>
    <ng-template #singlePanel>
      <div
        class="{{ prefixCls }}-panel-container {{ showWeek ? prefixCls + '-week-number' : '' }} {{
          hasTimePicker ? prefixCls + '-time' : ''
        }} {{ isRange ? prefixCls + '-range' : '' }}"
      >
        <div class="{{ prefixCls }}-panel" [class.ant-picker-panel-rtl]="dir === 'rtl'" tabindex="-1">
          <!-- Single ONLY -->
          <ng-container *ngTemplateOutlet="tplInnerPopup"></ng-container>
          <ng-container *ngTemplateOutlet="tplFooter"></ng-container>
        </div>
      </div>
    </ng-template>

    <ng-template #tplInnerPopup let-partType="partType">
      <div class="{{ prefixCls }}-panel" [class.ant-picker-panel-rtl]="dir === 'rtl'">
        <!-- TODO(@wenqi73) [selectedValue] [hoverValue] types-->
        <inner-popup
          [showWeek]="showWeek"
          [endPanelMode]="getPanelMode(endPanelMode, partType)"
          [partType]="partType"
          [locale]="locale!"
          [showTimePicker]="hasTimePicker"
          [timeOptions]="getTimeOptions(partType)"
          [panelMode]="getPanelMode(panelMode, partType)"
          (panelModeChange)="onPanelModeChange($event, partType)"
          [activeDate]="getActiveDate(partType)"
          [value]="getValue(partType)"
          [disabledDate]="disabledDate"
          [dateRender]="dateRender"
          [selectedValue]="$any(datePickerService?.value)"
          [hoverValue]="$any(hoverValue)"
          (cellHover)="onCellHover($event)"
          (selectDate)="changeValueFromSelect($event, !showTime)"
          (selectTime)="onSelectTime($event, partType)"
          (headerChange)="onActiveDateChange($event, partType)"
        ></inner-popup>
      </div>
    </ng-template>

    <ng-template #tplFooter>
      <calendar-footer
        *ngIf="hasFooter"
        [locale]="locale!"
        [isRange]="isRange"
        [showToday]="showToday"
        [showNow]="showNow"
        [hasTimePicker]="hasTimePicker"
        [okDisabled]="!isAllowed($any(datePickerService?.value))"
        [extraFooter]="extraFooter"
        [rangeQuickSelector]="ranges ? tplRangeQuickSelector : null"
        (clickOk)="onClickOk()"
        (clickToday)="onClickToday($event)"
      ></calendar-footer>
    </ng-template>

    <!-- Range ONLY: Range Quick Selector -->
    <ng-template #tplRangeQuickSelector>
      <li
        *ngFor="let name of getObjectKeys(ranges)"
        class="{{ prefixCls }}-preset"
        (click)="onClickPresetRange(ranges![name])"
        (mouseenter)="onHoverPresetRange(ranges![name])"
        (mouseleave)="onPresetRangeMouseLeave()"
      >
        <span class="ant-tag ant-tag-blue">{{ name }}</span>
      </li>
    </ng-template>
  `,
      imports: [InnerPopupComponent, NgTemplateOutlet, NgIf, CalendarFooterComponent, NgForOf],
      standalone: true
    }]
  }], () => [{
    type: DatePickerService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }], {
    isRange: [{
      type: Input
    }],
    inline: [{
      type: Input
    }],
    showWeek: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    disabledDate: [{
      type: Input
    }],
    disabledTime: [{
      type: Input
    }],
    showToday: [{
      type: Input
    }],
    showNow: [{
      type: Input
    }],
    showTime: [{
      type: Input
    }],
    extraFooter: [{
      type: Input
    }],
    ranges: [{
      type: Input
    }],
    dateRender: [{
      type: Input
    }],
    panelMode: [{
      type: Input
    }],
    defaultPickerValue: [{
      type: Input
    }],
    dir: [{
      type: Input
    }],
    panelModeChange: [{
      type: Output
    }],
    calendarChange: [{
      type: Output
    }],
    resultOk: [{
      type: Output
    }]
  });
})();
var POPUP_STYLE_PATCH = {
  position: "relative"
};
var NZ_CONFIG_MODULE_NAME11 = "datePicker";
var _NzDatePickerComponent = class _NzDatePickerComponent {
  get nzShowTime() {
    return this.showTime;
  }
  set nzShowTime(value) {
    this.showTime = typeof value === "object" ? value : toBoolean(value);
  }
  get realOpenState() {
    return this.isOpenHandledByUser() ? !!this.nzOpen : this.overlayOpen;
  }
  ngAfterViewInit() {
    if (this.nzAutoFocus) {
      this.focus();
    }
    if (this.isRange && this.platform.isBrowser) {
      this.nzResizeObserver.observe(this.elementRef).pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.updateInputWidthAndArrowLeft();
      });
    }
    this.datePickerService.inputPartChange$.pipe(takeUntil(this.destroy$)).subscribe((partType) => {
      if (partType) {
        this.datePickerService.activeInput = partType;
      }
      this.focus();
      this.updateInputWidthAndArrowLeft();
    });
    if (this.platform.isBrowser) {
      this.ngZone.runOutsideAngular(() => (
        // prevent mousedown event to trigger focusout event when click in date picker
        // see: https://github.com/NG-ZORRO/ng-zorro-antd/issues/7450
        fromEvent(this.elementRef.nativeElement, "mousedown").pipe(takeUntil(this.destroy$)).subscribe((event) => {
          if (event.target.tagName.toLowerCase() !== "input") {
            event.preventDefault();
          }
        })
      ));
    }
  }
  updateInputWidthAndArrowLeft() {
    this.inputWidth = this.rangePickerInputs?.first?.nativeElement.offsetWidth || 0;
    const baseStyle = {
      position: "absolute",
      width: `${this.inputWidth}px`
    };
    this.datePickerService.arrowLeft = this.datePickerService.activeInput === "left" ? 0 : this.inputWidth + this.separatorElement?.nativeElement.offsetWidth || 0;
    if (this.dir === "rtl") {
      this.activeBarStyle = __spreadProps(__spreadValues({}, baseStyle), {
        right: `${this.datePickerService.arrowLeft}px`
      });
    } else {
      this.activeBarStyle = __spreadProps(__spreadValues({}, baseStyle), {
        left: `${this.datePickerService.arrowLeft}px`
      });
    }
    this.cdr.markForCheck();
  }
  getInput(partType) {
    if (this.nzInline) {
      return void 0;
    }
    return this.isRange ? partType === "left" ? this.rangePickerInputs?.first.nativeElement : this.rangePickerInputs?.last.nativeElement : this.pickerInput.nativeElement;
  }
  focus() {
    const activeInputElement = this.getInput(this.datePickerService.activeInput);
    if (this.document.activeElement !== activeInputElement) {
      activeInputElement?.focus();
    }
  }
  onFocus(event, partType) {
    event.preventDefault();
    if (partType) {
      this.datePickerService.inputPartChange$.next(partType);
    }
    this.renderClass(true);
  }
  // blur event has not the relatedTarget in IE11, use focusout instead.
  onFocusout(event) {
    event.preventDefault();
    this.onTouchedFn();
    if (!this.elementRef.nativeElement.contains(event.relatedTarget)) {
      this.checkAndClose();
    }
    this.renderClass(false);
  }
  // Show overlay content
  open() {
    if (this.nzInline) {
      return;
    }
    if (!this.realOpenState && !this.nzDisabled) {
      this.updateInputWidthAndArrowLeft();
      this.overlayOpen = true;
      this.nzOnOpenChange.emit(true);
      this.focus();
      this.cdr.markForCheck();
    }
  }
  close() {
    if (this.nzInline) {
      return;
    }
    if (this.realOpenState) {
      this.overlayOpen = false;
      this.nzOnOpenChange.emit(false);
    }
  }
  showClear() {
    return !this.nzDisabled && !this.isEmptyValue(this.datePickerService.value) && this.nzAllowClear;
  }
  checkAndClose() {
    if (!this.realOpenState) {
      return;
    }
    if (this.panel.isAllowed(this.datePickerService.value, true)) {
      if (Array.isArray(this.datePickerService.value) && wrongSortOrder(this.datePickerService.value)) {
        const index = this.datePickerService.getActiveIndex();
        const value = this.datePickerService.value[index];
        this.panel.changeValueFromSelect(value, true);
        return;
      }
      this.updateInputValue();
      this.datePickerService.emitValue$.next();
    } else {
      this.datePickerService.setValue(this.datePickerService.initialValue);
      this.close();
    }
  }
  onClickInputBox(event) {
    event.stopPropagation();
    this.focus();
    if (!this.isOpenHandledByUser()) {
      this.open();
    }
  }
  onOverlayKeydown(event) {
    if (event.keyCode === ESCAPE) {
      this.datePickerService.initValue();
    }
  }
  // NOTE: A issue here, the first time position change, the animation will not be triggered.
  // Because the overlay's "positionChange" event is emitted after the content's full shown up.
  // All other components like "nz-dropdown" which depends on overlay also has the same issue.
  // See: https://github.com/NG-ZORRO/ng-zorro-antd/issues/1429
  onPositionChange(position) {
    this.currentPositionX = position.connectionPair.originX;
    this.currentPositionY = position.connectionPair.originY;
    this.cdr.detectChanges();
  }
  onClickClear(event) {
    event.preventDefault();
    event.stopPropagation();
    this.datePickerService.initValue(true);
    this.datePickerService.emitValue$.next();
  }
  updateInputValue() {
    const newValue = this.datePickerService.value;
    if (this.isRange) {
      this.inputValue = newValue ? newValue.map((v) => this.formatValue(v)) : ["", ""];
    } else {
      this.inputValue = this.formatValue(newValue);
    }
    this.cdr.markForCheck();
  }
  formatValue(value) {
    return this.dateHelper.format(value && value.nativeDate, this.nzFormat);
  }
  onInputChange(value, isEnter = false) {
    if (!this.platform.TRIDENT && this.document.activeElement === this.getInput(this.datePickerService.activeInput) && !this.realOpenState) {
      this.open();
      return;
    }
    const date = this.checkValidDate(value);
    if (date && this.realOpenState) {
      this.panel.changeValueFromSelect(date, isEnter);
    }
  }
  onKeyupEnter(event) {
    this.onInputChange(event.target.value, true);
  }
  checkValidDate(value) {
    const date = new CandyDate(this.dateHelper.parseDate(value, this.nzFormat));
    if (!date.isValid() || value !== this.dateHelper.format(date.nativeDate, this.nzFormat)) {
      return null;
    }
    return date;
  }
  getPlaceholder(partType) {
    return this.isRange ? this.nzPlaceHolder[this.datePickerService.getActiveIndex(partType)] : this.nzPlaceHolder;
  }
  isEmptyValue(value) {
    if (value === null) {
      return true;
    } else if (this.isRange) {
      return !value || !Array.isArray(value) || value.every((val) => !val);
    } else {
      return !value;
    }
  }
  // Whether open state is permanently controlled by user himself
  isOpenHandledByUser() {
    return this.nzOpen !== void 0;
  }
  // ------------------------------------------------------------------------
  // Input API End
  // ------------------------------------------------------------------------
  constructor(nzConfigService, datePickerService, i18n, cdr, renderer, ngZone, elementRef, dateHelper, nzResizeObserver, platform, destroy$, doc, directionality, noAnimation, nzFormStatusService, nzFormNoStatusService) {
    this.nzConfigService = nzConfigService;
    this.datePickerService = datePickerService;
    this.i18n = i18n;
    this.cdr = cdr;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.elementRef = elementRef;
    this.dateHelper = dateHelper;
    this.nzResizeObserver = nzResizeObserver;
    this.platform = platform;
    this.destroy$ = destroy$;
    this.directionality = directionality;
    this.noAnimation = noAnimation;
    this.nzFormStatusService = nzFormStatusService;
    this.nzFormNoStatusService = nzFormNoStatusService;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME11;
    this.isRange = false;
    this.dir = "ltr";
    this.statusCls = {};
    this.status = "";
    this.hasFeedback = false;
    this.panelMode = "date";
    this.isCustomPlaceHolder = false;
    this.isCustomFormat = false;
    this.showTime = false;
    this.isNzDisableFirstChange = true;
    this.nzAllowClear = true;
    this.nzAutoFocus = false;
    this.nzDisabled = false;
    this.nzBorderless = false;
    this.nzInputReadOnly = false;
    this.nzInline = false;
    this.nzPlaceHolder = "";
    this.nzPopupStyle = POPUP_STYLE_PATCH;
    this.nzSize = "default";
    this.nzStatus = "";
    this.nzShowToday = true;
    this.nzMode = "date";
    this.nzShowNow = true;
    this.nzDefaultPickerValue = null;
    this.nzSeparator = void 0;
    this.nzSuffixIcon = "calendar";
    this.nzBackdrop = false;
    this.nzId = null;
    this.nzPlacement = "bottomLeft";
    this.nzShowWeekNumber = false;
    this.nzOnPanelChange = new EventEmitter();
    this.nzOnCalendarChange = new EventEmitter();
    this.nzOnOk = new EventEmitter();
    this.nzOnOpenChange = new EventEmitter();
    this.inputSize = 12;
    this.prefixCls = PREFIX_CLASS;
    this.activeBarStyle = {};
    this.overlayOpen = false;
    this.overlayPositions = [...DEFAULT_DATE_PICKER_POSITIONS];
    this.currentPositionX = "start";
    this.currentPositionY = "bottom";
    this.onChangeFn = () => void 0;
    this.onTouchedFn = () => void 0;
    this.document = doc;
    this.origin = new CdkOverlayOrigin(this.elementRef);
  }
  ngOnInit() {
    this.nzFormStatusService?.formStatusChanges.pipe(distinctUntilChanged((pre, cur) => {
      return pre.status === cur.status && pre.hasFeedback === cur.hasFeedback;
    }), withLatestFrom(this.nzFormNoStatusService ? this.nzFormNoStatusService.noFormStatus : of(false)), map(([{
      status,
      hasFeedback
    }, noStatus]) => ({
      status: noStatus ? "" : status,
      hasFeedback
    })), takeUntil(this.destroy$)).subscribe(({
      status,
      hasFeedback
    }) => {
      this.setStatusStyles(status, hasFeedback);
    });
    if (!this.nzLocale) {
      this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe(() => this.setLocale());
    }
    this.datePickerService.isRange = this.isRange;
    this.datePickerService.initValue(true);
    this.datePickerService.emitValue$.pipe(takeUntil(this.destroy$)).subscribe(() => {
      const granularityComparaison = this.showTime ? "second" : "day";
      const value = this.datePickerService.value;
      const datePickerPreviousValue = this.datePickerService.initialValue;
      if (!this.isRange && value?.isSame(datePickerPreviousValue?.nativeDate, granularityComparaison)) {
        this.onTouchedFn();
        return this.close();
      }
      if (this.isRange) {
        const [previousStartDate, previousEndDate] = datePickerPreviousValue;
        const [currentStartDate, currentEndDate] = value;
        if (previousStartDate?.isSame(currentStartDate?.nativeDate, granularityComparaison) && previousEndDate?.isSame(currentEndDate?.nativeDate, granularityComparaison)) {
          this.onTouchedFn();
          return this.close();
        }
      }
      this.datePickerService.initialValue = cloneDate(value);
      if (this.isRange) {
        const vAsRange = value;
        if (vAsRange.length) {
          this.onChangeFn([vAsRange[0]?.nativeDate ?? null, vAsRange[1]?.nativeDate ?? null]);
        } else {
          this.onChangeFn([]);
        }
      } else {
        if (value) {
          this.onChangeFn(value.nativeDate);
        } else {
          this.onChangeFn(null);
        }
      }
      this.onTouchedFn();
      this.close();
    });
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.inputValue = this.isRange ? ["", ""] : "";
    this.setModeAndFormat();
    this.datePickerService.valueChange$.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.updateInputValue();
    });
  }
  ngOnChanges(changes) {
    const {
      nzStatus,
      nzPlacement
    } = changes;
    if (changes.nzPopupStyle) {
      this.nzPopupStyle = this.nzPopupStyle ? __spreadValues(__spreadValues({}, this.nzPopupStyle), POPUP_STYLE_PATCH) : POPUP_STYLE_PATCH;
    }
    if (changes.nzPlaceHolder?.currentValue) {
      this.isCustomPlaceHolder = true;
    }
    if (changes.nzFormat?.currentValue) {
      this.isCustomFormat = true;
    }
    if (changes.nzLocale) {
      this.setDefaultPlaceHolder();
    }
    if (changes.nzRenderExtraFooter) {
      this.extraFooter = valueFunctionProp(this.nzRenderExtraFooter);
    }
    if (changes.nzMode) {
      this.setDefaultPlaceHolder();
      this.setModeAndFormat();
    }
    if (nzStatus) {
      this.setStatusStyles(this.nzStatus, this.hasFeedback);
    }
    if (nzPlacement) {
      this.setPlacement(this.nzPlacement);
    }
  }
  setModeAndFormat() {
    const inputFormats = {
      year: "yyyy",
      month: "yyyy-MM",
      week: "YYYY-ww",
      date: this.nzShowTime ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd"
    };
    if (!this.nzMode) {
      this.nzMode = "date";
    }
    this.panelMode = this.isRange ? [this.nzMode, this.nzMode] : this.nzMode;
    if (!this.isCustomFormat) {
      this.nzFormat = inputFormats[this.nzMode];
    }
    this.inputSize = Math.max(10, this.nzFormat.length) + 2;
    this.updateInputValue();
  }
  /**
   * Triggered when overlayOpen changes (different with realOpenState)
   *
   * @param open The overlayOpen in picker component
   */
  onOpenChange(open) {
    this.nzOnOpenChange.emit(open);
  }
  writeValue(value) {
    this.setValue(value);
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChangeFn = fn;
  }
  registerOnTouched(fn) {
    this.onTouchedFn = fn;
  }
  setDisabledState(isDisabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || isDisabled;
    this.cdr.markForCheck();
    this.isNzDisableFirstChange = false;
  }
  // ------------------------------------------------------------------------
  // | Internal methods
  // ------------------------------------------------------------------------
  // Reload locale from i18n with side effects
  setLocale() {
    this.nzLocale = this.i18n.getLocaleData("DatePicker", {});
    this.setDefaultPlaceHolder();
    this.cdr.markForCheck();
  }
  setDefaultPlaceHolder() {
    if (!this.isCustomPlaceHolder && this.nzLocale) {
      const defaultPlaceholder = {
        year: this.getPropertyOfLocale("yearPlaceholder"),
        month: this.getPropertyOfLocale("monthPlaceholder"),
        week: this.getPropertyOfLocale("weekPlaceholder"),
        date: this.getPropertyOfLocale("placeholder")
      };
      const defaultRangePlaceholder = {
        year: this.getPropertyOfLocale("rangeYearPlaceholder"),
        month: this.getPropertyOfLocale("rangeMonthPlaceholder"),
        week: this.getPropertyOfLocale("rangeWeekPlaceholder"),
        date: this.getPropertyOfLocale("rangePlaceholder")
      };
      this.nzPlaceHolder = this.isRange ? defaultRangePlaceholder[this.nzMode] : defaultPlaceholder[this.nzMode];
    }
  }
  getPropertyOfLocale(type) {
    return this.nzLocale.lang[type] || this.i18n.getLocaleData(`DatePicker.lang.${type}`);
  }
  // Safe way of setting value with default
  setValue(value) {
    const newValue = this.datePickerService.makeValue(value);
    this.datePickerService.setValue(newValue);
    this.datePickerService.initialValue = cloneDate(newValue);
    this.cdr.detectChanges();
  }
  renderClass(value) {
    if (value) {
      this.renderer.addClass(this.elementRef.nativeElement, "ant-picker-focused");
    } else {
      this.renderer.removeClass(this.elementRef.nativeElement, "ant-picker-focused");
    }
  }
  onPanelModeChange(panelMode) {
    this.nzOnPanelChange.emit(panelMode);
  }
  // Emit nzOnCalendarChange when select date by nz-range-picker
  onCalendarChange(value) {
    if (this.isRange && Array.isArray(value)) {
      const rangeValue = value.filter((x) => x instanceof CandyDate).map((x) => x.nativeDate);
      this.nzOnCalendarChange.emit(rangeValue);
    }
  }
  onResultOk() {
    if (this.isRange) {
      const value = this.datePickerService.value;
      if (value.length) {
        this.nzOnOk.emit([value[0]?.nativeDate || null, value[1]?.nativeDate || null]);
      } else {
        this.nzOnOk.emit([]);
      }
    } else {
      if (this.datePickerService.value) {
        this.nzOnOk.emit(this.datePickerService.value.nativeDate);
      } else {
        this.nzOnOk.emit(null);
      }
    }
  }
  // status
  setStatusStyles(status, hasFeedback) {
    this.status = status;
    this.hasFeedback = hasFeedback;
    this.cdr.markForCheck();
    this.statusCls = getStatusClassNames(this.prefixCls, status, hasFeedback);
    Object.keys(this.statusCls).forEach((status2) => {
      if (this.statusCls[status2]) {
        this.renderer.addClass(this.elementRef.nativeElement, status2);
      } else {
        this.renderer.removeClass(this.elementRef.nativeElement, status2);
      }
    });
  }
  setPlacement(placement) {
    const position = DATE_PICKER_POSITION_MAP[placement];
    this.overlayPositions = [position, ...DEFAULT_DATE_PICKER_POSITIONS];
    this.currentPositionX = position.originX;
    this.currentPositionY = position.originY;
  }
};
_NzDatePickerComponent.\u0275fac = function NzDatePickerComponent_Factory(t) {
  return new (t || _NzDatePickerComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(DatePickerService), \u0275\u0275directiveInject(NzI18nService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(DateHelperService), \u0275\u0275directiveInject(NzResizeObserver), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(NzDestroyService), \u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9), \u0275\u0275directiveInject(NzFormStatusService, 8), \u0275\u0275directiveInject(NzFormNoStatusService, 8));
};
_NzDatePickerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzDatePickerComponent,
  selectors: [["nz-date-picker"], ["nz-week-picker"], ["nz-month-picker"], ["nz-year-picker"], ["nz-range-picker"]],
  viewQuery: function NzDatePickerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(CdkConnectedOverlay, 5);
      \u0275\u0275viewQuery(DateRangePopupComponent, 5);
      \u0275\u0275viewQuery(_c46, 5);
      \u0275\u0275viewQuery(_c53, 5);
      \u0275\u0275viewQuery(_c63, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.cdkConnectedOverlay = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.panel = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.separatorElement = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.pickerInput = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.rangePickerInputs = _t);
    }
  },
  hostVars: 16,
  hostBindings: function NzDatePickerComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzDatePickerComponent_click_HostBindingHandler($event) {
        return ctx.onClickInputBox($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-picker", true)("ant-picker-range", ctx.isRange)("ant-picker-large", ctx.nzSize === "large")("ant-picker-small", ctx.nzSize === "small")("ant-picker-disabled", ctx.nzDisabled)("ant-picker-rtl", ctx.dir === "rtl")("ant-picker-borderless", ctx.nzBorderless)("ant-picker-inline", ctx.nzInline);
    }
  },
  inputs: {
    nzAllowClear: "nzAllowClear",
    nzAutoFocus: "nzAutoFocus",
    nzDisabled: "nzDisabled",
    nzBorderless: "nzBorderless",
    nzInputReadOnly: "nzInputReadOnly",
    nzInline: "nzInline",
    nzOpen: "nzOpen",
    nzDisabledDate: "nzDisabledDate",
    nzLocale: "nzLocale",
    nzPlaceHolder: "nzPlaceHolder",
    nzPopupStyle: "nzPopupStyle",
    nzDropdownClassName: "nzDropdownClassName",
    nzSize: "nzSize",
    nzStatus: "nzStatus",
    nzFormat: "nzFormat",
    nzDateRender: "nzDateRender",
    nzDisabledTime: "nzDisabledTime",
    nzRenderExtraFooter: "nzRenderExtraFooter",
    nzShowToday: "nzShowToday",
    nzMode: "nzMode",
    nzShowNow: "nzShowNow",
    nzRanges: "nzRanges",
    nzDefaultPickerValue: "nzDefaultPickerValue",
    nzSeparator: "nzSeparator",
    nzSuffixIcon: "nzSuffixIcon",
    nzBackdrop: "nzBackdrop",
    nzId: "nzId",
    nzPlacement: "nzPlacement",
    nzShowWeekNumber: "nzShowWeekNumber",
    nzShowTime: "nzShowTime"
  },
  outputs: {
    nzOnPanelChange: "nzOnPanelChange",
    nzOnCalendarChange: "nzOnCalendarChange",
    nzOnOk: "nzOnOk",
    nzOnOpenChange: "nzOnOpenChange"
  },
  exportAs: ["nzDatePicker"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService, DatePickerService, {
    provide: NG_VALUE_ACCESSOR,
    multi: true,
    useExisting: forwardRef(() => _NzDatePickerComponent)
  }]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 8,
  vars: 7,
  consts: [[4, "ngIf", "ngIfElse"], ["tplRangeInput", ""], ["tplRightRest", ""], ["inlineMode", ""], ["cdkConnectedOverlay", "", "nzConnectedOverlay", "", 3, "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayTransformOriginOn", "positionChange", "detach", "overlayKeydown"], [3, "class", 4, "ngIf"], [4, "ngIf"], ["autocomplete", "off", 3, "disabled", "readOnly", "ngModel", "placeholder", "size", "ngModelChange", "focus", "focusout", "keyup.enter"], ["pickerInput", ""], [4, "ngTemplateOutlet"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["separatorElement", ""], [4, "nzStringTemplateOutlet"], ["defaultSeparator", ""], ["nz-icon", "", "nzType", "swap-right", "nzTheme", "outline"], ["autocomplete", "off", 3, "disabled", "readOnly", "size", "ngModel", "placeholder", "click", "focusout", "focus", "keyup.enter", "ngModelChange"], ["rangePickerInput", ""], [3, "ngStyle"], [3, "class", "click", 4, "ngIf"], [3, "status", 4, "ngIf"], [3, "click"], ["nz-icon", "", "nzType", "close-circle", "nzTheme", "fill"], ["nz-icon", "", 3, "nzType"], [3, "status"], [3, "isRange", "inline", "defaultPickerValue", "showWeek", "panelMode", "locale", "showToday", "showNow", "showTime", "dateRender", "disabledDate", "disabledTime", "extraFooter", "ranges", "dir", "panelModeChange", "calendarChange", "resultOk"], [1, "ant-picker-wrapper", 2, "position", "relative", 3, "nzNoAnimation"]],
  template: function NzDatePickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzDatePickerComponent_ng_container_0_Template, 3, 2, "ng-container", 0)(1, NzDatePickerComponent_ng_template_1_Template, 2, 6, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, NzDatePickerComponent_ng_template_3_Template, 5, 10, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(5, NzDatePickerComponent_ng_template_5_Template, 2, 36, "ng-template", null, 3, \u0275\u0275templateRefExtractor)(7, NzDatePickerComponent_ng_template_7_Template, 2, 3, "ng-template", 4);
      \u0275\u0275listener("positionChange", function NzDatePickerComponent_Template_ng_template_positionChange_7_listener($event) {
        return ctx.onPositionChange($event);
      })("detach", function NzDatePickerComponent_Template_ng_template_detach_7_listener() {
        return ctx.close();
      })("overlayKeydown", function NzDatePickerComponent_Template_ng_template_overlayKeydown_7_listener($event) {
        return ctx.onOverlayKeydown($event);
      });
    }
    if (rf & 2) {
      const _r6 = \u0275\u0275reference(6);
      \u0275\u0275property("ngIf", !ctx.nzInline)("ngIfElse", _r6);
      \u0275\u0275advance(7);
      \u0275\u0275property("cdkConnectedOverlayHasBackdrop", ctx.nzBackdrop)("cdkConnectedOverlayOrigin", ctx.origin)("cdkConnectedOverlayOpen", ctx.realOpenState)("cdkConnectedOverlayPositions", ctx.overlayPositions)("cdkConnectedOverlayTransformOriginOn", ".ant-picker-wrapper");
    }
  },
  dependencies: [NgIf, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, NgTemplateOutlet, NzOutletModule, NzStringTemplateOutletDirective, NzIconModule, NzIconDirective, NgStyle, NzFormPatchModule, NzFormItemFeedbackIconComponent, DateRangePopupComponent, CdkConnectedOverlay, NzOverlayModule, NzConnectedOverlayDirective, NzNoAnimationDirective],
  encapsulation: 2,
  data: {
    animation: [slideMotion]
  },
  changeDetection: 0
});
var NzDatePickerComponent = _NzDatePickerComponent;
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzAllowClear", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzAutoFocus", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzBorderless", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzInputReadOnly", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzInline", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzOpen", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzShowToday", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzShowNow", void 0);
__decorate([WithConfig()], NzDatePickerComponent.prototype, "nzSeparator", void 0);
__decorate([WithConfig()], NzDatePickerComponent.prototype, "nzSuffixIcon", void 0);
__decorate([WithConfig()], NzDatePickerComponent.prototype, "nzBackdrop", void 0);
__decorate([InputBoolean()], NzDatePickerComponent.prototype, "nzShowWeekNumber", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDatePickerComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "nz-date-picker,nz-week-picker,nz-month-picker,nz-year-picker,nz-range-picker",
      exportAs: "nzDatePicker",
      template: `
    <ng-container *ngIf="!nzInline; else inlineMode">
      <!-- Content of single picker -->
      <div *ngIf="!isRange" class="{{ prefixCls }}-input">
        <input
          #pickerInput
          [attr.id]="nzId"
          [class.ant-input-disabled]="nzDisabled"
          [disabled]="nzDisabled"
          [readOnly]="nzInputReadOnly"
          [(ngModel)]="inputValue"
          placeholder="{{ getPlaceholder() }}"
          [size]="inputSize"
          autocomplete="off"
          (focus)="onFocus($event)"
          (focusout)="onFocusout($event)"
          (ngModelChange)="onInputChange($event)"
          (keyup.enter)="onKeyupEnter($event)"
        />
        <ng-container *ngTemplateOutlet="tplRightRest"></ng-container>
      </div>

      <!-- Content of range picker -->
      <ng-container *ngIf="isRange">
        <div class="{{ prefixCls }}-input">
          <ng-container *ngTemplateOutlet="tplRangeInput; context: { partType: 'left' }"></ng-container>
        </div>
        <div #separatorElement class="{{ prefixCls }}-range-separator">
          <span class="{{ prefixCls }}-separator">
            <ng-container *nzStringTemplateOutlet="nzSeparator; let separator">
              <ng-container *ngIf="nzSeparator; else defaultSeparator">{{ nzSeparator }}</ng-container>
              <ng-template #defaultSeparator>
                <span nz-icon nzType="swap-right" nzTheme="outline"></span>
              </ng-template>
            </ng-container>
          </span>
        </div>
        <div class="{{ prefixCls }}-input">
          <ng-container *ngTemplateOutlet="tplRangeInput; context: { partType: 'right' }"></ng-container>
        </div>
        <ng-container *ngTemplateOutlet="tplRightRest"></ng-container>
      </ng-container>
    </ng-container>
    <!-- Input for Range ONLY -->
    <ng-template #tplRangeInput let-partType="partType">
      <input
        #rangePickerInput
        [attr.id]="nzId"
        [disabled]="nzDisabled"
        [readOnly]="nzInputReadOnly"
        [size]="inputSize"
        autocomplete="off"
        (click)="onClickInputBox($event)"
        (focusout)="onFocusout($event)"
        (focus)="onFocus($event, partType)"
        (keyup.enter)="onKeyupEnter($event)"
        [(ngModel)]="inputValue[datePickerService.getActiveIndex(partType)]"
        (ngModelChange)="onInputChange($event)"
        placeholder="{{ getPlaceholder(partType) }}"
      />
    </ng-template>

    <!-- Right operator icons -->
    <ng-template #tplRightRest>
      <div class="{{ prefixCls }}-active-bar" [ngStyle]="activeBarStyle"></div>
      <span *ngIf="showClear()" class="{{ prefixCls }}-clear" (click)="onClickClear($event)">
        <span nz-icon nzType="close-circle" nzTheme="fill"></span>
      </span>
      <span class="{{ prefixCls }}-suffix">
        <ng-container *nzStringTemplateOutlet="nzSuffixIcon; let suffixIcon">
          <span nz-icon [nzType]="suffixIcon"></span>
        </ng-container>
        <nz-form-item-feedback-icon *ngIf="hasFeedback && !!status" [status]="status"></nz-form-item-feedback-icon>
      </span>
    </ng-template>

    <ng-template #inlineMode>
      <div
        class="{{ prefixCls }}-dropdown {{ nzDropdownClassName }}"
        [class.ant-picker-dropdown-rtl]="dir === 'rtl'"
        [class.ant-picker-dropdown-placement-bottomLeft]="currentPositionY === 'bottom' && currentPositionX === 'start'"
        [class.ant-picker-dropdown-placement-topLeft]="currentPositionY === 'top' && currentPositionX === 'start'"
        [class.ant-picker-dropdown-placement-bottomRight]="currentPositionY === 'bottom' && currentPositionX === 'end'"
        [class.ant-picker-dropdown-placement-topRight]="currentPositionY === 'top' && currentPositionX === 'end'"
        [class.ant-picker-dropdown-range]="isRange"
        [class.ant-picker-active-left]="datePickerService.activeInput === 'left'"
        [class.ant-picker-active-right]="datePickerService.activeInput === 'right'"
        [ngStyle]="nzPopupStyle"
      >
        <date-range-popup
          [isRange]="isRange"
          [inline]="nzInline"
          [defaultPickerValue]="nzDefaultPickerValue"
          [showWeek]="nzShowWeekNumber || nzMode === 'week'"
          [panelMode]="panelMode"
          (panelModeChange)="onPanelModeChange($event)"
          (calendarChange)="onCalendarChange($event)"
          [locale]="nzLocale?.lang!"
          [showToday]="nzMode === 'date' && nzShowToday && !isRange && !nzShowTime"
          [showNow]="nzMode === 'date' && nzShowNow && !isRange && !!nzShowTime"
          [showTime]="nzShowTime"
          [dateRender]="nzDateRender"
          [disabledDate]="nzDisabledDate"
          [disabledTime]="nzDisabledTime"
          [extraFooter]="extraFooter"
          [ranges]="nzRanges"
          [dir]="dir"
          (resultOk)="onResultOk()"
        ></date-range-popup>
      </div>
    </ng-template>

    <!-- Overlay -->
    <ng-template
      cdkConnectedOverlay
      nzConnectedOverlay
      [cdkConnectedOverlayHasBackdrop]="nzBackdrop"
      [cdkConnectedOverlayOrigin]="origin"
      [cdkConnectedOverlayOpen]="realOpenState"
      [cdkConnectedOverlayPositions]="overlayPositions"
      [cdkConnectedOverlayTransformOriginOn]="'.ant-picker-wrapper'"
      (positionChange)="onPositionChange($event)"
      (detach)="close()"
      (overlayKeydown)="onOverlayKeydown($event)"
    >
      <div
        class="ant-picker-wrapper"
        [nzNoAnimation]="!!noAnimation?.nzNoAnimation"
        [@slideMotion]="'enter'"
        style="position: relative;"
      >
        <ng-container *ngTemplateOutlet="inlineMode"></ng-container>
      </div>
    </ng-template>
  `,
      host: {
        "[class.ant-picker]": `true`,
        "[class.ant-picker-range]": `isRange`,
        "[class.ant-picker-large]": `nzSize === 'large'`,
        "[class.ant-picker-small]": `nzSize === 'small'`,
        "[class.ant-picker-disabled]": `nzDisabled`,
        "[class.ant-picker-rtl]": `dir === 'rtl'`,
        "[class.ant-picker-borderless]": `nzBorderless`,
        "[class.ant-picker-inline]": `nzInline`,
        "(click)": "onClickInputBox($event)"
      },
      providers: [NzDestroyService, DatePickerService, {
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => NzDatePickerComponent)
      }],
      animations: [slideMotion],
      imports: [NgIf, FormsModule, NgTemplateOutlet, NzOutletModule, NzIconModule, NgStyle, NzFormPatchModule, DateRangePopupComponent, CdkConnectedOverlay, NzOverlayModule, NzNoAnimationDirective],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: DatePickerService
  }, {
    type: NzI18nService
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: DateHelperService
  }, {
    type: NzResizeObserver
  }, {
    type: Platform
  }, {
    type: NzDestroyService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: NzFormStatusService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormNoStatusService,
    decorators: [{
      type: Optional
    }]
  }], {
    nzAllowClear: [{
      type: Input
    }],
    nzAutoFocus: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzBorderless: [{
      type: Input
    }],
    nzInputReadOnly: [{
      type: Input
    }],
    nzInline: [{
      type: Input
    }],
    nzOpen: [{
      type: Input
    }],
    nzDisabledDate: [{
      type: Input
    }],
    nzLocale: [{
      type: Input
    }],
    nzPlaceHolder: [{
      type: Input
    }],
    nzPopupStyle: [{
      type: Input
    }],
    nzDropdownClassName: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzFormat: [{
      type: Input
    }],
    nzDateRender: [{
      type: Input
    }],
    nzDisabledTime: [{
      type: Input
    }],
    nzRenderExtraFooter: [{
      type: Input
    }],
    nzShowToday: [{
      type: Input
    }],
    nzMode: [{
      type: Input
    }],
    nzShowNow: [{
      type: Input
    }],
    nzRanges: [{
      type: Input
    }],
    nzDefaultPickerValue: [{
      type: Input
    }],
    nzSeparator: [{
      type: Input
    }],
    nzSuffixIcon: [{
      type: Input
    }],
    nzBackdrop: [{
      type: Input
    }],
    nzId: [{
      type: Input
    }],
    nzPlacement: [{
      type: Input
    }],
    nzShowWeekNumber: [{
      type: Input
    }],
    nzOnPanelChange: [{
      type: Output
    }],
    nzOnCalendarChange: [{
      type: Output
    }],
    nzOnOk: [{
      type: Output
    }],
    nzOnOpenChange: [{
      type: Output
    }],
    nzShowTime: [{
      type: Input
    }],
    cdkConnectedOverlay: [{
      type: ViewChild,
      args: [CdkConnectedOverlay, {
        static: false
      }]
    }],
    panel: [{
      type: ViewChild,
      args: [DateRangePopupComponent, {
        static: false
      }]
    }],
    separatorElement: [{
      type: ViewChild,
      args: ["separatorElement", {
        static: false
      }]
    }],
    pickerInput: [{
      type: ViewChild,
      args: ["pickerInput", {
        static: false
      }]
    }],
    rangePickerInputs: [{
      type: ViewChildren,
      args: ["rangePickerInput"]
    }]
  });
})();
var _NzMonthPickerComponent = class _NzMonthPickerComponent {
  constructor(datePicker) {
    this.datePicker = datePicker;
    this.datePicker.nzMode = "month";
  }
};
_NzMonthPickerComponent.\u0275fac = function NzMonthPickerComponent_Factory(t) {
  return new (t || _NzMonthPickerComponent)(\u0275\u0275directiveInject(NzDatePickerComponent, 9));
};
_NzMonthPickerComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzMonthPickerComponent,
  selectors: [["nz-month-picker"]],
  exportAs: ["nzMonthPicker"],
  standalone: true
});
var NzMonthPickerComponent = _NzMonthPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzMonthPickerComponent, [{
    type: Directive,
    args: [{
      selector: "nz-month-picker",
      exportAs: "nzMonthPicker",
      standalone: true
    }]
  }], () => [{
    type: NzDatePickerComponent,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], null);
})();
var _NzRangePickerComponent = class _NzRangePickerComponent {
  constructor(datePicker) {
    this.datePicker = datePicker;
    this.datePicker.isRange = true;
  }
};
_NzRangePickerComponent.\u0275fac = function NzRangePickerComponent_Factory(t) {
  return new (t || _NzRangePickerComponent)(\u0275\u0275directiveInject(NzDatePickerComponent, 9));
};
_NzRangePickerComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzRangePickerComponent,
  selectors: [["nz-range-picker"]],
  exportAs: ["nzRangePicker"],
  standalone: true
});
var NzRangePickerComponent = _NzRangePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRangePickerComponent, [{
    type: Directive,
    args: [{
      selector: "nz-range-picker",
      exportAs: "nzRangePicker",
      standalone: true
    }]
  }], () => [{
    type: NzDatePickerComponent,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], null);
})();
var _NzWeekPickerComponent = class _NzWeekPickerComponent {
  constructor(datePicker) {
    this.datePicker = datePicker;
    this.datePicker.nzMode = "week";
  }
};
_NzWeekPickerComponent.\u0275fac = function NzWeekPickerComponent_Factory(t) {
  return new (t || _NzWeekPickerComponent)(\u0275\u0275directiveInject(NzDatePickerComponent, 9));
};
_NzWeekPickerComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzWeekPickerComponent,
  selectors: [["nz-week-picker"]],
  exportAs: ["nzWeekPicker"],
  standalone: true
});
var NzWeekPickerComponent = _NzWeekPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzWeekPickerComponent, [{
    type: Directive,
    args: [{
      selector: "nz-week-picker",
      exportAs: "nzWeekPicker",
      standalone: true
    }]
  }], () => [{
    type: NzDatePickerComponent,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], null);
})();
var _NzYearPickerComponent = class _NzYearPickerComponent {
  constructor(datePicker) {
    this.datePicker = datePicker;
    this.datePicker.nzMode = "year";
  }
};
_NzYearPickerComponent.\u0275fac = function NzYearPickerComponent_Factory(t) {
  return new (t || _NzYearPickerComponent)(\u0275\u0275directiveInject(NzDatePickerComponent, 9));
};
_NzYearPickerComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzYearPickerComponent,
  selectors: [["nz-year-picker"]],
  exportAs: ["nzYearPicker"],
  standalone: true
});
var NzYearPickerComponent = _NzYearPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzYearPickerComponent, [{
    type: Directive,
    args: [{
      selector: "nz-year-picker",
      exportAs: "nzYearPicker",
      standalone: true
    }]
  }], () => [{
    type: NzDatePickerComponent,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], null);
})();
var _NzDatePickerModule = class _NzDatePickerModule {
};
_NzDatePickerModule.\u0275fac = function NzDatePickerModule_Factory(t) {
  return new (t || _NzDatePickerModule)();
};
_NzDatePickerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzDatePickerModule
});
_NzDatePickerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzDatePickerComponent, CalendarFooterComponent, InnerPopupComponent, DateRangePopupComponent]
});
var NzDatePickerModule = _NzDatePickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDatePickerModule, [{
    type: NgModule,
    args: [{
      imports: [NzDatePickerComponent, NzMonthPickerComponent, NzYearPickerComponent, NzWeekPickerComponent, NzRangePickerComponent, CalendarFooterComponent, InnerPopupComponent, DateRangePopupComponent],
      exports: [NzDatePickerComponent, NzRangePickerComponent, NzMonthPickerComponent, NzYearPickerComponent, NzWeekPickerComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-popconfirm.mjs
var _c020 = ["okBtn"];
var _c114 = ["cancelBtn"];
function NzPopconfirmComponent_ng_template_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275element(1, "span", 16);
    \u0275\u0275elementEnd();
  }
}
function NzPopconfirmComponent_ng_template_0_ng_container_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 18);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const icon_r11 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", icon_r11 || "exclamation-circle");
  }
}
function NzPopconfirmComponent_ng_template_0_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzPopconfirmComponent_ng_template_0_ng_container_7_ng_container_1_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementStart(2, "div", 17);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.nzIcon);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r3.nzTitle);
  }
}
function NzPopconfirmComponent_ng_template_0_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r5.nzCancelText);
  }
}
function NzPopconfirmComponent_ng_template_0_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "nzI18n");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(2, 1, "Modal.cancelText"));
  }
}
function NzPopconfirmComponent_ng_template_0_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r8.nzOkText);
  }
}
function NzPopconfirmComponent_ng_template_0_ng_container_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "nzI18n");
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(2, 1, "Modal.okText"));
  }
}
function NzPopconfirmComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3);
    \u0275\u0275template(2, NzPopconfirmComponent_ng_template_0_div_2_Template, 2, 0, "div", 4);
    \u0275\u0275elementStart(3, "div", 5)(4, "div")(5, "div", 6)(6, "div", 7);
    \u0275\u0275template(7, NzPopconfirmComponent_ng_template_0_ng_container_7_Template, 4, 2, "ng-container", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 9)(9, "button", 10, 11);
    \u0275\u0275listener("click", function NzPopconfirmComponent_ng_template_0_Template_button_click_9_listener() {
      \u0275\u0275restoreView(_r13);
      const ctx_r12 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r12.onCancel());
    });
    \u0275\u0275template(11, NzPopconfirmComponent_ng_template_0_ng_container_11_Template, 2, 1, "ng-container", 12)(12, NzPopconfirmComponent_ng_template_0_ng_container_12_Template, 3, 3, "ng-container", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "button", 13, 14);
    \u0275\u0275listener("click", function NzPopconfirmComponent_ng_template_0_Template_button_click_13_listener() {
      \u0275\u0275restoreView(_r13);
      const ctx_r14 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r14.onConfirm());
    });
    \u0275\u0275template(15, NzPopconfirmComponent_ng_template_0_ng_container_15_Template, 2, 1, "ng-container", 12)(16, NzPopconfirmComponent_ng_template_0_ng_container_16_Template, 3, 3, "ng-container", 12);
    \u0275\u0275elementEnd()()()()()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-popover-rtl", ctx_r0.dir === "rtl");
    \u0275\u0275property("cdkTrapFocusAutoCapture", ctx_r0.nzAutoFocus !== null)("ngClass", ctx_r0._classMap)("ngStyle", ctx_r0.nzOverlayStyle)("@.disabled", !!(ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation))("nzNoAnimation", ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation)("@zoomBigMotion", "active");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.nzPopconfirmShowArrow);
    \u0275\u0275advance(5);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.nzTitle);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzSize", "small");
    \u0275\u0275attribute("cdkFocusInitial", ctx_r0.nzAutoFocus === "cancel" || null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.nzCancelText);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r0.nzCancelText);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzSize", "small")("nzType", ctx_r0.nzOkType !== "danger" ? ctx_r0.nzOkType : "primary")("nzDanger", ctx_r0.nzOkDanger || ctx_r0.nzOkType === "danger")("nzLoading", ctx_r0.confirmLoading);
    \u0275\u0275attribute("cdkFocusInitial", ctx_r0.nzAutoFocus === "ok" || null);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.nzOkText);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r0.nzOkText);
  }
}
var NZ_CONFIG_MODULE_NAME12 = "popconfirm";
var _NzPopconfirmDirective = class _NzPopconfirmDirective extends NzTooltipBaseDirective {
  getProxyPropertyMap() {
    return __spreadValues({
      nzOkText: ["nzOkText", () => this.nzOkText],
      nzOkType: ["nzOkType", () => this.nzOkType],
      nzOkDanger: ["nzOkDanger", () => this.nzOkDanger],
      nzCancelText: ["nzCancelText", () => this.nzCancelText],
      nzBeforeConfirm: ["nzBeforeConfirm", () => this.nzBeforeConfirm],
      nzCondition: ["nzCondition", () => this.nzCondition],
      nzIcon: ["nzIcon", () => this.nzIcon],
      nzPopconfirmShowArrow: ["nzPopconfirmShowArrow", () => this.nzPopconfirmShowArrow],
      nzPopconfirmBackdrop: ["nzBackdrop", () => this.nzPopconfirmBackdrop],
      nzAutoFocus: ["nzAutoFocus", () => this.nzAutofocus]
    }, super.getProxyPropertyMap());
  }
  constructor(elementRef, hostView, renderer, noAnimation, nzConfigService) {
    super(elementRef, hostView, renderer, noAnimation, nzConfigService);
    this._nzModuleName = NZ_CONFIG_MODULE_NAME12;
    this.trigger = "click";
    this.placement = "top";
    this.nzCondition = false;
    this.nzPopconfirmShowArrow = true;
    this.nzPopconfirmBackdrop = false;
    this.nzAutofocus = null;
    this.visibleChange = new EventEmitter();
    this.nzOnCancel = new EventEmitter();
    this.nzOnConfirm = new EventEmitter();
    this.componentRef = this.hostView.createComponent(NzPopconfirmComponent);
  }
  /**
   * @override
   */
  createComponent() {
    super.createComponent();
    this.component.nzOnCancel.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.nzOnCancel.emit();
    });
    this.component.nzOnConfirm.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.nzOnConfirm.emit();
    });
  }
};
_NzPopconfirmDirective.\u0275fac = function NzPopconfirmDirective_Factory(t) {
  return new (t || _NzPopconfirmDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzNoAnimationDirective, 9), \u0275\u0275directiveInject(NzConfigService));
};
_NzPopconfirmDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPopconfirmDirective,
  selectors: [["", "nz-popconfirm", ""]],
  hostVars: 2,
  hostBindings: function NzPopconfirmDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-popover-open", ctx.visible);
    }
  },
  inputs: {
    arrowPointAtCenter: ["nzPopconfirmArrowPointAtCenter", "arrowPointAtCenter"],
    title: ["nzPopconfirmTitle", "title"],
    directiveTitle: ["nz-popconfirm", "directiveTitle"],
    trigger: ["nzPopconfirmTrigger", "trigger"],
    placement: ["nzPopconfirmPlacement", "placement"],
    origin: ["nzPopconfirmOrigin", "origin"],
    mouseEnterDelay: ["nzPopconfirmMouseEnterDelay", "mouseEnterDelay"],
    mouseLeaveDelay: ["nzPopconfirmMouseLeaveDelay", "mouseLeaveDelay"],
    overlayClassName: ["nzPopconfirmOverlayClassName", "overlayClassName"],
    overlayStyle: ["nzPopconfirmOverlayStyle", "overlayStyle"],
    visible: ["nzPopconfirmVisible", "visible"],
    nzOkText: "nzOkText",
    nzOkType: "nzOkType",
    nzOkDanger: "nzOkDanger",
    nzCancelText: "nzCancelText",
    nzBeforeConfirm: "nzBeforeConfirm",
    nzIcon: "nzIcon",
    nzCondition: "nzCondition",
    nzPopconfirmShowArrow: "nzPopconfirmShowArrow",
    nzPopconfirmBackdrop: "nzPopconfirmBackdrop",
    nzAutofocus: "nzAutofocus"
  },
  outputs: {
    visibleChange: "nzPopconfirmVisibleChange",
    nzOnCancel: "nzOnCancel",
    nzOnConfirm: "nzOnConfirm"
  },
  exportAs: ["nzPopconfirm"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NzPopconfirmDirective = _NzPopconfirmDirective;
__decorate([InputBoolean()], NzPopconfirmDirective.prototype, "arrowPointAtCenter", void 0);
__decorate([InputBoolean()], NzPopconfirmDirective.prototype, "nzOkDanger", void 0);
__decorate([InputBoolean()], NzPopconfirmDirective.prototype, "nzCondition", void 0);
__decorate([InputBoolean()], NzPopconfirmDirective.prototype, "nzPopconfirmShowArrow", void 0);
__decorate([WithConfig()], NzPopconfirmDirective.prototype, "nzPopconfirmBackdrop", void 0);
__decorate([WithConfig()], NzPopconfirmDirective.prototype, "nzAutofocus", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPopconfirmDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-popconfirm]",
      exportAs: "nzPopconfirm",
      host: {
        "[class.ant-popover-open]": "visible"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: Renderer2
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: NzConfigService
  }], {
    arrowPointAtCenter: [{
      type: Input,
      args: ["nzPopconfirmArrowPointAtCenter"]
    }],
    title: [{
      type: Input,
      args: ["nzPopconfirmTitle"]
    }],
    directiveTitle: [{
      type: Input,
      args: ["nz-popconfirm"]
    }],
    trigger: [{
      type: Input,
      args: ["nzPopconfirmTrigger"]
    }],
    placement: [{
      type: Input,
      args: ["nzPopconfirmPlacement"]
    }],
    origin: [{
      type: Input,
      args: ["nzPopconfirmOrigin"]
    }],
    mouseEnterDelay: [{
      type: Input,
      args: ["nzPopconfirmMouseEnterDelay"]
    }],
    mouseLeaveDelay: [{
      type: Input,
      args: ["nzPopconfirmMouseLeaveDelay"]
    }],
    overlayClassName: [{
      type: Input,
      args: ["nzPopconfirmOverlayClassName"]
    }],
    overlayStyle: [{
      type: Input,
      args: ["nzPopconfirmOverlayStyle"]
    }],
    visible: [{
      type: Input,
      args: ["nzPopconfirmVisible"]
    }],
    nzOkText: [{
      type: Input
    }],
    nzOkType: [{
      type: Input
    }],
    nzOkDanger: [{
      type: Input
    }],
    nzCancelText: [{
      type: Input
    }],
    nzBeforeConfirm: [{
      type: Input
    }],
    nzIcon: [{
      type: Input
    }],
    nzCondition: [{
      type: Input
    }],
    nzPopconfirmShowArrow: [{
      type: Input
    }],
    nzPopconfirmBackdrop: [{
      type: Input
    }],
    nzAutofocus: [{
      type: Input
    }],
    visibleChange: [{
      type: Output,
      args: ["nzPopconfirmVisibleChange"]
    }],
    nzOnCancel: [{
      type: Output
    }],
    nzOnConfirm: [{
      type: Output
    }]
  });
})();
var _NzPopconfirmComponent = class _NzPopconfirmComponent extends NzToolTipComponent {
  constructor(cdr, elementRef, directionality, document2, noAnimation) {
    super(cdr, directionality, noAnimation);
    this.elementRef = elementRef;
    this.nzCondition = false;
    this.nzPopconfirmShowArrow = true;
    this.nzOkType = "primary";
    this.nzOkDanger = false;
    this.nzAutoFocus = null;
    this.nzBeforeConfirm = null;
    this.nzOnCancel = new Subject();
    this.nzOnConfirm = new Subject();
    this._trigger = "click";
    this.elementFocusedBeforeModalWasOpened = null;
    this._prefix = "ant-popover";
    this.confirmLoading = false;
    this.document = document2;
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.nzOnCancel.complete();
    this.nzOnConfirm.complete();
  }
  /**
   * @override
   */
  show() {
    if (!this.nzCondition) {
      this.capturePreviouslyFocusedElement();
      super.show();
    } else {
      this.onConfirm();
    }
  }
  hide() {
    super.hide();
    this.restoreFocus();
  }
  handleConfirm() {
    this.nzOnConfirm.next();
    super.hide();
  }
  onCancel() {
    this.nzOnCancel.next();
    super.hide();
  }
  onConfirm() {
    if (this.nzBeforeConfirm) {
      const observable = wrapIntoObservable(this.nzBeforeConfirm()).pipe(first());
      this.confirmLoading = true;
      observable.pipe(finalize(() => {
        this.confirmLoading = false;
        this.cdr.markForCheck();
      }), takeUntil(this.nzVisibleChange), takeUntil(this.destroy$)).subscribe((value) => {
        if (value) {
          this.handleConfirm();
        }
      });
    } else {
      this.handleConfirm();
    }
  }
  capturePreviouslyFocusedElement() {
    if (this.document) {
      this.elementFocusedBeforeModalWasOpened = this.document.activeElement;
    }
  }
  restoreFocus() {
    const toFocus = this.elementFocusedBeforeModalWasOpened;
    if (toFocus && typeof toFocus.focus === "function") {
      const activeElement = this.document.activeElement;
      const element = this.elementRef.nativeElement;
      if (!activeElement || activeElement === this.document.body || activeElement === element || element.contains(activeElement)) {
        toFocus.focus();
      }
    }
  }
};
_NzPopconfirmComponent.\u0275fac = function NzPopconfirmComponent_Factory(t) {
  return new (t || _NzPopconfirmComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(DOCUMENT, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzPopconfirmComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzPopconfirmComponent,
  selectors: [["nz-popconfirm"]],
  viewQuery: function NzPopconfirmComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c020, 5, ElementRef);
      \u0275\u0275viewQuery(_c114, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.okBtn = _t);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.cancelBtn = _t);
    }
  },
  exportAs: ["nzPopconfirmComponent"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 6,
  consts: [["cdkConnectedOverlay", "", "nzConnectedOverlay", "", 3, "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPush", "nzArrowPointAtCenter", "overlayOutsideClick", "detach", "positionChange"], ["overlay", "cdkConnectedOverlay"], ["cdkTrapFocus", "", 1, "ant-popover", 3, "cdkTrapFocusAutoCapture", "ngClass", "ngStyle", "nzNoAnimation"], [1, "ant-popover-content"], ["class", "ant-popover-arrow", 4, "ngIf"], [1, "ant-popover-inner"], [1, "ant-popover-inner-content"], [1, "ant-popover-message"], [4, "nzStringTemplateOutlet"], [1, "ant-popover-buttons"], ["nz-button", "", 3, "nzSize", "click"], ["cancelBtn", ""], [4, "ngIf"], ["nz-button", "", 3, "nzSize", "nzType", "nzDanger", "nzLoading", "click"], ["okBtn", ""], [1, "ant-popover-arrow"], [1, "ant-popover-arrow-content"], [1, "ant-popover-message-title"], ["nz-icon", "", "nzTheme", "fill", 3, "nzType"]],
  template: function NzPopconfirmComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzPopconfirmComponent_ng_template_0_Template, 17, 21, "ng-template", 0, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275listener("overlayOutsideClick", function NzPopconfirmComponent_Template_ng_template_overlayOutsideClick_0_listener($event) {
        return ctx.onClickOutside($event);
      })("detach", function NzPopconfirmComponent_Template_ng_template_detach_0_listener() {
        return ctx.hide();
      })("positionChange", function NzPopconfirmComponent_Template_ng_template_positionChange_0_listener($event) {
        return ctx.onPositionChange($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275property("cdkConnectedOverlayHasBackdrop", ctx.nzBackdrop)("cdkConnectedOverlayOrigin", ctx.origin)("cdkConnectedOverlayPositions", ctx._positions)("cdkConnectedOverlayOpen", ctx._visible)("cdkConnectedOverlayPush", ctx.cdkConnectedOverlayPush)("nzArrowPointAtCenter", ctx.nzArrowPointAtCenter);
    }
  },
  dependencies: [OverlayModule, CdkConnectedOverlay, NzOverlayModule, NzConnectedOverlayDirective, A11yModule, CdkTrapFocus, NgClass, NgStyle, NzNoAnimationDirective, NgIf, NzOutletModule, NzStringTemplateOutletDirective, NzIconModule, NzIconDirective, NzButtonModule, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, NzI18nModule, NzI18nPipe],
  encapsulation: 2,
  data: {
    animation: [zoomBigMotion]
  },
  changeDetection: 0
});
var NzPopconfirmComponent = _NzPopconfirmComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPopconfirmComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-popconfirm",
      exportAs: "nzPopconfirmComponent",
      preserveWhitespaces: false,
      animations: [zoomBigMotion],
      template: `
    <ng-template
      #overlay="cdkConnectedOverlay"
      cdkConnectedOverlay
      nzConnectedOverlay
      [cdkConnectedOverlayHasBackdrop]="nzBackdrop"
      [cdkConnectedOverlayOrigin]="origin"
      (overlayOutsideClick)="onClickOutside($event)"
      (detach)="hide()"
      (positionChange)="onPositionChange($event)"
      [cdkConnectedOverlayPositions]="_positions"
      [cdkConnectedOverlayOpen]="_visible"
      [cdkConnectedOverlayPush]="cdkConnectedOverlayPush"
      [nzArrowPointAtCenter]="nzArrowPointAtCenter"
    >
      <div
        cdkTrapFocus
        [cdkTrapFocusAutoCapture]="nzAutoFocus !== null"
        class="ant-popover"
        [ngClass]="_classMap"
        [class.ant-popover-rtl]="dir === 'rtl'"
        [ngStyle]="nzOverlayStyle"
        [@.disabled]="!!noAnimation?.nzNoAnimation"
        [nzNoAnimation]="noAnimation?.nzNoAnimation"
        [@zoomBigMotion]="'active'"
      >
        <div class="ant-popover-content">
          <div class="ant-popover-arrow" *ngIf="nzPopconfirmShowArrow">
            <span class="ant-popover-arrow-content"></span>
          </div>
          <div class="ant-popover-inner">
            <div>
              <div class="ant-popover-inner-content">
                <div class="ant-popover-message">
                  <ng-container *nzStringTemplateOutlet="nzTitle">
                    <ng-container *nzStringTemplateOutlet="nzIcon; let icon">
                      <span nz-icon [nzType]="icon || 'exclamation-circle'" nzTheme="fill"></span>
                    </ng-container>
                    <div class="ant-popover-message-title">{{ nzTitle }}</div>
                  </ng-container>
                </div>
                <div class="ant-popover-buttons">
                  <button
                    nz-button
                    #cancelBtn
                    [nzSize]="'small'"
                    (click)="onCancel()"
                    [attr.cdkFocusInitial]="nzAutoFocus === 'cancel' || null"
                  >
                    <ng-container *ngIf="nzCancelText">{{ nzCancelText }}</ng-container>
                    <ng-container *ngIf="!nzCancelText">{{ 'Modal.cancelText' | nzI18n }}</ng-container>
                  </button>
                  <button
                    nz-button
                    #okBtn
                    [nzSize]="'small'"
                    [nzType]="nzOkType !== 'danger' ? nzOkType : 'primary'"
                    [nzDanger]="nzOkDanger || nzOkType === 'danger'"
                    [nzLoading]="confirmLoading"
                    (click)="onConfirm()"
                    [attr.cdkFocusInitial]="nzAutoFocus === 'ok' || null"
                  >
                    <ng-container *ngIf="nzOkText">{{ nzOkText }}</ng-container>
                    <ng-container *ngIf="!nzOkText">{{ 'Modal.okText' | nzI18n }}</ng-container>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </ng-template>
  `,
      imports: [OverlayModule, NzOverlayModule, A11yModule, NgClass, NgStyle, NzNoAnimationDirective, NgIf, NzOutletModule, NzIconModule, NzButtonModule, NzI18nModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    okBtn: [{
      type: ViewChildren,
      args: ["okBtn", {
        read: ElementRef
      }]
    }],
    cancelBtn: [{
      type: ViewChildren,
      args: ["cancelBtn", {
        read: ElementRef
      }]
    }]
  });
})();
var _NzPopconfirmModule = class _NzPopconfirmModule {
};
_NzPopconfirmModule.\u0275fac = function NzPopconfirmModule_Factory(t) {
  return new (t || _NzPopconfirmModule)();
};
_NzPopconfirmModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzPopconfirmModule
});
_NzPopconfirmModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzPopconfirmComponent]
});
var NzPopconfirmModule = _NzPopconfirmModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPopconfirmModule, [{
    type: NgModule,
    args: [{
      imports: [NzPopconfirmComponent, NzPopconfirmDirective],
      exports: [NzPopconfirmComponent, NzPopconfirmDirective]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-divider.mjs
function NzDividerComponent_span_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r1.nzText);
  }
}
function NzDividerComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 1);
    \u0275\u0275template(1, NzDividerComponent_span_0_ng_container_1_Template, 2, 1, "ng-container", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.nzText);
  }
}
var _NzDividerComponent = class _NzDividerComponent {
  constructor() {
    this.nzType = "horizontal";
    this.nzOrientation = "center";
    this.nzDashed = false;
    this.nzPlain = false;
  }
};
_NzDividerComponent.\u0275fac = function NzDividerComponent_Factory(t) {
  return new (t || _NzDividerComponent)();
};
_NzDividerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzDividerComponent,
  selectors: [["nz-divider"]],
  hostAttrs: [1, "ant-divider"],
  hostVars: 16,
  hostBindings: function NzDividerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-divider-horizontal", ctx.nzType === "horizontal")("ant-divider-vertical", ctx.nzType === "vertical")("ant-divider-with-text", ctx.nzText)("ant-divider-plain", ctx.nzPlain)("ant-divider-with-text-left", ctx.nzText && ctx.nzOrientation === "left")("ant-divider-with-text-right", ctx.nzText && ctx.nzOrientation === "right")("ant-divider-with-text-center", ctx.nzText && ctx.nzOrientation === "center")("ant-divider-dashed", ctx.nzDashed);
    }
  },
  inputs: {
    nzText: "nzText",
    nzType: "nzType",
    nzOrientation: "nzOrientation",
    nzDashed: "nzDashed",
    nzPlain: "nzPlain"
  },
  exportAs: ["nzDivider"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 1,
  consts: [["class", "ant-divider-inner-text", 4, "ngIf"], [1, "ant-divider-inner-text"], [4, "nzStringTemplateOutlet"]],
  template: function NzDividerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzDividerComponent_span_0_Template, 2, 1, "span", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.nzText);
    }
  },
  dependencies: [NgIf, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzDividerComponent = _NzDividerComponent;
__decorate([InputBoolean()], NzDividerComponent.prototype, "nzDashed", void 0);
__decorate([InputBoolean()], NzDividerComponent.prototype, "nzPlain", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDividerComponent, [{
    type: Component,
    args: [{
      selector: "nz-divider",
      exportAs: "nzDivider",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span *ngIf="nzText" class="ant-divider-inner-text">
      <ng-container *nzStringTemplateOutlet="nzText">{{ nzText }}</ng-container>
    </span>
  `,
      host: {
        class: "ant-divider",
        "[class.ant-divider-horizontal]": `nzType === 'horizontal'`,
        "[class.ant-divider-vertical]": `nzType === 'vertical'`,
        "[class.ant-divider-with-text]": `nzText`,
        "[class.ant-divider-plain]": `nzPlain`,
        "[class.ant-divider-with-text-left]": `nzText && nzOrientation === 'left'`,
        "[class.ant-divider-with-text-right]": `nzText && nzOrientation === 'right'`,
        "[class.ant-divider-with-text-center]": `nzText && nzOrientation === 'center'`,
        "[class.ant-divider-dashed]": `nzDashed`
      },
      imports: [NgIf, NzOutletModule],
      standalone: true
    }]
  }], () => [], {
    nzText: [{
      type: Input
    }],
    nzType: [{
      type: Input
    }],
    nzOrientation: [{
      type: Input
    }],
    nzDashed: [{
      type: Input
    }],
    nzPlain: [{
      type: Input
    }]
  });
})();
var _NzDividerModule = class _NzDividerModule {
};
_NzDividerModule.\u0275fac = function NzDividerModule_Factory(t) {
  return new (t || _NzDividerModule)();
};
_NzDividerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzDividerModule
});
_NzDividerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzDividerComponent]
});
var NzDividerModule = _NzDividerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDividerModule, [{
    type: NgModule,
    args: [{
      imports: [NzDividerComponent],
      exports: [NzDividerComponent]
    }]
  }], null, null);
})();

// node_modules/@delon/abc/fesm2022/st.mjs
function STFilterComponent_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5)(1, "input", 6);
    \u0275\u0275listener("ngModelChange", function STFilterComponent_Case_5_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.f.menus[0].value = $event);
    })("ngModelChange", function STFilterComponent_Case_5_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.n.emit($event));
    })("keyup.enter", function STFilterComponent_Case_5_Template_input_keyup_enter_1_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r10 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r10.confirm());
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngModel", ctx_r1.f.menus[0].value);
    \u0275\u0275attribute("placeholder", ctx_r1.f.placeholder);
  }
}
function STFilterComponent_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7)(1, "nz-input-number", 8);
    \u0275\u0275listener("ngModelChange", function STFilterComponent_Case_6_Template_nz_input_number_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r12);
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11.f.menus[0].value = $event);
    })("ngModelChange", function STFilterComponent_Case_6_Template_nz_input_number_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r12);
      const ctx_r13 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r13.n.emit($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngModel", ctx_r2.f.menus[0].value)("nzMin", ctx_r2.f.number.min)("nzMax", ctx_r2.f.number.max)("nzStep", ctx_r2.f.number.step)("nzPrecision", ctx_r2.f.number.precision)("nzPlaceHolder", ctx_r2.f.placeholder);
  }
}
function STFilterComponent_Case_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-range-picker", 11);
    \u0275\u0275listener("ngModelChange", function STFilterComponent_Case_7_Conditional_1_Template_nz_range_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r16 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r16.f.menus[0].value = $event);
    })("ngModelChange", function STFilterComponent_Case_7_Conditional_1_Template_nz_range_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r18 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r18.n.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r14 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzMode", ctx_r14.f.date.mode)("ngModel", ctx_r14.f.menus[0].value)("nzShowNow", ctx_r14.f.date.showNow)("nzShowToday", ctx_r14.f.date.showToday)("nzDisabledDate", ctx_r14.f.date.disabledDate)("nzDisabledTime", ctx_r14.f.date.disabledTime);
  }
}
function STFilterComponent_Case_7_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-date-picker", 11);
    \u0275\u0275listener("ngModelChange", function STFilterComponent_Case_7_Conditional_2_Template_nz_date_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r20);
      const ctx_r19 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r19.f.menus[0].value = $event);
    })("ngModelChange", function STFilterComponent_Case_7_Conditional_2_Template_nz_date_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r20);
      const ctx_r21 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r21.n.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r15 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzMode", ctx_r15.f.date.mode)("ngModel", ctx_r15.f.menus[0].value)("nzShowNow", ctx_r15.f.date.showNow)("nzShowToday", ctx_r15.f.date.showToday)("nzDisabledDate", ctx_r15.f.date.disabledDate)("nzDisabledTime", ctx_r15.f.date.disabledTime);
  }
}
function STFilterComponent_Case_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275template(1, STFilterComponent_Case_7_Conditional_1_Template, 1, 6, "nz-range-picker", 10)(2, STFilterComponent_Case_7_Conditional_2_Template, 1, 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r3.f.date.range ? 1 : 2);
  }
}
function STFilterComponent_Case_8_ng_template_1_Template(rf, ctx) {
}
var _c021 = (a0, a1, a2) => ({
  $implicit: a0,
  col: a1,
  handle: a2
});
function STFilterComponent_Case_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12);
    \u0275\u0275template(1, STFilterComponent_Case_8_ng_template_1_Template, 0, 0, "ng-template", 13);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r4.f.custom)("ngTemplateOutletContext", \u0275\u0275pureFunction3(2, _c021, ctx_r4.f, ctx_r4.col, ctx_r4));
  }
}
function STFilterComponent_Case_9_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r33 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 17);
    \u0275\u0275listener("ngModelChange", function STFilterComponent_Case_9_For_2_Conditional_1_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r33);
      const filter_r24 = \u0275\u0275nextContext().$implicit;
      return \u0275\u0275resetView(filter_r24.checked = $event);
    })("ngModelChange", function STFilterComponent_Case_9_For_2_Conditional_1_Template_label_ngModelChange_0_listener() {
      \u0275\u0275restoreView(_r33);
      const ctx_r34 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r34.checkboxChange());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const filter_r24 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("ngModel", filter_r24.checked);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", filter_r24.text, " ");
  }
}
function STFilterComponent_Case_9_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r38 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 18);
    \u0275\u0275listener("ngModelChange", function STFilterComponent_Case_9_For_2_Conditional_2_Template_label_ngModelChange_0_listener() {
      \u0275\u0275restoreView(_r38);
      const filter_r24 = \u0275\u0275nextContext().$implicit;
      const ctx_r36 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r36.radioChange(filter_r24));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const filter_r24 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("ngModel", filter_r24.checked);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", filter_r24.text, " ");
  }
}
function STFilterComponent_Case_9_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 15);
    \u0275\u0275template(1, STFilterComponent_Case_9_For_2_Conditional_1_Template, 2, 2, "label", 16)(2, STFilterComponent_Case_9_For_2_Conditional_2_Template, 2, 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r23 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r23.f.multiple ? 1 : 2);
  }
}
function STFilterComponent_Case_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 14);
    \u0275\u0275repeaterCreate(1, STFilterComponent_Case_9_For_2_Template, 3, 1, "li", 15, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r5.f.menus);
  }
}
function STFilterComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r41 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 19)(1, "a", 20);
    \u0275\u0275listener("click", function STFilterComponent_Conditional_10_Template_a_click_1_listener() {
      \u0275\u0275restoreView(_r41);
      const ctx_r40 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r40.confirm());
    });
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "a", 21);
    \u0275\u0275listener("click", function STFilterComponent_Conditional_10_Template_a_click_4_listener() {
      \u0275\u0275restoreView(_r41);
      const ctx_r42 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r42.reset());
    });
    \u0275\u0275elementStart(5, "span");
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r6.f.confirmText || ctx_r6.locale.filterConfirm);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r6.f.clearText || ctx_r6.locale.filterReset);
  }
}
var _c115 = ["table"];
var _c212 = ["contextmenuTpl"];
function STComponent_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "small", 14);
  }
  if (rf & 2) {
    const i_r16 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("innerHTML", i_r16.optional, \u0275\u0275sanitizeHtml);
  }
}
function STComponent_ng_template_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 15);
  }
  if (rf & 2) {
    const i_r16 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("nzTooltipTitle", i_r16.optionalHelp);
  }
}
function STComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 11);
    \u0275\u0275template(1, STComponent_ng_template_0_Conditional_1_Template, 1, 1, "small", 12)(2, STComponent_ng_template_0_Conditional_2_Template, 1, 1, "i", 13);
  }
  if (rf & 2) {
    const i_r16 = ctx.$implicit;
    \u0275\u0275property("innerHTML", i_r16._text, \u0275\u0275sanitizeHtml);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, i_r16.optional ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, i_r16.optionalHelp ? 2 : -1);
  }
}
function STComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 16);
    \u0275\u0275listener("ngModelChange", function STComponent_ng_template_2_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r22 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r22._allChecked = $event);
    })("ngModelChange", function STComponent_ng_template_2_Template_label_ngModelChange_0_listener() {
      \u0275\u0275restoreView(_r23);
      const ctx_r24 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r24.checkAll());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const custom_r21 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-table-selection-select-all-custom", custom_r21);
    \u0275\u0275property("nzDisabled", ctx_r2._allCheckedDisabled)("ngModel", ctx_r2._allChecked)("nzIndeterminate", ctx_r2._indeterminate);
  }
}
function STComponent_Conditional_6_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "th", 17);
  }
  if (rf & 2) {
    const ctx_r31 = \u0275\u0275nextContext(3);
    \u0275\u0275property("rowSpan", ctx_r31._headers.length);
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-resize-handle", 20);
    \u0275\u0275element(1, "i");
    \u0275\u0275elementEnd();
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_2_ng_template_0_Template(rf, ctx) {
}
var _c39 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const _c_r39 = \u0275\u0275nextContext().let;
    const ctx_r46 = \u0275\u0275nextContext();
    const h_r33 = ctx_r46.$implicit;
    const index_r34 = ctx_r46.$index;
    \u0275\u0275property("ngTemplateOutlet", _c_r39.__renderTitle)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c39, h_r33.column, index_r34));
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_0_ng_template_0_Template(rf, ctx) {
}
var _c47 = () => ({
  $implicit: false
});
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(7);
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275property("ngTemplateOutlet", _r3)("ngTemplateOutletContext", \u0275\u0275pureFunction0(2, _c47));
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_ng_template_1_Template(rf, ctx) {
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26)(1, "div", 27);
    \u0275\u0275element(2, "i", 28);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r54 = \u0275\u0275reference(4);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzDropdownMenu", _r54);
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_For_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r62 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 29);
    \u0275\u0275listener("click", function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_For_7_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r62);
      const rw_r56 = restoredCtx.$implicit;
      const ctx_r61 = \u0275\u0275nextContext(8);
      return \u0275\u0275resetView(ctx_r61._rowSelection(rw_r56));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const rw_r56 = ctx.$implicit;
    \u0275\u0275property("innerHTML", rw_r56.text, \u0275\u0275sanitizeHtml);
  }
}
var _c54 = () => ({
  $implicit: true
});
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22);
    \u0275\u0275template(1, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 5)(2, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_Conditional_2_Template, 3, 1, "div", 23);
    \u0275\u0275elementStart(3, "nz-dropdown-menu", null, 24)(5, "ul", 25);
    \u0275\u0275repeaterCreate(6, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_For_7_Template, 1, 1, "li", 30, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const _c_r39 = \u0275\u0275nextContext(3).let;
    \u0275\u0275nextContext(4);
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r3)("ngTemplateOutletContext", \u0275\u0275pureFunction0(3, _c54));
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, _c_r39.selections.length ? 2 : -1);
    \u0275\u0275advance(4);
    \u0275\u0275repeater(_c_r39.selections);
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_0_Template, 1, 3, null, 5)(1, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Conditional_1_Template, 8, 4);
  }
  if (rf & 2) {
    const _c_r39 = \u0275\u0275nextContext(2).let;
    \u0275\u0275conditional(0, _c_r39.selections.length === 0 ? 0 : 1);
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_1_ng_template_0_Template(rf, ctx) {
}
var _c64 = (a0) => ({
  $implicit: a0
});
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_1_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const _c_r39 = \u0275\u0275nextContext(2).let;
    \u0275\u0275nextContext(4);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c64, _c_r39.title));
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_0_Template, 2, 1)(1, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Case_1_Template, 1, 4);
  }
  if (rf & 2) {
    const _c_r39 = \u0275\u0275nextContext().let;
    let STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_contFlowTmp;
    \u0275\u0275conditional(0, (STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_contFlowTmp = _c_r39.type) === "checkbox" ? 0 : 1);
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r69 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "st-filter", 31);
    \u0275\u0275listener("n", function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_4_Template_st_filter_n_0_listener($event) {
      \u0275\u0275restoreView(_r69);
      const ctx_r68 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r68.handleFilterNotify($event));
    })("handle", function STComponent_Conditional_6_For_2_For_3_th_0_Conditional_4_Template_st_filter_handle_0_listener($event) {
      \u0275\u0275restoreView(_r69);
      const _c_r39 = \u0275\u0275nextContext().let;
      const ctx_r70 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r70._handleFilter(_c_r39, $event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _c_r39 = \u0275\u0275nextContext().let;
    const h_r33 = \u0275\u0275nextContext().$implicit;
    const ctx_r43 = \u0275\u0275nextContext(3);
    \u0275\u0275property("col", h_r33.column)("f", _c_r39.filter)("locale", ctx_r43.locale);
  }
}
function STComponent_Conditional_6_For_2_For_3_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r75 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "th", 19);
    \u0275\u0275listener("nzSortOrderChange", function STComponent_Conditional_6_For_2_For_3_th_0_Template_th_nzSortOrderChange_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r75);
      const _c_r39 = restoredCtx.let;
      const index_r34 = \u0275\u0275nextContext().$index;
      const ctx_r74 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r74.sort(_c_r39, index_r34, $event));
    })("nzResizeEnd", function STComponent_Conditional_6_For_2_For_3_th_0_Template_th_nzResizeEnd_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r75);
      const _c_r39 = restoredCtx.let;
      const ctx_r77 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r77.colResize($event, _c_r39));
    });
    \u0275\u0275template(1, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_1_Template, 2, 0, "nz-resize-handle", 20)(2, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_2_Template, 1, 5, null, 5)(3, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_3_Template, 2, 1)(4, STComponent_Conditional_6_For_2_For_3_th_0_Conditional_4_Template, 1, 3, "st-filter", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _c_r39 = ctx.let;
    const ctx_r78 = \u0275\u0275nextContext();
    const h_r33 = ctx_r78.$implicit;
    const \u0275$index_3_r35 = ctx_r78.$index;
    const \u0275$count_3_r37 = ctx_r78.$count;
    const index_r34 = ctx_r78.$index;
    \u0275\u0275classProp("st__has-filter", _c_r39.filter);
    \u0275\u0275property("colSpan", h_r33.colSpan)("rowSpan", h_r33.rowSpan)("nzWidth", _c_r39.width)("nzLeft", _c_r39._left)("nzRight", _c_r39._right)("ngClass", _c_r39._className)("nzShowSort", _c_r39._sort.enabled)("nzSortOrder", _c_r39._sort.default)("nzCustomFilter", !!_c_r39.filter)("nzDisabled", \u0275$index_3_r35 === \u0275$count_3_r37 - 1 || _c_r39.resizable.disabled)("nzMaxWidth", _c_r39.resizable.maxWidth)("nzMinWidth", _c_r39.resizable.minWidth)("nzBounds", _c_r39.resizable.bounds)("nzPreview", _c_r39.resizable.preview);
    \u0275\u0275attribute("data-col", _c_r39.indexKey)("data-col-index", index_r34);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, !(\u0275$index_3_r35 === \u0275$count_3_r37 - 1) && !_c_r39.resizable.disabled ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, _c_r39.__renderTitle ? 2 : 3);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(4, _c_r39.filter ? 4 : -1);
  }
}
function STComponent_Conditional_6_For_2_For_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_6_For_2_For_3_th_0_Template, 5, 21, "th", 18);
  }
  if (rf & 2) {
    const h_r33 = ctx.$implicit;
    \u0275\u0275property("let", h_r33.column);
  }
}
function STComponent_Conditional_6_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr");
    \u0275\u0275template(1, STComponent_Conditional_6_For_2_Conditional_1_Template, 1, 1, "th", 17);
    \u0275\u0275repeaterCreate(2, STComponent_Conditional_6_For_2_For_3_Template, 1, 1, "th", 32, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r26 = ctx.$implicit;
    const $index_r27 = ctx.$index;
    const ctx_r25 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, $index_r27 === 0 && ctx_r25.expand ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275repeater(row_r26);
  }
}
function STComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "thead");
    \u0275\u0275repeaterCreate(1, STComponent_Conditional_6_For_2_Template, 4, 1, "tr", null, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r5._headers);
  }
}
function STComponent_Conditional_8_ng_template_0_Template(rf, ctx) {
}
function STComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_8_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r6.bodyHeader)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c64, ctx_r6._statistical));
  }
}
function STComponent_ng_template_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r87 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 36);
    \u0275\u0275listener("nzExpandChange", function STComponent_ng_template_9_Conditional_1_Template_td_nzExpandChange_0_listener($event) {
      \u0275\u0275restoreView(_r87);
      const i_r80 = \u0275\u0275nextContext().$implicit;
      const ctx_r85 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r85._expandChange(i_r80, $event));
    })("click", function STComponent_ng_template_9_Conditional_1_Template_td_click_0_listener($event) {
      \u0275\u0275restoreView(_r87);
      const ctx_r88 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r88._stopPropagation($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r80 = \u0275\u0275nextContext().$implicit;
    const ctx_r82 = \u0275\u0275nextContext();
    \u0275\u0275property("nzShowExpand", ctx_r82.expand && i_r80.showExpand !== false)("nzExpand", i_r80.expand);
  }
}
function STComponent_ng_template_9_For_3_Conditional_0_Conditional_1_ng_template_1_Template(rf, ctx) {
}
function STComponent_ng_template_9_For_3_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 40);
    \u0275\u0275template(1, STComponent_ng_template_9_For_3_Conditional_0_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r90 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c64, c_r90.title));
  }
}
function STComponent_ng_template_9_For_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r100 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 37);
    \u0275\u0275template(1, STComponent_ng_template_9_For_3_Conditional_0_Conditional_1_Template, 2, 4, "span", 38);
    \u0275\u0275elementStart(2, "st-td", 39);
    \u0275\u0275listener("n", function STComponent_ng_template_9_For_3_Conditional_0_Template_st_td_n_2_listener($event) {
      \u0275\u0275restoreView(_r100);
      const ctx_r99 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r99._handleTd($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r101 = \u0275\u0275nextContext();
    const c_r90 = ctx_r101.$implicit;
    const cIdx_r91 = ctx_r101.$index;
    const ctx_r102 = \u0275\u0275nextContext();
    const i_r80 = ctx_r102.$implicit;
    const index_r81 = ctx_r102.index;
    const ctx_r95 = \u0275\u0275nextContext();
    \u0275\u0275property("nzLeft", !!c_r90._left)("nzRight", !!c_r90._right)("ngClass", c_r90._className);
    \u0275\u0275attribute("data-col-index", cIdx_r91)("colspan", (i_r80._values[cIdx_r91].props == null ? null : i_r80._values[cIdx_r91].props.colSpan) === 1 ? null : i_r80._values[cIdx_r91].props == null ? null : i_r80._values[cIdx_r91].props.colSpan)("rowspan", (i_r80._values[cIdx_r91].props == null ? null : i_r80._values[cIdx_r91].props.rowSpan) === 1 ? null : i_r80._values[cIdx_r91].props == null ? null : i_r80._values[cIdx_r91].props.rowSpan);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r95.responsive ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r95._data)("i", i_r80)("index", index_r81)("c", c_r90)("cIdx", cIdx_r91);
  }
}
function STComponent_ng_template_9_For_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_ng_template_9_For_3_Conditional_0_Template, 3, 12, "td", 37);
  }
  if (rf & 2) {
    const cIdx_r91 = ctx.$index;
    const i_r80 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275conditional(0, (i_r80._values[cIdx_r91].props == null ? null : i_r80._values[cIdx_r91].props.colSpan) > 0 && (i_r80._values[cIdx_r91].props == null ? null : i_r80._values[cIdx_r91].props.rowSpan) > 0 ? 0 : -1);
  }
}
function STComponent_ng_template_9_ng_template_5_Template(rf, ctx) {
}
function STComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r105 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr", 33);
    \u0275\u0275listener("click", function STComponent_ng_template_9_Template_tr_click_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r105);
      const i_r80 = restoredCtx.$implicit;
      const index_r81 = restoredCtx.index;
      const ctx_r104 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r104._rowClick($event, i_r80, index_r81, false));
    })("dblclick", function STComponent_ng_template_9_Template_tr_dblclick_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r105);
      const i_r80 = restoredCtx.$implicit;
      const index_r81 = restoredCtx.index;
      const ctx_r106 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r106._rowClick($event, i_r80, index_r81, true));
    });
    \u0275\u0275template(1, STComponent_ng_template_9_Conditional_1_Template, 1, 2, "td", 34);
    \u0275\u0275repeaterCreate(2, STComponent_ng_template_9_For_3_Template, 1, 1, null, null, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "tr", 35);
    \u0275\u0275template(5, STComponent_ng_template_9_ng_template_5_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r80 = ctx.$implicit;
    const index_r81 = ctx.index;
    const ctx_r7 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", i_r80._rowClassName);
    \u0275\u0275attribute("data-index", index_r81);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r7.expand ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r7._columns);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzExpand", i_r80.expand);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r7.expand)("ngTemplateOutletContext", \u0275\u0275pureFunction2(6, _c39, i_r80, index_r81));
  }
}
function STComponent_Conditional_11_ng_template_0_ng_template_0_Template(rf, ctx) {
}
function STComponent_Conditional_11_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_11_ng_template_0_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const i_r108 = ctx.$implicit;
    const index_r109 = ctx.index;
    \u0275\u0275nextContext(2);
    const _r8 = \u0275\u0275reference(10);
    \u0275\u0275property("ngTemplateOutlet", _r8)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c39, i_r108, index_r109));
  }
}
function STComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_11_ng_template_0_Template, 1, 5, "ng-template", 7);
  }
}
function STComponent_Conditional_12_For_1_ng_template_0_Template(rf, ctx) {
}
function STComponent_Conditional_12_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_12_For_1_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const i_r112 = ctx.$implicit;
    const $index_r113 = ctx.$index;
    \u0275\u0275nextContext(2);
    const _r8 = \u0275\u0275reference(10);
    \u0275\u0275property("ngTemplateOutlet", _r8)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c39, i_r112, $index_r113));
  }
}
function STComponent_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, STComponent_Conditional_12_For_1_Template, 1, 5, null, 5, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext();
    \u0275\u0275repeater(ctx_r10._data);
  }
}
function STComponent_Conditional_13_ng_template_0_Template(rf, ctx) {
}
function STComponent_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_Conditional_13_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r11 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r11.body)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c64, ctx_r11._statistical));
  }
}
function STComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const range_r119 = ctx.range;
    const total_r120 = ctx.$implicit;
    const ctx_r12 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate(ctx_r12.renderTotal(total_r120, range_r119));
  }
}
function STComponent_For_20_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r130 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 29);
    \u0275\u0275listener("click", function STComponent_For_20_Conditional_0_Template_li_click_0_listener() {
      \u0275\u0275restoreView(_r130);
      const i_r121 = \u0275\u0275nextContext().$implicit;
      return \u0275\u0275resetView(i_r121.fn(i_r121));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r121 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("innerHTML", i_r121.text, \u0275\u0275sanitizeHtml);
  }
}
function STComponent_For_20_Conditional_1_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r139 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 29);
    \u0275\u0275listener("click", function STComponent_For_20_Conditional_1_For_3_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r139);
      const ci_r133 = restoredCtx.$implicit;
      return \u0275\u0275resetView(ci_r133.fn(ci_r133));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ci_r133 = ctx.$implicit;
    \u0275\u0275property("innerHTML", ci_r133.text, \u0275\u0275sanitizeHtml);
  }
}
function STComponent_For_20_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 41)(1, "ul");
    \u0275\u0275repeaterCreate(2, STComponent_For_20_Conditional_1_For_3_Template, 1, 1, "li", 30, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const i_r121 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("nzTitle", i_r121.text);
    \u0275\u0275advance(2);
    \u0275\u0275repeater(i_r121.children);
  }
}
function STComponent_For_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STComponent_For_20_Conditional_0_Template, 1, 1, "li", 30)(1, STComponent_For_20_Conditional_1_Template, 4, 1);
  }
  if (rf & 2) {
    const i_r121 = ctx.$implicit;
    \u0275\u0275conditional(0, i_r121.children.length === 0 ? 0 : 1);
  }
}
function STTdComponent_ng_template_0_Conditional_0_ng_template_1_Template(rf, ctx) {
}
function STTdComponent_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 5);
    \u0275\u0275template(1, STTdComponent_ng_template_0_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext();
    const child_r9 = ctx_r13.child;
    const i_r8 = ctx_r13.$implicit;
    \u0275\u0275nextContext();
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275classProp("d-block", child_r9)("width-100", child_r9);
    \u0275\u0275property("nzTooltipTitle", i_r8.tooltip);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r3)("ngTemplateOutletContext", \u0275\u0275pureFunction1(7, _c64, i_r8));
  }
}
function STTdComponent_ng_template_0_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function STTdComponent_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_ng_template_0_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const i_r8 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext();
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275property("ngTemplateOutlet", _r3)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c64, i_r8));
  }
}
function STTdComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_ng_template_0_Conditional_0_Template, 2, 9, "span", 4)(1, STTdComponent_ng_template_0_Conditional_1_Template, 1, 4);
  }
  if (rf & 2) {
    const i_r8 = ctx.$implicit;
    \u0275\u0275conditional(0, i_r8.tooltip ? 0 : 1);
  }
}
function STTdComponent_ng_template_2_Conditional_0_ng_template_1_Template(rf, ctx) {
}
function STTdComponent_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275listener("nzOnConfirm", function STTdComponent_ng_template_2_Conditional_0_Template_a_nzOnConfirm_0_listener() {
      \u0275\u0275restoreView(_r22);
      const i_r16 = \u0275\u0275nextContext().$implicit;
      const ctx_r20 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r20._btn(i_r16));
    })("click", function STTdComponent_ng_template_2_Conditional_0_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r22);
      const ctx_r23 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r23._stopPropagation($event));
    });
    \u0275\u0275template(1, STTdComponent_ng_template_2_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r16 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext();
    const _r5 = \u0275\u0275reference(5);
    \u0275\u0275property("nzPopconfirmTitle", i_r16.pop.title)("nzIcon", i_r16.pop.icon)("nzCondition", i_r16.pop.condition(i_r16))("nzCancelText", i_r16.pop.cancelText)("nzOkText", i_r16.pop.okText)("nzOkType", i_r16.pop.okType)("ngClass", i_r16._className);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r5)("ngTemplateOutletContext", \u0275\u0275pureFunction1(9, _c64, i_r16));
  }
}
function STTdComponent_ng_template_2_Conditional_1_ng_template_1_Template(rf, ctx) {
}
function STTdComponent_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 8);
    \u0275\u0275listener("click", function STTdComponent_ng_template_2_Conditional_1_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r28);
      const i_r16 = \u0275\u0275nextContext().$implicit;
      const ctx_r26 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r26._btn(i_r16, $event));
    });
    \u0275\u0275template(1, STTdComponent_ng_template_2_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r16 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext();
    const _r5 = \u0275\u0275reference(5);
    \u0275\u0275property("ngClass", i_r16._className);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r5)("ngTemplateOutletContext", \u0275\u0275pureFunction1(3, _c64, i_r16));
  }
}
function STTdComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_ng_template_2_Conditional_0_Template, 2, 11, "a", 6)(1, STTdComponent_ng_template_2_Conditional_1_Template, 2, 5);
  }
  if (rf & 2) {
    const i_r16 = ctx.$implicit;
    \u0275\u0275conditional(0, i_r16.pop ? 0 : 1);
  }
}
function STTdComponent_ng_template_4_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 10);
  }
  if (rf & 2) {
    const i_r30 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("nzIconfont", i_r30._icon.iconfont);
  }
}
function STTdComponent_ng_template_4_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 11);
  }
  if (rf & 2) {
    const i_r30 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("nzType", i_r30._icon.type)("nzTheme", i_r30._icon.theme)("nzSpin", i_r30._icon.spin)("nzTwotoneColor", i_r30._icon.twoToneColor);
  }
}
function STTdComponent_ng_template_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_ng_template_4_Conditional_0_Conditional_0_Template, 1, 1, "i", 10)(1, STTdComponent_ng_template_4_Conditional_0_Conditional_1_Template, 1, 4);
  }
  if (rf & 2) {
    const i_r30 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275conditional(0, i_r30._icon.iconfont ? 0 : 1);
  }
}
var _c73 = (a0) => ({
  "pl-xs": a0
});
function STTdComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_ng_template_4_Conditional_0_Template, 2, 1);
    \u0275\u0275element(1, "span", 9);
  }
  if (rf & 2) {
    const i_r30 = ctx.$implicit;
    \u0275\u0275conditional(0, i_r30._icon ? 0 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", i_r30._text, \u0275\u0275sanitizeHtml)("ngClass", \u0275\u0275pureFunction1(3, _c73, i_r30._icon));
  }
}
function STTdComponent_Conditional_6_ng_template_0_Template(rf, ctx) {
}
var _c83 = (a0, a1, a2) => ({
  $implicit: a0,
  index: a1,
  column: a2
});
function STTdComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_Conditional_6_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r6.c.__render)("ngTemplateOutletContext", \u0275\u0275pureFunction3(2, _c83, ctx_r6.i, ctx_r6.index, ctx_r6.c));
  }
}
function STTdComponent_Conditional_7_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r48 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 12);
    \u0275\u0275listener("ngModelChange", function STTdComponent_Conditional_7_Case_0_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r48);
      const ctx_r47 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r47._checkbox($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r38 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzDisabled", ctx_r38.i.disabled)("ngModel", ctx_r38.i.checked);
  }
}
function STTdComponent_Conditional_7_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r50 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 13);
    \u0275\u0275listener("ngModelChange", function STTdComponent_Conditional_7_Case_1_Template_label_ngModelChange_0_listener() {
      \u0275\u0275restoreView(_r50);
      const ctx_r49 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r49._radio());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r39 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzDisabled", ctx_r39.i.disabled)("ngModel", ctx_r39.i.checked);
  }
}
function STTdComponent_Conditional_7_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r52 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 14);
    \u0275\u0275listener("click", function STTdComponent_Conditional_7_Case_2_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r52);
      const ctx_r51 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r51._link($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r40 = \u0275\u0275nextContext(2);
    \u0275\u0275property("innerHTML", ctx_r40.i._values[ctx_r40.cIdx]._text, \u0275\u0275sanitizeHtml);
    \u0275\u0275attribute("title", ctx_r40.i._values[ctx_r40.cIdx].text);
  }
}
function STTdComponent_Conditional_7_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-tag", 15);
    \u0275\u0275element(1, "span", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r41 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzColor", ctx_r41.i._values[ctx_r41.cIdx].color)("nz-tooltip", ctx_r41.i._values[ctx_r41.cIdx].tooltip);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r41.i._values[ctx_r41.cIdx]._text, \u0275\u0275sanitizeHtml);
  }
}
function STTdComponent_Conditional_7_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-badge", 17);
  }
  if (rf & 2) {
    const ctx_r42 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzStatus", ctx_r42.i._values[ctx_r42.cIdx].color)("nzText", ctx_r42.i._values[ctx_r42.cIdx].text)("nz-tooltip", ctx_r42.i._values[ctx_r42.cIdx].tooltip);
  }
}
function STTdComponent_Conditional_7_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "cell", 18);
  }
  if (rf & 2) {
    const ctx_r43 = \u0275\u0275nextContext(2);
    let tmp_1_0;
    \u0275\u0275property("value", ctx_r43.i._values[ctx_r43.cIdx].text)("options", (tmp_1_0 = ctx_r43.i._values[ctx_r43.cIdx].cell) !== null && tmp_1_0 !== void 0 ? tmp_1_0 : ctx_r43.c.cell);
  }
}
function STTdComponent_Conditional_7_Case_6_ng_template_0_Template(rf, ctx) {
}
function STTdComponent_Conditional_7_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_Conditional_7_Case_6_ng_template_0_Template, 0, 0, "ng-template", 19);
  }
  if (rf & 2) {
    const ctx_r44 = \u0275\u0275nextContext(2);
    \u0275\u0275property("record", ctx_r44.i)("column", ctx_r44.c);
  }
}
function STTdComponent_Conditional_7_Case_7_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 20);
  }
  if (rf & 2) {
    const ctx_r54 = \u0275\u0275nextContext(3);
    \u0275\u0275property("innerText", ctx_r54.i._values[ctx_r54.cIdx]._text);
    \u0275\u0275attribute("title", ctx_r54.c._isTruncate ? ctx_r54.i._values[ctx_r54.cIdx].text : null);
  }
}
function STTdComponent_Conditional_7_Case_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 16);
  }
  if (rf & 2) {
    const ctx_r55 = \u0275\u0275nextContext(3);
    \u0275\u0275property("innerHTML", ctx_r55.i._values[ctx_r55.cIdx]._text, \u0275\u0275sanitizeHtml);
    \u0275\u0275attribute("title", ctx_r55.c._isTruncate ? ctx_r55.i._values[ctx_r55.cIdx].text : null);
  }
}
function STTdComponent_Conditional_7_Case_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_Conditional_7_Case_7_Conditional_0_Template, 1, 2, "span", 20)(1, STTdComponent_Conditional_7_Case_7_Conditional_1_Template, 1, 2);
  }
  if (rf & 2) {
    const ctx_r45 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(0, ctx_r45.c.safeType === "text" ? 0 : 1);
  }
}
function STTdComponent_Conditional_7_For_9_Conditional_0_For_7_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "li", 26);
  }
}
function STTdComponent_Conditional_7_For_9_Conditional_0_For_7_Conditional_1_ng_template_1_Template(rf, ctx) {
}
var _c93 = (a0) => ({
  $implicit: a0,
  child: true
});
function STTdComponent_Conditional_7_For_9_Conditional_0_For_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 27);
    \u0275\u0275template(1, STTdComponent_Conditional_7_For_9_Conditional_0_For_7_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const subBtn_r66 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext(4);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275classProp("st__btn-disabled", subBtn_r66._disabled);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c93, subBtn_r66));
  }
}
function STTdComponent_Conditional_7_For_9_Conditional_0_For_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_Conditional_7_For_9_Conditional_0_For_7_Conditional_0_Template, 1, 0, "li", 26)(1, STTdComponent_Conditional_7_For_9_Conditional_0_For_7_Conditional_1_Template, 2, 6);
  }
  if (rf & 2) {
    const subBtn_r66 = ctx.$implicit;
    \u0275\u0275conditional(0, subBtn_r66.type === "divider" ? 0 : 1);
  }
}
function STTdComponent_Conditional_7_For_9_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 22);
    \u0275\u0275element(1, "span", 16)(2, "i", 23);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-dropdown-menu", null, 24)(5, "ul", 25);
    \u0275\u0275repeaterCreate(6, STTdComponent_Conditional_7_For_9_Conditional_0_For_7_Template, 2, 1, null, null, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r64 = \u0275\u0275reference(4);
    const btn_r56 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("nzDropdownMenu", _r64);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", btn_r56._text, \u0275\u0275sanitizeHtml);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(btn_r56.children);
  }
}
function STTdComponent_Conditional_7_For_9_Conditional_1_ng_template_1_Template(rf, ctx) {
}
var _c103 = (a0) => ({
  $implicit: a0,
  child: false
});
function STTdComponent_Conditional_7_For_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275template(1, STTdComponent_Conditional_7_For_9_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const btn_r56 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275classProp("st__btn-disabled", btn_r56._disabled);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c103, btn_r56));
  }
}
function STTdComponent_Conditional_7_For_9_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-divider", 21);
  }
}
function STTdComponent_Conditional_7_For_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_Conditional_7_For_9_Conditional_0_Template, 8, 2)(1, STTdComponent_Conditional_7_For_9_Conditional_1_Template, 2, 6)(2, STTdComponent_Conditional_7_For_9_Conditional_2_Template, 1, 0, "nz-divider", 21);
  }
  if (rf & 2) {
    const btn_r56 = ctx.$implicit;
    const $index_r57 = ctx.$index;
    const $count_r59 = ctx.$count;
    \u0275\u0275conditional(0, btn_r56.children.length > 0 ? 0 : 1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(2, !($index_r57 === $count_r59 - 1) ? 2 : -1);
  }
}
function STTdComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, STTdComponent_Conditional_7_Case_0_Template, 1, 2)(1, STTdComponent_Conditional_7_Case_1_Template, 1, 2)(2, STTdComponent_Conditional_7_Case_2_Template, 1, 2)(3, STTdComponent_Conditional_7_Case_3_Template, 2, 3)(4, STTdComponent_Conditional_7_Case_4_Template, 1, 3)(5, STTdComponent_Conditional_7_Case_5_Template, 1, 2)(6, STTdComponent_Conditional_7_Case_6_Template, 1, 2)(7, STTdComponent_Conditional_7_Case_7_Template, 2, 1);
    \u0275\u0275repeaterCreate(8, STTdComponent_Conditional_7_For_9_Template, 3, 2, null, null, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext();
    let STTdComponent_Conditional_7_contFlowTmp;
    \u0275\u0275conditional(0, (STTdComponent_Conditional_7_contFlowTmp = ctx_r7.c.type) === "checkbox" ? 0 : STTdComponent_Conditional_7_contFlowTmp === "radio" ? 1 : STTdComponent_Conditional_7_contFlowTmp === "link" ? 2 : STTdComponent_Conditional_7_contFlowTmp === "tag" ? 3 : STTdComponent_Conditional_7_contFlowTmp === "badge" ? 4 : STTdComponent_Conditional_7_contFlowTmp === "cell" ? 5 : STTdComponent_Conditional_7_contFlowTmp === "widget" ? 6 : 7);
    \u0275\u0275advance(8);
    \u0275\u0275repeater(ctx_r7.i._values[ctx_r7.cIdx].buttons);
  }
}
var _STRowSource = class _STRowSource {
  constructor() {
    this.titles = {};
    this.rows = {};
  }
  add(type, path, ref) {
    this[type === "title" ? "titles" : "rows"][path] = ref;
  }
  getTitle(path) {
    return this.titles[path];
  }
  getRow(path) {
    return this.rows[path];
  }
};
_STRowSource.\u0275fac = function STRowSource_Factory(t) {
  return new (t || _STRowSource)();
};
_STRowSource.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _STRowSource,
  factory: _STRowSource.\u0275fac
});
var STRowSource = _STRowSource;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STRowSource, [{
    type: Injectable
  }], null, null);
})();
var _STRowDirective = class _STRowDirective {
  constructor(ref, source) {
    this.ref = ref;
    this.source = source;
  }
  ngOnInit() {
    this.source.add(this.type, this.id, this.ref);
  }
};
_STRowDirective.\u0275fac = function STRowDirective_Factory(t) {
  return new (t || _STRowDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(STRowSource, 1));
};
_STRowDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _STRowDirective,
  selectors: [["", "st-row", ""]],
  inputs: {
    id: ["st-row", "id"],
    type: "type"
  }
});
var STRowDirective = _STRowDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STRowDirective, [{
    type: Directive,
    args: [{
      selector: "[st-row]"
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: STRowSource,
    decorators: [{
      type: Host
    }]
  }], {
    id: [{
      type: Input,
      args: ["st-row"]
    }],
    type: [{
      type: Input
    }]
  });
})();
var _STWidgetRegistry = class _STWidgetRegistry {
  constructor() {
    this._widgets = {};
  }
  get widgets() {
    return this._widgets;
  }
  register(type, widget) {
    this._widgets[type] = widget;
  }
  has(type) {
    return this._widgets.hasOwnProperty(type);
  }
  get(type) {
    return this._widgets[type];
  }
};
_STWidgetRegistry.\u0275fac = function STWidgetRegistry_Factory(t) {
  return new (t || _STWidgetRegistry)();
};
_STWidgetRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _STWidgetRegistry,
  factory: _STWidgetRegistry.\u0275fac,
  providedIn: "root"
});
var STWidgetRegistry = _STWidgetRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STWidgetRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _STColumnSource = class _STColumnSource {
  constructor(dom, rowSource, acl, i18nSrv, stWidgetRegistry) {
    this.dom = dom;
    this.rowSource = rowSource;
    this.acl = acl;
    this.i18nSrv = i18nSrv;
    this.stWidgetRegistry = stWidgetRegistry;
  }
  setCog(val) {
    this.cog = val;
  }
  fixPop(i, def) {
    if (i.pop == null || i.pop === false) {
      i.pop = false;
      return;
    }
    let pop = __spreadValues({}, def);
    if (typeof i.pop === "string") {
      pop.title = i.pop;
    } else if (typeof i.pop === "object") {
      pop = __spreadValues(__spreadValues({}, pop), i.pop);
    }
    if (typeof pop.condition !== "function") {
      pop.condition = () => false;
    }
    i.pop = pop;
  }
  btnCoerce(list2) {
    if (!list2)
      return [];
    const ret = [];
    const {
      modal,
      drawer,
      pop,
      btnIcon
    } = this.cog;
    for (const item of list2) {
      if (this.acl && item.acl && !this.acl.can(item.acl)) {
        continue;
      }
      if (item.type === "modal" || item.type === "static") {
        if (item.modal == null || item.modal.component == null) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            console.warn(`[st] Should specify modal parameter when type is modal or static`);
          }
          item.type = "none";
        } else {
          item.modal = __spreadValues(__spreadValues(__spreadValues({}, {
            paramsName: "record",
            size: "lg"
          }), modal), item.modal);
        }
      }
      if (item.type === "drawer") {
        if (item.drawer == null || item.drawer.component == null) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            console.warn(`[st] Should specify drawer parameter when type is drawer`);
          }
          item.type = "none";
        } else {
          item.drawer = __spreadValues(__spreadValues(__spreadValues({}, {
            paramsName: "record",
            size: "lg"
          }), drawer), item.drawer);
        }
      }
      if (item.type === "del" && typeof item.pop === "undefined") {
        item.pop = true;
      }
      this.fixPop(item, pop);
      if (typeof item.icon !== "function") {
        item.icon = __spreadValues(__spreadValues({}, btnIcon), typeof item.icon === "string" ? {
          type: item.icon
        } : item.icon);
      }
      item.children = item.children && item.children.length > 0 ? this.btnCoerce(item.children) : [];
      if (item.i18n && this.i18nSrv) {
        item.text = this.i18nSrv.fanyi(item.i18n);
      }
      ret.push(item);
    }
    this.btnCoerceIf(ret);
    return ret;
  }
  btnCoerceIf(list2) {
    for (const item of list2) {
      item.iifBehavior = item.iifBehavior || this.cog.iifBehavior;
      if (item.children && item.children.length > 0) {
        this.btnCoerceIf(item.children);
      } else {
        item.children = [];
      }
    }
  }
  fixedCoerce(list2) {
    const countReduce = (a, b) => a + +b.width.toString().replace("px", "");
    list2.filter((w) => w.fixed && w.fixed === "left" && w.width).forEach((item, idx) => item._left = `${list2.slice(0, idx).reduce(countReduce, 0)}px`);
    list2.filter((w) => w.fixed && w.fixed === "right" && w.width).reverse().forEach((item, idx) => item._right = `${idx > 0 ? list2.slice(-idx).reduce(countReduce, 0) : 0}px`);
  }
  sortCoerce(item) {
    const res = this.fixSortCoerce(item);
    res.reName = __spreadValues(__spreadValues({}, this.cog.sortReName), res.reName);
    return res;
  }
  fixSortCoerce(item) {
    if (typeof item.sort === "undefined") {
      return {
        enabled: false
      };
    }
    let res = {};
    if (typeof item.sort === "string") {
      res.key = item.sort;
    } else if (typeof item.sort !== "boolean") {
      res = item.sort;
    } else if (typeof item.sort === "boolean") {
      res.compare = (a, b) => a[item.indexKey] - b[item.indexKey];
    }
    if (!res.key) {
      res.key = item.indexKey;
    }
    res.enabled = true;
    return res;
  }
  filterCoerce(item) {
    if (item.filter == null) {
      return null;
    }
    let res = item.filter;
    res.type = res.type || "default";
    res.showOPArea = res.showOPArea !== false;
    let icon = "filter";
    let iconTheme = "fill";
    let fixMenus = true;
    let value = void 0;
    switch (res.type) {
      case "keyword":
        icon = "search";
        iconTheme = "outline";
        break;
      case "number":
        icon = "search";
        iconTheme = "outline";
        res.number = __spreadValues({
          step: 1,
          min: -Infinity,
          max: Infinity
        }, res.number);
        break;
      case "date":
        icon = "calendar";
        iconTheme = "outline";
        res.date = __spreadValues({
          range: false,
          mode: "date",
          showToday: true,
          showNow: false
        }, res.date);
        break;
      case "custom":
        break;
      default:
        fixMenus = false;
        break;
    }
    if (fixMenus && (res.menus == null || res.menus.length === 0)) {
      res.menus = [{
        value
      }];
    }
    if (res.menus?.length === 0) {
      return null;
    }
    if (typeof res.multiple === "undefined") {
      res.multiple = true;
    }
    res.confirmText = res.confirmText || this.cog.filterConfirmText;
    res.clearText = res.clearText || this.cog.filterClearText;
    res.key = res.key || item.indexKey;
    res.icon = res.icon || icon;
    const baseIcon = {
      type: icon,
      theme: iconTheme
    };
    if (typeof res.icon === "string") {
      res.icon = __spreadProps(__spreadValues({}, baseIcon), {
        type: res.icon
      });
    } else {
      res.icon = __spreadValues(__spreadValues({}, baseIcon), res.icon);
    }
    this.updateDefault(res);
    if (this.acl) {
      res.menus = res.menus?.filter((w) => this.acl.can(w.acl));
    }
    return res.menus?.length === 0 ? null : res;
  }
  restoreRender(item) {
    if (item.renderTitle) {
      item.__renderTitle = typeof item.renderTitle === "string" ? this.rowSource.getTitle(item.renderTitle) : item.renderTitle;
    }
    if (item.render) {
      item.__render = typeof item.render === "string" ? this.rowSource.getRow(item.render) : item.render;
    }
  }
  widgetCoerce(item) {
    if (item.type !== "widget")
      return;
    if (item.widget == null || !this.stWidgetRegistry.has(item.widget.type)) {
      delete item.type;
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        warn(`st: No widget for type "${item.widget?.type}"`);
      }
    }
  }
  genHeaders(rootColumns) {
    const rows = [];
    const widths = [];
    const fillRowCells = (columns, colIndex, rowIndex = 0) => {
      rows[rowIndex] = rows[rowIndex] || [];
      let currentColIndex = colIndex;
      const colSpans = columns.map((column) => {
        const cell = {
          column,
          colStart: currentColIndex,
          hasSubColumns: false
        };
        let colSpan = 1;
        const subColumns = column.children;
        if (Array.isArray(subColumns) && subColumns.length > 0) {
          colSpan = fillRowCells(subColumns, currentColIndex, rowIndex + 1).reduce((total2, count) => total2 + count, 0);
          cell.hasSubColumns = true;
        } else {
          widths.push(cell.column.width || "");
        }
        if ("colSpan" in column) {
          colSpan = column.colSpan;
        }
        if ("rowSpan" in column) {
          cell.rowSpan = column.rowSpan;
        }
        cell.colSpan = colSpan;
        cell.colEnd = cell.colStart + colSpan - 1;
        rows[rowIndex].push(cell);
        currentColIndex += colSpan;
        return colSpan;
      });
      return colSpans;
    };
    fillRowCells(rootColumns, 0);
    const rowCount = rows.length;
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      rows[rowIndex].forEach((cell) => {
        if (!("rowSpan" in cell) && !cell.hasSubColumns) {
          cell.rowSpan = rowCount - rowIndex;
        }
      });
    }
    return {
      headers: rows,
      headerWidths: rowCount > 1 ? widths : null
    };
  }
  cleanCond(list2) {
    const res = [];
    const copyList = deepCopy(list2);
    for (const item of copyList) {
      if (typeof item.iif === "function" && !item.iif(item)) {
        continue;
      }
      if (this.acl && item.acl && !this.acl.can(item.acl)) {
        continue;
      }
      if (Array.isArray(item.children) && item.children.length > 0) {
        item.children = this.cleanCond(item.children);
      }
      res.push(item);
    }
    return res;
  }
  mergeClass(item) {
    const builtInClassNames = [];
    if (item._isTruncate) {
      builtInClassNames.push("text-truncate");
    }
    const rawClassName = item.className;
    if (!rawClassName) {
      const typeClass = {
        number: "text-right",
        currency: "text-right",
        date: "text-center"
      }[item.type];
      if (typeClass) {
        builtInClassNames.push(typeClass);
      }
      item._className = builtInClassNames;
      return;
    }
    const rawClassNameIsArray = Array.isArray(rawClassName);
    if (!rawClassNameIsArray && typeof rawClassName === "object") {
      const objClassNames = rawClassName;
      builtInClassNames.forEach((key) => objClassNames[key] = true);
      item._className = objClassNames;
      return;
    }
    const arrayClassNames = rawClassNameIsArray ? Array.from(rawClassName) : [rawClassName];
    arrayClassNames.splice(0, 0, ...builtInClassNames);
    item._className = [...new Set(arrayClassNames)].filter((w) => !!w);
  }
  process(list2, options) {
    if (!list2 || list2.length === 0) {
      return {
        columns: [],
        headers: [],
        headerWidths: null
      };
    }
    const {
      noIndex
    } = this.cog;
    let checkboxCount = 0;
    let radioCount = 0;
    let point = 0;
    const columns = [];
    const processItem = (item) => {
      if (item.index) {
        if (!Array.isArray(item.index)) {
          item.index = item.index.toString().split(".");
        }
        item.indexKey = item.index.join(".");
      }
      const tit = (typeof item.title === "string" ? {
        text: item.title
      } : item.title) || {};
      if (tit.i18n && this.i18nSrv) {
        tit.text = this.i18nSrv.fanyi(tit.i18n);
      }
      if (tit.text) {
        tit._text = this.dom.bypassSecurityTrustHtml(tit.text);
      }
      item.title = tit;
      if (item.type === "no") {
        item.noIndex = item.noIndex == null ? noIndex : item.noIndex;
      }
      if (item.selections == null) {
        item.selections = [];
      }
      if (item.type === "checkbox") {
        ++checkboxCount;
        if (!item.width) {
          item.width = `${item.selections.length > 0 ? 62 : 50}px`;
        }
      }
      if (this.acl) {
        item.selections = item.selections.filter((w) => this.acl.can(w.acl));
      }
      if (item.type === "radio") {
        ++radioCount;
        item.selections = [];
        if (!item.width) {
          item.width = "50px";
        }
      }
      if (item.cell != null) {
        item.type = "cell";
      }
      if (item.type === "yn") {
        item.yn = __spreadValues(__spreadValues({
          truth: true
        }, this.cog.yn), item.yn);
      }
      if (item.type === "date") {
        item.dateFormat = item.dateFormat || this.cog.date?.format;
      }
      if (item.type === "link" && typeof item.click !== "function" || item.type === "badge" && item.badge == null || item.type === "tag" && item.tag == null || item.type === "enum" && item.enum == null) {
        item.type = "";
      }
      item._isTruncate = !!item.width && options.widthMode.strictBehavior === "truncate" && item.type !== "img";
      this.mergeClass(item);
      if (typeof item.width === "number") {
        item._width = item.width;
        item.width = `${item.width}px`;
      }
      item._left = false;
      item._right = false;
      item.safeType = item.safeType ?? options.safeType;
      item._sort = this.sortCoerce(item);
      item.filter = this.filterCoerce(item);
      item.buttons = this.btnCoerce(item.buttons);
      this.widgetCoerce(item);
      this.restoreRender(item);
      item.resizable = __spreadValues(__spreadValues({
        disabled: true,
        bounds: "window",
        minWidth: 60,
        maxWidth: 360,
        preview: true
      }, options.resizable), typeof item.resizable === "boolean" ? {
        disabled: !item.resizable
      } : item.resizable);
      item.__point = point++;
      return item;
    };
    const processList = (data) => {
      for (const item of data) {
        columns.push(processItem(item));
        if (Array.isArray(item.children)) {
          processList(item.children);
        }
      }
    };
    const copyList = this.cleanCond(list2);
    processList(copyList);
    if (checkboxCount > 1) {
      throw new Error(`[st]: just only one column checkbox`);
    }
    if (radioCount > 1) {
      throw new Error(`[st]: just only one column radio`);
    }
    this.fixedCoerce(columns);
    return __spreadValues({
      columns: columns.filter((w) => !Array.isArray(w.children) || w.children.length === 0)
    }, this.genHeaders(copyList));
  }
  restoreAllRender(columns) {
    columns.forEach((i) => this.restoreRender(i));
  }
  updateDefault(filter2) {
    if (filter2.menus == null)
      return this;
    if (filter2.type === "default") {
      filter2.default = filter2.menus.findIndex((w) => w.checked) !== -1;
    } else {
      filter2.default = !!filter2.menus[0].value;
    }
    return this;
  }
  cleanFilter(col) {
    const f = col.filter;
    f.default = false;
    if (f.type === "default") {
      f.menus.forEach((i) => i.checked = false);
    } else {
      f.menus[0].value = void 0;
    }
    return this;
  }
};
_STColumnSource.\u0275fac = function STColumnSource_Factory(t) {
  return new (t || _STColumnSource)(\u0275\u0275inject(DomSanitizer), \u0275\u0275inject(STRowSource, 1), \u0275\u0275inject(ACLService, 8), \u0275\u0275inject(ALAIN_I18N_TOKEN, 8), \u0275\u0275inject(STWidgetRegistry));
};
_STColumnSource.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _STColumnSource,
  factory: _STColumnSource.\u0275fac
});
var STColumnSource = _STColumnSource;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STColumnSource, [{
    type: Injectable
  }], () => [{
    type: DomSanitizer
  }, {
    type: STRowSource,
    decorators: [{
      type: Host
    }]
  }, {
    type: ACLService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ALAIN_I18N_TOKEN]
    }]
  }, {
    type: STWidgetRegistry
  }], null);
})();
var _STDataSource = class _STDataSource {
  constructor(http, datePipe, ynPipe, numberPipe, currencySrv, dom) {
    this.http = http;
    this.datePipe = datePipe;
    this.ynPipe = ynPipe;
    this.numberPipe = numberPipe;
    this.currencySrv = currencySrv;
    this.dom = dom;
    this.sortTick = 0;
  }
  setCog(val) {
    this.cog = val;
  }
  process(options) {
    let data$;
    let isRemote = false;
    const {
      data,
      res,
      total: total2,
      page,
      pi,
      ps,
      paginator,
      columns
    } = options;
    let retTotal;
    let retPs;
    let retList;
    let retPi;
    let rawData;
    let showPage = page.show;
    if (typeof data === "string") {
      isRemote = true;
      data$ = this.getByRemote(data, options).pipe(map((result) => {
        rawData = result;
        let ret;
        if (Array.isArray(result)) {
          ret = result;
          retTotal = ret.length;
          retPs = retTotal;
          showPage = false;
        } else {
          const reName = res.reName;
          if (typeof reName === "function") {
            const fnRes = reName(result, {
              pi,
              ps,
              total: total2
            });
            ret = fnRes.list;
            retTotal = fnRes.total;
          } else {
            ret = deepGet(result, reName.list, []);
            if (ret == null || !Array.isArray(ret)) {
              ret = [];
            }
            const resultTotal = reName.total && deepGet(result, reName.total, null);
            retTotal = resultTotal == null ? total2 || 0 : +resultTotal;
          }
        }
        return deepCopy(ret);
      }));
    } else if (data == null || Array.isArray(data)) {
      data$ = of(data ?? []);
    } else {
      data$ = data;
    }
    if (!isRemote) {
      data$ = data$.pipe(
        // sort
        map((result) => {
          rawData = result;
          let copyResult = deepCopy(result);
          const sorterFn = this.getSorterFn(columns);
          if (sorterFn) {
            copyResult = copyResult.sort(sorterFn);
          }
          return copyResult;
        }),
        // filter
        map((result) => {
          columns.filter((w) => w.filter).forEach((c) => {
            const filter2 = c.filter;
            const values = this.getFilteredData(filter2);
            if (values.length === 0)
              return;
            const onFilter = filter2.fn;
            if (typeof onFilter !== "function") {
              if (typeof ngDevMode === "undefined" || ngDevMode) {
                console.warn(`[st] Muse provide the fn function in filter`);
              }
              return;
            }
            result = result.filter((record) => values.some((v) => onFilter(v, record)));
          });
          return result;
        }),
        // paging
        map((result) => {
          if (paginator && page.front) {
            const maxPageIndex = Math.ceil(result.length / ps);
            retPi = Math.max(1, pi > maxPageIndex ? maxPageIndex : pi);
            retTotal = result.length;
            if (page.show === true) {
              return result.slice((retPi - 1) * ps, retPi * ps);
            }
          }
          return result;
        })
      );
    }
    if (typeof res.process === "function") {
      data$ = data$.pipe(map((result) => res.process(result, rawData)));
    }
    data$ = data$.pipe(map((result) => this.optimizeData({
      result,
      columns,
      rowClassName: options.rowClassName
    })));
    return data$.pipe(map((result) => {
      retList = result;
      const realTotal = retTotal || total2;
      const realPs = retPs || ps;
      return {
        pi: retPi,
        ps: retPs,
        total: retTotal,
        list: retList,
        statistical: this.genStatistical(columns, retList, rawData),
        pageShow: typeof showPage === "undefined" ? realTotal > realPs : showPage
      };
    }));
  }
  get(item, col, idx) {
    try {
      const safeHtml = col.safeType === "safeHtml";
      if (col.format) {
        const formatRes = col.format(item, col, idx) || "";
        return {
          text: formatRes,
          _text: safeHtml ? this.dom.bypassSecurityTrustHtml(formatRes) : formatRes,
          org: formatRes,
          safeType: col.safeType
        };
      }
      const value = deepGet(item, col.index, col.default);
      let text = value;
      let color;
      let tooltip;
      switch (col.type) {
        case "no":
          text = this.getNoIndex(item, col, idx);
          break;
        case "img":
          text = value ? `<img src="${value}" class="img">` : "";
          break;
        case "number":
          text = this.numberPipe.transform(value, col.numberDigits);
          break;
        case "currency":
          text = this.currencySrv.format(value, col.currency?.format);
          break;
        case "date":
          text = value === col.default ? col.default : this.datePipe.transform(value, col.dateFormat);
          break;
        case "yn":
          text = this.ynPipe.transform(value === col.yn.truth, col.yn.yes, col.yn.no, col.yn.mode, false);
          break;
        case "enum":
          text = col.enum[value];
          break;
        case "tag":
        case "badge":
          const data = col.type === "tag" ? col.tag : col.badge;
          if (data && data[text]) {
            const dataItem = data[text];
            text = dataItem.text;
            color = dataItem.color;
            tooltip = dataItem.tooltip;
          } else {
            text = "";
          }
          break;
      }
      if (text == null)
        text = "";
      return {
        text,
        _text: safeHtml ? this.dom.bypassSecurityTrustHtml(text) : text,
        org: value,
        color,
        tooltip,
        safeType: col.safeType,
        buttons: []
      };
    } catch (ex) {
      const text = `INVALID DATA`;
      console.error(`Failed to get data`, item, col, ex);
      return {
        text,
        _text: text,
        org: text,
        buttons: [],
        safeType: "text"
      };
    }
  }
  getByRemote(url, options) {
    const {
      req,
      page,
      paginator,
      pi,
      ps,
      singleSort,
      multiSort,
      columns
    } = options;
    const method = (req.method || "GET").toUpperCase();
    let params = {};
    const reName = req.reName;
    if (paginator) {
      if (req.type === "page") {
        params = {
          [reName.pi]: page.zeroIndexed ? pi - 1 : pi,
          [reName.ps]: ps
        };
      } else {
        params = {
          [reName.skip]: (pi - 1) * ps,
          [reName.limit]: ps
        };
      }
    }
    params = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, params), req.params), this.getReqSortMap(singleSort, multiSort, columns)), this.getReqFilterMap(columns));
    if (options.req.ignoreParamNull == true) {
      Object.keys(params).forEach((key) => {
        if (params[key] == null)
          delete params[key];
      });
    }
    let reqOptions = {
      params,
      body: req.body,
      headers: req.headers
    };
    if (method === "POST" && req.allInBody === true) {
      reqOptions = {
        body: __spreadValues(__spreadValues({}, req.body), params),
        headers: req.headers
      };
    }
    if (typeof req.process === "function") {
      reqOptions = req.process(reqOptions);
    }
    if (!(reqOptions.params instanceof HttpParams)) {
      reqOptions.params = new HttpParams({
        fromObject: reqOptions.params
      });
    }
    if (typeof options.customRequest === "function") {
      return options.customRequest({
        method,
        url,
        options: reqOptions
      });
    }
    return this.http.request(method, url, reqOptions);
  }
  getCell(c, item, idx) {
    const onCellResult = typeof c.onCell === "function" ? c.onCell(item, idx) : null;
    const mergedColSpan = onCellResult?.colSpan ?? 1;
    const mergedRowSpan = onCellResult?.rowSpan ?? 1;
    return {
      colSpan: mergedColSpan <= 0 ? null : mergedColSpan,
      rowSpan: mergedRowSpan <= 0 ? null : mergedRowSpan
    };
  }
  optimizeData(options) {
    const {
      result,
      columns,
      rowClassName
    } = options;
    for (let i = 0, len = result.length; i < len; i++) {
      result[i]._values = columns.map((c) => {
        const props = this.getCell(c, result[i], i);
        if (Array.isArray(c.buttons) && c.buttons.length > 0) {
          return {
            buttons: this.genButtons(c.buttons, result[i], c),
            _text: "",
            props
          };
        }
        let cell;
        if (typeof c.cell === "function") {
          cell = c.cell(result[i], c);
        }
        return __spreadProps(__spreadValues({}, this.get(result[i], c, i)), {
          props,
          cell
        });
      });
      result[i]._rowClassName = [rowClassName ? rowClassName(result[i], i) : null, result[i].className].filter((w) => !!w).join(" ");
    }
    return result;
  }
  getNoIndex(item, col, idx) {
    return typeof col.noIndex === "function" ? col.noIndex(item, col, idx) : col.noIndex + idx;
  }
  genButtons(_btns, item, col) {
    const fn = (btns) => {
      return deepCopy(btns).filter((btn) => {
        const result = typeof btn.iif === "function" ? btn.iif(item, btn, col) : true;
        const isRenderDisabled = btn.iifBehavior === "disabled";
        btn._result = result;
        btn._disabled = !result && isRenderDisabled;
        if (btn.children?.length) {
          btn.children = fn(btn.children);
        }
        return result || isRenderDisabled;
      });
    };
    const res = fn(_btns);
    const fnText = (btns) => {
      for (const btn of btns) {
        btn._text = typeof btn.text === "function" ? btn.text(item, btn) : btn.text || "";
        btn._className = typeof btn.className === "function" ? btn.className(item, btn) : btn.className;
        btn._icon = typeof btn.icon === "function" ? btn.icon(item, btn) : btn.icon;
        if (btn.children?.length) {
          btn.children = fnText(btn.children);
        }
      }
      return btns;
    };
    return this.fixMaxMultiple(fnText(res), col);
  }
  fixMaxMultiple(btns, col) {
    const curCog = col.maxMultipleButton;
    const btnSize = btns.length;
    if (curCog == null || btnSize <= 0)
      return btns;
    const cog = __spreadValues(__spreadValues({}, this.cog.maxMultipleButton), typeof curCog === "number" ? {
      count: curCog
    } : curCog);
    if (cog.count >= btnSize)
      return btns;
    const newBtns = btns.slice(0, cog.count);
    newBtns.push({
      _text: cog.text,
      children: btns.slice(cog.count)
    });
    return newBtns;
  }
  // #region sort
  getValidSort(columns) {
    return columns.filter((item) => item._sort && item._sort.enabled && item._sort.default).map((item) => item._sort);
  }
  getSorterFn(columns) {
    const sortList = this.getValidSort(columns);
    if (sortList.length === 0) {
      return;
    }
    const sortItem = sortList[0];
    if (sortItem.compare === null) {
      return;
    }
    if (typeof sortItem.compare !== "function") {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        console.warn(`[st] Muse provide the compare function in sort`);
      }
      return;
    }
    return (a, b) => {
      const result = sortItem.compare(a, b);
      if (result !== 0) {
        return sortItem.default === "descend" ? -result : result;
      }
      return 0;
    };
  }
  get nextSortTick() {
    return ++this.sortTick;
  }
  getReqSortMap(singleSort, multiSort, columns) {
    let ret = {};
    const sortList = this.getValidSort(columns);
    if (multiSort) {
      const ms = __spreadValues({
        key: "sort",
        separator: "-",
        nameSeparator: ".",
        keepEmptyKey: true,
        arrayParam: false
      }, multiSort);
      const sortMap = sortList.sort((a, b) => a.tick - b.tick).map((item) => item.key + ms.nameSeparator + ((item.reName || {})[item.default] || item.default));
      ret = {
        [ms.key]: ms.arrayParam ? sortMap : sortMap.join(ms.separator)
      };
      return sortMap.length === 0 && ms.keepEmptyKey === false ? {} : ret;
    }
    if (sortList.length === 0)
      return ret;
    const mapData = sortList[0];
    let sortFiled = mapData.key;
    let sortValue = (sortList[0].reName || {})[mapData.default] || mapData.default;
    if (singleSort) {
      sortValue = sortFiled + (singleSort.nameSeparator || ".") + sortValue;
      sortFiled = singleSort.key || "sort";
    }
    ret[sortFiled] = sortValue;
    return ret;
  }
  // #endregion
  // #region filter
  getFilteredData(filter2) {
    return filter2.type === "default" ? filter2.menus.filter((f) => f.checked === true) : filter2.menus.slice(0, 1);
  }
  getReqFilterMap(columns) {
    let ret = {};
    columns.filter((w) => w.filter && w.filter.default === true).forEach((col) => {
      const filter2 = col.filter;
      const values = this.getFilteredData(filter2);
      let obj = {};
      if (filter2.reName) {
        obj = filter2.reName(filter2.menus, col);
      } else {
        obj[filter2.key] = values.map((i) => i.value).join(",");
      }
      ret = __spreadValues(__spreadValues({}, ret), obj);
    });
    return ret;
  }
  // #endregion
  // #region statistical
  genStatistical(columns, list2, rawData) {
    const res = {};
    columns.forEach((col, index) => {
      res[col.key || col.indexKey || index] = col.statistical == null ? {} : this.getStatistical(col, index, list2, rawData);
    });
    return res;
  }
  getStatistical(col, index, list2, rawData) {
    const val = col.statistical;
    const item = __spreadValues({
      digits: 2,
      currency: void 0
    }, typeof val === "string" ? {
      type: val
    } : val);
    let res = {
      value: 0
    };
    let currency = false;
    if (typeof item.type === "function") {
      res = item.type(this.getValues(index, list2), col, list2, rawData);
      currency = true;
    } else {
      switch (item.type) {
        case "count":
          res.value = list2.length;
          break;
        case "distinctCount":
          res.value = this.getValues(index, list2).filter((value, idx, self) => self.indexOf(value) === idx).length;
          break;
        case "sum":
          res.value = this.toFixed(this.getSum(index, list2), item.digits);
          currency = true;
          break;
        case "average":
          res.value = this.toFixed(this.getSum(index, list2) / list2.length, item.digits);
          currency = true;
          break;
        case "max":
          res.value = Math.max(...this.getValues(index, list2));
          currency = true;
          break;
        case "min":
          res.value = Math.min(...this.getValues(index, list2));
          currency = true;
          break;
      }
    }
    if (item.currency === true || item.currency == null && currency === true) {
      res.text = this.currencySrv.format(res.value, col.currency?.format);
    } else {
      res.text = String(res.value);
    }
    return res;
  }
  toFixed(val, digits) {
    if (isNaN(val) || !isFinite(val)) {
      return 0;
    }
    return parseFloat(val.toFixed(digits));
  }
  getValues(index, list2) {
    return list2.map((i) => i._values[index].org).map((i) => i === "" || i == null ? 0 : i);
  }
  getSum(index, list2) {
    return this.getValues(index, list2).reduce((p, i) => p += parseFloat(String(i)), 0);
  }
};
_STDataSource.\u0275fac = function STDataSource_Factory(t) {
  return new (t || _STDataSource)(\u0275\u0275inject(_HttpClient), \u0275\u0275inject(DatePipe, 1), \u0275\u0275inject(YNPipe, 1), \u0275\u0275inject(DecimalPipe, 1), \u0275\u0275inject(CurrencyService), \u0275\u0275inject(DomSanitizer));
};
_STDataSource.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _STDataSource,
  factory: _STDataSource.\u0275fac
});
var STDataSource = _STDataSource;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STDataSource, [{
    type: Injectable
  }], () => [{
    type: _HttpClient
  }, {
    type: DatePipe,
    decorators: [{
      type: Host
    }]
  }, {
    type: YNPipe,
    decorators: [{
      type: Host
    }]
  }, {
    type: DecimalPipe,
    decorators: [{
      type: Host
    }]
  }, {
    type: CurrencyService
  }, {
    type: DomSanitizer
  }], null);
})();
var _STExport = class _STExport {
  constructor(xlsxSrv) {
    this.xlsxSrv = xlsxSrv;
  }
  _stGet(item, col, index, colIndex) {
    const ret = {
      t: "s",
      v: ""
    };
    if (col.format) {
      ret.v = col.format(item, col, index);
    } else {
      const val = item._values ? item._values[colIndex].text : deepGet(item, col.index, "");
      ret.v = val;
      if (val != null) {
        switch (col.type) {
          case "currency":
            ret.t = "n";
            break;
          case "date":
            if (`${val}`.length > 0) {
              ret.t = "d";
              ret.z = col.dateFormat;
            }
            break;
          case "yn":
            const yn2 = col.yn;
            ret.v = val === yn2.truth ? yn2.yes : yn2.no;
            break;
        }
      }
    }
    ret.v = ret.v || "";
    return ret;
  }
  genSheet(opt) {
    const sheets = {};
    const sheet = sheets[opt.sheetname || "Sheet1"] = {};
    const dataLen = opt.data.length;
    const columns = opt.columens;
    let validColCount = 0;
    let wpx = false;
    const invalidFn = (col) => col.exported === false || !col.index || !(!col.buttons || col.buttons.length === 0);
    for (const [idx, col] of columns.entries()) {
      if (invalidFn(col))
        continue;
      if (!wpx && col._width != null)
        wpx = true;
      ++validColCount;
      const columnName = this.xlsxSrv.numberToSchema(validColCount);
      sheet[`${columnName}1`] = {
        t: "s",
        v: typeof col.title === "object" ? col.title.text : col.title
      };
      for (let dataIdx = 0; dataIdx < dataLen; dataIdx++) {
        sheet[`${columnName}${dataIdx + 2}`] = this._stGet(opt.data[dataIdx], col, dataIdx, idx);
      }
    }
    if (wpx) {
      sheet["!cols"] = columns.filter((col) => !invalidFn(col)).map((col) => ({
        wpx: col._width
      }));
    }
    if (validColCount > 0 && dataLen > 0) {
      sheet["!ref"] = `A1:${this.xlsxSrv.numberToSchema(validColCount)}${dataLen + 1}`;
    }
    return sheets;
  }
  export(opt) {
    return __async(this, null, function* () {
      const sheets = this.genSheet(opt);
      return this.xlsxSrv.export({
        sheets,
        filename: opt.filename,
        callback: opt.callback
      });
    });
  }
};
_STExport.\u0275fac = function STExport_Factory(t) {
  return new (t || _STExport)(\u0275\u0275inject(XlsxService, 8));
};
_STExport.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _STExport,
  factory: _STExport.\u0275fac
});
var STExport = _STExport;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STExport, [{
    type: Injectable
  }], () => [{
    type: XlsxService,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _STWidgetHostDirective = class _STWidgetHostDirective {
  constructor(stWidgetRegistry, viewContainerRef) {
    this.stWidgetRegistry = stWidgetRegistry;
    this.viewContainerRef = viewContainerRef;
  }
  ngOnInit() {
    const widget = this.column.widget;
    const componentType = this.stWidgetRegistry.get(widget.type);
    this.viewContainerRef.clear();
    const componentRef = this.viewContainerRef.createComponent(componentType);
    const {
      record,
      column
    } = this;
    const data = widget.params ? widget.params({
      record,
      column
    }) : {
      record
    };
    Object.keys(data).forEach((key) => {
      componentRef.instance[key] = data[key];
    });
  }
};
_STWidgetHostDirective.\u0275fac = function STWidgetHostDirective_Factory(t) {
  return new (t || _STWidgetHostDirective)(\u0275\u0275directiveInject(STWidgetRegistry), \u0275\u0275directiveInject(ViewContainerRef));
};
_STWidgetHostDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _STWidgetHostDirective,
  selectors: [["", "st-widget-host", ""]],
  inputs: {
    record: "record",
    column: "column"
  }
});
var STWidgetHostDirective = _STWidgetHostDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STWidgetHostDirective, [{
    type: Directive,
    args: [{
      selector: "[st-widget-host]"
    }]
  }], () => [{
    type: STWidgetRegistry
  }, {
    type: ViewContainerRef
  }], {
    record: [{
      type: Input
    }],
    column: [{
      type: Input
    }]
  });
})();
var ST_DEFAULT_CONFIG = {
  pi: 1,
  ps: 10,
  size: "default",
  responsive: true,
  responsiveHideHeaderFooter: false,
  req: {
    type: "page",
    method: "GET",
    allInBody: false,
    lazyLoad: false,
    ignoreParamNull: false,
    reName: {
      pi: "pi",
      ps: "ps",
      skip: "skip",
      limit: "limit"
    }
  },
  res: {
    reName: {
      list: ["list"],
      total: ["total"]
    }
  },
  page: {
    front: true,
    zeroIndexed: false,
    position: "bottom",
    placement: "right",
    show: true,
    showSize: false,
    pageSizes: [10, 20, 30, 40, 50],
    showQuickJumper: false,
    total: true,
    toTop: true,
    toTopOffset: 100,
    itemRender: null,
    simple: false
  },
  modal: {
    paramsName: "record",
    size: "lg",
    exact: true
  },
  drawer: {
    paramsName: "record",
    size: "md",
    footer: true,
    footerHeight: 55
  },
  pop: {
    title: "\u786E\u8BA4\u5220\u9664\u5417\uFF1F",
    trigger: "click",
    placement: "top"
  },
  btnIcon: {
    theme: "outline",
    spin: false
  },
  noIndex: 1,
  expandRowByClick: false,
  expandAccordion: false,
  widthMode: {
    type: "default",
    strictBehavior: "truncate"
  },
  virtualItemSize: 54,
  virtualMaxBufferPx: 200,
  virtualMinBufferPx: 100,
  iifBehavior: "hide",
  loadingDelay: 0,
  safeType: "safeHtml",
  date: {
    format: `yyyy-MM-dd HH:mm`
  },
  yn: {
    truth: true,
    yes: "\u662F",
    mode: "icon"
  },
  maxMultipleButton: {
    text: "\u66F4\u591A",
    count: 2
  }
};
var _STFilterComponent = class _STFilterComponent {
  get icon() {
    return this.f.icon;
  }
  constructor(cdr) {
    this.cdr = cdr;
    this.visible = false;
    this.locale = {};
    this.n = new EventEmitter();
    this.handle = new EventEmitter();
  }
  stopPropagation($event) {
    $event.stopPropagation();
  }
  checkboxChange() {
    this.n.emit(this.f.menus?.filter((w) => w.checked));
  }
  radioChange(item) {
    this.f.menus.forEach((i) => i.checked = false);
    item.checked = !item.checked;
    this.n.emit(item);
  }
  close(result) {
    if (result != null)
      this.handle.emit(result);
    this.visible = false;
    this.cdr.detectChanges();
  }
  confirm() {
    this.handle.emit(true);
    return this;
  }
  reset() {
    this.handle.emit(false);
    return this;
  }
};
_STFilterComponent.\u0275fac = function STFilterComponent_Factory(t) {
  return new (t || _STFilterComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_STFilterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _STFilterComponent,
  selectors: [["st-filter"]],
  hostVars: 6,
  hostBindings: function STFilterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-table-filter-trigger-container", true)("st__filter", true)("ant-table-filter-trigger-container-open", ctx.visible);
    }
  },
  inputs: {
    col: "col",
    locale: "locale",
    f: "f"
  },
  outputs: {
    n: "n",
    handle: "handle"
  },
  decls: 11,
  vars: 9,
  consts: [["nz-dropdown", "", "nzTrigger", "click", "nzOverlayClassName", "st__filter-wrap", 1, "ant-table-filter-trigger", 3, "nzDropdownMenu", "nzClickHide", "nzVisible", "nzVisibleChange", "click"], ["nz-icon", "", 3, "nzType", "nzTheme"], ["filterMenu", "nzDropdownMenu"], [1, "ant-table-filter-dropdown"], ["class", "ant-table-filter-dropdown-btns"], [1, "st__filter-keyword"], ["type", "text", "nz-input", "", 3, "ngModel", "ngModelChange", "keyup.enter"], [1, "p-sm", "st__filter-number"], [1, "width-100", 3, "ngModel", "nzMin", "nzMax", "nzStep", "nzPrecision", "nzPlaceHolder", "ngModelChange"], [1, "p-sm", "st__filter-date"], ["nzInline", "", 3, "nzMode", "ngModel", "nzShowNow", "nzShowToday", "nzDisabledDate", "nzDisabledTime"], ["nzInline", "", 3, "nzMode", "ngModel", "nzShowNow", "nzShowToday", "nzDisabledDate", "nzDisabledTime", "ngModelChange"], [1, "st__filter-custom"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["nz-menu", ""], ["nz-menu-item", ""], ["nz-checkbox", "", 3, "ngModel"], ["nz-checkbox", "", 3, "ngModel", "ngModelChange"], ["nz-radio", "", 3, "ngModel", "ngModelChange"], [1, "ant-table-filter-dropdown-btns"], [1, "ant-table-filter-dropdown-link", "confirm", 3, "click"], [1, "ant-table-filter-dropdown-link", "clear", 3, "click"]],
  template: function STFilterComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275listener("nzVisibleChange", function STFilterComponent_Template_span_nzVisibleChange_0_listener($event) {
        return ctx.visible = $event;
      })("click", function STFilterComponent_Template_span_click_0_listener($event) {
        return ctx.stopPropagation($event);
      });
      \u0275\u0275element(1, "i", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "nz-dropdown-menu", null, 2)(4, "div", 3);
      \u0275\u0275template(5, STFilterComponent_Case_5_Template, 2, 2)(6, STFilterComponent_Case_6_Template, 2, 6)(7, STFilterComponent_Case_7_Template, 3, 1)(8, STFilterComponent_Case_8_Template, 2, 6)(9, STFilterComponent_Case_9_Template, 3, 0)(10, STFilterComponent_Conditional_10_Template, 7, 2, "div", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      const _r0 = \u0275\u0275reference(3);
      let STFilterComponent_contFlowTmp;
      \u0275\u0275classProp("active", ctx.visible || ctx.f.default);
      \u0275\u0275property("nzDropdownMenu", _r0)("nzClickHide", false)("nzVisible", ctx.visible);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzType", ctx.icon.type)("nzTheme", ctx.icon.theme);
      \u0275\u0275advance(4);
      \u0275\u0275conditional(5, (STFilterComponent_contFlowTmp = ctx.f.type) === "keyword" ? 5 : STFilterComponent_contFlowTmp === "number" ? 6 : STFilterComponent_contFlowTmp === "date" ? 7 : STFilterComponent_contFlowTmp === "custom" ? 8 : 9);
      \u0275\u0275advance(5);
      \u0275\u0275conditional(10, ctx.f.showOPArea ? 10 : -1);
    }
  },
  dependencies: [NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, NzIconDirective, NzCheckboxComponent, NzMenuDirective, NzMenuItemComponent, NzDropDownDirective, NzDropdownMenuComponent, NzRadioComponent, NzInputDirective, NzInputNumberComponent, NzDatePickerComponent, NzRangePickerComponent],
  encapsulation: 2,
  changeDetection: 0
});
var STFilterComponent = _STFilterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STFilterComponent, [{
    type: Component,
    args: [{
      selector: "st-filter",
      template: `
    <span
      class="ant-table-filter-trigger"
      [class.active]="visible || f.default"
      nz-dropdown
      [nzDropdownMenu]="filterMenu"
      nzTrigger="click"
      [nzClickHide]="false"
      [(nzVisible)]="visible"
      nzOverlayClassName="st__filter-wrap"
      (click)="stopPropagation($event)"
    >
      <i nz-icon [nzType]="icon.type" [nzTheme]="icon.theme!"></i>
    </span>
    <nz-dropdown-menu #filterMenu="nzDropdownMenu">
      <div class="ant-table-filter-dropdown">
        @switch (f.type) {
          @case ('keyword') {
            <div class="st__filter-keyword">
              <input
                type="text"
                nz-input
                [attr.placeholder]="f.placeholder"
                [(ngModel)]="f.menus![0]!.value"
                (ngModelChange)="n.emit($event)"
                (keyup.enter)="confirm()"
              />
            </div>
          }
          @case ('number') {
            <div class="p-sm st__filter-number">
              <nz-input-number
                [(ngModel)]="f.menus![0]!.value"
                (ngModelChange)="n.emit($event)"
                [nzMin]="f.number!.min!"
                [nzMax]="f.number!.max!"
                [nzStep]="f.number!.step!"
                [nzPrecision]="f.number!.precision"
                [nzPlaceHolder]="f.placeholder!"
                class="width-100"
              />
            </div>
          }
          @case ('date') {
            <div class="p-sm st__filter-date">
              @if (f.date!.range) {
                <nz-range-picker
                  nzInline
                  [nzMode]="f.date!.mode"
                  [(ngModel)]="f.menus![0]!.value"
                  (ngModelChange)="n.emit($event)"
                  [nzShowNow]="f.date!.showNow"
                  [nzShowToday]="f.date!.showToday"
                  [nzDisabledDate]="f.date!.disabledDate"
                  [nzDisabledTime]="f.date!.disabledTime"
                />
              } @else {
                <nz-date-picker
                  nzInline
                  [nzMode]="f.date!.mode"
                  [(ngModel)]="f.menus![0]!.value"
                  (ngModelChange)="n.emit($event)"
                  [nzShowNow]="f.date!.showNow"
                  [nzShowToday]="f.date!.showToday"
                  [nzDisabledDate]="f.date!.disabledDate"
                  [nzDisabledTime]="f.date!.disabledTime"
                />
              }
            </div>
          }
          @case ('custom') {
            <div class="st__filter-custom">
              <ng-template
                [ngTemplateOutlet]="f.custom!"
                [ngTemplateOutletContext]="{ $implicit: f, col: col, handle: this }"
              />
            </div>
          }
          @default {
            <ul nz-menu>
              @for (filter of f.menus; track $index) {
                <li nz-menu-item>
                  @if (f.multiple) {
                    <label nz-checkbox [(ngModel)]="filter.checked" (ngModelChange)="checkboxChange()">
                      {{ filter.text }}
                    </label>
                  } @else {
                    <label nz-radio [ngModel]="filter.checked" (ngModelChange)="radioChange(filter)">
                      {{ filter.text }}
                    </label>
                  }
                </li>
              }
            </ul>
          }
        }
        @if (f.showOPArea) {
          <div class="ant-table-filter-dropdown-btns">
            <a class="ant-table-filter-dropdown-link confirm" (click)="confirm()">
              <span>{{ f.confirmText || locale.filterConfirm }}</span>
            </a>
            <a class="ant-table-filter-dropdown-link clear" (click)="reset()">
              <span>{{ f.clearText || locale.filterReset }}</span>
            </a>
          </div>
        }
      </div>
    </nz-dropdown-menu>
  `,
      host: {
        "[class.ant-table-filter-trigger-container]": `true`,
        "[class.st__filter]": `true`,
        "[class.ant-table-filter-trigger-container-open]": `visible`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    col: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    f: [{
      type: Input
    }],
    n: [{
      type: Output
    }],
    handle: [{
      type: Output
    }]
  });
})();
var _STComponent = class _STComponent {
  get req() {
    return this._req;
  }
  set req(value) {
    this._req = deepMergeKey({}, true, this.cog.req, value);
  }
  /** 返回体配置 */
  get res() {
    return this._res;
  }
  set res(value) {
    const item = this._res = deepMergeKey({}, true, this.cog.res, value);
    const reName = item.reName;
    if (typeof reName !== "function") {
      if (!Array.isArray(reName.list))
        reName.list = reName.list.split(".");
      if (!Array.isArray(reName.total))
        reName.total = reName.total.split(".");
    }
    this._res = item;
  }
  get page() {
    return this._page;
  }
  set page(value) {
    this._page = __spreadValues(__spreadValues({}, this.cog.page), value);
    this.updateTotalTpl();
  }
  get multiSort() {
    return this._multiSort;
  }
  set multiSort(value) {
    if (typeof value === "boolean" && !toBoolean2(value) || typeof value === "object" && Object.keys(value).length === 0) {
      this._multiSort = void 0;
      return;
    }
    this._multiSort = __spreadValues({}, typeof value === "object" ? value : {});
  }
  set widthMode(value) {
    this._widthMode = __spreadValues(__spreadValues({}, this.cog.widthMode), value);
  }
  get widthMode() {
    return this._widthMode;
  }
  set widthConfig(val) {
    this._widthConfig = val;
    this.customWidthConfig = val && val.length > 0;
  }
  set resizable(val) {
    this._resizable = typeof val === "object" ? val : {
      disabled: !toBoolean2(val)
    };
  }
  /**
   * Get the number of the current page
   */
  get count() {
    return this._data.length;
  }
  /**
   * Get the data of the current page
   */
  get list() {
    return this._data;
  }
  get noColumns() {
    return this.columns == null;
  }
  constructor(i18nSrv, cdr, el, exportSrv, doc, columnSource, dataSource, delonI18n, configSrv, cms) {
    this.cdr = cdr;
    this.el = el;
    this.exportSrv = exportSrv;
    this.doc = doc;
    this.columnSource = columnSource;
    this.dataSource = dataSource;
    this.delonI18n = delonI18n;
    this.cms = cms;
    this.destroy$ = inject(DestroyRef);
    this.totalTpl = ``;
    this.inied = false;
    this.customWidthConfig = false;
    this._widthConfig = [];
    this.locale = {};
    this._loading = false;
    this._data = [];
    this._statistical = {};
    this._isPagination = true;
    this._allChecked = false;
    this._allCheckedDisabled = false;
    this._indeterminate = false;
    this._headers = [];
    this._columns = [];
    this.contextmenuList = [];
    this.ps = 10;
    this.pi = 1;
    this.total = 0;
    this.loading = null;
    this.loadingDelay = 0;
    this.loadingIndicator = null;
    this.bordered = false;
    this.scroll = {
      x: null,
      y: null
    };
    this.showHeader = true;
    this.expandRowByClick = false;
    this.expandAccordion = false;
    this.expand = null;
    this.responsive = true;
    this.error = new EventEmitter();
    this.change = new EventEmitter();
    this.virtualScroll = false;
    this.virtualItemSize = 54;
    this.virtualMaxBufferPx = 200;
    this.virtualMinBufferPx = 100;
    this.virtualForTrackBy = (index) => index;
    this.delonI18n.change.pipe(takeUntilDestroyed()).subscribe(() => {
      this.locale = this.delonI18n.getData("st");
      if (this._columns.length > 0) {
        this.updateTotalTpl();
        this.cd();
      }
    });
    i18nSrv.change.pipe(takeUntilDestroyed(), filter(() => this._columns.length > 0)).subscribe(() => this.refreshColumns());
    this.setCog(configSrv.merge("st", ST_DEFAULT_CONFIG));
  }
  setCog(cog) {
    const copyMultiSort = __spreadValues({}, cog.multiSort);
    delete cog.multiSort;
    this.cog = cog;
    Object.assign(this, cog);
    if (copyMultiSort.global !== false) {
      this.multiSort = copyMultiSort;
    }
    this.columnSource.setCog(cog);
    this.dataSource.setCog(cog);
  }
  cd() {
    this.cdr.detectChanges();
    return this;
  }
  refreshData() {
    this._data = [...this._data];
    return this.cd();
  }
  renderTotal(total2, range) {
    return this.totalTpl ? this.totalTpl.replace("{{total}}", total2).replace("{{range[0]}}", range[0]).replace("{{range[1]}}", range[1]) : "";
  }
  changeEmit(type, data) {
    const res = {
      type,
      pi: this.pi,
      ps: this.ps,
      total: this.total
    };
    if (data != null) {
      res[type] = data;
    }
    this.change.emit(res);
  }
  // #region data
  /**
   * 获取过滤后所有数据
   * - 本地数据：包含排序、过滤后不分页数据
   * - 远程数据：不传递 `pi`、`ps` 两个参数
   */
  get filteredData() {
    return this.loadData({
      paginator: false
    }).pipe(map((res) => res.list));
  }
  updateTotalTpl() {
    const {
      total: total2
    } = this.page;
    if (typeof total2 === "string" && total2.length) {
      this.totalTpl = total2;
    } else if (toBoolean2(total2)) {
      this.totalTpl = this.locale.total;
    } else {
      this.totalTpl = "";
    }
  }
  setLoading(val) {
    if (this.loading == null) {
      this._loading = val;
      this.cdr.detectChanges();
    }
  }
  loadData(options) {
    const {
      pi,
      ps,
      data,
      req,
      res,
      page,
      total: total2,
      singleSort,
      multiSort,
      rowClassName
    } = this;
    return this.dataSource.process(__spreadValues({
      pi,
      ps,
      total: total2,
      data,
      req,
      res,
      page,
      columns: this._columns,
      singleSort,
      multiSort,
      rowClassName,
      paginator: true,
      customRequest: this.customRequest || this.cog.customRequest
    }, options)).pipe(takeUntilDestroyed(this.destroy$));
  }
  loadPageData() {
    this.setLoading(true);
    return this.loadData().pipe(finalize(() => this.setLoading(false)), catchError((error) => {
      this.error.emit({
        type: "req",
        error
      });
      return throwError(() => error);
    }), map((result) => {
      const undefinedString = "undefined";
      if (typeof result.pi !== undefinedString) {
        this.pi = result.pi;
      }
      if (typeof result.ps !== undefinedString) {
        this.ps = result.ps;
      }
      if (typeof result.total !== undefinedString) {
        this.total = result.total;
      }
      if (typeof result.pageShow !== undefinedString) {
        this._isPagination = result.pageShow;
      }
      this._data = result.list ?? [];
      this._statistical = result.statistical;
      if (this.cdkVirtualScrollViewport != null) {
        Promise.resolve().then(() => this.cdkVirtualScrollViewport?.checkViewportSize());
      }
      this._refCheck();
      this.changeEmit("loaded", result.list);
      return this;
    }));
  }
  /** 清空所有数据 */
  clear(cleanStatus = true) {
    if (cleanStatus) {
      this.clearStatus();
    }
    this._data = [];
    return this.cd();
  }
  /** 清空所有状态 */
  clearStatus() {
    return this.clearCheck().clearRadio().clearFilter().clearSort();
  }
  /**
   * 根据页码重新加载数据
   *
   * @param pi 指定当前页码，默认：`1`
   * @param extraParams 重新指定 `extraParams` 值
   * @param options 选项
   */
  load(pi = 1, extraParams, options) {
    if (pi !== -1)
      this.pi = pi;
    if (typeof extraParams !== "undefined") {
      this.req.params = options && options.merge ? __spreadValues(__spreadValues({}, this.req.params), extraParams) : extraParams;
    }
    this._change("pi", options);
    return this;
  }
  /**
   * 重新刷新当前页
   *
   * @param extraParams 重新指定 `extraParams` 值
   */
  reload(extraParams, options) {
    return this.load(-1, extraParams, options);
  }
  /**
   * 重置且重新设置 `pi` 为 `1`，包含以下值：
   * - `check` 数据
   * - `radio` 数据
   * - `sort` 数据
   * - `fileter` 数据
   *
   * @param extraParams 重新指定 `extraParams` 值
   */
  reset(extraParams, options) {
    this.clearStatus().load(1, extraParams, options);
    return this;
  }
  _toTop(enforce) {
    if (!(enforce == null ? this.page.toTop : enforce))
      return;
    const el = this.el.nativeElement;
    el.scrollIntoView();
    this.doc.documentElement.scrollTop -= this.page.toTopOffset;
    if (this.scroll) {
      if (this.cdkVirtualScrollViewport) {
        this.cdkVirtualScrollViewport.scrollTo({
          top: 0,
          left: 0
        });
      } else {
        el.querySelector(".ant-table-body, .ant-table-content")?.scrollTo(0, 0);
      }
    }
  }
  _change(type, options) {
    if (type === "pi" || type === "ps" && this.pi <= Math.ceil(this.total / this.ps)) {
      this.loadPageData().subscribe(() => this._toTop(options?.toTop));
    }
    this.changeEmit(type);
  }
  closeOtherExpand(item) {
    if (this.expandAccordion === false)
      return;
    this._data.filter((i) => i !== item).forEach((i) => i.expand = false);
  }
  _rowClick(e, item, index, dbl) {
    const el = e.target;
    if (el.nodeName === "INPUT")
      return;
    const {
      expand,
      expandRowByClick
    } = this;
    if (!!expand && item.showExpand !== false && expandRowByClick) {
      item.expand = !item.expand;
      this.closeOtherExpand(item);
      this.changeEmit("expand", item);
      return;
    }
    const data = {
      e,
      item,
      index
    };
    if (dbl) {
      this.changeEmit("dblClick", data);
    } else {
      this._clickRowClassName(el, item, index);
      this.changeEmit("click", data);
    }
  }
  _clickRowClassName(el, item, index) {
    const cr = this.clickRowClassName;
    if (cr == null)
      return;
    const config = __spreadValues({
      exclusive: false
    }, typeof cr === "string" ? {
      fn: () => cr
    } : cr);
    const className = config.fn(item, index);
    const trEl = el.closest("tr");
    if (config.exclusive) {
      trEl.parentElement.querySelectorAll("tr").forEach((a) => a.classList.remove(className));
    }
    if (trEl.classList.contains(className)) {
      trEl.classList.remove(className);
    } else {
      trEl.classList.add(className);
    }
  }
  _expandChange(item, expand) {
    item.expand = expand;
    this.closeOtherExpand(item);
    this.changeEmit("expand", item);
  }
  _stopPropagation(ev) {
    ev.stopPropagation();
  }
  _refColAndData() {
    this._columns.forEach((c) => {
      this._data.forEach((i, idx) => {
        const values = i._values;
        if (c.type === "no") {
          const text = `${this.dataSource.getNoIndex(i, c, idx)}`;
          values[c.__point] = {
            text,
            _text: text,
            org: idx,
            safeType: "text"
          };
        }
        values[c.__point].props = this.dataSource.getCell(c, i, idx);
      });
    });
    return this.refreshData();
  }
  /**
   * Add a rows in the table, like this:
   *
   * ```
   * this.st.addRow(stDataItem)
   * ```
   *
   * **TIPS:** Don't change the `total` value, it is recommended to use the `reload` method if needed
   */
  addRow(data, options) {
    if (!Array.isArray(data))
      data = [data];
    this._data.splice(options?.index ?? 0, 0, ...data);
    return this.optimizeData()._refColAndData();
  }
  /**
   * Remove a row in the table, like this:
   *
   * ```
   * this.st.removeRow(0)
   * this.st.removeRow(stDataItem)
   * ```
   *
   * **TIPS:** Don't change the `total` value, it is recommended to use the `reload` method if needed
   */
  removeRow(data) {
    if (typeof data === "number") {
      this._data.splice(data, 1);
    } else {
      if (!Array.isArray(data)) {
        data = [data];
      }
      const curData = this._data;
      for (var i = curData.length; i--; ) {
        if (data.indexOf(curData[i]) !== -1) {
          curData.splice(i, 1);
        }
      }
    }
    return this._refCheck()._refColAndData();
  }
  /**
   * Sets the row value for the `index` in the table, like this:
   *
   * - `optinos.refreshSchema` Whether to refresh of st schemas
   * - `optinos.emitReload` Whether to trigger a reload http request when data is url
   *
   * ```
   * this.st.setRow(0, { price: 100 })
   * this.st.setRow(0, { price: 100, name: 'asdf' })
   * this.st.setRow(item, { price: 100 })
   * ```
   */
  setRow(index, item, options) {
    options = __spreadValues({
      refreshSchema: false,
      emitReload: false
    }, options);
    if (typeof index !== "number") {
      index = this._data.indexOf(index);
    }
    this._data[index] = deepMergeKey(this._data[index], false, item);
    this.optimizeData();
    if (options.refreshSchema) {
      this.resetColumns({
        emitReload: options.emitReload
      });
      return this;
    }
    return this.refreshData();
  }
  // #endregion
  // #region sort
  sort(col, idx, value) {
    if (this.multiSort) {
      col._sort.default = value;
      col._sort.tick = this.dataSource.nextSortTick;
    } else {
      this._columns.forEach((item, index) => item._sort.default = index === idx ? value : null);
    }
    this.cdr.detectChanges();
    this.loadPageData().subscribe(() => {
      const res = {
        value,
        map: this.dataSource.getReqSortMap(this.singleSort, this.multiSort, this._columns),
        column: col
      };
      this.changeEmit("sort", res);
    });
  }
  clearSort() {
    this._columns.forEach((item) => item._sort.default = null);
    return this;
  }
  // #endregion
  // #region filter
  _handleFilter(col, confirm) {
    if (!confirm) {
      this.columnSource.cleanFilter(col);
    }
    this.pi = 1;
    this.columnSource.updateDefault(col.filter);
    this.loadPageData().subscribe(() => this.changeEmit("filter", col));
  }
  handleFilterNotify(value) {
    this.changeEmit("filterChange", value);
  }
  clearFilter() {
    this._columns.filter((w) => w.filter && w.filter.default === true).forEach((col) => this.columnSource.cleanFilter(col));
    return this;
  }
  // #endregion
  // #region checkbox
  /** 清除所有 `checkbox` */
  clearCheck() {
    return this.checkAll(false);
  }
  _refCheck() {
    const validData = this._data.filter((w) => !w.disabled);
    const checkedList = validData.filter((w) => w.checked === true);
    this._allChecked = checkedList.length > 0 && checkedList.length === validData.length;
    const allUnChecked = validData.every((value) => !value.checked);
    this._indeterminate = !this._allChecked && !allUnChecked;
    this._allCheckedDisabled = this._data.length === this._data.filter((w) => w.disabled).length;
    return this.cd();
  }
  checkAll(checked) {
    checked = typeof checked === "undefined" ? this._allChecked : checked;
    this._data.filter((w) => !w.disabled).forEach((i) => i.checked = checked);
    return this._refCheck()._checkNotify().refreshData();
  }
  _rowSelection(row) {
    row.select(this._data);
    return this._refCheck()._checkNotify();
  }
  _checkNotify() {
    const res = this._data.filter((w) => !w.disabled && w.checked === true);
    this.changeEmit("checkbox", res);
    return this;
  }
  // #endregion
  // #region radio
  /** 清除所有 `radio` */
  clearRadio() {
    this._data.filter((w) => w.checked).forEach((item) => item.checked = false);
    this.changeEmit("radio", null);
    return this.refreshData();
  }
  // #endregion
  _handleTd(ev) {
    switch (ev.type) {
      case "checkbox":
        this._refCheck()._checkNotify();
        break;
      case "radio":
        this.changeEmit("radio", ev.item);
        this.refreshData();
        break;
    }
  }
  // #region export
  /**
   * 导出当前页，确保已经注册 `XlsxModule`
   *
   * @param newData 重新指定数据；若为 `true` 表示使用 `filteredData` 数据
   * @param opt 额外参数
   */
  export(newData, opt) {
    const data = Array.isArray(newData) ? this.dataSource.optimizeData({
      columns: this._columns,
      result: newData
    }) : this._data;
    (newData === true ? this.filteredData : of(data)).subscribe((res) => this.exportSrv.export(__spreadProps(__spreadValues({
      columens: this._columns
    }, opt), {
      data: res
    })));
  }
  // #endregion
  // #region resizable
  colResize({
    width
  }, column) {
    column.width = `${width}px`;
    this.changeEmit("resize", column);
  }
  // #endregion
  // #region contextmenu
  onContextmenu(event) {
    if (!this.contextmenu) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    const colEl = event.target.closest("[data-col-index]");
    if (!colEl) {
      return;
    }
    const colIndex = Number(colEl.dataset.colIndex);
    const rowIndex = Number(colEl.closest("tr").dataset.index);
    const isTitle = isNaN(rowIndex);
    const obs$ = this.contextmenu({
      event,
      type: isTitle ? "head" : "body",
      rowIndex: isTitle ? null : rowIndex,
      colIndex,
      data: isTitle ? null : this.list[rowIndex],
      column: this._columns[colIndex]
    });
    (isObservable(obs$) ? obs$ : of(obs$)).pipe(takeUntilDestroyed(this.destroy$), filter((res) => res.length > 0)).subscribe((res) => {
      this.contextmenuList = res.map((i) => {
        if (!Array.isArray(i.children)) {
          i.children = [];
        }
        return i;
      });
      this.cdr.detectChanges();
      this.cms.create(event, this.contextmenuTpl);
    });
  }
  // #endregion
  get cdkVirtualScrollViewport() {
    return this.orgTable?.cdkVirtualScrollViewport;
  }
  _resetColumns(options) {
    options = __spreadValues({
      emitReload: true,
      preClearData: false
    }, options);
    if (typeof options.columns !== "undefined") {
      this.columns = options.columns;
    }
    if (typeof options.pi !== "undefined") {
      this.pi = options.pi;
    }
    if (typeof options.ps !== "undefined") {
      this.ps = options.ps;
    }
    if (options.emitReload) {
      options.preClearData = true;
    }
    if (options.preClearData) {
      this._data = [];
    }
    this.refreshColumns();
    if (options.emitReload) {
      return this.loadPageData();
    } else {
      this.cd();
      return of(this);
    }
  }
  resetColumns(options) {
    return lastValueFrom(this._resetColumns(options));
  }
  refreshColumns() {
    const res = this.columnSource.process(this.columns, {
      widthMode: this.widthMode,
      resizable: this._resizable,
      safeType: this.cog.safeType
    });
    this._columns = res.columns;
    this._headers = res.headers;
    if (this.customWidthConfig === false && res.headerWidths != null) {
      this._widthConfig = res.headerWidths;
    }
    return this;
  }
  optimizeData() {
    this._data = this.dataSource.optimizeData({
      columns: this._columns,
      result: this._data,
      rowClassName: this.rowClassName
    });
    return this;
  }
  /**
   * Return pure data, `st` internally maintains a set of data for caching, this part of data may affect the backend
   *
   * 返回纯净数据，`st` 内部会维护一组用于缓存的数据，这部分数据可能会影响后端
   */
  pureItem(itemOrIndex) {
    if (typeof itemOrIndex === "number") {
      itemOrIndex = this._data[itemOrIndex];
    }
    if (!itemOrIndex) {
      return null;
    }
    const copyItem = deepCopy(itemOrIndex);
    ["_values", "_rowClassName"].forEach((key) => delete copyItem[key]);
    return copyItem;
  }
  ngAfterViewInit() {
    this.refreshColumns();
    if (!this.req.lazyLoad)
      this.loadPageData().subscribe();
    this.inied = true;
  }
  ngOnChanges(changes) {
    if (changes.loading) {
      this._loading = changes.loading.currentValue;
    }
    if (!this.inied)
      return;
    if (changes.columns) {
      this.refreshColumns().optimizeData();
    }
    if (changes.data) {
      this.loadPageData().subscribe();
    }
  }
};
_STComponent.\u0275fac = function STComponent_Factory(t) {
  return new (t || _STComponent)(\u0275\u0275directiveInject(ALAIN_I18N_TOKEN, 8), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(STExport), \u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(STColumnSource), \u0275\u0275directiveInject(STDataSource), \u0275\u0275directiveInject(DelonLocaleService), \u0275\u0275directiveInject(AlainConfigService), \u0275\u0275directiveInject(NzContextMenuService));
};
_STComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _STComponent,
  selectors: [["st"]],
  viewQuery: function STComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c115, 5);
      \u0275\u0275viewQuery(_c212, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.orgTable = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contextmenuTpl = _t.first);
    }
  },
  hostVars: 14,
  hostBindings: function STComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("st", true)("st__p-left", ctx.page.placement === "left")("st__p-center", ctx.page.placement === "center")("st__width-strict", ctx.widthMode.type === "strict")("st__row-class", ctx.rowClassName)("ant-table-rep", ctx.responsive)("ant-table-rep__hide-header-footer", ctx.responsiveHideHeaderFooter);
    }
  },
  inputs: {
    req: "req",
    res: "res",
    page: "page",
    data: "data",
    columns: "columns",
    contextmenu: "contextmenu",
    ps: "ps",
    pi: "pi",
    total: "total",
    loading: "loading",
    loadingDelay: "loadingDelay",
    loadingIndicator: "loadingIndicator",
    bordered: "bordered",
    size: "size",
    scroll: "scroll",
    singleSort: "singleSort",
    multiSort: "multiSort",
    rowClassName: "rowClassName",
    clickRowClassName: "clickRowClassName",
    widthMode: "widthMode",
    widthConfig: "widthConfig",
    resizable: "resizable",
    header: "header",
    showHeader: "showHeader",
    footer: "footer",
    bodyHeader: "bodyHeader",
    body: "body",
    expandRowByClick: "expandRowByClick",
    expandAccordion: "expandAccordion",
    expand: "expand",
    noResult: "noResult",
    responsive: "responsive",
    responsiveHideHeaderFooter: "responsiveHideHeaderFooter",
    virtualScroll: "virtualScroll",
    virtualItemSize: "virtualItemSize",
    virtualMaxBufferPx: "virtualMaxBufferPx",
    virtualMinBufferPx: "virtualMinBufferPx",
    customRequest: "customRequest",
    virtualForTrackBy: "virtualForTrackBy"
  },
  outputs: {
    error: "error",
    change: "change"
  },
  exportAs: ["st"],
  features: [\u0275\u0275ProvidersFeature([STDataSource, STRowSource, STColumnSource, STExport, DatePipe, YNPipe, DecimalPipe]), \u0275\u0275NgOnChangesFeature],
  decls: 21,
  vars: 34,
  consts: [["titleTpl", ""], ["chkAllTpl", ""], [3, "nzData", "nzPageIndex", "nzPageSize", "nzTotal", "nzShowPagination", "nzFrontPagination", "nzBordered", "nzSize", "nzLoading", "nzLoadingDelay", "nzLoadingIndicator", "nzTitle", "nzFooter", "nzScroll", "nzVirtualItemSize", "nzVirtualMaxBufferPx", "nzVirtualMinBufferPx", "nzVirtualForTrackBy", "nzNoResult", "nzPageSizeOptions", "nzShowQuickJumper", "nzShowSizeChanger", "nzPaginationPosition", "nzPaginationType", "nzItemRender", "nzSimple", "nzShowTotal", "nzWidthConfig", "nzPageIndexChange", "nzPageSizeChange", "contextmenu"], ["table", ""], [1, "st__body"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["bodyTpl", ""], ["nz-virtual-scroll", ""], ["totalTpl", ""], ["contextmenuTpl", "nzDropdownMenu"], ["nz-menu", "", 1, "st__contextmenu"], [3, "innerHTML"], ["class", "st__head-optional", 3, "innerHTML"], ["class", "st__head-tip", "nz-tooltip", "", "nz-icon", "", "nzType", "question-circle", 3, "nzTooltipTitle"], [1, "st__head-optional", 3, "innerHTML"], ["nz-tooltip", "", "nz-icon", "", "nzType", "question-circle", 1, "st__head-tip", 3, "nzTooltipTitle"], ["nz-checkbox", "", 1, "st__checkall", 3, "nzDisabled", "ngModel", "nzIndeterminate", "ngModelChange"], ["nzWidth", "50px", 3, "rowSpan"], ["nz-resizable", "", 3, "colSpan", "rowSpan", "nzWidth", "nzLeft", "nzRight", "ngClass", "nzShowSort", "nzSortOrder", "nzCustomFilter", "st__has-filter", "nzDisabled", "nzMaxWidth", "nzMinWidth", "nzBounds", "nzPreview", "nzSortOrderChange", "nzResizeEnd", 4, "let"], ["nz-resizable", "", 3, "colSpan", "rowSpan", "nzWidth", "nzLeft", "nzRight", "ngClass", "nzShowSort", "nzSortOrder", "nzCustomFilter", "nzDisabled", "nzMaxWidth", "nzMinWidth", "nzBounds", "nzPreview", "nzSortOrderChange", "nzResizeEnd"], ["nzDirection", "right"], ["nz-th-extra", "", 3, "col", "f", "locale"], [1, "ant-table-selection"], ["class", "ant-table-selection-extra"], ["selectionMenu", "nzDropdownMenu"], ["nz-menu", "", 1, "ant-table-selection-menu"], [1, "ant-table-selection-extra"], ["nz-dropdown", "", "nzPlacement", "bottomLeft", 1, "ant-table-selection-down", "st__checkall-selection", 3, "nzDropdownMenu"], ["nz-icon", "", "nzType", "down"], ["nz-menu-item", "", 3, "innerHTML", "click"], ["nz-menu-item", "", 3, "innerHTML"], ["nz-th-extra", "", 3, "col", "f", "locale", "n", "handle"], ["nz-resizable", "", 3, "colSpan", "rowSpan", "nzWidth", "nzLeft", "nzRight", "ngClass", "nzShowSort", "nzSortOrder", "nzCustomFilter", "st__has-filter", "nzDisabled", "nzMaxWidth", "nzMinWidth", "nzBounds", "nzPreview"], [3, "ngClass", "click", "dblclick"], ["nzWidth", "50px", 3, "nzShowExpand", "nzExpand"], [3, "nzExpand"], ["nzWidth", "50px", 3, "nzShowExpand", "nzExpand", "nzExpandChange", "click"], [3, "nzLeft", "nzRight", "ngClass"], ["class", "ant-table-rep__title"], [3, "data", "i", "index", "c", "cIdx", "n"], [1, "ant-table-rep__title"], ["nz-submenu", "", 3, "nzTitle"]],
  template: function STComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, STComponent_ng_template_0_Template, 3, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, STComponent_ng_template_2_Template, 1, 5, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(4, "nz-table", 2, 3);
      \u0275\u0275listener("nzPageIndexChange", function STComponent_Template_nz_table_nzPageIndexChange_4_listener($event) {
        return ctx.pi = $event;
      })("nzPageIndexChange", function STComponent_Template_nz_table_nzPageIndexChange_4_listener() {
        return ctx._change("pi");
      })("nzPageSizeChange", function STComponent_Template_nz_table_nzPageSizeChange_4_listener($event) {
        return ctx.ps = $event;
      })("nzPageSizeChange", function STComponent_Template_nz_table_nzPageSizeChange_4_listener() {
        return ctx._change("ps");
      })("contextmenu", function STComponent_Template_nz_table_contextmenu_4_listener($event) {
        return ctx.onContextmenu($event);
      });
      \u0275\u0275template(6, STComponent_Conditional_6_Template, 3, 0, "thead");
      \u0275\u0275elementStart(7, "tbody", 4);
      \u0275\u0275template(8, STComponent_Conditional_8_Template, 1, 4, null, 5)(9, STComponent_ng_template_9_Template, 6, 9, "ng-template", null, 6, \u0275\u0275templateRefExtractor)(11, STComponent_Conditional_11_Template, 1, 0, null, 7)(12, STComponent_Conditional_12_Template, 2, 0)(13, STComponent_Conditional_13_Template, 1, 4, null, 5);
      \u0275\u0275elementEnd();
      \u0275\u0275template(14, STComponent_ng_template_14_Template, 1, 1, "ng-template", null, 8, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(16, "nz-dropdown-menu", null, 9)(18, "ul", 10);
      \u0275\u0275repeaterCreate(19, STComponent_For_20_Template, 2, 1, null, null, \u0275\u0275repeaterTrackByIndex);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      const _r13 = \u0275\u0275reference(15);
      \u0275\u0275advance(4);
      \u0275\u0275classProp("st__no-column", ctx.noColumns);
      \u0275\u0275property("nzData", ctx._data)("nzPageIndex", ctx.pi)("nzPageSize", ctx.ps)("nzTotal", ctx.total)("nzShowPagination", ctx._isPagination)("nzFrontPagination", false)("nzBordered", ctx.bordered)("nzSize", ctx.size)("nzLoading", ctx.noColumns || ctx._loading)("nzLoadingDelay", ctx.loadingDelay)("nzLoadingIndicator", ctx.loadingIndicator)("nzTitle", ctx.header)("nzFooter", ctx.footer)("nzScroll", ctx.scroll)("nzVirtualItemSize", ctx.virtualItemSize)("nzVirtualMaxBufferPx", ctx.virtualMaxBufferPx)("nzVirtualMinBufferPx", ctx.virtualMinBufferPx)("nzVirtualForTrackBy", ctx.virtualForTrackBy)("nzNoResult", ctx.noResult)("nzPageSizeOptions", ctx.page.pageSizes)("nzShowQuickJumper", ctx.page.showQuickJumper)("nzShowSizeChanger", ctx.page.showSize)("nzPaginationPosition", ctx.page.position)("nzPaginationType", ctx.page.type)("nzItemRender", ctx.page.itemRender)("nzSimple", ctx.page.simple)("nzShowTotal", _r13)("nzWidthConfig", ctx._widthConfig);
      \u0275\u0275advance(2);
      \u0275\u0275conditional(6, ctx.showHeader ? 6 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275conditional(8, !ctx._loading ? 8 : -1);
      \u0275\u0275advance(3);
      \u0275\u0275conditional(11, ctx.virtualScroll ? 11 : 12);
      \u0275\u0275advance(2);
      \u0275\u0275conditional(13, !ctx._loading ? 13 : -1);
      \u0275\u0275advance(6);
      \u0275\u0275repeater(ctx.contextmenuList);
    }
  },
  dependencies: () => [NgClass, NgTemplateOutlet, NgControlStatus, NgModel, LetDirective, NzTableComponent, NzThAddOnComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzTableVirtualScrollDirective, NzCellFixedDirective, NzTrExpandDirective, NzTableFixedRowComponent, NzIconDirective, NzCheckboxComponent, NzMenuDirective, NzMenuItemComponent, NzSubMenuComponent, NzDropDownDirective, NzDropdownMenuComponent, NzTooltipDirective, NzResizableDirective, NzResizeHandleComponent, STFilterComponent, STTdComponent],
  encapsulation: 2,
  changeDetection: 0
});
var STComponent = _STComponent;
__decorate([InputNumber2()], STComponent.prototype, "ps", void 0);
__decorate([InputNumber2()], STComponent.prototype, "pi", void 0);
__decorate([InputNumber2()], STComponent.prototype, "total", void 0);
__decorate([InputNumber2()], STComponent.prototype, "loadingDelay", void 0);
__decorate([InputBoolean2()], STComponent.prototype, "bordered", void 0);
__decorate([InputBoolean2()], STComponent.prototype, "showHeader", void 0);
__decorate([InputBoolean2()], STComponent.prototype, "expandRowByClick", void 0);
__decorate([InputBoolean2()], STComponent.prototype, "expandAccordion", void 0);
__decorate([InputBoolean2()], STComponent.prototype, "responsive", void 0);
__decorate([InputBoolean2()], STComponent.prototype, "responsiveHideHeaderFooter", void 0);
__decorate([InputBoolean2()], STComponent.prototype, "virtualScroll", void 0);
__decorate([InputNumber2()], STComponent.prototype, "virtualItemSize", void 0);
__decorate([InputNumber2()], STComponent.prototype, "virtualMaxBufferPx", void 0);
__decorate([InputNumber2()], STComponent.prototype, "virtualMinBufferPx", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STComponent, [{
    type: Component,
    args: [{
      selector: "st",
      exportAs: "st",
      providers: [STDataSource, STRowSource, STColumnSource, STExport, DatePipe, YNPipe, DecimalPipe],
      host: {
        "[class.st]": `true`,
        "[class.st__p-left]": `page.placement === 'left'`,
        "[class.st__p-center]": `page.placement === 'center'`,
        "[class.st__width-strict]": `widthMode.type === 'strict'`,
        "[class.st__row-class]": `rowClassName`,
        "[class.ant-table-rep]": `responsive`,
        "[class.ant-table-rep__hide-header-footer]": `responsiveHideHeaderFooter`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<ng-template #titleTpl let-i>
  <span [innerHTML]="i._text"></span>
  @if (i.optional) {
    <small class="st__head-optional" [innerHTML]="i.optional"></small>
  }
  @if (i.optionalHelp) {
    <i class="st__head-tip" nz-tooltip [nzTooltipTitle]="i.optionalHelp" nz-icon nzType="question-circle"></i>
  }
</ng-template>
<ng-template #chkAllTpl let-custom>
  <label
    nz-checkbox
    class="st__checkall"
    [nzDisabled]="_allCheckedDisabled"
    [(ngModel)]="_allChecked"
    [nzIndeterminate]="_indeterminate"
    (ngModelChange)="checkAll()"
    [class.ant-table-selection-select-all-custom]="custom"
  ></label>
</ng-template>
<nz-table
  #table
  [nzData]="_data"
  [(nzPageIndex)]="pi"
  (nzPageIndexChange)="_change('pi')"
  [(nzPageSize)]="ps"
  (nzPageSizeChange)="_change('ps')"
  [nzTotal]="total"
  [nzShowPagination]="_isPagination"
  [nzFrontPagination]="false"
  [nzBordered]="bordered"
  [nzSize]="size"
  [nzLoading]="noColumns || _loading"
  [nzLoadingDelay]="loadingDelay"
  [nzLoadingIndicator]="loadingIndicator"
  [nzTitle]="header!"
  [nzFooter]="footer!"
  [nzScroll]="scroll"
  [nzVirtualItemSize]="virtualItemSize"
  [nzVirtualMaxBufferPx]="virtualMaxBufferPx"
  [nzVirtualMinBufferPx]="virtualMinBufferPx"
  [nzVirtualForTrackBy]="virtualForTrackBy"
  [nzNoResult]="noResult!"
  [nzPageSizeOptions]="page.pageSizes!"
  [nzShowQuickJumper]="page.showQuickJumper"
  [nzShowSizeChanger]="page.showSize"
  [nzPaginationPosition]="page.position!"
  [nzPaginationType]="page.type!"
  [nzItemRender]="page.itemRender!"
  [nzSimple]="page.simple"
  [nzShowTotal]="totalTpl"
  [nzWidthConfig]="_widthConfig"
  (contextmenu)="onContextmenu($event)"
  [class.st__no-column]="noColumns"
>
  @if (showHeader) {
    <thead>
      @for (row of _headers; track $index) {
        <tr>
          @if ($first && expand) {
            <th nzWidth="50px" [rowSpan]="_headers.length"></th>
          }
          @for (h of row; track index; let index = $index; let last = $last) {
            <th
              *let="h.column as _c"
              [colSpan]="h.colSpan"
              [rowSpan]="h.rowSpan"
              [nzWidth]="$any(_c).width"
              [nzLeft]="_c._left!"
              [nzRight]="_c._right!"
              [ngClass]="_c._className"
              [attr.data-col]="_c.indexKey"
              [attr.data-col-index]="index"
              [nzShowSort]="_c._sort.enabled"
              [nzSortOrder]="$any(_c)._sort.default"
              (nzSortOrderChange)="sort(_c, index, $event)"
              [nzCustomFilter]="!!_c.filter"
              [class.st__has-filter]="_c.filter"
              nz-resizable
              [nzDisabled]="last || $any(_c).resizable.disabled"
              [nzMaxWidth]="$any(_c).resizable.maxWidth"
              [nzMinWidth]="$any(_c).resizable.minWidth"
              [nzBounds]="$any(_c).resizable.bounds"
              [nzPreview]="$any(_c).resizable.preview"
              (nzResizeEnd)="colResize($event, _c)"
            >
              @if ($any(!last && !$any(_c).resizable.disabled)) {
                <nz-resize-handle nzDirection="right">
                  <i></i>
                </nz-resize-handle>
              }
              @if (_c.__renderTitle) {
                <ng-template
                  [ngTemplateOutlet]="_c.__renderTitle!"
                  [ngTemplateOutletContext]="{ $implicit: h.column, index: index }"
                />
              } @else {
                @switch (_c.type) {
                  @case ('checkbox') {
                    @if (_c.selections!.length === 0) {
                      <ng-template [ngTemplateOutlet]="chkAllTpl" [ngTemplateOutletContext]="{ $implicit: false }" />
                    } @else {
                      <div class="ant-table-selection">
                        <ng-template [ngTemplateOutlet]="chkAllTpl" [ngTemplateOutletContext]="{ $implicit: true }" />
                        @if (_c.selections!.length) {
                          <div class="ant-table-selection-extra">
                            <div
                              nz-dropdown
                              nzPlacement="bottomLeft"
                              [nzDropdownMenu]="selectionMenu"
                              class="ant-table-selection-down st__checkall-selection"
                            >
                              <i nz-icon nzType="down"></i>
                            </div>
                          </div>
                        }
                        <nz-dropdown-menu #selectionMenu="nzDropdownMenu">
                          <ul nz-menu class="ant-table-selection-menu">
                            @for (rw of _c.selections; track $index) {
                              <li nz-menu-item (click)="_rowSelection(rw)" [innerHTML]="rw.text"></li>
                            }
                          </ul>
                        </nz-dropdown-menu>
                      </div>
                    }
                  }
                  @default {
                    <ng-template [ngTemplateOutlet]="titleTpl" [ngTemplateOutletContext]="{ $implicit: _c.title }" />
                  }
                }
              }
              @if (_c.filter) {
                <st-filter
                  nz-th-extra
                  [col]="h.column"
                  [f]="_c.filter"
                  [locale]="locale"
                  (n)="handleFilterNotify($event)"
                  (handle)="_handleFilter(_c, $event)"
                />
              }
            </th>
          }
        </tr>
      }
    </thead>
  }
  <tbody class="st__body">
    @if (!_loading) {
      <ng-template [ngTemplateOutlet]="bodyHeader!" [ngTemplateOutletContext]="{ $implicit: _statistical }" />
    }
    <ng-template #bodyTpl let-i let-index="index">
      <tr
        [attr.data-index]="index"
        (click)="_rowClick($event, i, index, false)"
        (dblclick)="_rowClick($event, i, index, true)"
        [ngClass]="i._rowClassName"
      >
        @if (expand) {
          <td
            [nzShowExpand]="expand && i.showExpand !== false"
            [nzExpand]="i.expand"
            (nzExpandChange)="_expandChange(i, $event)"
            (click)="_stopPropagation($event)"
            nzWidth="50px"
          ></td>
        }
        @for (c of _columns; track cIdx; let cIdx = $index) {
          @if (i._values[cIdx].props?.colSpan > 0 && i._values[cIdx].props?.rowSpan > 0) {
            <td
              [nzLeft]="!!c._left"
              [nzRight]="!!c._right"
              [attr.data-col-index]="cIdx"
              [ngClass]="c._className"
              [attr.colspan]="i._values[cIdx].props?.colSpan === 1 ? null : i._values[cIdx].props?.colSpan"
              [attr.rowspan]="i._values[cIdx].props?.rowSpan === 1 ? null : i._values[cIdx].props?.rowSpan"
            >
              @if (responsive) {
                <span class="ant-table-rep__title">
                  <ng-template [ngTemplateOutlet]="titleTpl" [ngTemplateOutletContext]="{ $implicit: c.title }" />
                </span>
              }
              <st-td [data]="_data" [i]="i" [index]="index" [c]="c" [cIdx]="cIdx" (n)="_handleTd($event)" />
            </td>
          }
        }
      </tr>
      <tr [nzExpand]="i.expand">
        <ng-template [ngTemplateOutlet]="expand" [ngTemplateOutletContext]="{ $implicit: i, index: index }" />
      </tr>
    </ng-template>
    @if (virtualScroll) {
      <ng-template nz-virtual-scroll let-i let-index="index">
        <ng-template [ngTemplateOutlet]="bodyTpl" [ngTemplateOutletContext]="{ $implicit: i, index: index }" />
      </ng-template>
    } @else {
      @for (i of _data; track $index) {
        <ng-template [ngTemplateOutlet]="bodyTpl" [ngTemplateOutletContext]="{ $implicit: i, index: $index }" />
      }
    }
    @if (!_loading) {
      <ng-template [ngTemplateOutlet]="body!" [ngTemplateOutletContext]="{ $implicit: _statistical }" />
    }
  </tbody>
  <ng-template #totalTpl let-range="range" let-total>{{ renderTotal(total, range) }}</ng-template>
</nz-table>
<nz-dropdown-menu #contextmenuTpl="nzDropdownMenu">
  <ul nz-menu class="st__contextmenu">
    @for (i of contextmenuList; track $index) {
      @if (i.children!.length === 0) {
        <li nz-menu-item (click)="i.fn!(i)" [innerHTML]="i.text"></li>
      } @else {
        <li nz-submenu [nzTitle]="i.text">
          <ul>
            @for (ci of i.children; track $index) {
              <li nz-menu-item (click)="ci.fn!(ci)" [innerHTML]="ci.text"></li>
            }
          </ul>
        </li>
      }
    }
  </ul>
</nz-dropdown-menu>
`
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ALAIN_I18N_TOKEN]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: STExport
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: STColumnSource
  }, {
    type: STDataSource
  }, {
    type: DelonLocaleService
  }, {
    type: AlainConfigService
  }, {
    type: NzContextMenuService
  }], {
    orgTable: [{
      type: ViewChild,
      args: ["table"]
    }],
    contextmenuTpl: [{
      type: ViewChild,
      args: ["contextmenuTpl"]
    }],
    req: [{
      type: Input
    }],
    res: [{
      type: Input
    }],
    page: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    contextmenu: [{
      type: Input
    }],
    ps: [{
      type: Input
    }],
    pi: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    loadingDelay: [{
      type: Input
    }],
    loadingIndicator: [{
      type: Input
    }],
    bordered: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    scroll: [{
      type: Input
    }],
    singleSort: [{
      type: Input
    }],
    multiSort: [{
      type: Input
    }],
    rowClassName: [{
      type: Input
    }],
    clickRowClassName: [{
      type: Input
    }],
    widthMode: [{
      type: Input
    }],
    widthConfig: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    header: [{
      type: Input
    }],
    showHeader: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    bodyHeader: [{
      type: Input
    }],
    body: [{
      type: Input
    }],
    expandRowByClick: [{
      type: Input
    }],
    expandAccordion: [{
      type: Input
    }],
    expand: [{
      type: Input
    }],
    noResult: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    responsiveHideHeaderFooter: [{
      type: Input
    }],
    error: [{
      type: Output
    }],
    change: [{
      type: Output
    }],
    virtualScroll: [{
      type: Input
    }],
    virtualItemSize: [{
      type: Input
    }],
    virtualMaxBufferPx: [{
      type: Input
    }],
    virtualMinBufferPx: [{
      type: Input
    }],
    customRequest: [{
      type: Input
    }],
    virtualForTrackBy: [{
      type: Input
    }]
  });
})();
var _STTdComponent = class _STTdComponent {
  get routerState() {
    const {
      pi,
      ps,
      total: total2
    } = this.stComp;
    return {
      pi,
      ps,
      total: total2
    };
  }
  constructor(stComp, router, modalHelper, drawerHelper) {
    this.stComp = stComp;
    this.router = router;
    this.modalHelper = modalHelper;
    this.drawerHelper = drawerHelper;
    this.n = new EventEmitter();
  }
  report(type) {
    this.n.emit({
      type,
      item: this.i,
      col: this.c
    });
  }
  _checkbox(value) {
    this.i.checked = value;
    this.report("checkbox");
  }
  _radio() {
    this.data.filter((w) => !w.disabled).forEach((i) => i.checked = false);
    this.i.checked = true;
    this.report("radio");
  }
  _link(e) {
    this._stopPropagation(e);
    const res = this.c.click(this.i, this.stComp);
    if (typeof res === "string") {
      this.router.navigateByUrl(res, {
        state: this.routerState
      });
    }
    return false;
  }
  _stopPropagation(ev) {
    ev.preventDefault();
    ev.stopPropagation();
  }
  _btn(btn, ev) {
    ev?.stopPropagation();
    const cog = this.stComp.cog;
    let record = this.i;
    if (btn.type === "modal" || btn.type === "static") {
      if (cog.modal.pureRecoard === true) {
        record = this.stComp.pureItem(record);
      }
      const modal = btn.modal;
      const obj = {
        [modal.paramsName]: record
      };
      this.modalHelper[btn.type === "modal" ? "create" : "createStatic"](modal.component, __spreadValues(__spreadValues({}, obj), modal.params && modal.params(record)), deepMergeKey({}, true, cog.modal, modal)).pipe(filter((w) => typeof w !== "undefined")).subscribe((res) => this.btnCallback(record, btn, res));
      return;
    } else if (btn.type === "drawer") {
      if (cog.drawer.pureRecoard === true) {
        record = this.stComp.pureItem(record);
      }
      const drawer = btn.drawer;
      const obj = {
        [drawer.paramsName]: record
      };
      this.drawerHelper.create(drawer.title, drawer.component, __spreadValues(__spreadValues({}, obj), drawer.params && drawer.params(record)), deepMergeKey({}, true, cog.drawer, drawer)).pipe(filter((w) => typeof w !== "undefined")).subscribe((res) => this.btnCallback(record, btn, res));
      return;
    } else if (btn.type === "link") {
      const clickRes = this.btnCallback(record, btn);
      if (typeof clickRes === "string") {
        this.router.navigateByUrl(clickRes, {
          state: this.routerState
        });
      }
      return;
    }
    this.btnCallback(record, btn);
  }
  btnCallback(record, btn, modal) {
    if (!btn.click)
      return;
    if (typeof btn.click === "string") {
      switch (btn.click) {
        case "load":
          this.stComp.load();
          break;
        case "reload":
          this.stComp.reload();
          break;
      }
    } else {
      return btn.click(record, modal, this.stComp);
    }
  }
};
_STTdComponent.\u0275fac = function STTdComponent_Factory(t) {
  return new (t || _STTdComponent)(\u0275\u0275directiveInject(STComponent, 1), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ModalHelper), \u0275\u0275directiveInject(DrawerHelper));
};
_STTdComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _STTdComponent,
  selectors: [["st-td"]],
  inputs: {
    c: "c",
    cIdx: "cIdx",
    data: "data",
    i: "i",
    index: "index"
  },
  outputs: {
    n: "n"
  },
  decls: 8,
  vars: 1,
  consts: [["btnTpl", ""], ["btnItemTpl", ""], ["btnTextTpl", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["nz-tooltip", "", 3, "nzTooltipTitle", "d-block", "width-100"], ["nz-tooltip", "", 3, "nzTooltipTitle"], ["nz-popconfirm", "", "class", "st__btn-text", 3, "nzPopconfirmTitle", "nzIcon", "nzCondition", "nzCancelText", "nzOkText", "nzOkType", "ngClass"], ["nz-popconfirm", "", 1, "st__btn-text", 3, "nzPopconfirmTitle", "nzIcon", "nzCondition", "nzCancelText", "nzOkText", "nzOkType", "ngClass", "nzOnConfirm", "click"], [1, "st__btn-text", 3, "ngClass", "click"], [3, "innerHTML", "ngClass"], ["nz-icon", "", 3, "nzIconfont"], ["nz-icon", "", 3, "nzType", "nzTheme", "nzSpin", "nzTwotoneColor"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel", "ngModelChange"], ["nz-radio", "", 3, "nzDisabled", "ngModel", "ngModelChange"], [3, "innerHTML", "click"], [3, "nzColor", "nz-tooltip"], [3, "innerHTML"], [3, "nzStatus", "nzText", "nz-tooltip"], [3, "value", "options"], ["st-widget-host", "", 3, "record", "column"], [3, "innerText"], ["nzType", "vertical"], ["nz-dropdown", "", "nzOverlayClassName", "st__btn-sub", 3, "nzDropdownMenu"], ["nz-icon", "", "nzType", "down"], ["btnMenu", "nzDropdownMenu"], ["nz-menu", ""], ["nz-menu-divider", ""], ["nz-menu-item", ""]],
  template: function STTdComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, STTdComponent_ng_template_0_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, STTdComponent_ng_template_2_Template, 2, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(4, STTdComponent_ng_template_4_Template, 2, 5, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(6, STTdComponent_Conditional_6_Template, 1, 6, null, 3)(7, STTdComponent_Conditional_7_Template, 10, 1);
    }
    if (rf & 2) {
      \u0275\u0275advance(6);
      \u0275\u0275conditional(6, ctx.c.__render ? 6 : 7);
    }
  },
  dependencies: [NgClass, NgTemplateOutlet, NgControlStatus, NgModel, CellComponent, NzPopconfirmDirective, NzIconDirective, NzBadgeComponent, NzCheckboxComponent, NzDividerComponent, NzMenuDirective, NzMenuItemComponent, NzMenuDividerDirective, NzDropDownDirective, NzDropDownADirective, NzDropdownMenuComponent, NzRadioComponent, NzTagComponent, NzTooltipDirective, STWidgetHostDirective],
  encapsulation: 2,
  changeDetection: 0
});
var STTdComponent = _STTdComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STTdComponent, [{
    type: Component,
    args: [{
      selector: "st-td",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<ng-template #btnTpl let-i let-child="child">
  @if (i.tooltip) {
    <span nz-tooltip [nzTooltipTitle]="i.tooltip" [class.d-block]="child" [class.width-100]="child">
      <ng-template [ngTemplateOutlet]="btnItemTpl" [ngTemplateOutletContext]="{ $implicit: i }" />
    </span>
  } @else {
    <ng-template [ngTemplateOutlet]="btnItemTpl" [ngTemplateOutletContext]="{ $implicit: i }" />
  }
</ng-template>
<ng-template #btnItemTpl let-i>
  @if (i.pop) {
    <a
      nz-popconfirm
      [nzPopconfirmTitle]="i.pop.title"
      [nzIcon]="i.pop.icon"
      [nzCondition]="i.pop.condition(i)"
      [nzCancelText]="i.pop.cancelText"
      [nzOkText]="i.pop.okText"
      [nzOkType]="i.pop.okType"
      (nzOnConfirm)="_btn(i)"
      class="st__btn-text"
      [ngClass]="i._className"
      (click)="_stopPropagation($event)"
    >
      <ng-template [ngTemplateOutlet]="btnTextTpl" [ngTemplateOutletContext]="{ $implicit: i }" />
    </a>
  } @else {
    <a (click)="_btn(i, $event)" class="st__btn-text" [ngClass]="i._className">
      <ng-template [ngTemplateOutlet]="btnTextTpl" [ngTemplateOutletContext]="{ $implicit: i }" />
    </a>
  }
</ng-template>
<ng-template #btnTextTpl let-i>
  @if (i._icon) {
    @if (i._icon.iconfont) {
      <i nz-icon [nzIconfont]="i._icon.iconfont"></i>
    } @else {
      <i
        nz-icon
        [nzType]="i._icon.type"
        [nzTheme]="i._icon.theme"
        [nzSpin]="i._icon.spin"
        [nzTwotoneColor]="i._icon.twoToneColor"
      ></i>
    }
  }
  <span [innerHTML]="i._text" [ngClass]="{ 'pl-xs': i._icon }"></span>
</ng-template>
@if (c.__render) {
  <ng-template [ngTemplateOutlet]="c.__render!" [ngTemplateOutletContext]="{ $implicit: i, index: index, column: c }" />
} @else {
  @switch (c.type) {
    @case ('checkbox') {
      <label nz-checkbox [nzDisabled]="i.disabled" [ngModel]="i.checked" (ngModelChange)="_checkbox($event)"></label>
    }
    @case ('radio') {
      <label nz-radio [nzDisabled]="i.disabled" [ngModel]="i.checked" (ngModelChange)="_radio()"></label>
    }
    @case ('link') {
      <a (click)="_link($event)" [innerHTML]="i._values[cIdx]._text" [attr.title]="i._values[cIdx].text"></a>
    }
    @case ('tag') {
      <nz-tag [nzColor]="i._values[cIdx].color" [nz-tooltip]="i._values[cIdx].tooltip">
        <span [innerHTML]="i._values[cIdx]._text"></span>
      </nz-tag>
    }
    @case ('badge') {
      <nz-badge
        [nzStatus]="i._values[cIdx].color"
        [nzText]="i._values[cIdx].text"
        [nz-tooltip]="i._values[cIdx].tooltip"
      />
    }
    @case ('cell') {
      <cell [value]="i._values[cIdx].text" [options]="i._values[cIdx].cell ?? c.cell" />
    }
    @case ('widget') {
      <ng-template st-widget-host [record]="i" [column]="c" />
    }
    @default {
      @if (c.safeType === 'text') {
        <span [innerText]="i._values[cIdx]._text" [attr.title]="c._isTruncate ? i._values[cIdx].text : null"></span>
      } @else {
        <span [innerHTML]="i._values[cIdx]._text" [attr.title]="c._isTruncate ? i._values[cIdx].text : null"></span>
      }
    }
  }
  @for (btn of i._values[cIdx].buttons; track $index) {
    @if (btn.children!.length > 0) {
      <a nz-dropdown [nzDropdownMenu]="btnMenu" nzOverlayClassName="st__btn-sub">
        <span [innerHTML]="btn._text"></span>
        <i nz-icon nzType="down"></i>
      </a>
      <nz-dropdown-menu #btnMenu="nzDropdownMenu">
        <ul nz-menu>
          @for (subBtn of btn.children; track $index) {
            @if (subBtn.type === 'divider') {
              <li nz-menu-divider></li>
            } @else {
              <li nz-menu-item [class.st__btn-disabled]="subBtn._disabled">
                <ng-template
                  [ngTemplateOutlet]="btnTpl"
                  [ngTemplateOutletContext]="{ $implicit: subBtn, child: true }"
                />
              </li>
            }
          }
        </ul>
      </nz-dropdown-menu>
    } @else {
      <span [class.st__btn-disabled]="btn._disabled">
        <ng-template [ngTemplateOutlet]="btnTpl" [ngTemplateOutletContext]="{ $implicit: btn, child: false }" />
      </span>
    }
    @if (!$last) {
      <nz-divider nzType="vertical" />
    }
  }
}
`
    }]
  }], () => [{
    type: STComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: Router
  }, {
    type: ModalHelper
  }, {
    type: DrawerHelper
  }], {
    c: [{
      type: Input
    }],
    cIdx: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    i: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    n: [{
      type: Output
    }]
  });
})();
var COMPONENTS2 = [STComponent, STRowDirective, STWidgetHostDirective];
var _STModule = class _STModule {
};
_STModule.\u0275fac = function STModule_Factory(t) {
  return new (t || _STModule)();
};
_STModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _STModule
});
_STModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, FormsModule, DelonACLModule, LetModule, CellModule, NzPopconfirmModule, NzTableModule, NzIconModule, NzBadgeModule, NzCheckboxModule, NzDividerModule, NzDropDownModule, NzMenuModule, NzRadioModule, NzTagModule, NzInputModule, NzToolTipModule, NzResizableModule, NzInputNumberModule, NzDatePickerModule]
});
var STModule = _STModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, DelonACLModule, LetModule, CellModule, NzPopconfirmModule, NzTableModule, NzIconModule, NzBadgeModule, NzCheckboxModule, NzDividerModule, NzDropDownModule, NzMenuModule, NzRadioModule, NzTagModule, NzInputModule, NzToolTipModule, NzResizableModule, NzInputNumberModule, NzDatePickerModule],
      declarations: [...COMPONENTS2, STFilterComponent, STTdComponent],
      exports: COMPONENTS2
    }]
  }], null, null);
})();
function provideSTWidgets(...widgets) {
  return makeEnvironmentProviders([{
    provide: ENVIRONMENT_INITIALIZER,
    multi: true,
    useValue: () => {
      const srv = inject(STWidgetRegistry);
      widgets.forEach((widget) => srv.register(widget.KEY, widget.type));
    }
  }]);
}

// node_modules/@delon/form/fesm2022/form.mjs
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist(), 1);

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-grid.mjs
var _NzRowDirective = class _NzRowDirective {
  getGutter() {
    const results = [null, null];
    const gutter = this.nzGutter || 0;
    const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, null];
    normalizedGutter.forEach((g, index) => {
      if (typeof g === "object" && g !== null) {
        results[index] = null;
        Object.keys(gridResponsiveMap).map((screen2) => {
          const bp = screen2;
          if (this.mediaMatcher.matchMedia(gridResponsiveMap[bp]).matches && g[bp]) {
            results[index] = g[bp];
          }
        });
      } else {
        results[index] = Number(g) || null;
      }
    });
    return results;
  }
  setGutterStyle() {
    const [horizontalGutter, verticalGutter] = this.getGutter();
    this.actualGutter$.next([horizontalGutter, verticalGutter]);
    const renderGutter = (name, gutter) => {
      const nativeElement = this.elementRef.nativeElement;
      if (gutter !== null) {
        this.renderer.setStyle(nativeElement, name, `-${gutter / 2}px`);
      }
    };
    renderGutter("margin-left", horizontalGutter);
    renderGutter("margin-right", horizontalGutter);
    renderGutter("margin-top", verticalGutter);
    renderGutter("margin-bottom", verticalGutter);
  }
  constructor(elementRef, renderer, mediaMatcher, ngZone, platform, breakpointService, directionality) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.mediaMatcher = mediaMatcher;
    this.ngZone = ngZone;
    this.platform = platform;
    this.breakpointService = breakpointService;
    this.directionality = directionality;
    this.nzAlign = null;
    this.nzJustify = null;
    this.nzGutter = null;
    this.actualGutter$ = new ReplaySubject(1);
    this.dir = "ltr";
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
    this.setGutterStyle();
  }
  ngOnChanges(changes) {
    if (changes.nzGutter) {
      this.setGutterStyle();
    }
  }
  ngAfterViewInit() {
    if (this.platform.isBrowser) {
      this.breakpointService.subscribe(gridResponsiveMap).pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.setGutterStyle();
      });
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzRowDirective.\u0275fac = function NzRowDirective_Factory(t) {
  return new (t || _NzRowDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(MediaMatcher), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(NzBreakpointService), \u0275\u0275directiveInject(Directionality, 8));
};
_NzRowDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzRowDirective,
  selectors: [["", "nz-row", ""], ["nz-row"], ["nz-form-item"]],
  hostAttrs: [1, "ant-row"],
  hostVars: 20,
  hostBindings: function NzRowDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-row-top", ctx.nzAlign === "top")("ant-row-middle", ctx.nzAlign === "middle")("ant-row-bottom", ctx.nzAlign === "bottom")("ant-row-start", ctx.nzJustify === "start")("ant-row-end", ctx.nzJustify === "end")("ant-row-center", ctx.nzJustify === "center")("ant-row-space-around", ctx.nzJustify === "space-around")("ant-row-space-between", ctx.nzJustify === "space-between")("ant-row-space-evenly", ctx.nzJustify === "space-evenly")("ant-row-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzAlign: "nzAlign",
    nzJustify: "nzJustify",
    nzGutter: "nzGutter"
  },
  exportAs: ["nzRow"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzRowDirective = _NzRowDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzRowDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-row],nz-row,nz-form-item",
      exportAs: "nzRow",
      host: {
        class: "ant-row",
        "[class.ant-row-top]": `nzAlign === 'top'`,
        "[class.ant-row-middle]": `nzAlign === 'middle'`,
        "[class.ant-row-bottom]": `nzAlign === 'bottom'`,
        "[class.ant-row-start]": `nzJustify === 'start'`,
        "[class.ant-row-end]": `nzJustify === 'end'`,
        "[class.ant-row-center]": `nzJustify === 'center'`,
        "[class.ant-row-space-around]": `nzJustify === 'space-around'`,
        "[class.ant-row-space-between]": `nzJustify === 'space-between'`,
        "[class.ant-row-space-evenly]": `nzJustify === 'space-evenly'`,
        "[class.ant-row-rtl]": `dir === "rtl"`
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: MediaMatcher
  }, {
    type: NgZone
  }, {
    type: Platform
  }, {
    type: NzBreakpointService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzAlign: [{
      type: Input
    }],
    nzJustify: [{
      type: Input
    }],
    nzGutter: [{
      type: Input
    }]
  });
})();
var _NzColDirective = class _NzColDirective {
  setHostClassMap() {
    const hostClassMap = __spreadValues({
      ["ant-col"]: true,
      [`ant-col-${this.nzSpan}`]: isNotNil(this.nzSpan),
      [`ant-col-order-${this.nzOrder}`]: isNotNil(this.nzOrder),
      [`ant-col-offset-${this.nzOffset}`]: isNotNil(this.nzOffset),
      [`ant-col-pull-${this.nzPull}`]: isNotNil(this.nzPull),
      [`ant-col-push-${this.nzPush}`]: isNotNil(this.nzPush),
      ["ant-col-rtl"]: this.dir === "rtl"
    }, this.generateClass());
    for (const i in this.classMap) {
      if (this.classMap.hasOwnProperty(i)) {
        this.renderer.removeClass(this.elementRef.nativeElement, i);
      }
    }
    this.classMap = __spreadValues({}, hostClassMap);
    for (const i in this.classMap) {
      if (this.classMap.hasOwnProperty(i) && this.classMap[i]) {
        this.renderer.addClass(this.elementRef.nativeElement, i);
      }
    }
  }
  setHostFlexStyle() {
    this.hostFlexStyle = this.parseFlex(this.nzFlex);
  }
  parseFlex(flex) {
    if (typeof flex === "number") {
      return `${flex} ${flex} auto`;
    } else if (typeof flex === "string") {
      if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
        return `0 0 ${flex}`;
      }
    }
    return flex;
  }
  generateClass() {
    const listOfSizeInputName = ["nzXs", "nzSm", "nzMd", "nzLg", "nzXl", "nzXXl"];
    const listClassMap = {};
    listOfSizeInputName.forEach((name) => {
      const sizeName = name.replace("nz", "").toLowerCase();
      if (isNotNil(this[name])) {
        if (typeof this[name] === "number" || typeof this[name] === "string") {
          listClassMap[`ant-col-${sizeName}-${this[name]}`] = true;
        } else {
          const embedded = this[name];
          const prefixArray = ["span", "pull", "push", "offset", "order"];
          prefixArray.forEach((prefix) => {
            const prefixClass = prefix === "span" ? "-" : `-${prefix}-`;
            listClassMap[`ant-col-${sizeName}${prefixClass}${embedded[prefix]}`] = embedded && isNotNil(embedded[prefix]);
          });
        }
      }
    });
    return listClassMap;
  }
  constructor(elementRef, nzRowDirective, renderer, directionality) {
    this.elementRef = elementRef;
    this.nzRowDirective = nzRowDirective;
    this.renderer = renderer;
    this.directionality = directionality;
    this.classMap = {};
    this.destroy$ = new Subject();
    this.hostFlexStyle = null;
    this.dir = "ltr";
    this.nzFlex = null;
    this.nzSpan = null;
    this.nzOrder = null;
    this.nzOffset = null;
    this.nzPush = null;
    this.nzPull = null;
    this.nzXs = null;
    this.nzSm = null;
    this.nzMd = null;
    this.nzLg = null;
    this.nzXl = null;
    this.nzXXl = null;
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.setHostClassMap();
    });
    this.setHostClassMap();
    this.setHostFlexStyle();
  }
  ngOnChanges(changes) {
    this.setHostClassMap();
    const {
      nzFlex
    } = changes;
    if (nzFlex) {
      this.setHostFlexStyle();
    }
  }
  ngAfterViewInit() {
    if (this.nzRowDirective) {
      this.nzRowDirective.actualGutter$.pipe(takeUntil(this.destroy$)).subscribe(([horizontalGutter, verticalGutter]) => {
        const renderGutter = (name, gutter) => {
          const nativeElement = this.elementRef.nativeElement;
          if (gutter !== null) {
            this.renderer.setStyle(nativeElement, name, `${gutter / 2}px`);
          }
        };
        renderGutter("padding-left", horizontalGutter);
        renderGutter("padding-right", horizontalGutter);
        renderGutter("padding-top", verticalGutter);
        renderGutter("padding-bottom", verticalGutter);
      });
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzColDirective.\u0275fac = function NzColDirective_Factory(t) {
  return new (t || _NzColDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NzRowDirective, 9), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(Directionality, 8));
};
_NzColDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzColDirective,
  selectors: [["", "nz-col", ""], ["nz-col"], ["nz-form-control"], ["nz-form-label"]],
  hostVars: 2,
  hostBindings: function NzColDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("flex", ctx.hostFlexStyle);
    }
  },
  inputs: {
    nzFlex: "nzFlex",
    nzSpan: "nzSpan",
    nzOrder: "nzOrder",
    nzOffset: "nzOffset",
    nzPush: "nzPush",
    nzPull: "nzPull",
    nzXs: "nzXs",
    nzSm: "nzSm",
    nzMd: "nzMd",
    nzLg: "nzLg",
    nzXl: "nzXl",
    nzXXl: "nzXXl"
  },
  exportAs: ["nzCol"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzColDirective = _NzColDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzColDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-col],nz-col,nz-form-control,nz-form-label",
      exportAs: "nzCol",
      host: {
        "[style.flex]": "hostFlexStyle"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NzRowDirective,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: Renderer2
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzFlex: [{
      type: Input
    }],
    nzSpan: [{
      type: Input
    }],
    nzOrder: [{
      type: Input
    }],
    nzOffset: [{
      type: Input
    }],
    nzPush: [{
      type: Input
    }],
    nzPull: [{
      type: Input
    }],
    nzXs: [{
      type: Input
    }],
    nzSm: [{
      type: Input
    }],
    nzMd: [{
      type: Input
    }],
    nzLg: [{
      type: Input
    }],
    nzXl: [{
      type: Input
    }],
    nzXXl: [{
      type: Input
    }]
  });
})();
var _NzGridModule = class _NzGridModule {
};
_NzGridModule.\u0275fac = function NzGridModule_Factory(t) {
  return new (t || _NzGridModule)();
};
_NzGridModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzGridModule
});
_NzGridModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzGridModule = _NzGridModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzGridModule, [{
    type: NgModule,
    args: [{
      imports: [NzColDirective, NzRowDirective],
      exports: [NzColDirective, NzRowDirective]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-form.mjs
var _c022 = ["*"];
function NzFormControlComponent_div_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r2.innerTip);
  }
}
var _c116 = (a0) => [a0];
var _c213 = (a0) => ({
  $implicit: a0
});
function NzFormControlComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5);
    \u0275\u0275template(2, NzFormControlComponent_div_3_ng_container_2_Template, 2, 1, "ng-container", 6);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("@helpMotion", void 0);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(4, _c116, "ant-form-item-explain-" + ctx_r0.status));
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.innerTip)("nzStringTemplateOutletContext", \u0275\u0275pureFunction1(6, _c213, ctx_r0.validateControl));
  }
}
function NzFormControlComponent_div_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r3.nzExtra);
  }
}
function NzFormControlComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275template(1, NzFormControlComponent_div_4_ng_container_1_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r1.nzExtra);
  }
}
function NzFormLabelComponent_span_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 3);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tooltipIconType_r2 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", tooltipIconType_r2)("nzTheme", ctx_r1.tooltipIcon.theme);
  }
}
function NzFormLabelComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 1);
    \u0275\u0275template(1, NzFormLabelComponent_span_2_ng_container_1_Template, 2, 2, "ng-container", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzTooltipTitle", ctx_r0.nzTooltipTitle);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.tooltipIcon.type);
  }
}
var _NzFormItemComponent = class _NzFormItemComponent {
  setWithHelpViaTips(value) {
    this.withHelpClass = value;
    this.cdr.markForCheck();
  }
  setStatus(status) {
    this.status = status;
    this.cdr.markForCheck();
  }
  setHasFeedback(hasFeedback) {
    this.hasFeedback = hasFeedback;
    this.cdr.markForCheck();
  }
  constructor(cdr) {
    this.cdr = cdr;
    this.status = "";
    this.hasFeedback = false;
    this.withHelpClass = false;
    this.destroy$ = new Subject();
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzFormItemComponent.\u0275fac = function NzFormItemComponent_Factory(t) {
  return new (t || _NzFormItemComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_NzFormItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzFormItemComponent,
  selectors: [["nz-form-item"]],
  hostAttrs: [1, "ant-form-item"],
  hostVars: 12,
  hostBindings: function NzFormItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-form-item-has-success", ctx.status === "success")("ant-form-item-has-warning", ctx.status === "warning")("ant-form-item-has-error", ctx.status === "error")("ant-form-item-is-validating", ctx.status === "validating")("ant-form-item-has-feedback", ctx.hasFeedback && ctx.status)("ant-form-item-with-help", ctx.withHelpClass);
    }
  },
  exportAs: ["nzFormItem"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c022,
  decls: 1,
  vars: 0,
  template: function NzFormItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzFormItemComponent = _NzFormItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormItemComponent, [{
    type: Component,
    args: [{
      selector: "nz-form-item",
      exportAs: "nzFormItem",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      host: {
        class: "ant-form-item",
        "[class.ant-form-item-has-success]": 'status === "success"',
        "[class.ant-form-item-has-warning]": 'status === "warning"',
        "[class.ant-form-item-has-error]": 'status === "error"',
        "[class.ant-form-item-is-validating]": 'status === "validating"',
        "[class.ant-form-item-has-feedback]": "hasFeedback && status",
        "[class.ant-form-item-with-help]": "withHelpClass"
      },
      template: ` <ng-content></ng-content> `,
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], null);
})();
var NZ_CONFIG_MODULE_NAME13 = "form";
var DefaultTooltipIcon = {
  type: "question-circle",
  theme: "outline"
};
var _NzFormDirective = class _NzFormDirective {
  getInputObservable(changeType) {
    return this.inputChanges$.pipe(filter((changes) => changeType in changes), map((value) => value[changeType]));
  }
  constructor(nzConfigService, directionality) {
    this.nzConfigService = nzConfigService;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME13;
    this.nzLayout = "horizontal";
    this.nzNoColon = false;
    this.nzAutoTips = {};
    this.nzDisableAutoTips = false;
    this.nzTooltipIcon = DefaultTooltipIcon;
    this.nzLabelAlign = "right";
    this.nzLabelWrap = false;
    this.dir = "ltr";
    this.destroy$ = new Subject();
    this.inputChanges$ = new Subject();
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngOnChanges(changes) {
    this.inputChanges$.next(changes);
  }
  ngOnDestroy() {
    this.inputChanges$.complete();
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzFormDirective.\u0275fac = function NzFormDirective_Factory(t) {
  return new (t || _NzFormDirective)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(Directionality, 8));
};
_NzFormDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzFormDirective,
  selectors: [["", "nz-form", ""]],
  hostAttrs: [1, "ant-form"],
  hostVars: 8,
  hostBindings: function NzFormDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-form-horizontal", ctx.nzLayout === "horizontal")("ant-form-vertical", ctx.nzLayout === "vertical")("ant-form-inline", ctx.nzLayout === "inline")("ant-form-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzLayout: "nzLayout",
    nzNoColon: "nzNoColon",
    nzAutoTips: "nzAutoTips",
    nzDisableAutoTips: "nzDisableAutoTips",
    nzTooltipIcon: "nzTooltipIcon",
    nzLabelAlign: "nzLabelAlign",
    nzLabelWrap: "nzLabelWrap"
  },
  exportAs: ["nzForm"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature]
});
var NzFormDirective = _NzFormDirective;
__decorate([WithConfig(), InputBoolean()], NzFormDirective.prototype, "nzNoColon", void 0);
__decorate([WithConfig()], NzFormDirective.prototype, "nzAutoTips", void 0);
__decorate([InputBoolean()], NzFormDirective.prototype, "nzDisableAutoTips", void 0);
__decorate([WithConfig()], NzFormDirective.prototype, "nzTooltipIcon", void 0);
__decorate([WithConfig(), InputBoolean()], NzFormDirective.prototype, "nzLabelWrap", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-form]",
      exportAs: "nzForm",
      host: {
        class: "ant-form",
        "[class.ant-form-horizontal]": `nzLayout === 'horizontal'`,
        "[class.ant-form-vertical]": `nzLayout === 'vertical'`,
        "[class.ant-form-inline]": `nzLayout === 'inline'`,
        "[class.ant-form-rtl]": `dir === 'rtl'`
      },
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzLayout: [{
      type: Input
    }],
    nzNoColon: [{
      type: Input
    }],
    nzAutoTips: [{
      type: Input
    }],
    nzDisableAutoTips: [{
      type: Input
    }],
    nzTooltipIcon: [{
      type: Input
    }],
    nzLabelAlign: [{
      type: Input
    }],
    nzLabelWrap: [{
      type: Input
    }]
  });
})();
var _NzFormControlComponent = class _NzFormControlComponent {
  get disableAutoTips() {
    return this.nzDisableAutoTips !== "default" ? toBoolean(this.nzDisableAutoTips) : this.nzFormDirective?.nzDisableAutoTips;
  }
  set nzHasFeedback(value) {
    this._hasFeedback = toBoolean(value);
    this.nzFormStatusService.formStatusChanges.next({
      status: this.status,
      hasFeedback: this._hasFeedback
    });
    if (this.nzFormItemComponent) {
      this.nzFormItemComponent.setHasFeedback(this._hasFeedback);
    }
  }
  get nzHasFeedback() {
    return this._hasFeedback;
  }
  set nzValidateStatus(value) {
    if (value instanceof AbstractControl || value instanceof NgModel) {
      this.validateControl = value;
      this.validateString = null;
      this.watchControl();
    } else if (value instanceof FormControlName) {
      this.validateControl = value.control;
      this.validateString = null;
      this.watchControl();
    } else {
      this.validateString = value;
      this.validateControl = null;
      this.setStatus();
    }
  }
  watchControl() {
    this.validateChanges.unsubscribe();
    if (this.validateControl && this.validateControl.statusChanges) {
      this.validateChanges = this.validateControl.statusChanges.pipe(startWith(null), takeUntil(this.destroyed$)).subscribe(() => {
        if (!this.disableAutoTips) {
          this.updateAutoErrorTip();
        }
        this.setStatus();
        this.cdr.markForCheck();
      });
    }
  }
  setStatus() {
    this.status = this.getControlStatus(this.validateString);
    this.innerTip = this.getInnerTip(this.status);
    this.nzFormStatusService.formStatusChanges.next({
      status: this.status,
      hasFeedback: this.nzHasFeedback
    });
    if (this.nzFormItemComponent) {
      this.nzFormItemComponent.setWithHelpViaTips(!!this.innerTip);
      this.nzFormItemComponent.setStatus(this.status);
    }
  }
  getControlStatus(validateString) {
    let status;
    if (validateString === "warning" || this.validateControlStatus("INVALID", "warning")) {
      status = "warning";
    } else if (validateString === "error" || this.validateControlStatus("INVALID")) {
      status = "error";
    } else if (validateString === "validating" || validateString === "pending" || this.validateControlStatus("PENDING")) {
      status = "validating";
    } else if (validateString === "success" || this.validateControlStatus("VALID")) {
      status = "success";
    } else {
      status = "";
    }
    return status;
  }
  validateControlStatus(validStatus, statusType) {
    if (!this.validateControl) {
      return false;
    } else {
      const {
        dirty,
        touched,
        status
      } = this.validateControl;
      return (!!dirty || !!touched) && (statusType ? this.validateControl.hasError(statusType) : status === validStatus);
    }
  }
  getInnerTip(status) {
    switch (status) {
      case "error":
        return !this.disableAutoTips && this.autoErrorTip || this.nzErrorTip || null;
      case "validating":
        return this.nzValidatingTip || null;
      case "success":
        return this.nzSuccessTip || null;
      case "warning":
        return this.nzWarningTip || null;
      default:
        return null;
    }
  }
  updateAutoErrorTip() {
    if (this.validateControl) {
      const errors = this.validateControl.errors || {};
      let autoErrorTip = "";
      for (const key in errors) {
        if (errors.hasOwnProperty(key)) {
          autoErrorTip = errors[key]?.[this.localeId] ?? this.nzAutoTips?.[this.localeId]?.[key] ?? this.nzAutoTips.default?.[key] ?? this.nzFormDirective?.nzAutoTips?.[this.localeId]?.[key] ?? this.nzFormDirective?.nzAutoTips.default?.[key];
        }
        if (!!autoErrorTip) {
          break;
        }
      }
      this.autoErrorTip = autoErrorTip;
    }
  }
  subscribeAutoTips(observable) {
    observable?.pipe(takeUntil(this.destroyed$)).subscribe(() => {
      if (!this.disableAutoTips) {
        this.updateAutoErrorTip();
        this.setStatus();
        this.cdr.markForCheck();
      }
    });
  }
  constructor(nzFormItemComponent, cdr, i18n, nzFormDirective, nzFormStatusService) {
    this.nzFormItemComponent = nzFormItemComponent;
    this.cdr = cdr;
    this.nzFormDirective = nzFormDirective;
    this.nzFormStatusService = nzFormStatusService;
    this._hasFeedback = false;
    this.validateChanges = Subscription.EMPTY;
    this.validateString = null;
    this.destroyed$ = new Subject();
    this.status = "";
    this.validateControl = null;
    this.innerTip = null;
    this.nzAutoTips = {};
    this.nzDisableAutoTips = "default";
    this.subscribeAutoTips(i18n.localeChange.pipe(tap((locale3) => this.localeId = locale3.locale)));
    this.subscribeAutoTips(this.nzFormDirective?.getInputObservable("nzAutoTips"));
    this.subscribeAutoTips(this.nzFormDirective?.getInputObservable("nzDisableAutoTips").pipe(filter(() => this.nzDisableAutoTips === "default")));
  }
  ngOnChanges(changes) {
    const {
      nzDisableAutoTips,
      nzAutoTips,
      nzSuccessTip,
      nzWarningTip,
      nzErrorTip,
      nzValidatingTip
    } = changes;
    if (nzDisableAutoTips || nzAutoTips) {
      this.updateAutoErrorTip();
      this.setStatus();
    } else if (nzSuccessTip || nzWarningTip || nzErrorTip || nzValidatingTip) {
      this.setStatus();
    }
  }
  ngOnInit() {
    this.setStatus();
  }
  ngOnDestroy() {
    this.destroyed$.next();
    this.destroyed$.complete();
  }
  ngAfterContentInit() {
    if (!this.validateControl && !this.validateString) {
      if (this.defaultValidateControl instanceof FormControlDirective) {
        this.nzValidateStatus = this.defaultValidateControl.control;
      } else {
        this.nzValidateStatus = this.defaultValidateControl;
      }
    }
  }
};
_NzFormControlComponent.\u0275fac = function NzFormControlComponent_Factory(t) {
  return new (t || _NzFormControlComponent)(\u0275\u0275directiveInject(NzFormItemComponent, 9), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzI18nService), \u0275\u0275directiveInject(NzFormDirective, 8), \u0275\u0275directiveInject(NzFormStatusService));
};
_NzFormControlComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzFormControlComponent,
  selectors: [["nz-form-control"]],
  contentQueries: function NzFormControlComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NgControl, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.defaultValidateControl = _t.first);
    }
  },
  hostAttrs: [1, "ant-form-item-control"],
  inputs: {
    nzSuccessTip: "nzSuccessTip",
    nzWarningTip: "nzWarningTip",
    nzErrorTip: "nzErrorTip",
    nzValidatingTip: "nzValidatingTip",
    nzExtra: "nzExtra",
    nzAutoTips: "nzAutoTips",
    nzDisableAutoTips: "nzDisableAutoTips",
    nzHasFeedback: "nzHasFeedback",
    nzValidateStatus: "nzValidateStatus"
  },
  exportAs: ["nzFormControl"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzFormStatusService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c022,
  decls: 5,
  vars: 2,
  consts: [[1, "ant-form-item-control-input"], [1, "ant-form-item-control-input-content"], ["class", "ant-form-item-explain ant-form-item-explain-connected", 4, "ngIf"], ["class", "ant-form-item-extra", 4, "ngIf"], [1, "ant-form-item-explain", "ant-form-item-explain-connected"], ["role", "alert", 3, "ngClass"], [4, "nzStringTemplateOutlet", "nzStringTemplateOutletContext"], [1, "ant-form-item-extra"], [4, "nzStringTemplateOutlet"]],
  template: function NzFormControlComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
      \u0275\u0275projection(2);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(3, NzFormControlComponent_div_3_Template, 3, 8, "div", 2)(4, NzFormControlComponent_div_4_Template, 2, 1, "div", 3);
    }
    if (rf & 2) {
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.innerTip);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzExtra);
    }
  },
  dependencies: [NgClass, NzOutletModule, NzStringTemplateOutletDirective, NgIf],
  encapsulation: 2,
  data: {
    animation: [helpMotion]
  },
  changeDetection: 0
});
var NzFormControlComponent = _NzFormControlComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormControlComponent, [{
    type: Component,
    args: [{
      selector: "nz-form-control",
      exportAs: "nzFormControl",
      preserveWhitespaces: false,
      animations: [helpMotion],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <div class="ant-form-item-control-input">
      <div class="ant-form-item-control-input-content">
        <ng-content></ng-content>
      </div>
    </div>
    <div @helpMotion class="ant-form-item-explain ant-form-item-explain-connected" *ngIf="innerTip">
      <div role="alert" [ngClass]="['ant-form-item-explain-' + status]">
        <ng-container *nzStringTemplateOutlet="innerTip; context: { $implicit: validateControl }">{{
          innerTip
        }}</ng-container>
      </div>
    </div>
    <div class="ant-form-item-extra" *ngIf="nzExtra">
      <ng-container *nzStringTemplateOutlet="nzExtra">{{ nzExtra }}</ng-container>
    </div>
  `,
      providers: [NzFormStatusService],
      host: {
        class: "ant-form-item-control"
      },
      imports: [NgClass, NzOutletModule, NgIf],
      standalone: true
    }]
  }], () => [{
    type: NzFormItemComponent,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzI18nService
  }, {
    type: NzFormDirective,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzFormStatusService
  }], {
    defaultValidateControl: [{
      type: ContentChild,
      args: [NgControl, {
        static: false
      }]
    }],
    nzSuccessTip: [{
      type: Input
    }],
    nzWarningTip: [{
      type: Input
    }],
    nzErrorTip: [{
      type: Input
    }],
    nzValidatingTip: [{
      type: Input
    }],
    nzExtra: [{
      type: Input
    }],
    nzAutoTips: [{
      type: Input
    }],
    nzDisableAutoTips: [{
      type: Input
    }],
    nzHasFeedback: [{
      type: Input
    }],
    nzValidateStatus: [{
      type: Input
    }]
  });
})();
function toTooltipIcon(value) {
  const icon = typeof value === "string" ? {
    type: value
  } : value;
  return __spreadValues(__spreadValues({}, DefaultTooltipIcon), icon);
}
var _NzFormLabelComponent = class _NzFormLabelComponent {
  set nzNoColon(value) {
    this.noColon = toBoolean(value);
  }
  get nzNoColon() {
    return this.noColon !== "default" ? this.noColon : this.nzFormDirective?.nzNoColon;
  }
  set nzTooltipIcon(value) {
    this._tooltipIcon = toTooltipIcon(value);
  }
  // due to 'get' and 'set' accessor must have the same type, so it was renamed to `tooltipIcon`
  get tooltipIcon() {
    return this._tooltipIcon !== "default" ? this._tooltipIcon : toTooltipIcon(this.nzFormDirective?.nzTooltipIcon || DefaultTooltipIcon);
  }
  set nzLabelAlign(value) {
    this.labelAlign = value;
  }
  get nzLabelAlign() {
    return this.labelAlign !== "default" ? this.labelAlign : this.nzFormDirective?.nzLabelAlign || "right";
  }
  set nzLabelWrap(value) {
    this.labelWrap = toBoolean(value);
  }
  get nzLabelWrap() {
    return this.labelWrap !== "default" ? this.labelWrap : this.nzFormDirective?.nzLabelWrap;
  }
  constructor(cdr, nzFormDirective) {
    this.cdr = cdr;
    this.nzFormDirective = nzFormDirective;
    this.nzRequired = false;
    this.noColon = "default";
    this._tooltipIcon = "default";
    this.labelAlign = "default";
    this.labelWrap = "default";
    this.destroy$ = new Subject();
    if (this.nzFormDirective) {
      this.nzFormDirective.getInputObservable("nzNoColon").pipe(filter(() => this.noColon === "default"), takeUntil(this.destroy$)).subscribe(() => this.cdr.markForCheck());
      this.nzFormDirective.getInputObservable("nzTooltipIcon").pipe(filter(() => this._tooltipIcon === "default"), takeUntil(this.destroy$)).subscribe(() => this.cdr.markForCheck());
      this.nzFormDirective.getInputObservable("nzLabelAlign").pipe(filter(() => this.labelAlign === "default"), takeUntil(this.destroy$)).subscribe(() => this.cdr.markForCheck());
      this.nzFormDirective.getInputObservable("nzLabelWrap").pipe(filter(() => this.labelWrap === "default"), takeUntil(this.destroy$)).subscribe(() => this.cdr.markForCheck());
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzFormLabelComponent.\u0275fac = function NzFormLabelComponent_Factory(t) {
  return new (t || _NzFormLabelComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzFormDirective, 12));
};
_NzFormLabelComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzFormLabelComponent,
  selectors: [["nz-form-label"]],
  hostAttrs: [1, "ant-form-item-label"],
  hostVars: 4,
  hostBindings: function NzFormLabelComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-form-item-label-left", ctx.nzLabelAlign === "left")("ant-form-item-label-wrap", ctx.nzLabelWrap);
    }
  },
  inputs: {
    nzFor: "nzFor",
    nzRequired: "nzRequired",
    nzNoColon: "nzNoColon",
    nzTooltipTitle: "nzTooltipTitle",
    nzTooltipIcon: "nzTooltipIcon",
    nzLabelAlign: "nzLabelAlign",
    nzLabelWrap: "nzLabelWrap"
  },
  exportAs: ["nzFormLabel"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c022,
  decls: 3,
  vars: 6,
  consts: [["class", "ant-form-item-tooltip", "nz-tooltip", "", 3, "nzTooltipTitle", 4, "ngIf"], ["nz-tooltip", "", 1, "ant-form-item-tooltip", 3, "nzTooltipTitle"], [4, "nzStringTemplateOutlet"], ["nz-icon", "", 3, "nzType", "nzTheme"]],
  template: function NzFormLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "label");
      \u0275\u0275projection(1);
      \u0275\u0275template(2, NzFormLabelComponent_span_2_Template, 2, 2, "span", 0);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-form-item-no-colon", ctx.nzNoColon)("ant-form-item-required", ctx.nzRequired);
      \u0275\u0275attribute("for", ctx.nzFor);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.nzTooltipTitle);
    }
  },
  dependencies: [NgIf, NzOutletModule, NzStringTemplateOutletDirective, NzTooltipDirective, NzIconModule, NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzFormLabelComponent = _NzFormLabelComponent;
__decorate([InputBoolean()], NzFormLabelComponent.prototype, "nzRequired", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormLabelComponent, [{
    type: Component,
    args: [{
      selector: "nz-form-label",
      exportAs: "nzFormLabel",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <label [attr.for]="nzFor" [class.ant-form-item-no-colon]="nzNoColon" [class.ant-form-item-required]="nzRequired">
      <ng-content></ng-content>
      <span *ngIf="nzTooltipTitle" class="ant-form-item-tooltip" nz-tooltip [nzTooltipTitle]="nzTooltipTitle">
        <ng-container *nzStringTemplateOutlet="tooltipIcon.type; let tooltipIconType">
          <span nz-icon [nzType]="tooltipIconType" [nzTheme]="tooltipIcon.theme"></span>
        </ng-container>
      </span>
    </label>
  `,
      host: {
        class: "ant-form-item-label",
        "[class.ant-form-item-label-left]": `nzLabelAlign === 'left'`,
        "[class.ant-form-item-label-wrap]": `nzLabelWrap`
      },
      imports: [NgIf, NzOutletModule, NzTooltipDirective, NzIconModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzFormDirective,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }]
  }], {
    nzFor: [{
      type: Input
    }],
    nzRequired: [{
      type: Input
    }],
    nzNoColon: [{
      type: Input
    }],
    nzTooltipTitle: [{
      type: Input
    }],
    nzTooltipIcon: [{
      type: Input
    }],
    nzLabelAlign: [{
      type: Input
    }],
    nzLabelWrap: [{
      type: Input
    }]
  });
})();
var _NzFormSplitComponent = class _NzFormSplitComponent {
};
_NzFormSplitComponent.\u0275fac = function NzFormSplitComponent_Factory(t) {
  return new (t || _NzFormSplitComponent)();
};
_NzFormSplitComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzFormSplitComponent,
  selectors: [["nz-form-split"]],
  hostAttrs: [1, "ant-form-split"],
  exportAs: ["nzFormSplit"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c022,
  decls: 1,
  vars: 0,
  template: function NzFormSplitComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzFormSplitComponent = _NzFormSplitComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormSplitComponent, [{
    type: Component,
    args: [{
      selector: "nz-form-split",
      exportAs: "nzFormSplit",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: ` <ng-content></ng-content> `,
      host: {
        class: "ant-form-split"
      },
      standalone: true
    }]
  }], null, null);
})();
var _NzFormTextComponent = class _NzFormTextComponent {
};
_NzFormTextComponent.\u0275fac = function NzFormTextComponent_Factory(t) {
  return new (t || _NzFormTextComponent)();
};
_NzFormTextComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzFormTextComponent,
  selectors: [["nz-form-text"]],
  hostAttrs: [1, "ant-form-text"],
  exportAs: ["nzFormText"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c022,
  decls: 1,
  vars: 0,
  template: function NzFormTextComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzFormTextComponent = _NzFormTextComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormTextComponent, [{
    type: Component,
    args: [{
      selector: "nz-form-text",
      exportAs: "nzFormText",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: ` <ng-content></ng-content> `,
      host: {
        class: "ant-form-text"
      },
      standalone: true
    }]
  }], null, null);
})();
var _NzFormModule = class _NzFormModule {
};
_NzFormModule.\u0275fac = function NzFormModule_Factory(t) {
  return new (t || _NzFormModule)();
};
_NzFormModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzFormModule
});
_NzFormModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzFormLabelComponent, NzFormControlComponent, NzGridModule]
});
var NzFormModule = _NzFormModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzFormModule, [{
    type: NgModule,
    args: [{
      imports: [NzFormDirective, NzFormItemComponent, NzFormLabelComponent, NzFormControlComponent, NzFormTextComponent, NzFormSplitComponent],
      exports: [NzGridModule, NzFormDirective, NzFormItemComponent, NzFormLabelComponent, NzFormControlComponent, NzFormTextComponent, NzFormSplitComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-switch.mjs
var _c023 = ["switchElement"];
function NzSwitchComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
}
function NzSwitchComponent_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r5.nzCheckedChildren);
  }
}
function NzSwitchComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzSwitchComponent_ng_container_5_ng_container_1_Template, 2, 1, "ng-container", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2.nzCheckedChildren);
  }
}
function NzSwitchComponent_ng_template_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r6.nzUnCheckedChildren);
  }
}
function NzSwitchComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzSwitchComponent_ng_template_6_ng_container_0_Template, 2, 1, "ng-container", 9);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.nzUnCheckedChildren);
  }
}
var NZ_CONFIG_MODULE_NAME14 = "switch";
var _NzSwitchComponent = class _NzSwitchComponent {
  updateValue(value) {
    if (this.isChecked !== value) {
      this.isChecked = value;
      this.onChange(this.isChecked);
    }
  }
  focus() {
    this.focusMonitor.focusVia(this.switchElement.nativeElement, "keyboard");
  }
  blur() {
    this.switchElement.nativeElement.blur();
  }
  constructor(nzConfigService, host, ngZone, cdr, focusMonitor, directionality) {
    this.nzConfigService = nzConfigService;
    this.host = host;
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.focusMonitor = focusMonitor;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME14;
    this.isChecked = false;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.nzLoading = false;
    this.nzDisabled = false;
    this.nzControl = false;
    this.nzCheckedChildren = null;
    this.nzUnCheckedChildren = null;
    this.nzSize = "default";
    this.nzId = null;
    this.dir = "ltr";
    this.destroy$ = new Subject();
    this.isNzDisableFirstChange = true;
  }
  ngOnInit() {
    this.directionality.change.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.host.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        event.preventDefault();
        if (this.nzControl || this.nzDisabled || this.nzLoading) {
          return;
        }
        this.ngZone.run(() => {
          this.updateValue(!this.isChecked);
          this.cdr.markForCheck();
        });
      });
      fromEvent(this.switchElement.nativeElement, "keydown").pipe(takeUntil(this.destroy$)).subscribe((event) => {
        if (this.nzControl || this.nzDisabled || this.nzLoading) {
          return;
        }
        const {
          keyCode
        } = event;
        if (keyCode !== LEFT_ARROW && keyCode !== RIGHT_ARROW && keyCode !== SPACE && keyCode !== ENTER) {
          return;
        }
        event.preventDefault();
        this.ngZone.run(() => {
          if (keyCode === LEFT_ARROW) {
            this.updateValue(false);
          } else if (keyCode === RIGHT_ARROW) {
            this.updateValue(true);
          } else if (keyCode === SPACE || keyCode === ENTER) {
            this.updateValue(!this.isChecked);
          }
          this.cdr.markForCheck();
        });
      });
    });
  }
  ngAfterViewInit() {
    this.focusMonitor.monitor(this.switchElement.nativeElement, true).pipe(takeUntil(this.destroy$)).subscribe((focusOrigin) => {
      if (!focusOrigin) {
        Promise.resolve().then(() => this.onTouched());
      }
    });
  }
  ngOnDestroy() {
    this.focusMonitor.stopMonitoring(this.switchElement.nativeElement);
    this.destroy$.next();
    this.destroy$.complete();
  }
  writeValue(value) {
    this.isChecked = value;
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(disabled) {
    this.nzDisabled = this.isNzDisableFirstChange && this.nzDisabled || disabled;
    this.isNzDisableFirstChange = false;
    this.cdr.markForCheck();
  }
};
_NzSwitchComponent.\u0275fac = function NzSwitchComponent_Factory(t) {
  return new (t || _NzSwitchComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(FocusMonitor), \u0275\u0275directiveInject(Directionality, 8));
};
_NzSwitchComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSwitchComponent,
  selectors: [["nz-switch"]],
  viewQuery: function NzSwitchComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c023, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.switchElement = _t.first);
    }
  },
  inputs: {
    nzLoading: "nzLoading",
    nzDisabled: "nzDisabled",
    nzControl: "nzControl",
    nzCheckedChildren: "nzCheckedChildren",
    nzUnCheckedChildren: "nzUnCheckedChildren",
    nzSize: "nzSize",
    nzId: "nzId"
  },
  exportAs: ["nzSwitch"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NzSwitchComponent),
    multi: true
  }]), \u0275\u0275StandaloneFeature],
  decls: 9,
  vars: 16,
  consts: [["nz-wave", "", "type", "button", 1, "ant-switch", 3, "disabled", "nzWaveExtraNode"], ["switchElement", ""], [1, "ant-switch-handle"], ["nz-icon", "", "nzType", "loading", "class", "ant-switch-loading-icon", 4, "ngIf"], [1, "ant-switch-inner"], [4, "ngIf", "ngIfElse"], ["uncheckTemplate", ""], [1, "ant-click-animating-node"], ["nz-icon", "", "nzType", "loading", 1, "ant-switch-loading-icon"], [4, "nzStringTemplateOutlet"]],
  template: function NzSwitchComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0, 1)(2, "span", 2);
      \u0275\u0275template(3, NzSwitchComponent_span_3_Template, 1, 0, "span", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "span", 4);
      \u0275\u0275template(5, NzSwitchComponent_ng_container_5_Template, 2, 1, "ng-container", 5)(6, NzSwitchComponent_ng_template_6_Template, 1, 1, "ng-template", null, 6, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementEnd();
      \u0275\u0275element(8, "div", 7);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const _r4 = \u0275\u0275reference(7);
      \u0275\u0275classProp("ant-switch-checked", ctx.isChecked)("ant-switch-loading", ctx.nzLoading)("ant-switch-disabled", ctx.nzDisabled)("ant-switch-small", ctx.nzSize === "small")("ant-switch-rtl", ctx.dir === "rtl");
      \u0275\u0275property("disabled", ctx.nzDisabled)("nzWaveExtraNode", true);
      \u0275\u0275attribute("id", ctx.nzId);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.nzLoading);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.isChecked)("ngIfElse", _r4);
    }
  },
  dependencies: [NzWaveModule, NzWaveDirective, NzIconModule, NzIconDirective, NgIf, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzSwitchComponent = _NzSwitchComponent;
__decorate([InputBoolean()], NzSwitchComponent.prototype, "nzLoading", void 0);
__decorate([InputBoolean()], NzSwitchComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzSwitchComponent.prototype, "nzControl", void 0);
__decorate([WithConfig()], NzSwitchComponent.prototype, "nzSize", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSwitchComponent, [{
    type: Component,
    args: [{
      selector: "nz-switch",
      exportAs: "nzSwitch",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NzSwitchComponent),
        multi: true
      }],
      template: `
    <button
      nz-wave
      type="button"
      class="ant-switch"
      #switchElement
      [attr.id]="nzId"
      [disabled]="nzDisabled"
      [class.ant-switch-checked]="isChecked"
      [class.ant-switch-loading]="nzLoading"
      [class.ant-switch-disabled]="nzDisabled"
      [class.ant-switch-small]="nzSize === 'small'"
      [class.ant-switch-rtl]="dir === 'rtl'"
      [nzWaveExtraNode]="true"
    >
      <span class="ant-switch-handle">
        <span *ngIf="nzLoading" nz-icon nzType="loading" class="ant-switch-loading-icon"></span>
      </span>
      <span class="ant-switch-inner">
        <ng-container *ngIf="isChecked; else uncheckTemplate">
          <ng-container *nzStringTemplateOutlet="nzCheckedChildren">{{ nzCheckedChildren }}</ng-container>
        </ng-container>
        <ng-template #uncheckTemplate>
          <ng-container *nzStringTemplateOutlet="nzUnCheckedChildren">{{ nzUnCheckedChildren }}</ng-container>
        </ng-template>
      </span>
      <div class="ant-click-animating-node"></div>
    </button>
  `,
      imports: [NzWaveModule, NzIconModule, NgIf, NzOutletModule],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: FocusMonitor
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    switchElement: [{
      type: ViewChild,
      args: ["switchElement", {
        static: true
      }]
    }],
    nzLoading: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzControl: [{
      type: Input
    }],
    nzCheckedChildren: [{
      type: Input
    }],
    nzUnCheckedChildren: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzId: [{
      type: Input
    }]
  });
})();
var _NzSwitchModule = class _NzSwitchModule {
};
_NzSwitchModule.\u0275fac = function NzSwitchModule_Factory(t) {
  return new (t || _NzSwitchModule)();
};
_NzSwitchModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzSwitchModule
});
_NzSwitchModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzSwitchComponent]
});
var NzSwitchModule = _NzSwitchModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSwitchModule, [{
    type: NgModule,
    args: [{
      imports: [NzSwitchComponent],
      exports: [NzSwitchComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-core-tree.mjs
var NzTreeNode = class _NzTreeNode {
  get treeService() {
    return this.service || this.parentNode && this.parentNode.treeService;
  }
  /**
   * Init nzTreeNode
   *
   * @param option: user's input
   * @param parent
   * @param service: base nzTreeService
   */
  constructor(option, parent = null, service = null) {
    this._title = "";
    this.level = 0;
    this.parentNode = null;
    this._icon = "";
    this._children = [];
    this._isLeaf = false;
    this._isChecked = false;
    this._isSelectable = false;
    this._isDisabled = false;
    this._isDisableCheckbox = false;
    this._isExpanded = false;
    this._isHalfChecked = false;
    this._isSelected = false;
    this._isLoading = false;
    this.canHide = false;
    this.isMatched = false;
    this.service = null;
    if (option instanceof _NzTreeNode) {
      return option;
    }
    this.service = service || null;
    this.origin = option;
    this.key = option.key;
    this.parentNode = parent;
    this._title = option.title || "---";
    this._icon = option.icon || "";
    this._isLeaf = option.isLeaf || false;
    this._children = [];
    this._isChecked = option.checked || false;
    this._isSelectable = option.disabled || option.selectable !== false;
    this._isDisabled = option.disabled || false;
    this._isDisableCheckbox = option.disableCheckbox || false;
    this._isExpanded = option.isLeaf ? false : option.expanded || false;
    this._isHalfChecked = false;
    this._isSelected = !option.disabled && option.selected || false;
    this._isLoading = false;
    this.isMatched = false;
    if (parent) {
      this.level = parent.level + 1;
    } else {
      this.level = 0;
    }
    if (typeof option.children !== "undefined" && option.children !== null) {
      option.children.forEach((nodeOptions) => {
        const s = this.treeService;
        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {
          nodeOptions.checked = option.checked;
        }
        this._children.push(new _NzTreeNode(nodeOptions, this));
      });
    }
  }
  /**
   * auto generate
   * get
   * set
   */
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this.update();
  }
  get icon() {
    return this._icon;
  }
  set icon(value) {
    this._icon = value;
    this.update();
  }
  get children() {
    return this._children;
  }
  set children(value) {
    this._children = value;
    this.update();
  }
  get isLeaf() {
    return this._isLeaf;
  }
  set isLeaf(value) {
    this._isLeaf = value;
    this.update();
  }
  get isChecked() {
    return this._isChecked;
  }
  set isChecked(value) {
    this._isChecked = value;
    this.origin.checked = value;
    this.afterValueChange("isChecked");
  }
  get isHalfChecked() {
    return this._isHalfChecked;
  }
  set isHalfChecked(value) {
    this._isHalfChecked = value;
    this.afterValueChange("isHalfChecked");
  }
  get isSelectable() {
    return this._isSelectable;
  }
  set isSelectable(value) {
    this._isSelectable = value;
    this.update();
  }
  get isDisabled() {
    return this._isDisabled;
  }
  set isDisabled(value) {
    this._isDisabled = value;
    this.update();
  }
  get isDisableCheckbox() {
    return this._isDisableCheckbox;
  }
  set isDisableCheckbox(value) {
    this._isDisableCheckbox = value;
    this.update();
  }
  get isExpanded() {
    return this._isExpanded;
  }
  set isExpanded(value) {
    this._isExpanded = value;
    this.origin.expanded = value;
    this.afterValueChange("isExpanded");
    this.afterValueChange("reRender");
  }
  get isSelected() {
    return this._isSelected;
  }
  set isSelected(value) {
    this._isSelected = value;
    this.origin.selected = value;
    this.afterValueChange("isSelected");
  }
  get isLoading() {
    return this._isLoading;
  }
  set isLoading(value) {
    this._isLoading = value;
    this.update();
  }
  setSyncChecked(checked = false, halfChecked = false) {
    this.setChecked(checked, halfChecked);
    if (this.treeService && !this.treeService.isCheckStrictly) {
      this.treeService.conduct(this);
    }
  }
  setChecked(checked = false, halfChecked = false) {
    this.origin.checked = checked;
    this.isChecked = checked;
    this.isHalfChecked = halfChecked;
  }
  setExpanded(value) {
    this._isExpanded = value;
    this.origin.expanded = value;
    this.afterValueChange("isExpanded");
  }
  getParentNode() {
    return this.parentNode;
  }
  getChildren() {
    return this.children;
  }
  /**
   * Support appending child nodes by position. Leaf node cannot be appended.
   */
  addChildren(children, childPos = -1) {
    if (!this.isLeaf) {
      children.forEach((node) => {
        const refreshLevel = (n) => {
          n.getChildren().forEach((c) => {
            c.level = c.getParentNode().level + 1;
            c.origin.level = c.level;
            refreshLevel(c);
          });
        };
        let child = node;
        if (child instanceof _NzTreeNode) {
          child.parentNode = this;
        } else {
          child = new _NzTreeNode(node, this);
        }
        child.level = this.level + 1;
        child.origin.level = child.level;
        refreshLevel(child);
        try {
          childPos === -1 ? this.children.push(child) : this.children.splice(childPos, 0, child);
        } catch (e) {
        }
      });
      this.origin.children = this.getChildren().map((v) => v.origin);
      this.isLoading = false;
    }
    this.afterValueChange("addChildren");
    this.afterValueChange("reRender");
  }
  clearChildren() {
    this.afterValueChange("clearChildren");
    this.children = [];
    this.origin.children = [];
    this.afterValueChange("reRender");
  }
  remove() {
    const parentNode = this.getParentNode();
    if (parentNode) {
      parentNode.children = parentNode.getChildren().filter((v) => v.key !== this.key);
      parentNode.origin.children = parentNode.origin.children.filter((v) => v.key !== this.key);
      this.afterValueChange("remove");
      this.afterValueChange("reRender");
    }
  }
  afterValueChange(key) {
    if (this.treeService) {
      switch (key) {
        case "isChecked":
          this.treeService.setCheckedNodeList(this);
          break;
        case "isHalfChecked":
          this.treeService.setHalfCheckedNodeList(this);
          break;
        case "isExpanded":
          this.treeService.setExpandedNodeList(this);
          break;
        case "isSelected":
          this.treeService.setNodeActive(this);
          break;
        case "clearChildren":
          this.treeService.afterRemove(this.getChildren());
          break;
        case "remove":
          this.treeService.afterRemove([this]);
          break;
        case "reRender":
          this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map((v) => v.key));
          break;
      }
    }
    this.update();
  }
  update() {
    if (this.component) {
      this.component.markForCheck();
    }
  }
};
function isCheckDisabled(node) {
  const {
    isDisabled,
    isDisableCheckbox
  } = node;
  return !!(isDisabled || isDisableCheckbox);
}
function isInArray(needle, haystack) {
  return haystack.length > 0 && haystack.indexOf(needle) > -1;
}
function getPosition(level, index) {
  return `${level}-${index}`;
}
function getKey(key, pos) {
  if (key !== null && key !== void 0) {
    return key;
  }
  return pos;
}
function flattenTreeData(treeNodeList = [], expandedKeys = []) {
  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  const flattenList = [];
  function dig(list2, parent = null) {
    return list2.map((treeNode, index) => {
      const pos = getPosition(parent ? parent.pos : "0", index);
      const mergedKey = getKey(treeNode.key, pos);
      treeNode.isStart = [...parent ? parent.isStart : [], index === 0];
      treeNode.isEnd = [...parent ? parent.isEnd : [], index === list2.length - 1];
      const flattenNode = {
        parent,
        pos,
        children: [],
        data: treeNode,
        isStart: [...parent ? parent.isStart : [], index === 0],
        isEnd: [...parent ? parent.isEnd : [], index === list2.length - 1]
      };
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {
        flattenNode.children = dig(treeNode.children || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
var _NzTreeBaseService = class _NzTreeBaseService {
  constructor() {
    this.DRAG_SIDE_RANGE = 0.25;
    this.DRAG_MIN_GAP = 2;
    this.isCheckStrictly = false;
    this.isMultiple = false;
    this.rootNodes = [];
    this.flattenNodes$ = new BehaviorSubject([]);
    this.selectedNodeList = [];
    this.expandedNodeList = [];
    this.checkedNodeList = [];
    this.halfCheckedNodeList = [];
    this.matchedNodeList = [];
  }
  /**
   * reset tree nodes will clear default node list
   */
  initTree(nzNodes) {
    this.rootNodes = nzNodes;
    this.expandedNodeList = [];
    this.selectedNodeList = [];
    this.halfCheckedNodeList = [];
    this.checkedNodeList = [];
    this.matchedNodeList = [];
  }
  flattenTreeData(nzNodes, expandedKeys = []) {
    this.flattenNodes$.next(flattenTreeData(nzNodes, expandedKeys).map((item) => item.data));
  }
  getSelectedNode() {
    return this.selectedNode;
  }
  /**
   * get some list
   */
  getSelectedNodeList() {
    return this.conductNodeState("select");
  }
  /**
   * get checked node keys
   */
  getCheckedNodeKeys() {
    const keys = [];
    const checkedNodes = this.getCheckedNodeList();
    const calc = (nodes) => {
      nodes.forEach((node) => {
        keys.push(node.key);
        if (node.children.length < 1)
          return;
        calc(node.children);
      });
    };
    calc(checkedNodes);
    return keys;
  }
  /**
   * return checked nodes
   */
  getCheckedNodeList() {
    return this.conductNodeState("check");
  }
  getHalfCheckedNodeList() {
    return this.conductNodeState("halfCheck");
  }
  /**
   * return expanded nodes
   */
  getExpandedNodeList() {
    return this.conductNodeState("expand");
  }
  /**
   * return search matched nodes
   */
  getMatchedNodeList() {
    return this.conductNodeState("match");
  }
  isArrayOfNzTreeNode(value) {
    return value.every((item) => item instanceof NzTreeNode);
  }
  /**
   * set drag node
   */
  setSelectedNode(node) {
    this.selectedNode = node;
  }
  /**
   * set node selected status
   */
  setNodeActive(node) {
    if (!this.isMultiple && node.isSelected) {
      this.selectedNodeList.forEach((n) => {
        if (node.key !== n.key) {
          n.isSelected = false;
        }
      });
      this.selectedNodeList = [];
    }
    this.setSelectedNodeList(node, this.isMultiple);
  }
  /**
   * add or remove node to selectedNodeList
   */
  setSelectedNodeList(node, isMultiple = false) {
    const index = this.getIndexOfArray(this.selectedNodeList, node.key);
    if (isMultiple) {
      if (node.isSelected && index === -1) {
        this.selectedNodeList.push(node);
      }
    } else {
      if (node.isSelected && index === -1) {
        this.selectedNodeList = [node];
      }
    }
    if (!node.isSelected) {
      this.selectedNodeList = this.selectedNodeList.filter((n) => n.key !== node.key);
    }
  }
  /**
   * merge checked nodes
   */
  setHalfCheckedNodeList(node) {
    const index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);
    if (node.isHalfChecked && index === -1) {
      this.halfCheckedNodeList.push(node);
    } else if (!node.isHalfChecked && index > -1) {
      this.halfCheckedNodeList = this.halfCheckedNodeList.filter((n) => node.key !== n.key);
    }
  }
  setCheckedNodeList(node) {
    const index = this.getIndexOfArray(this.checkedNodeList, node.key);
    if (node.isChecked && index === -1) {
      this.checkedNodeList.push(node);
    } else if (!node.isChecked && index > -1) {
      this.checkedNodeList = this.checkedNodeList.filter((n) => node.key !== n.key);
    }
  }
  /**
   * conduct checked/selected/expanded keys
   */
  conductNodeState(type = "check") {
    let resultNodesList = [];
    switch (type) {
      case "select":
        resultNodesList = this.selectedNodeList;
        break;
      case "expand":
        resultNodesList = this.expandedNodeList;
        break;
      case "match":
        resultNodesList = this.matchedNodeList;
        break;
      case "check":
        resultNodesList = this.checkedNodeList;
        const isIgnore = (node) => {
          const parentNode = node.getParentNode();
          if (parentNode) {
            if (this.checkedNodeList.findIndex((n) => n.key === parentNode.key) > -1) {
              return true;
            } else {
              return isIgnore(parentNode);
            }
          }
          return false;
        };
        if (!this.isCheckStrictly) {
          resultNodesList = this.checkedNodeList.filter((n) => !isIgnore(n));
        }
        break;
      case "halfCheck":
        if (!this.isCheckStrictly) {
          resultNodesList = this.halfCheckedNodeList;
        }
        break;
    }
    return resultNodesList;
  }
  /**
   * set expanded nodes
   */
  setExpandedNodeList(node) {
    if (node.isLeaf) {
      return;
    }
    const index = this.getIndexOfArray(this.expandedNodeList, node.key);
    if (node.isExpanded && index === -1) {
      this.expandedNodeList.push(node);
    } else if (!node.isExpanded && index > -1) {
      this.expandedNodeList.splice(index, 1);
    }
  }
  setMatchedNodeList(node) {
    const index = this.getIndexOfArray(this.matchedNodeList, node.key);
    if (node.isMatched && index === -1) {
      this.matchedNodeList.push(node);
    } else if (!node.isMatched && index > -1) {
      this.matchedNodeList.splice(index, 1);
    }
  }
  /**
   * check state
   *
   * @param isCheckStrictly
   */
  refreshCheckState(isCheckStrictly = false) {
    if (isCheckStrictly) {
      return;
    }
    this.checkedNodeList.forEach((node) => {
      this.conduct(node, isCheckStrictly);
    });
  }
  // reset other node checked state based current node
  conduct(node, isCheckStrictly = false) {
    const isChecked = node.isChecked;
    if (node && !isCheckStrictly) {
      this.conductUp(node);
      this.conductDown(node, isChecked);
    }
  }
  /**
   * 1、children half checked
   * 2、children all checked, parent checked
   * 3、no children checked
   */
  conductUp(node) {
    const parentNode = node.getParentNode();
    if (parentNode) {
      if (!isCheckDisabled(parentNode)) {
        if (parentNode.children.every((child) => isCheckDisabled(child) || !child.isHalfChecked && child.isChecked)) {
          parentNode.isChecked = true;
          parentNode.isHalfChecked = false;
        } else if (parentNode.children.some((child) => child.isHalfChecked || child.isChecked)) {
          parentNode.isChecked = false;
          parentNode.isHalfChecked = true;
        } else {
          parentNode.isChecked = false;
          parentNode.isHalfChecked = false;
        }
      }
      this.setCheckedNodeList(parentNode);
      this.setHalfCheckedNodeList(parentNode);
      this.conductUp(parentNode);
    }
  }
  /**
   * reset child check state
   */
  conductDown(node, value) {
    if (!isCheckDisabled(node)) {
      node.isChecked = value;
      node.isHalfChecked = false;
      this.setCheckedNodeList(node);
      this.setHalfCheckedNodeList(node);
      node.children.forEach((n) => {
        this.conductDown(n, value);
      });
    }
  }
  /**
   * flush after delete node
   */
  afterRemove(nodes) {
    const loopNode = (node) => {
      this.selectedNodeList = this.selectedNodeList.filter((n) => n.key !== node.key);
      this.expandedNodeList = this.expandedNodeList.filter((n) => n.key !== node.key);
      this.checkedNodeList = this.checkedNodeList.filter((n) => n.key !== node.key);
      if (node.children) {
        node.children.forEach((child) => {
          loopNode(child);
        });
      }
    };
    nodes.forEach((n) => {
      loopNode(n);
    });
    this.refreshCheckState(this.isCheckStrictly);
  }
  /**
   * drag event
   */
  refreshDragNode(node) {
    if (node.children.length === 0) {
      this.conductUp(node);
    } else {
      node.children.forEach((child) => {
        this.refreshDragNode(child);
      });
    }
  }
  // reset node level
  resetNodeLevel(node) {
    const parentNode = node.getParentNode();
    if (parentNode) {
      node.level = parentNode.level + 1;
    } else {
      node.level = 0;
    }
    for (const child of node.children) {
      this.resetNodeLevel(child);
    }
  }
  calcDropPosition(event) {
    const {
      clientY
    } = event;
    const {
      top,
      bottom,
      height
    } = event.target.getBoundingClientRect();
    const des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);
    if (clientY <= top + des) {
      return -1;
    } else if (clientY >= bottom - des) {
      return 1;
    }
    return 0;
  }
  /**
   * drop
   * 0: inner -1: pre 1: next
   */
  dropAndApply(targetNode, dragPos = -1) {
    if (!targetNode || dragPos > 1) {
      return;
    }
    const treeService = targetNode.treeService;
    const targetParent = targetNode.getParentNode();
    const isSelectedRootNode = this.selectedNode.getParentNode();
    if (isSelectedRootNode) {
      isSelectedRootNode.children = isSelectedRootNode.children.filter((n) => n.key !== this.selectedNode.key);
    } else {
      this.rootNodes = this.rootNodes.filter((n) => n.key !== this.selectedNode.key);
    }
    switch (dragPos) {
      case 0:
        targetNode.addChildren([this.selectedNode]);
        this.resetNodeLevel(targetNode);
        break;
      case -1:
      case 1:
        const tIndex = dragPos === 1 ? 1 : 0;
        if (targetParent) {
          targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);
          const parentNode = this.selectedNode.getParentNode();
          if (parentNode) {
            this.resetNodeLevel(parentNode);
          }
        } else {
          const targetIndex = this.rootNodes.indexOf(targetNode) + tIndex;
          this.rootNodes.splice(targetIndex, 0, this.selectedNode);
          this.rootNodes[targetIndex].parentNode = null;
          this.resetNodeLevel(this.rootNodes[targetIndex]);
        }
        break;
    }
    this.rootNodes.forEach((child) => {
      if (!child.treeService) {
        child.service = treeService;
      }
      this.refreshDragNode(child);
    });
  }
  /**
   * emit Structure
   * eventName
   * node
   * event: MouseEvent / DragEvent
   * dragNode
   */
  formatEvent(eventName, node, event) {
    const emitStructure = {
      eventName,
      node,
      event
    };
    switch (eventName) {
      case "dragstart":
      case "dragenter":
      case "dragover":
      case "dragleave":
      case "drop":
      case "dragend":
        Object.assign(emitStructure, {
          dragNode: this.getSelectedNode()
        });
        break;
      case "click":
      case "dblclick":
        Object.assign(emitStructure, {
          selectedKeys: this.selectedNodeList
        });
        Object.assign(emitStructure, {
          nodes: this.selectedNodeList
        });
        Object.assign(emitStructure, {
          keys: this.selectedNodeList.map((n) => n.key)
        });
        break;
      case "check":
        const checkedNodeList = this.getCheckedNodeList();
        Object.assign(emitStructure, {
          checkedKeys: checkedNodeList
        });
        Object.assign(emitStructure, {
          nodes: checkedNodeList
        });
        Object.assign(emitStructure, {
          keys: checkedNodeList.map((n) => n.key)
        });
        break;
      case "search":
        Object.assign(emitStructure, {
          matchedKeys: this.getMatchedNodeList()
        });
        Object.assign(emitStructure, {
          nodes: this.getMatchedNodeList()
        });
        Object.assign(emitStructure, {
          keys: this.getMatchedNodeList().map((n) => n.key)
        });
        break;
      case "expand":
        Object.assign(emitStructure, {
          nodes: this.expandedNodeList
        });
        Object.assign(emitStructure, {
          keys: this.expandedNodeList.map((n) => n.key)
        });
        break;
    }
    return emitStructure;
  }
  /**
   * New functions for flatten nodes
   */
  getIndexOfArray(list2, key) {
    return list2.findIndex((v) => v.key === key);
  }
  /**
   * Render by nzCheckedKeys
   * When keys equals null, just render with checkStrictly
   *
   * @param keys
   * @param checkStrictly
   */
  conductCheck(keys, checkStrictly) {
    this.checkedNodeList = [];
    this.halfCheckedNodeList = [];
    const calc = (nodes) => {
      nodes.forEach((node) => {
        if (keys === null) {
          node.isChecked = !!node.origin.checked;
        } else {
          if (isInArray(node.key, keys || [])) {
            node.isChecked = true;
            node.isHalfChecked = false;
          } else {
            node.isChecked = false;
            node.isHalfChecked = false;
          }
        }
        if (node.children.length > 0) {
          calc(node.children);
        }
      });
    };
    calc(this.rootNodes);
    this.refreshCheckState(checkStrictly);
  }
  conductExpandedKeys(keys = []) {
    const expandedKeySet = new Set(keys === true ? [] : keys);
    this.expandedNodeList = [];
    const calc = (nodes) => {
      nodes.forEach((node) => {
        node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);
        if (node.isExpanded) {
          this.setExpandedNodeList(node);
        }
        if (node.children.length > 0) {
          calc(node.children);
        }
      });
    };
    calc(this.rootNodes);
  }
  conductSelectedKeys(keys, isMulti) {
    this.selectedNodeList.forEach((node) => node.isSelected = false);
    this.selectedNodeList = [];
    const calc = (nodes) => nodes.every((node) => {
      if (isInArray(node.key, keys)) {
        node.isSelected = true;
        this.setSelectedNodeList(node);
        if (!isMulti) {
          return false;
        }
      } else {
        node.isSelected = false;
      }
      if (node.children.length > 0) {
        return calc(node.children);
      }
      return true;
    });
    calc(this.rootNodes);
  }
  /**
   * Expand parent nodes by child node
   *
   * @param node
   */
  expandNodeAllParentBySearch(node) {
    const calc = (n) => {
      if (n) {
        n.canHide = false;
        n.setExpanded(true);
        this.setExpandedNodeList(n);
        if (n.getParentNode()) {
          return calc(n.getParentNode());
        }
      }
    };
    calc(node.getParentNode());
  }
};
_NzTreeBaseService.\u0275fac = function NzTreeBaseService_Factory(t) {
  return new (t || _NzTreeBaseService)();
};
_NzTreeBaseService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NzTreeBaseService,
  factory: _NzTreeBaseService.\u0275fac
});
var NzTreeBaseService = _NzTreeBaseService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTreeBaseService, [{
    type: Injectable
  }], null, null);
})();
var NzTreeHigherOrderServiceToken = new InjectionToken("NzTreeHigherOrder");

// node_modules/@delon/util/fesm2022/array.mjs
var _ArrayService = class _ArrayService {
  constructor(cog) {
    this.c = cog.merge("utilArray", {
      deepMapName: "deep",
      parentMapName: "parent",
      idMapName: "id",
      parentIdMapName: "parent_id",
      childrenMapName: "children",
      titleMapName: "title",
      checkedMapname: "checked",
      selectedMapname: "selected",
      expandedMapname: "expanded",
      disabledMapname: "disabled"
    });
  }
  /**
   * Convert tree structure to array structure
   *
   * 将树结构转换成数组结构
   */
  treeToArr(tree, options) {
    const opt = __spreadValues({
      deepMapName: this.c.deepMapName,
      parentMapName: this.c.parentMapName,
      childrenMapName: this.c.childrenMapName,
      clearChildren: true,
      cb: null
    }, options);
    const result = [];
    const inFn = (list2, parent, deep = 0) => {
      for (const i of list2) {
        i[opt.deepMapName] = deep;
        i[opt.parentMapName] = parent;
        if (opt.cb) {
          opt.cb(i, parent, deep);
        }
        result.push(i);
        const children = i[opt.childrenMapName];
        if (children != null && Array.isArray(children) && children.length > 0) {
          inFn(children, i, deep + 1);
        }
        if (opt.clearChildren) {
          delete i[opt.childrenMapName];
        }
      }
    };
    inFn(tree, null);
    return result;
  }
  /**
   * Convert array structure to tree structure
   *
   * 数组转换成树数据
   */
  arrToTree(arr, options) {
    if (!Array.isArray(arr) || arr.length === 0) {
      return [];
    }
    const opt = __spreadValues({
      idMapName: this.c.idMapName,
      parentIdMapName: this.c.parentIdMapName,
      childrenMapName: this.c.childrenMapName,
      cb: null
    }, options);
    const tree = [];
    const childrenOf = {};
    let rootPid = opt.rootParentIdValue;
    const arrType = arr;
    if (!rootPid) {
      const pids = arrType.map((i) => i[opt.parentIdMapName]);
      const emptyPid = pids.findIndex((w) => w == null);
      rootPid = emptyPid !== -1 ? pids[emptyPid] : pids.sort()[0];
    }
    for (const item of arrType) {
      const id = item[opt.idMapName];
      const pid = item[opt.parentIdMapName];
      childrenOf[id] = childrenOf[id] || [];
      item[opt.childrenMapName] = childrenOf[id];
      if (opt.cb) {
        opt.cb(item);
      }
      if (pid !== rootPid) {
        childrenOf[pid] = childrenOf[pid] || [];
        childrenOf[pid].push(item);
      } else {
        tree.push(item);
      }
    }
    return tree;
  }
  /**
   * 数组转换成 `nz-tree` 数据源，通过 `options` 转化项名，也可以使用 `options.cb` 更高级决定数据项
   */
  arrToTreeNode(arr, options) {
    const opt = __spreadValues({
      idMapName: this.c.idMapName,
      parentIdMapName: this.c.parentIdMapName,
      titleMapName: this.c.titleMapName,
      isLeafMapName: "isLeaf",
      checkedMapname: this.c.checkedMapname,
      selectedMapname: this.c.selectedMapname,
      expandedMapname: this.c.expandedMapname,
      disabledMapname: this.c.disabledMapname,
      cb: null
    }, options);
    const tree = this.arrToTree(arr, {
      idMapName: opt.idMapName,
      parentIdMapName: opt.parentIdMapName,
      childrenMapName: "children"
    });
    this.visitTree(tree, (item, parent, deep) => {
      item.key = item[opt.idMapName];
      item.title = item[opt.titleMapName];
      item.checked = item[opt.checkedMapname];
      item.selected = item[opt.selectedMapname];
      item.expanded = item[opt.expandedMapname];
      item.disabled = item[opt.disabledMapname];
      if (item[opt.isLeafMapName] == null) {
        item.isLeaf = item.children.length === 0;
      } else {
        item.isLeaf = item[opt.isLeafMapName];
      }
      if (opt.cb) {
        opt.cb(item, parent, deep);
      }
    });
    return tree.map((node) => new NzTreeNode(node));
  }
  /**
   * 递归访问整个树
   */
  visitTree(tree, cb, options) {
    options = __spreadValues({
      childrenMapName: this.c.childrenMapName
    }, options);
    const inFn = (data, parent, deep) => {
      for (const item of data) {
        cb(item, parent, deep);
        const childrenVal = item[options.childrenMapName];
        if (Array.isArray(childrenVal) && childrenVal.length > 0) {
          inFn(childrenVal, item, deep + 1);
        }
      }
    };
    inFn(tree, null, 1);
  }
  /**
   * Return the value of the first tree value in the tree where predicate is true, and `undefined` otherwise
   *
   * 根据条件返回树的第一个值，否则返回 `undefined`
   */
  findTree(tree, predicate, options) {
    let res;
    this.visitTree(tree, (item) => {
      if (res === void 0 && predicate(item)) {
        res = item;
      }
    }, options);
    return res;
  }
  /**
   * 获取所有已经选中的 `key` 值
   */
  getKeysByTreeNode(tree, options) {
    const opt = __spreadValues({
      includeHalfChecked: true
    }, options);
    const keys = [];
    this.visitTree(tree, (item, parent, deep) => {
      if (item.isChecked || opt.includeHalfChecked && item.isHalfChecked) {
        keys.push(opt.cb ? opt.cb(item, parent, deep) : opt.keyMapName ? item.origin[opt.keyMapName] : item.key);
      }
    });
    return keys;
  }
  baseFlat(array, depth, result = []) {
    let index = -1;
    while (++index < array.length) {
      const value = array[index];
      if (depth > 0 && Array.isArray(value)) {
        if (depth > 1) {
          this.baseFlat(value, depth - 1, result);
        } else {
          let pushIndex = -1;
          const offset = result.length;
          while (++pushIndex < value.length) {
            result[offset + pushIndex] = value[pushIndex];
          }
        }
      } else {
        result[result.length] = value;
      }
    }
    return result;
  }
  /**
   * Recursively flattens array
   *
   * 递归扁平数组
   * ```ts
   * srv.flat([1, [2, 3, [4, 5, [6]]]]) => [1,2,3,4,5,6]
   * srv.flat([1, [2, 3, [4, 5, [6]]]], 1) => [1,2,3,[4, 5, [6]]]
   * ```
   */
  flat(array, depth = 1 / 0) {
    return Array.isArray(array) ? this.baseFlat(array, depth) : array;
  }
  /**
   * Group the array
   *
   * 对数组进行分组
   * ```ts
   * srv.groupBy([6.1, 4.2, 6.3], Math.floor) => {"4":[4.2],"6":[6.1,6.3]}
   * srv.groupBy(['one', 'two', 'three'], v => v.length) => {"3":["one","two"],"5":["three"]}
   * ```
   */
  groupBy(array, iteratee) {
    if (!Array.isArray(array)) {
      return {};
    }
    return array.reduce((result, value) => {
      const key = iteratee(value);
      if (Object.prototype.hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
      return result;
    }, {});
  }
  /**
   * Creates a duplicate-free version of an array
   *
   * 创建去重后的数组
   * ```ts
   * uniq([1, 2, 2, 3, 1]) => [1,2,3]
   * uniq([{ a: 1 }, { a: 1 }, { a: 2 }], 'a') => [{"a":1},{"a":2}]
   * uniq([{ a: 1 }, { a: 1 }, { a: 2 }], i => (i.a === 1 ? 'a' : 'b')) => [{"a":1},{"a":2}]
   * ```
   */
  uniq(array, predicate) {
    return Array.from(array.reduce((map2, value) => {
      const key = predicate ? typeof predicate === "string" ? value[predicate] : predicate(value) : value;
      if (!map2.has(key)) {
        map2.set(key, value);
      }
      return map2;
    }, /* @__PURE__ */ new Map()).values());
  }
};
_ArrayService.\u0275fac = function ArrayService_Factory(t) {
  return new (t || _ArrayService)(\u0275\u0275inject(AlainConfigService));
};
_ArrayService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ArrayService,
  factory: _ArrayService.\u0275fac,
  providedIn: "root"
});
var ArrayService = _ArrayService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ArrayService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AlainConfigService
  }], null);
})();

// node_modules/@delon/form/fesm2022/form.mjs
var _c024 = ["target"];
function SFItemComponent_ng_template_0_Template(rf, ctx) {
}
function SFItemComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function SFComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 10);
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(5);
    \u0275\u0275property("nzType", ctx_r10._btn.submit_icon.type)("nzTheme", ctx_r10._btn.submit_icon.theme)("nzTwotoneColor", ctx_r10._btn.submit_icon.twoToneColor)("nzIconfont", ctx_r10._btn.submit_icon.iconfont);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 10);
  }
  if (rf & 2) {
    const ctx_r12 = \u0275\u0275nextContext(6);
    \u0275\u0275property("nzType", ctx_r12._btn.reset_icon.type)("nzTheme", ctx_r12._btn.reset_icon.theme)("nzTwotoneColor", ctx_r12._btn.reset_icon.twoToneColor)("nzIconfont", ctx_r12._btn.reset_icon.iconfont);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 12);
    \u0275\u0275listener("click", function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r14);
      const ctx_r13 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r13.reset(true));
    });
    \u0275\u0275template(1, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Conditional_1_Template, 1, 4, "i", 10);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r11 = \u0275\u0275nextContext(5);
    \u0275\u0275property("nzType", ctx_r11._btn.reset_type)("nzSize", ctx_r11._btn.render.size)("disabled", ctx_r11.loading);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r11._btn.reset_icon ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r11._btn.reset, " ");
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 9);
    \u0275\u0275template(1, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_1_Template, 1, 4, "i", 10);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Template, 3, 5, "button", 11);
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(4);
    \u0275\u0275property("nzType", ctx_r8._btn.submit_type)("nzSize", ctx_r8._btn.render.size)("nzLoading", ctx_r8.loading)("disabled", ctx_r8.liveValidate && !ctx_r8.valid);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r8._btn.submit_icon ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r8._btn.submit, " ");
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, ctx_r8._btn.reset ? 3 : -1);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_5_ng_template_0_Template(rf, ctx) {
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_5_ng_template_0_Template, 0, 0, "ng-template", 13);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(4);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-form-item", 5)(1, "div", 6)(2, "div", 7)(3, "div", 8);
    \u0275\u0275template(4, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Template, 4, 7)(5, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_5_Template, 1, 1);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngClass", ctx_r7._btn.render.class)("fixed-label", ctx_r7._btn.render.spanLabelFixed);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzSpan", ctx_r7.btnGrid.span)("nzOffset", ctx_r7.btnGrid.offset)("nzXs", ctx_r7.btnGrid.xs)("nzSm", ctx_r7.btnGrid.sm)("nzMd", ctx_r7.btnGrid.md)("nzLg", ctx_r7.btnGrid.lg)("nzXl", ctx_r7.btnGrid.xl)("nzXXl", ctx_r7.btnGrid.xxl);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(4, ctx_r7.button ? 4 : 5);
  }
}
function SFComponent_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SFComponent_ng_template_2_Conditional_0_Conditional_0_Template, 6, 11, "nz-form-item", 4);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(0, ctx_r5._btn && ctx_r5._btn.render ? 0 : -1);
  }
}
function SFComponent_ng_template_2_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function SFComponent_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SFComponent_ng_template_2_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 13);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function SFComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SFComponent_ng_template_2_Conditional_0_Template, 1, 1)(1, SFComponent_ng_template_2_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275conditional(0, ctx_r2.button !== "none" ? 0 : 1);
  }
}
function SFComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "sf-item", 3);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275property("formProperty", ctx_r4.rootProperty)("footer", _r3);
  }
}
var _c117 = ["*"];
function SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 11);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(4);
    \u0275\u0275property("nzTooltipTitle", ctx_r5.oh.text)("nzTooltipPlacement", ctx_r5.oh.placement)("nzTooltipTrigger", ctx_r5.oh.trigger)("nzTooltipColor", ctx_r5.oh.bgColor)("nzTooltipOverlayClassName", ctx_r5.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r5.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r5.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r5.oh.mouseLeaveDelay)("nzType", ctx_r5.oh.icon);
  }
}
function SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 10);
    \u0275\u0275text(1);
    \u0275\u0275template(2, SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Conditional_2_Template, 1, 9, "i", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r4.ui.optional, " ");
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, ctx_r4.oh ? 2 : -1);
  }
}
function SFItemWrapComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label")(1, "span", 8);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Template, 3, 2, "span", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("ant-form-item-required", ctx_r3.ui._required);
    \u0275\u0275attribute("for", ctx_r3.id);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r3.t);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, ctx_r3.ui.optional || ctx_r3.oh ? 3 : -1);
  }
}
function SFItemWrapComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275template(1, SFItemWrapComponent_Conditional_1_Conditional_1_Template, 4, 5, "label", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzSpan", ctx_r0.ui.spanLabel);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r0.t ? 1 : -1);
  }
}
function SFItemWrapComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12)(1, "div", 13);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("@helpMotion", void 0);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.error, " ");
  }
}
function SFItemWrapComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 14);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r2.ui._description, \u0275\u0275sanitizeHtml);
  }
}
function ArrayWidget_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 9);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzTooltipTitle", ctx_r4.oh.text)("nzTooltipPlacement", ctx_r4.oh.placement)("nzTooltipTrigger", ctx_r4.oh.trigger)("nzTooltipOverlayClassName", ctx_r4.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r4.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r4.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r4.oh.mouseLeaveDelay)("nzType", ctx_r4.oh.icon);
  }
}
function ArrayWidget_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7)(1, "label");
    \u0275\u0275text(2);
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4);
    \u0275\u0275template(5, ArrayWidget_Conditional_1_Conditional_5_Template, 1, 8, "i", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 10)(7, "button", 11);
    \u0275\u0275listener("click", function ArrayWidget_Conditional_1_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r5 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r5.addItem());
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzSpan", ctx_r0.ui.spanLabel);
    \u0275\u0275advance(1);
    \u0275\u0275classProp("ant-form-item-required", ctx_r0.ui.required);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r0.schema.title, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r0.ui.optional, " ");
    \u0275\u0275advance(1);
    \u0275\u0275conditional(5, ctx_r0.oh ? 5 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzType", ctx_r0.addType)("disabled", ctx_r0.addDisabled)("innerHTML", ctx_r0.addTitle, \u0275\u0275sanitizeHtml);
  }
}
function ArrayWidget_ng_container_5_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275listener("click", function ArrayWidget_ng_container_5_Conditional_1_Conditional_3_Template_span_click_0_listener() {
      \u0275\u0275restoreView(_r13);
      const $index_r8 = \u0275\u0275nextContext(2).index;
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11.removeItem($index_r8));
    });
    \u0275\u0275element(1, "i", 17);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(3);
    \u0275\u0275attribute("title", ctx_r10.removeTitle);
  }
}
function ArrayWidget_ng_container_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13)(1, "nz-card");
    \u0275\u0275element(2, "sf-item", 14);
    \u0275\u0275template(3, ArrayWidget_ng_container_5_Conditional_1_Conditional_3_Template, 2, 1, "span", 15);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r14 = \u0275\u0275nextContext();
    const $index_r8 = ctx_r14.index;
    const i_r7 = ctx_r14.$implicit;
    const ctx_r9 = \u0275\u0275nextContext();
    \u0275\u0275property("nzSpan", ctx_r9.arraySpan);
    \u0275\u0275attribute("data-index", $index_r8);
    \u0275\u0275advance(2);
    \u0275\u0275property("formProperty", i_r7);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, ctx_r9.showRemove ? 3 : -1);
  }
}
function ArrayWidget_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, ArrayWidget_ng_container_5_Conditional_1_Template, 4, 4, "div", 12);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const i_r7 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, i_r7.visible && !i_r7.ui.hidden ? 1 : -1);
  }
}
function ArrayWidget_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r2.error);
  }
}
function ArrayWidget_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 19);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r3.ui._description, \u0275\u0275sanitizeHtml);
  }
}
function CheckboxWidget_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 3);
    \u0275\u0275listener("ngModelChange", function CheckboxWidget_ng_template_0_Conditional_0_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.allChecked = $event);
    })("ngModelChange", function CheckboxWidget_ng_template_0_Conditional_0_Template_label_ngModelChange_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r6 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r6.onAllChecked());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngModel", ctx_r3.allChecked)("nzIndeterminate", ctx_r3.indeterminate);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r3.ui.checkAllText || ctx_r3.l.checkAllText, " ");
  }
}
function CheckboxWidget_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CheckboxWidget_ng_template_0_Conditional_0_Template, 2, 3, "label", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275conditional(0, ctx_r0.ui.checkAll ? 0 : -1);
  }
}
function CheckboxWidget_Conditional_3_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 7);
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275property("nzTooltipTitle", ctx_r9.oh.text)("nzTooltipPlacement", ctx_r9.oh.placement)("nzTooltipTrigger", ctx_r9.oh.trigger)("nzTooltipOverlayClassName", ctx_r9.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r9.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r9.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r9.oh.mouseLeaveDelay)("nzType", ctx_r9.oh.icon);
  }
}
function CheckboxWidget_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 5);
    \u0275\u0275listener("ngModelChange", function CheckboxWidget_Conditional_3_Conditional_0_Template_label_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r10 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r10._setValue($event));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementStart(2, "span", 6);
    \u0275\u0275text(3);
    \u0275\u0275template(4, CheckboxWidget_Conditional_3_Conditional_0_Conditional_4_Template, 1, 8, "i", 7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzDisabled", ctx_r7.disabled)("ngModel", ctx_r7.value);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r7.schema.title, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r7.ui.optional, " ");
    \u0275\u0275advance(1);
    \u0275\u0275conditional(4, ctx_r7.oh ? 4 : -1);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = \u0275\u0275getCurrentView();
    \u0275\u0275template(0, CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 8);
    \u0275\u0275elementStart(1, "nz-checkbox-group", 9);
    \u0275\u0275listener("ngModelChange", function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template_nz_checkbox_group_ngModelChange_1_listener() {
      \u0275\u0275restoreView(_r16);
      const ctx_r15 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r15.notifySet());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r12 = \u0275\u0275nextContext(3);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngModel", ctx_r12.data);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_ng_template_1_Template(rf, ctx) {
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12);
    \u0275\u0275template(1, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_ng_template_1_Template, 0, 0, "ng-template", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r17 = \u0275\u0275nextContext(4);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("nzSpan", ctx_r17.grid_span);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_For_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12)(1, "label", 13);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const i_r20 = ctx.$implicit;
    const ctx_r18 = \u0275\u0275nextContext(4);
    \u0275\u0275property("nzSpan", ctx_r18.grid_span);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzValue", i_r20.value)("ngModel", i_r20.checked)("nzDisabled", i_r20.disabled);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", i_r20.label, " ");
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r26 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-checkbox-wrapper", 10);
    \u0275\u0275listener("nzOnChange", function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template_nz_checkbox_wrapper_nzOnChange_0_listener($event) {
      \u0275\u0275restoreView(_r26);
      const ctx_r25 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r25.groupInGridChange($event));
    });
    \u0275\u0275elementStart(1, "div", 11);
    \u0275\u0275template(2, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_Template, 2, 2, "div", 12);
    \u0275\u0275repeaterCreate(3, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_For_4_Template, 3, 5, "div", 12, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(2, ctx_r13.ui.checkAll ? 2 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r13.data);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template, 2, 2)(1, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template, 5, 1);
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(0, ctx_r8.grid_span === 0 ? 0 : 1);
  }
}
function CheckboxWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, CheckboxWidget_Conditional_3_Conditional_0_Template, 5, 5, "label", 4)(1, CheckboxWidget_Conditional_3_Conditional_1_Template, 2, 1);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275conditional(0, ctx_r2.data.length === 0 ? 0 : 1);
  }
}
function CustomWidget_ng_template_1_Template(rf, ctx) {
}
var _c214 = (a0, a1, a2) => ({
  $implicit: a0,
  schema: a1,
  ui: a2
});
function DateWidget_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-year-picker", 1);
    \u0275\u0275listener("ngModelChange", function DateWidget_Case_1_Template_nz_year_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r5 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r5.displayValue = $event);
    })("ngModelChange", function DateWidget_Case_1_Template_nz_year_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7._change($event));
    })("nzOnOpenChange", function DateWidget_Case_1_Template_nz_year_picker_nzOnOpenChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r8 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r8._openChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzId", ctx_r0.id)("nzDisabled", ctx_r0.disabled)("nzSize", ctx_r0.ui.size)("nzFormat", ctx_r0.displayFormat)("ngModel", ctx_r0.displayValue)("nzAllowClear", ctx_r0.i.allowClear)("ngClass", ctx_r0.ui.className)("nzDisabledDate", ctx_r0.ui.disabledDate)("nzLocale", ctx_r0.ui.locale)("nzPlaceHolder", ctx_r0.ui.placeholder)("nzPopupStyle", ctx_r0.ui.popupStyle)("nzDropdownClassName", ctx_r0.ui.dropdownClassName)("nzRenderExtraFooter", ctx_r0.ui.renderExtraFooter)("nzInputReadOnly", ctx_r0.ui.inputReadOnly)("nzInline", ctx_r0.ui.inline);
  }
}
function DateWidget_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-month-picker", 1);
    \u0275\u0275listener("ngModelChange", function DateWidget_Case_2_Template_nz_month_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.displayValue = $event);
    })("ngModelChange", function DateWidget_Case_2_Template_nz_month_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11._change($event));
    })("nzOnOpenChange", function DateWidget_Case_2_Template_nz_month_picker_nzOnOpenChange_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r12 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r12._openChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("nzId", ctx_r1.id)("nzDisabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("nzFormat", ctx_r1.displayFormat)("ngModel", ctx_r1.displayValue)("nzAllowClear", ctx_r1.i.allowClear)("ngClass", ctx_r1.ui.className)("nzDisabledDate", ctx_r1.ui.disabledDate)("nzLocale", ctx_r1.ui.locale)("nzPlaceHolder", ctx_r1.ui.placeholder)("nzPopupStyle", ctx_r1.ui.popupStyle)("nzDropdownClassName", ctx_r1.ui.dropdownClassName)("nzRenderExtraFooter", ctx_r1.ui.renderExtraFooter)("nzInputReadOnly", ctx_r1.ui.inputReadOnly)("nzInline", ctx_r1.ui.inline);
  }
}
function DateWidget_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-week-picker", 2);
    \u0275\u0275listener("ngModelChange", function DateWidget_Case_3_Template_nz_week_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r14);
      const ctx_r13 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r13.displayValue = $event);
    })("ngModelChange", function DateWidget_Case_3_Template_nz_week_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r14);
      const ctx_r15 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r15._change($event));
    })("nzOnOpenChange", function DateWidget_Case_3_Template_nz_week_picker_nzOnOpenChange_0_listener($event) {
      \u0275\u0275restoreView(_r14);
      const ctx_r16 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r16._openChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("nzId", ctx_r2.id)("nzDisabled", ctx_r2.disabled)("nzSize", ctx_r2.ui.size)("nzFormat", ctx_r2.displayFormat)("ngModel", ctx_r2.displayValue)("nzAllowClear", ctx_r2.i.allowClear)("ngClass", ctx_r2.ui.className)("nzDisabledDate", ctx_r2.ui.disabledDate)("nzLocale", ctx_r2.ui.locale)("nzPlaceHolder", ctx_r2.ui.placeholder)("nzPopupStyle", ctx_r2.ui.popupStyle)("nzDropdownClassName", ctx_r2.ui.dropdownClassName)("nzInputReadOnly", ctx_r2.ui.inputReadOnly)("nzInline", ctx_r2.ui.inline);
  }
}
function DateWidget_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-range-picker", 3);
    \u0275\u0275listener("ngModelChange", function DateWidget_Case_4_Template_nz_range_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r18);
      const ctx_r17 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r17.displayValue = $event);
    })("ngModelChange", function DateWidget_Case_4_Template_nz_range_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r18);
      const ctx_r19 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r19._change($event));
    })("nzOnOpenChange", function DateWidget_Case_4_Template_nz_range_picker_nzOnOpenChange_0_listener($event) {
      \u0275\u0275restoreView(_r18);
      const ctx_r20 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r20._openChange($event));
    })("nzOnOk", function DateWidget_Case_4_Template_nz_range_picker_nzOnOk_0_listener($event) {
      \u0275\u0275restoreView(_r18);
      const ctx_r21 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r21._ok($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("nzId", ctx_r3.id)("nzDisabled", ctx_r3.disabled)("nzSize", ctx_r3.ui.size)("nzFormat", ctx_r3.displayFormat)("ngModel", ctx_r3.displayValue)("nzAllowClear", ctx_r3.i.allowClear)("ngClass", ctx_r3.ui.className)("nzDisabledDate", ctx_r3.ui.disabledDate)("nzLocale", ctx_r3.ui.locale)("nzPlaceHolder", ctx_r3.ui.placeholder)("nzPopupStyle", ctx_r3.ui.popupStyle)("nzDropdownClassName", ctx_r3.ui.dropdownClassName)("nzDisabledTime", ctx_r3.ui.disabledTime)("nzRenderExtraFooter", ctx_r3.ui.renderExtraFooter)("nzRanges", ctx_r3.ui.ranges)("nzShowTime", ctx_r3.ui.showTime)("nzSeparator", ctx_r3.ui.separator)("nzShowWeekNumber", ctx_r3.ui.showWeekNumber || false)("nzMode", ctx_r3.ui.rangeMode)("nzInputReadOnly", ctx_r3.ui.inputReadOnly)("nzInline", ctx_r3.ui.inline);
  }
}
function DateWidget_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-date-picker", 4);
    \u0275\u0275listener("ngModelChange", function DateWidget_Case_5_Template_nz_date_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r22 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r22.displayValue = $event);
    })("ngModelChange", function DateWidget_Case_5_Template_nz_date_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r24 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r24._change($event));
    })("nzOnOpenChange", function DateWidget_Case_5_Template_nz_date_picker_nzOnOpenChange_0_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r25 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r25._openChange($event));
    })("nzOnOk", function DateWidget_Case_5_Template_nz_date_picker_nzOnOk_0_listener($event) {
      \u0275\u0275restoreView(_r23);
      const ctx_r26 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r26._ok($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275property("nzId", ctx_r4.id)("nzDisabled", ctx_r4.disabled)("nzSize", ctx_r4.ui.size)("nzFormat", ctx_r4.displayFormat)("ngModel", ctx_r4.displayValue)("nzAllowClear", ctx_r4.i.allowClear)("ngClass", ctx_r4.ui.className)("nzDisabledDate", ctx_r4.ui.disabledDate)("nzLocale", ctx_r4.ui.locale)("nzPlaceHolder", ctx_r4.ui.placeholder)("nzPopupStyle", ctx_r4.ui.popupStyle)("nzDropdownClassName", ctx_r4.ui.dropdownClassName)("nzDisabledTime", ctx_r4.ui.disabledTime)("nzRenderExtraFooter", ctx_r4.ui.renderExtraFooter)("nzShowTime", ctx_r4.ui.showTime)("nzShowToday", ctx_r4.i.showToday)("nzShowWeekNumber", ctx_r4.ui.showWeekNumber || false)("nzInputReadOnly", ctx_r4.ui.inputReadOnly)("nzInline", ctx_r4.ui.inline);
  }
}
var _c310 = (a0) => ({
  "ant-input-number__hide-step": a0
});
function ObjectWidget_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r5.title);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275element(1, "sf-item", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("nzSpan", i_r9.grid.span)("nzOffset", i_r9.grid.offset)("nzXs", i_r9.grid.xs)("nzSm", i_r9.grid.sm)("nzMd", i_r9.grid.md)("nzLg", i_r9.grid.lg)("nzXl", i_r9.grid.xl)("nzXXl", i_r9.grid.xxl);
    \u0275\u0275advance(1);
    \u0275\u0275property("formProperty", i_r9.property)("fixed-label", i_r9.spanLabelFixed);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ObjectWidget_ng_template_0_Conditional_1_For_2_Conditional_0_Template, 2, 10, "div", 5);
  }
  if (rf & 2) {
    const i_r9 = ctx.$implicit;
    \u0275\u0275conditional(0, i_r9.property.visible && i_r9.show ? 0 : -1);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275repeaterCreate(1, ObjectWidget_ng_template_0_Conditional_1_For_2_Template, 1, 1, null, null, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzGutter", ctx_r6.grid.gutter);
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r6.list);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "sf-item", 6);
  }
  if (rf & 2) {
    const i_r17 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("formProperty", i_r17.property)("fixed-label", i_r17.spanLabelFixed);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ObjectWidget_ng_template_0_Conditional_2_For_1_Conditional_0_Template, 1, 2, "sf-item", 6);
  }
  if (rf & 2) {
    const i_r17 = ctx.$implicit;
    \u0275\u0275conditional(0, i_r17.property.visible && i_r17.show ? 0 : -1);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, ObjectWidget_ng_template_0_Conditional_2_For_1_Template, 1, 1, null, null, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275repeater(ctx_r7.list);
  }
}
function ObjectWidget_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ObjectWidget_ng_template_0_Conditional_0_Template, 2, 1, "div", 2)(1, ObjectWidget_ng_template_0_Conditional_1_Template, 3, 1, "div", 3)(2, ObjectWidget_ng_template_0_Conditional_2_Template, 2, 0);
  }
  if (rf & 2) {
    const noTitle_r4 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275conditional(0, !noTitle_r4 && ctx_r0.title ? 0 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r0.grid ? 1 : 2);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 13);
  }
  if (rf & 2) {
    const ctx_r27 = \u0275\u0275nextContext(3);
    \u0275\u0275property("nzType", ctx_r27.expand ? "down" : "up");
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 15);
  }
  if (rf & 2) {
    const ctx_r29 = \u0275\u0275nextContext(4);
    \u0275\u0275property("nzTooltipTitle", ctx_r29.oh.text)("nzTooltipPlacement", ctx_r29.oh.placement)("nzTooltipTrigger", ctx_r29.oh.trigger)("nzTooltipColor", ctx_r29.oh.bgColor)("nzTooltipOverlayClassName", ctx_r29.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r29.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r29.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r29.oh.mouseLeaveDelay)("nzType", ctx_r29.oh.icon);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275text(1);
    \u0275\u0275template(2, ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Conditional_2_Template, 1, 9, "i", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r28 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r28.ui.optional, " ");
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, ctx_r28.oh ? 2 : -1);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r31 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275listener("click", function ObjectWidget_Conditional_2_ng_template_1_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r31);
      const ctx_r30 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r30.changeExpand());
    });
    \u0275\u0275template(1, ObjectWidget_Conditional_2_ng_template_1_Conditional_1_Template, 1, 1, "i", 11);
    \u0275\u0275text(2);
    \u0275\u0275template(3, ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Template, 3, 2, "span", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r24 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("point", ctx_r24.showExpand);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r24.showExpand ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r24.title, " ");
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, ctx_r24.ui.optional || ctx_r24.oh ? 3 : -1);
  }
}
function ObjectWidget_Conditional_2_ng_template_3_Template(rf, ctx) {
}
var _c48 = () => [];
var _c55 = () => ({
  $implicit: true
});
function ObjectWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-card", 7);
    \u0275\u0275template(1, ObjectWidget_Conditional_2_ng_template_1_Template, 4, 5, "ng-template", null, 8, \u0275\u0275templateRefExtractor)(3, ObjectWidget_Conditional_2_ng_template_3_Template, 0, 0, "ng-template", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _r25 = \u0275\u0275reference(2);
    const ctx_r2 = \u0275\u0275nextContext();
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275classProp("sf__object-card-fold", !ctx_r2.expand);
    \u0275\u0275property("nzTitle", _r25)("nzExtra", ctx_r2.ui.cardExtra)("nzSize", ctx_r2.ui.cardSize || "small")("nzActions", ctx_r2.ui.cardActions || \u0275\u0275pureFunction0(11, _c48))("nzBodyStyle", ctx_r2.ui.cardBodyStyle)("nzBordered", ctx_r2.ui.cardBordered || true)("nzBorderless", ctx_r2.ui.cardBorderless || false);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction0(12, _c55));
  }
}
function ObjectWidget_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function ObjectWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ObjectWidget_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function RadioWidget_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 2);
    \u0275\u0275element(1, "span", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r3 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzValue", option_r3.value)("nzDisabled", ctx_r2.disabled || option_r3.disabled);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", option_r3.label, \u0275\u0275sanitizeHtml);
  }
}
function RadioWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, RadioWidget_Conditional_2_For_1_Template, 2, 3, "label", 2, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275repeater(ctx_r0.data);
  }
}
function RadioWidget_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 4);
    \u0275\u0275element(1, "span", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r9 = ctx.$implicit;
    const ctx_r8 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzValue", option_r9.value)("nzDisabled", ctx_r8.disabled || option_r9.disabled);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", option_r9.label, \u0275\u0275sanitizeHtml);
  }
}
function RadioWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, RadioWidget_Conditional_3_For_1_Template, 2, 3, "label", 4, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275repeater(ctx_r1.data);
  }
}
function SelectWidget_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-option", 3);
  }
  if (rf & 2) {
    const o_r4 = ctx.$implicit;
    \u0275\u0275property("nzLabel", o_r4.label)("nzValue", o_r4.value)("nzHide", o_r4.hide)("nzDisabled", o_r4.disabled);
  }
}
function SelectWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, SelectWidget_Conditional_2_For_1_Template, 1, 4, "nz-option", 3, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275repeater(ctx_r0.data);
  }
}
function SelectWidget_Conditional_3_For_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-option", 5);
  }
  if (rf & 2) {
    const o_r16 = ctx.$implicit;
    \u0275\u0275property("nzLabel", o_r16.label)("nzValue", o_r16.value)("nzDisabled", o_r16.disabled)("nzHide", o_r16.hide);
  }
}
function SelectWidget_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-option-group", 4);
    \u0275\u0275repeaterCreate(1, SelectWidget_Conditional_3_For_1_For_2_Template, 1, 4, "nz-option", 5, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r10 = ctx.$implicit;
    \u0275\u0275property("nzLabel", i_r10.label);
    \u0275\u0275advance(1);
    \u0275\u0275repeater(i_r10.children);
  }
}
function SelectWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, SelectWidget_Conditional_3_For_1_Template, 3, 1, "nz-option-group", 4, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275repeater(ctx_r1.data);
  }
}
function SelectWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-option", 2);
    \u0275\u0275element(1, "i", 6);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r2.ui.searchLoadingText, " ");
  }
}
function StringWidget_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 3);
    \u0275\u0275listener("ngModelChange", function StringWidget_ng_template_1_Template_input_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.change($event));
    })("keyup.enter", function StringWidget_ng_template_1_Template_input_keyup_enter_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.enter($event));
    })("focus", function StringWidget_ng_template_1_Template_input_focus_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.focus($event));
    })("blur", function StringWidget_ng_template_1_Template_input_blur_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r8 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r8.blur($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("disabled", ctx_r0.disabled)("nzSize", ctx_r0.ui.size)("nzBorderless", ctx_r0.ui.borderless)("ngModel", ctx_r0.value);
    \u0275\u0275attribute("id", ctx_r0.id)("disabled", ctx_r0.disabled)("maxLength", ctx_r0.schema.maxLength || null)("type", ctx_r0.ui.type || "text")("placeholder", ctx_r0.ui.placeholder)("autocomplete", ctx_r0.ui.autocomplete)("autoFocus", ctx_r0.ui.autofocus);
  }
}
function StringWidget_Conditional_3_ng_template_1_Template(rf, ctx) {
}
function StringWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-input-group", 2);
    \u0275\u0275template(1, StringWidget_Conditional_3_ng_template_1_Template, 0, 0, "ng-template", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("nzAddOnBefore", ctx_r2.ui.addOnBefore)("nzAddOnAfter", ctx_r2.ui.addOnAfter)("nzAddOnBeforeIcon", ctx_r2.ui.addOnBeforeIcon)("nzAddOnAfterIcon", ctx_r2.ui.addOnAfterIcon)("nzPrefix", ctx_r2.ui.prefix)("nzPrefixIcon", ctx_r2.ui.prefixIcon)("nzSuffix", ctx_r2.ui.suffix)("nzSuffixIcon", ctx_r2.ui.suffixIcon);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function StringWidget_Conditional_4_ng_template_0_Template(rf, ctx) {
}
function StringWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, StringWidget_Conditional_4_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function TextWidget_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r0.text, \u0275\u0275sanitizeHtml);
  }
}
function TextWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("innerText", ctx_r1.text);
  }
}
function TextareaWidget_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "textarea", 3);
    \u0275\u0275listener("ngModelChange", function TextareaWidget_ng_template_1_Template_textarea_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.change($event));
    })("focus", function TextareaWidget_ng_template_1_Template_textarea_focus_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.focus($event));
    })("blur", function TextareaWidget_ng_template_1_Template_textarea_blur_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.blur($event));
    });
    \u0275\u0275text(1, "      ");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("disabled", ctx_r0.disabled)("nzSize", ctx_r0.ui.size)("ngModel", ctx_r0.value)("nzAutosize", ctx_r0.autosize)("nzBorderless", ctx_r0.ui.borderless);
    \u0275\u0275attribute("id", ctx_r0.id)("disabled", ctx_r0.disabled)("maxLength", ctx_r0.schema.maxLength || null)("placeholder", ctx_r0.ui.placeholder);
  }
}
function TextareaWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-textarea-count", 2)(1, "textarea", 3);
    \u0275\u0275listener("ngModelChange", function TextareaWidget_Conditional_3_Template_textarea_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r8 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r8.change($event));
    })("focus", function TextareaWidget_Conditional_3_Template_textarea_focus_1_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r10 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r10.focus($event));
    })("blur", function TextareaWidget_Conditional_3_Template_textarea_blur_1_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11.blur($event));
    });
    \u0275\u0275text(2, "        ");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("nzMaxCharacterCount", ctx_r2.ui.maxCharacterCount)("nzComputeCharacterCount", ctx_r2.ui.computeCharacterCount);
    \u0275\u0275advance(1);
    \u0275\u0275property("disabled", ctx_r2.disabled)("nzSize", ctx_r2.ui.size)("ngModel", ctx_r2.value)("nzAutosize", ctx_r2.autosize)("nzBorderless", ctx_r2.ui.borderless);
    \u0275\u0275attribute("id", ctx_r2.id)("disabled", ctx_r2.disabled)("maxLength", ctx_r2.schema.maxLength || null)("placeholder", ctx_r2.ui.placeholder);
  }
}
function TextareaWidget_Conditional_4_ng_template_0_Template(rf, ctx) {
}
function TextareaWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TextareaWidget_Conditional_4_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
var SF_DEFAULT_CONFIG = {
  formatMap: {
    "date-time": {
      widget: "date",
      showTime: true,
      format: `yyyy-MM-dd'T'HH:mm:ss.SSSxxx`
    },
    date: {
      widget: "date",
      format: "yyyy-MM-dd"
    },
    "full-date": {
      widget: "date",
      format: "yyyy-MM-dd"
    },
    time: {
      widget: "time",
      format: "HH:mm:ss.SSSxxx"
    },
    "full-time": {
      widget: "time"
    },
    week: {
      widget: "date",
      mode: "week",
      format: "yyyy-ww"
    },
    month: {
      widget: "date",
      mode: "month",
      format: "yyyy-MM"
    },
    uri: {
      widget: "upload"
    },
    email: {
      widget: "autocomplete",
      type: "email"
    },
    color: {
      widget: "string",
      type: "color"
    },
    "": {
      widget: "string"
    }
  },
  ingoreKeywords: ["type", "enum"],
  liveValidate: true,
  autocomplete: null,
  firstVisual: false,
  onlyVisual: false,
  errors: {},
  ui: {},
  button: {
    submit_type: "primary",
    reset_type: "default"
  },
  uiDateStringFormat: "yyyy-MM-dd HH:mm:ss",
  uiDateNumberFormat: "T",
  uiTimeStringFormat: "HH:mm:ss",
  uiTimeNumberFormat: "T",
  uiEmailSuffixes: ["qq.com", "163.com", "gmail.com", "126.com", "aliyun.com"],
  delay: false
};
function mergeConfig(srv) {
  return srv.merge("sf", SF_DEFAULT_CONFIG);
}
var SF_SEQ = "/";
function isBlank(o) {
  return o == null;
}
function toBool(value, defaultValue) {
  return toBoolean2(value, defaultValue);
}
function di(ui, ...args) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (ui.debug) {
      console.warn(...args);
    }
  }
}
function findSchemaDefinition($ref, definitions) {
  const match3 = /^#\/definitions\/(.*)$/.exec($ref);
  if (match3 && match3[1]) {
    const parts = match3[1].split(SF_SEQ);
    let current = definitions;
    for (let part of parts) {
      part = part.replace(/~1/g, SF_SEQ).replace(/~0/g, "~");
      if (current.hasOwnProperty(part)) {
        current = current[part];
      } else {
        throw new Error(`Could not find a definition for ${$ref}.`);
      }
    }
    return current;
  }
  throw new Error(`Could not find a definition for ${$ref}.`);
}
function retrieveSchema(schema, definitions = {}) {
  if (schema.hasOwnProperty("$ref")) {
    const $refSchema = findSchemaDefinition(schema.$ref, definitions);
    const _a = schema, {
      $ref
    } = _a, localSchema = __objRest(_a, [
      "$ref"
    ]);
    return retrieveSchema(__spreadValues(__spreadValues({}, $refSchema), localSchema), definitions);
  }
  return schema;
}
function resolveIfSchema(_schema, _ui) {
  const fn = (schema, ui) => {
    resolveIf(schema, ui);
    Object.keys(schema.properties).forEach((key) => {
      const property = schema.properties[key];
      const uiKey = `$${key}`;
      if (property.items) {
        fn(property.items, ui[uiKey].$items);
      }
      if (property.properties) {
        fn(property, ui[uiKey]);
      }
    });
  };
  fn(_schema, _ui);
}
function resolveIf(schema, ui) {
  if (!(schema.hasOwnProperty("if") && schema.hasOwnProperty("then")))
    return null;
  if (!schema.if.properties)
    throw new Error(`if: does not contain 'properties'`);
  const allKeys = Object.keys(schema.properties);
  const ifKeys = Object.keys(schema.if.properties);
  detectKey(allKeys, ifKeys);
  detectKey(allKeys, schema.then.required);
  schema.required = schema.required.concat(schema.then.required);
  const hasElse = schema.hasOwnProperty("else");
  if (hasElse) {
    detectKey(allKeys, schema.else.required);
    schema.required = schema.required.concat(schema.else.required);
  }
  const visibleIf = {};
  const visibleElse = {};
  ifKeys.forEach((key) => {
    const cond = schema.if.properties[key].enum;
    visibleIf[key] = cond;
    if (hasElse)
      visibleElse[key] = (value) => !cond.includes(value);
  });
  schema.then.required.forEach((key) => ui[`$${key}`].visibleIf = visibleIf);
  if (hasElse) {
    schema.else.required.forEach((key) => ui[`$${key}`].visibleIf = visibleElse);
  }
  return schema;
}
function detectKey(keys, detectKeys) {
  detectKeys.forEach((key) => {
    if (!keys.includes(key)) {
      throw new Error(`if: properties does not contain '${key}'`);
    }
  });
}
function orderProperties(properties, order) {
  if (!Array.isArray(order))
    return properties;
  const arrayToHash = (arr) => arr.reduce((prev, curr) => {
    prev[curr] = true;
    return prev;
  }, {});
  const errorPropList = (arr) => `property [${arr.join(`', '`)}]`;
  const propertyHash = arrayToHash(properties);
  const orderHash = arrayToHash(order);
  const extraneous = order.filter((prop) => prop !== "*" && !propertyHash[prop]);
  if (extraneous.length) {
    throw new Error(`ui schema order list contains extraneous ${errorPropList(extraneous)}`);
  }
  const rest = properties.filter((prop) => !orderHash[prop]);
  const restIndex = order.indexOf("*");
  if (restIndex === -1) {
    if (rest.length) {
      throw new Error(`ui schema order list does not contain ${errorPropList(rest)}`);
    }
    return order;
  }
  if (restIndex !== order.lastIndexOf("*")) {
    throw new Error("ui schema order list contains more than one wildcard item");
  }
  const complete = [...order];
  complete.splice(restIndex, 1, ...rest);
  return complete;
}
function getEnum(list2, formData, readOnly) {
  if (isBlank(list2) || !Array.isArray(list2) || list2.length === 0)
    return [];
  if (typeof list2[0] !== "object") {
    list2 = list2.map((item) => {
      return {
        label: item,
        value: item
      };
    });
  }
  if (formData) {
    if (!Array.isArray(formData))
      formData = [formData];
    list2.forEach((item) => {
      if (~formData.indexOf(item.value))
        item.checked = true;
    });
  }
  if (readOnly) {
    list2.forEach((item) => item.disabled = true);
  }
  return list2;
}
function getCopyEnum(list2, formData, readOnly) {
  return getEnum(deepCopy(list2 || []), formData, readOnly);
}
function getData(schema, ui, formData, asyncArgs) {
  if (typeof ui.asyncData === "function") {
    return ui.asyncData(asyncArgs).pipe(map((list2) => getEnum(list2, formData, schema.readOnly)));
  }
  return of(getCopyEnum(schema.enum, formData, schema.readOnly));
}
var FormProperty = class {
  constructor(injector, schemaValidatorFactory, schema, ui, formData, parent, path, _options) {
    this.injector = injector;
    this._options = _options;
    this._errors = null;
    this._valueChanges = new BehaviorSubject({
      path: null,
      pathValue: null,
      value: null
    });
    this._errorsChanges = new BehaviorSubject(null);
    this._visible = true;
    this._visibilityChanges = new BehaviorSubject(true);
    this._objErrors = {};
    this._value = null;
    this.schema = schema;
    this.ui = ui;
    this.schemaValidator = schemaValidatorFactory.createValidatorFn(schema, {
      ingoreKeywords: this.ui.ingoreKeywords,
      debug: ui.debug
    });
    this.formData = formData || schema.default;
    this._parent = parent;
    if (parent) {
      this._root = parent.root;
    } else {
      this._root = this;
    }
    this.path = path;
  }
  get valueChanges() {
    return this._valueChanges;
  }
  get errorsChanges() {
    return this._errorsChanges;
  }
  get type() {
    return this.schema.type;
  }
  get parent() {
    return this._parent;
  }
  get root() {
    return this._root;
  }
  get value() {
    return this._value;
  }
  get errors() {
    return this._errors;
  }
  get visible() {
    return this._visible;
  }
  get valid() {
    return this._errors === null || this._errors.length === 0;
  }
  get options() {
    return this._options;
  }
  cd(onlySelf = false) {
    this.widget?.detectChanges(onlySelf);
  }
  /**
   * 更新值且校验数据
   */
  updateValueAndValidity(options) {
    options = __spreadValues({
      onlySelf: false,
      emitValidator: true,
      emitValueEvent: true,
      updatePath: "",
      updateValue: null
    }, options);
    this._updateValue();
    if (options.emitValueEvent) {
      options.updatePath = options.updatePath || this.path;
      options.updateValue = options.updateValue == null ? this.value : options.updateValue;
      this.valueChanges.next({
        value: this.value,
        path: options.updatePath,
        pathValue: options.updateValue
      });
    }
    if (options.emitValidator && this.ui.liveValidate === true) {
      this._runValidation();
    }
    if (this.parent && !options.onlySelf) {
      this.parent.updateValueAndValidity(__spreadProps(__spreadValues({}, options), {
        emitValidator: false
      }));
    }
  }
  /** 根据路径搜索表单属性 */
  searchProperty(path) {
    let prop = this;
    let base = null;
    let result = null;
    if (path[0] === SF_SEQ) {
      base = this.findRoot();
      result = base.getProperty(path.substring(1));
    } else {
      while (result === null && prop.parent !== null) {
        prop = base = prop.parent;
        result = base.getProperty(path);
      }
    }
    return result;
  }
  /** 查找根表单属性 */
  findRoot() {
    let property = this;
    while (property.parent !== null) {
      property = property.parent;
    }
    return property;
  }
  // #region process errors
  isEmptyData(value) {
    if (isBlank(value))
      return true;
    switch (this.type) {
      case "string":
        return `${value}`.length === 0;
    }
    return false;
  }
  /**
   * @internal
   */
  _runValidation() {
    let errors;
    const isEmpty2 = this.isEmptyData(this._value);
    if (isEmpty2 && this.ui._required) {
      errors = [{
        keyword: "required"
      }];
    } else if (isEmpty2) {
      errors = [];
    } else {
      errors = this.schemaValidator(this._value) || [];
    }
    const customValidator = this.ui.validator;
    if (typeof customValidator === "function") {
      const customErrors = customValidator(this.value, this, this.findRoot());
      if (customErrors instanceof Observable) {
        customErrors.subscribe((res) => {
          this.setCustomErrors(errors, res);
          this.cd(false);
        });
        return;
      }
      this.setCustomErrors(errors, customErrors);
      return;
    }
    this._errors = errors;
    this.setErrors(this._errors);
  }
  setCustomErrors(errors, list2) {
    const hasCustomError = Array.isArray(list2) && list2.length > 0;
    if (hasCustomError) {
      list2.forEach((err) => {
        if (!err.message) {
          throw new Error(`The custom validator must contain a 'message' attribute to viewed error text`);
        }
        err.keyword = null;
      });
    }
    this._errors = hasCustomError ? errors.concat(...list2) : errors;
    this.setErrors(this._errors);
  }
  /**
   * Set the current error message
   *
   * 设置当前错误消息
   *
   * @param emitFormat 若提供的消息带有 `{xx}` 会自动根据参数进行转化，包含自定义函数
   *
   * @example
   *
   * this.sf.getProperty('/name')?.setErrors({ keyword: 'required' });
   * this.sf.getProperty('/name')?.setErrors({ message: 'Please input your username!' });
   * this.sf.getProperty('/name')?.setErrors(); // Clean error
   */
  setErrors(errors = [], emitFormat = true) {
    let arrErrs = Array.isArray(errors) ? errors : [errors];
    if (emitFormat && arrErrs && !this.ui.onlyVisual) {
      const l = this.widget && this.widget.l.error || {};
      arrErrs = arrErrs.map((err) => {
        let message = err.keyword == null && err.message ? err.message : (this.ui.errors || {})[err.keyword] || this._options.errors[err.keyword] || l[err.keyword] || ``;
        if (message && typeof message === "function") {
          message = message(err);
        }
        if (message) {
          if (~message.indexOf("{") && err.params) {
            message = message.replace(/{([\.a-zA-Z0-9]+)}/g, (_v, key) => err.params[key] || "");
          }
          err.message = message;
        }
        return err;
      });
    }
    this._errors = arrErrs;
    this._errorsChanges.next(arrErrs);
    if (this._parent) {
      this._parent.setParentAndPlatErrors(arrErrs, this.path);
    }
  }
  setParentAndPlatErrors(errors, path) {
    this._objErrors[path] = errors;
    const platErrors = [];
    Object.keys(this._objErrors).forEach((p) => {
      const property = this.searchProperty(p);
      if (property && !property.visible)
        return;
      platErrors.push(...this._objErrors[p]);
    });
    this.setErrors(platErrors, false);
  }
  // #endregion
  // #region condition
  /**
   * Set the hide or display of widget
   * 设置小部件的隐藏或显示
   */
  setVisible(visible) {
    this._visible = visible;
    this._visibilityChanges.next(visible);
    if (visible) {
      this.injector.get(NgZone).onStable.pipe(take(1)).subscribe(() => {
        this.resetValue(this.value, true);
      });
    }
    return this;
  }
  _bindVisibility() {
    const visibleIf = this.ui.visibleIf;
    if (typeof visibleIf === "object" && Object.keys(visibleIf).length === 0) {
      this.setVisible(false);
    } else if (visibleIf != null) {
      const propertiesBinding = [];
      for (const dependencyPath in visibleIf) {
        if (visibleIf.hasOwnProperty(dependencyPath)) {
          const property = this.searchProperty(dependencyPath);
          if (property) {
            const valueCheck = property.valueChanges.pipe(map((res) => {
              const vi = visibleIf[dependencyPath];
              if (typeof vi === "function") {
                const viFnRes = vi(res.value, property);
                if (typeof viFnRes === "object") {
                  const fixViFnRes = __spreadValues({
                    show: false,
                    required: false
                  }, viFnRes);
                  const parentRequired = this.parent?.schema.required;
                  if (parentRequired && this.propertyId) {
                    const idx = parentRequired.findIndex((w) => w === this.propertyId);
                    if (fixViFnRes.required) {
                      if (idx === -1)
                        parentRequired.push(this.propertyId);
                    } else {
                      if (idx !== -1)
                        parentRequired.splice(idx, 1);
                    }
                    this.ui._required = fixViFnRes.required;
                  }
                  return fixViFnRes.show;
                }
                return viFnRes;
              }
              if (vi.indexOf("$ANY$") !== -1) {
                return res.value && res.value.length > 0;
              } else {
                return vi.indexOf(res.value) !== -1;
              }
            }));
            const visibilityCheck = property._visibilityChanges;
            const and = combineLatest([valueCheck, visibilityCheck]).pipe(map((results) => results[0] && results[1]));
            propertiesBinding.push(and);
          } else {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              console.warn(`Can't find property ${dependencyPath} for visibility check of ${this.path}`);
            }
          }
        }
      }
      combineLatest(propertiesBinding).pipe(map((values) => this.ui.visibleIfLogical === "and" ? values.every((v) => v) : values.some((v) => v)), distinctUntilChanged()).subscribe((visible) => this.setVisible(visible));
    }
  }
  // #endregion
  updateFeedback(status = "") {
    this.ui.feedback = status;
    this.widget?.injector.get(NzFormStatusService).formStatusChanges.next({
      status,
      hasFeedback: !!status
    });
    this.cd(true);
  }
};
var PropertyGroup = class _PropertyGroup extends FormProperty {
  constructor() {
    super(...arguments);
    this.properties = null;
  }
  getProperty(path) {
    const subPathIdx = path.indexOf(SF_SEQ);
    const propertyId = subPathIdx !== -1 ? path.substring(0, subPathIdx) : path;
    let property = this.properties[propertyId];
    if (property !== null && subPathIdx !== -1 && property instanceof _PropertyGroup) {
      const subPath = path.substring(subPathIdx + 1);
      property = property.getProperty(subPath);
    }
    return property;
  }
  forEachChild(fn) {
    for (const propertyId in this.properties) {
      if (this.properties.hasOwnProperty(propertyId)) {
        const property = this.properties[propertyId];
        fn(property, propertyId);
      }
    }
  }
  forEachChildRecursive(fn) {
    this.forEachChild((child) => {
      fn(child);
      if (child instanceof _PropertyGroup) {
        child.forEachChildRecursive(fn);
      }
    });
  }
  _bindVisibility() {
    super._bindVisibility();
    this._bindVisibilityRecursive();
  }
  _bindVisibilityRecursive() {
    this.forEachChildRecursive((property) => {
      property._bindVisibility();
    });
  }
  isRoot() {
    return this === this.root;
  }
};
var ObjectProperty = class extends PropertyGroup {
  get propertiesId() {
    return this._propertiesId;
  }
  constructor(injector, formPropertyFactory, schemaValidatorFactory, schema, ui, formData, parent, path, options) {
    super(injector, schemaValidatorFactory, schema, ui, formData, parent, path, options);
    this.formPropertyFactory = formPropertyFactory;
    this._propertiesId = [];
    this.createProperties();
  }
  createProperties() {
    this.properties = {};
    this._propertiesId = [];
    let orderedProperties;
    try {
      orderedProperties = orderProperties(Object.keys(this.schema.properties), this.ui.order);
    } catch (e) {
      console.error(`Invalid ${this.schema.title || "root"} object field configuration:`, e);
    }
    orderedProperties.forEach((propertyId) => {
      this.properties[propertyId] = this.formPropertyFactory.createProperty(this.schema.properties[propertyId], this.ui[`$${propertyId}`], (this.formData || {})[propertyId], this, propertyId);
      this._propertiesId.push(propertyId);
    });
  }
  setValue(value, onlySelf) {
    const properties = this.properties;
    for (const propertyId in value) {
      if (value.hasOwnProperty(propertyId) && properties[propertyId]) {
        properties[propertyId].setValue(value[propertyId], true);
      }
    }
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    value = value || this.schema.default || {};
    const properties = this.properties;
    for (const propertyId in this.schema.properties) {
      if (this.schema.properties.hasOwnProperty(propertyId)) {
        properties[propertyId].resetValue(value[propertyId], true);
      }
    }
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  _hasValue() {
    return this.value != null && !!Object.keys(this.value).length;
  }
  _updateValue() {
    const value = {};
    this.forEachChild((property, propertyId) => {
      if (property.visible && property._hasValue()) {
        value[propertyId] = property.value;
      }
    });
    this._value = value;
  }
};
var ArrayProperty = class extends PropertyGroup {
  constructor(injector, formPropertyFactory, schemaValidatorFactory, schema, ui, formData, parent, path, options) {
    super(injector, schemaValidatorFactory, schema, ui, formData, parent, path, options);
    this.formPropertyFactory = formPropertyFactory;
    this.properties = [];
  }
  getProperty(path) {
    const subPathIdx = path.indexOf(SF_SEQ);
    const pos = +(subPathIdx !== -1 ? path.substring(0, subPathIdx) : path);
    const list2 = this.properties;
    if (isNaN(pos) || pos >= list2.length) {
      return void 0;
    }
    const subPath = path.substring(subPathIdx + 1);
    return list2[pos].getProperty(subPath);
  }
  setValue(value, onlySelf) {
    this.properties = [];
    this.clearErrors();
    this.resetProperties(value);
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    this._value = value || this.schema.default || [];
    this.setValue(this._value, onlySelf);
  }
  _hasValue() {
    return true;
  }
  _updateValue() {
    const value = [];
    this.forEachChild((property) => {
      if (property.visible) {
        value.push(__spreadValues(__spreadValues({}, this.widget?.cleanValue ? null : property.formData), property.value));
      }
    });
    this._value = value;
  }
  addProperty(formData) {
    const newProperty = this.formPropertyFactory.createProperty(deepCopy(this.schema.items), deepCopy(this.ui.$items), formData, this);
    this.properties.push(newProperty);
    return newProperty;
  }
  resetProperties(formDatas) {
    for (const item of formDatas) {
      const property = this.addProperty(item);
      property.resetValue(item, true);
    }
  }
  clearErrors(property) {
    (property || this)._objErrors = {};
  }
  // #region actions
  add(formData) {
    const newProperty = this.addProperty(formData);
    newProperty.resetValue(formData, false);
    return newProperty;
  }
  remove(index) {
    const list2 = this.properties;
    this.clearErrors();
    list2.splice(index, 1);
    list2.forEach((property, idx) => {
      property.path = [property.parent.path, idx].join(SF_SEQ);
      this.clearErrors(property);
      if (property instanceof ObjectProperty) {
        property.forEachChild((p) => {
          p.updateValueAndValidity();
        });
      }
    });
    if (list2.length === 0) {
      this.updateValueAndValidity();
    }
  }
};
var AtomicProperty = class extends FormProperty {
  setValue(value, onlySelf) {
    this._value = value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    if (value == null) {
      value = this.schema.default !== void 0 ? this.schema.default : this.fallbackValue();
    }
    this._value = value;
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
    if (this.widget) {
      this.widget.reset(value);
      this.cd(onlySelf);
    }
  }
  _hasValue() {
    return this.fallbackValue() !== this.value;
  }
  _updateValue() {
  }
};
var BooleanProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
};
var NumberProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
  setValue(value, onlySelf) {
    if (typeof value === "string") {
      if (value.length) {
        value = value.indexOf(".") > -1 ? parseFloat(value) : parseInt(value, 10);
      } else {
        value = void 0;
      }
    }
    this._value = value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
};
var StringProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
  setValue(value, onlySelf) {
    this._value = value == null ? "" : value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
};
var FormPropertyFactory = class {
  constructor(injector, schemaValidatorFactory, cogSrv) {
    this.injector = injector;
    this.schemaValidatorFactory = schemaValidatorFactory;
    this.options = mergeConfig(cogSrv);
  }
  createProperty(schema, ui, formData, parent = null, propertyId) {
    let newProperty = null;
    let path = "";
    if (parent) {
      path += parent.path;
      if (parent.parent !== null) {
        path += SF_SEQ;
      }
      switch (parent.type) {
        case "object":
          path += propertyId;
          break;
        case "array":
          path += parent.properties.length;
          break;
        default:
          throw new Error(`Instanciation of a FormProperty with an unknown parent type: ${parent.type}`);
      }
    } else {
      path = SF_SEQ;
    }
    if (schema.$ref) {
      const refSchema = retrieveSchema(schema, parent.root.schema.definitions);
      newProperty = this.createProperty(refSchema, ui, formData, parent, path);
    } else {
      if (propertyId && parent.schema.required.indexOf(propertyId.split(SF_SEQ).pop()) !== -1 || ui.showRequired === true) {
        ui._required = true;
      }
      if (schema.title == null) {
        schema.title = propertyId;
      }
      if ((schema.type === "string" || schema.type === "number") && !schema.format && !ui.format) {
        if (ui.widget === "date")
          ui._format = schema.type === "string" ? this.options.uiDateStringFormat : this.options.uiDateNumberFormat;
        else if (ui.widget === "time")
          ui._format = schema.type === "string" ? this.options.uiTimeStringFormat : this.options.uiTimeNumberFormat;
      } else {
        ui._format = ui.format;
      }
      switch (schema.type) {
        case "integer":
        case "number":
          newProperty = new NumberProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "string":
          newProperty = new StringProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "boolean":
          newProperty = new BooleanProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "object":
          newProperty = new ObjectProperty(this.injector, this, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "array":
          newProperty = new ArrayProperty(this.injector, this, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        default:
          throw new TypeError(`Undefined type ${schema.type}`);
      }
    }
    newProperty.propertyId = propertyId;
    if (newProperty instanceof PropertyGroup) {
      this.initializeRoot(newProperty);
    }
    return newProperty;
  }
  initializeRoot(rootProperty) {
    rootProperty._bindVisibility();
  }
};
var TerminatorService = class {
  constructor() {
    this.onDestroy = new Subject();
  }
  destroy() {
    this.onDestroy.next(true);
  }
};
var _SchemaValidatorFactory = class _SchemaValidatorFactory {
};
_SchemaValidatorFactory.\u0275fac = function SchemaValidatorFactory_Factory(t) {
  return new (t || _SchemaValidatorFactory)();
};
_SchemaValidatorFactory.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _SchemaValidatorFactory,
  factory: _SchemaValidatorFactory.\u0275fac
});
var SchemaValidatorFactory = _SchemaValidatorFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchemaValidatorFactory, [{
    type: Injectable
  }], null, null);
})();
var _AjvSchemaValidatorFactory = class _AjvSchemaValidatorFactory extends SchemaValidatorFactory {
  constructor(cogSrv, ngZone) {
    super();
    this.ngZone = ngZone;
    if (!(typeof document === "object" && !!document)) {
      return;
    }
    this.options = mergeConfig(cogSrv);
    const customOptions = this.options.ajv || {};
    this.ngZone.runOutsideAngular(() => {
      this.ajv = new import_ajv.default(__spreadProps(__spreadValues({
        allErrors: true,
        loopEnum: 50
      }, customOptions), {
        formats: __spreadValues({
          "data-url": /^data:([a-z]+\/[a-z0-9-+.]+)?;name=(.*);base64,(.*)$/,
          color: REGEX.color,
          mobile: REGEX.mobile,
          "id-card": REGEX.idCard
        }, customOptions.formats)
      }));
      (0, import_ajv_formats.default)(this.ajv);
    });
  }
  createValidatorFn(schema, extraOptions) {
    const ingoreKeywords = [...this.options.ingoreKeywords, ...extraOptions.ingoreKeywords || []];
    return (value) => {
      try {
        this.ngZone.runOutsideAngular(() => this.ajv.validate(schema, value));
      } catch (e) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (extraOptions.debug) {
            console.warn(e);
          }
        }
      }
      let errors = this.ajv.errors;
      if (this.options && ingoreKeywords && errors) {
        errors = errors.filter((w) => ingoreKeywords.indexOf(w.keyword) === -1);
      }
      return errors;
    };
  }
};
_AjvSchemaValidatorFactory.\u0275fac = function AjvSchemaValidatorFactory_Factory(t) {
  return new (t || _AjvSchemaValidatorFactory)(\u0275\u0275inject(AlainConfigService), \u0275\u0275inject(NgZone));
};
_AjvSchemaValidatorFactory.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _AjvSchemaValidatorFactory,
  factory: _AjvSchemaValidatorFactory.\u0275fac
});
var AjvSchemaValidatorFactory = _AjvSchemaValidatorFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AjvSchemaValidatorFactory, [{
    type: Injectable
  }], () => [{
    type: AlainConfigService,
    decorators: [{
      type: Inject,
      args: [AlainConfigService]
    }]
  }, {
    type: NgZone
  }], null);
})();
var WidgetRegistry = class {
  constructor() {
    this._widgets = {};
  }
  get widgets() {
    return this._widgets;
  }
  setDefault(widget) {
    this.defaultWidget = widget;
  }
  register(type, widget) {
    this._widgets[type] = widget;
  }
  has(type) {
    return this._widgets.hasOwnProperty(type);
  }
  getType(type) {
    if (this.has(type)) {
      return this._widgets[type];
    }
    return this.defaultWidget;
  }
};
var _WidgetFactory = class _WidgetFactory {
  constructor(registry) {
    this.registry = registry;
  }
  createWidget(container, type) {
    if (!this.registry.has(type)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        console.warn(`No widget for type "${type}"`);
      }
    }
    const componentClass = this.registry.getType(type);
    return container.createComponent(componentClass);
  }
};
_WidgetFactory.\u0275fac = function WidgetFactory_Factory(t) {
  return new (t || _WidgetFactory)(\u0275\u0275inject(WidgetRegistry));
};
_WidgetFactory.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _WidgetFactory,
  factory: _WidgetFactory.\u0275fac
});
var WidgetFactory = _WidgetFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WidgetFactory, [{
    type: Injectable
  }], () => [{
    type: WidgetRegistry
  }], null);
})();
var nextUniqueId = 0;
var _SFItemComponent = class _SFItemComponent {
  constructor(widgetFactory, terminator) {
    this.widgetFactory = widgetFactory;
    this.terminator = terminator;
    this.destroy$ = new Subject();
    this.widget = null;
    this.footer = null;
  }
  onWidgetInstanciated(widget) {
    this.widget = widget;
    const id = `_sf-${nextUniqueId++}`;
    const ui = this.formProperty.ui;
    this.widget.formProperty = this.formProperty;
    this.widget.schema = this.formProperty.schema;
    this.widget.ui = ui;
    this.widget.id = id;
    this.formProperty.widget = widget;
  }
  ngOnInit() {
    this.terminator.onDestroy.subscribe(() => this.ngOnDestroy());
  }
  ngOnChanges() {
    const p = this.formProperty;
    this.ref = this.widgetFactory.createWidget(this.container, p.ui.widget || p.schema.type);
    this.onWidgetInstanciated(this.ref.instance);
  }
  ngOnDestroy() {
    const {
      destroy$
    } = this;
    destroy$.next();
    destroy$.complete();
    this.ref.destroy();
  }
};
_SFItemComponent.\u0275fac = function SFItemComponent_Factory(t) {
  return new (t || _SFItemComponent)(\u0275\u0275directiveInject(WidgetFactory), \u0275\u0275directiveInject(TerminatorService));
};
_SFItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SFItemComponent,
  selectors: [["sf-item"]],
  viewQuery: function SFItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c024, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.container = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function SFItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("sf__item", true);
    }
  },
  inputs: {
    formProperty: "formProperty",
    footer: "footer"
  },
  exportAs: ["sfItem"],
  features: [\u0275\u0275ProvidersFeature([NzFormStatusService]), \u0275\u0275NgOnChangesFeature],
  decls: 3,
  vars: 1,
  consts: [["target", ""], [4, "ngTemplateOutlet"]],
  template: function SFItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, SFItemComponent_ng_template_0_Template, 0, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, SFItemComponent_ng_container_2_Template, 1, 0, "ng-container", 1);
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngTemplateOutlet", ctx.footer);
    }
  },
  dependencies: [NgTemplateOutlet],
  encapsulation: 2
});
var SFItemComponent = _SFItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFItemComponent, [{
    type: Component,
    args: [{
      selector: "sf-item",
      exportAs: "sfItem",
      host: {
        "[class.sf__item]": "true"
      },
      template: `
    <ng-template #target />
    <ng-container *ngTemplateOutlet="footer" />
  `,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      providers: [NzFormStatusService]
    }]
  }], () => [{
    type: WidgetFactory
  }, {
    type: TerminatorService
  }], {
    formProperty: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    container: [{
      type: ViewChild,
      args: ["target", {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var _SFFixedDirective = class _SFFixedDirective {
  init() {
    if (!this._inited || this.num == null || this.num <= 0)
      return;
    const el = this.el.nativeElement;
    const widgetEl = el.querySelector(".ant-row") || el;
    this.render.addClass(widgetEl, "sf__fixed");
    const labelEl = widgetEl.querySelector(".ant-form-item-label");
    const controlEl = widgetEl.querySelector(".ant-form-item-control-wrapper,.ant-form-item-control");
    const unit = `${this.num}px`;
    if (labelEl) {
      this.render.setStyle(labelEl, "flex", `0 0 ${unit}`);
      this.render.setStyle(controlEl, "max-width", `calc(100% - ${unit})`);
    } else {
      this.render.setStyle(controlEl, "margin-left", unit);
    }
  }
  constructor(el, render) {
    this.el = el;
    this.render = render;
    this._inited = false;
  }
  ngAfterViewInit() {
    this._inited = true;
    this.init();
  }
  ngOnChanges() {
    if (this._inited)
      this.init();
  }
};
_SFFixedDirective.\u0275fac = function SFFixedDirective_Factory(t) {
  return new (t || _SFFixedDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
_SFFixedDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SFFixedDirective,
  selectors: [["", "fixed-label", ""]],
  inputs: {
    num: ["fixed-label", "num"]
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var SFFixedDirective = _SFFixedDirective;
__decorate([InputNumber2()], SFFixedDirective.prototype, "num", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFFixedDirective, [{
    type: Directive,
    args: [{
      selector: "[fixed-label]"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    num: [{
      type: Input,
      args: ["fixed-label"]
    }]
  });
})();
function useFactory(injector, schemaValidatorFactory, cogSrv) {
  return new FormPropertyFactory(injector, schemaValidatorFactory, cogSrv);
}
var _SFComponent = class _SFComponent {
  get btnGrid() {
    return this._btn.render.grid;
  }
  /**
   * Form default mode, will force override `layout`, `firstVisual`, `liveValidate` parameters
   *
   * 表单预设模式，会强制覆盖 `layout`，`firstVisual`，`liveValidate` 参数
   */
  set mode(value) {
    switch (value) {
      case "search":
        this.layout = "inline";
        this.firstVisual = false;
        this.liveValidate = false;
        if (this._btn) {
          this._btn.submit = this._btn.search;
        }
        break;
      case "edit":
        this.layout = "horizontal";
        this.firstVisual = false;
        this.liveValidate = true;
        if (this._btn) {
          this._btn.submit = this._btn.edit;
        }
        break;
    }
    this._mode = value;
  }
  get mode() {
    return this._mode;
  }
  // #endregion
  /**
   * Whether the form is valid
   *
   * 表单是否有效
   */
  get valid() {
    return this._valid;
  }
  /**
   * The value of the form
   *
   * 表单值
   */
  get value() {
    return this._item;
  }
  /**
   * Get form element property based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)获取表单元素属性
   */
  getProperty(path) {
    return this.rootProperty?.searchProperty(path);
  }
  /**
   * Get element value based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)获取表单元素值
   */
  getValue(path) {
    return this.getProperty(path)?.value;
  }
  /**
   * Set form element new value based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)设置某个表单元素属性值
   */
  setValue(path, value) {
    const item = this.getProperty(path);
    if (!item) {
      throw new Error(`Invalid path: ${path}`);
    }
    item.resetValue(value, false);
    return this;
  }
  /**
   * Update the feedback status of the widget
   *
   * 更新小部件的反馈状态
   *
   * ```ts
   * // Validate status of the widget
   * this.sf.updateFeedback('/name', 'validating');
   * // Clean validate status of the widget
   * this.sf.updateFeedback('/name');
   * ```
   */
  updateFeedback(path, status = "") {
    this.getProperty(path)?.updateFeedback(status);
    return this;
  }
  onSubmit(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!this.liveValidate)
      this.validator();
    if (!this.valid)
      return;
    this.formSubmit.emit(this.value);
  }
  constructor(formPropertyFactory, terminator, dom, cdr, localeSrv, aclSrv, i18nSrv, cogSrv, platform) {
    this.formPropertyFactory = formPropertyFactory;
    this.terminator = terminator;
    this.dom = dom;
    this.cdr = cdr;
    this.localeSrv = localeSrv;
    this.aclSrv = aclSrv;
    this.i18nSrv = i18nSrv;
    this.platform = platform;
    this._renders = /* @__PURE__ */ new Map();
    this._valid = true;
    this._inited = false;
    this.locale = {};
    this.rootProperty = null;
    this.layout = "horizontal";
    this.button = {};
    this.liveValidate = true;
    this.firstVisual = true;
    this.onlyVisual = false;
    this.compact = false;
    this.loading = false;
    this.disabled = false;
    this.noColon = false;
    this.cleanValue = false;
    this.delay = false;
    this.formValueChange = new EventEmitter();
    this.formChange = new EventEmitter();
    this.formSubmit = new EventEmitter();
    this.formReset = new EventEmitter();
    this.formError = new EventEmitter();
    this.options = mergeConfig(cogSrv);
    this.liveValidate = this.options.liveValidate;
    this.firstVisual = this.options.firstVisual;
    this.autocomplete = this.options.autocomplete;
    this.delay = this.options.delay;
    this.localeSrv.change.pipe(takeUntilDestroyed()).subscribe(() => {
      this.locale = this.localeSrv.getData("sf");
      if (this._inited) {
        this.validator({
          emitError: false,
          onlyRoot: false
        });
        this.coverButtonProperty();
        this.cdr.markForCheck();
      }
    });
    const refSchemas = [this.aclSrv ? this.aclSrv.change : null, this.i18nSrv ? this.i18nSrv.change : null].filter((o) => o != null);
    if (refSchemas.length > 0) {
      merge(...refSchemas).pipe(filter(() => this._inited), takeUntilDestroyed()).subscribe(() => this.refreshSchema());
    }
  }
  fanyi(key) {
    return (this.i18nSrv ? this.i18nSrv.fanyi(key) : "") || key;
  }
  inheritUI(ui) {
    ["optionalHelp"].filter((key) => !!this._defUi[key]).forEach((key) => ui[key] = __spreadValues(__spreadValues({}, this._defUi[key]), ui[key]));
  }
  coverProperty() {
    const isHorizontal = this.layout === "horizontal";
    const _schema = deepCopy(this.schema);
    const {
      definitions
    } = _schema;
    const inFn = (schema, _parentSchema, uiSchema, parentUiSchema, uiRes) => {
      if (!Array.isArray(schema.required))
        schema.required = [];
      Object.keys(schema.properties).forEach((key) => {
        const uiKeyPrefix = "$";
        const uiKey = uiKeyPrefix + key;
        const property = retrieveSchema(schema.properties[key], definitions);
        const curUi = __spreadValues(__spreadValues({}, property.ui), uiSchema[uiKey]);
        const ui = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues({}, this._defUi), parentUiSchema), {
          // 忽略部分会引起呈现的属性
          visibleIf: void 0,
          hidden: void 0,
          optional: void 0,
          optionalHelp: void 0,
          widget: property.type
        }), property.format && this.options.formatMap[property.format]), typeof property.ui === "string" ? {
          widget: property.ui
        } : null), !property.format && !property.ui && Array.isArray(property.enum) && property.enum.length > 0 ? {
          widget: "select"
        } : null), curUi);
        Object.keys(ui).filter((key2) => key2.startsWith(uiKeyPrefix)).forEach((key2) => delete ui[key2]);
        if (isHorizontal) {
          if (parentUiSchema.spanLabelFixed) {
            if (!curUi.spanLabelFixed) {
              ui.spanLabelFixed = parentUiSchema.spanLabelFixed;
            }
          } else {
            if (!ui.spanLabel)
              ui.spanLabel = typeof parentUiSchema.spanLabel === "undefined" ? 5 : parentUiSchema.spanLabel;
            if (!ui.spanControl)
              ui.spanControl = typeof parentUiSchema.spanControl === "undefined" ? 19 : parentUiSchema.spanControl;
            if (!ui.offsetControl)
              ui.offsetControl = typeof parentUiSchema.offsetControl === "undefined" ? null : parentUiSchema.offsetControl;
          }
        } else {
          ui.spanLabel = null;
          ui.spanControl = null;
          ui.offsetControl = null;
        }
        if (this.layout === "inline") {
          delete ui.grid;
        }
        if (this.layout !== "horizontal") {
          ui.spanLabelFixed = null;
        }
        if (ui.spanLabelFixed != null && ui.spanLabelFixed > 0) {
          ui.spanLabel = null;
          ui.spanControl = null;
        }
        if (ui.widget === "date" && ui.end != null) {
          const dateEndProperty = schema.properties[ui.end];
          if (dateEndProperty) {
            dateEndProperty.ui = __spreadProps(__spreadValues({}, dateEndProperty.ui), {
              widget: ui.widget,
              hidden: true
            });
          } else {
            ui.end = null;
          }
        }
        this.inheritUI(ui);
        if (ui.optionalHelp) {
          if (typeof ui.optionalHelp === "string") {
            ui.optionalHelp = {
              text: ui.optionalHelp
            };
          }
          const oh = ui.optionalHelp = __spreadValues({
            text: "",
            icon: "question-circle",
            placement: "top",
            trigger: "hover",
            mouseEnterDelay: 0.15,
            mouseLeaveDelay: 0.1
          }, ui.optionalHelp);
          if (oh.i18n) {
            oh.text = this.fanyi(oh.i18n);
          }
          if (!oh.text) {
            ui.optionalHelp = void 0;
          }
        }
        if (ui.i18n) {
          property.title = this.fanyi(ui.i18n);
        }
        if (ui.descriptionI18n) {
          property.description = this.fanyi(ui.descriptionI18n);
        }
        if (property.description) {
          ui._description = this.dom.bypassSecurityTrustHtml(property.description);
        }
        ui.hidden = typeof ui.hidden === "boolean" ? ui.hidden : false;
        if (ui.hidden === false && ui.acl && this.aclSrv && !this.aclSrv.can(ui.acl)) {
          ui.hidden = true;
        }
        uiRes[uiKey] = ui;
        delete property.ui;
        if (ui.hidden === true) {
          const idx = schema.required.indexOf(key);
          if (idx !== -1) {
            schema.required.splice(idx, 1);
          }
        }
        if (property.items) {
          ui.$items = __spreadValues(__spreadValues(__spreadValues({}, property.items.ui), uiSchema[uiKey]), ui.$items);
          inFn(property.items, property.items, uiSchema[uiKey]?.$items ?? {}, ui.$items, ui.$items);
        }
        if (property.properties && Object.keys(property.properties).length) {
          inFn(property, schema, uiSchema[uiKey] || {}, ui, ui);
        }
      });
    };
    if (this.ui == null)
      this.ui = {};
    this._defUi = __spreadValues(__spreadValues(__spreadValues({
      onlyVisual: this.options.onlyVisual,
      size: this.options.size,
      liveValidate: this.liveValidate
    }, this.options.ui), _schema.ui), this.ui["*"]);
    if (this.onlyVisual === true) {
      this._defUi.onlyVisual = true;
    }
    if (this.layout === "inline") {
      delete this._defUi.grid;
    }
    this._ui = __spreadValues({}, this._defUi);
    inFn(_schema, _schema, this.ui, this.ui, this._ui);
    resolveIfSchema(_schema, this._ui);
    this._schema = _schema;
    delete _schema.ui;
    di(this._ui, "cover schema & ui", this._ui, _schema);
  }
  coverButtonProperty() {
    this._btn = __spreadValues(__spreadValues(__spreadValues({
      render: {
        size: "default"
      }
    }, this.locale), this.options.button), this.button);
    const firstKey = Object.keys(this._ui).find((w) => w.startsWith("$"));
    const btnRender = this._btn.render;
    if (this.layout === "horizontal") {
      const btnUi = firstKey ? this._ui[firstKey] : this._defUi;
      if (!btnRender.grid) {
        btnRender.grid = {
          offset: btnUi.spanLabel,
          span: btnUi.spanControl
        };
      }
      if (btnRender.spanLabelFixed == null) {
        btnRender.spanLabelFixed = btnUi.spanLabelFixed;
      }
      if (!btnRender.class && typeof btnUi.spanLabelFixed === "number" && btnUi.spanLabelFixed > 0) {
        btnRender.class = "text-center";
      }
    } else {
      btnRender.grid = {};
    }
    if (this._mode) {
      this.mode = this._mode;
    }
    di(this._ui, "button property", this._btn);
  }
  ngOnInit() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.validator();
    this._inited = true;
  }
  ngOnChanges(changes) {
    if (!this.platform.isBrowser) {
      return;
    }
    const ingoreRender = ["disabled", "loading"];
    if (Object.keys(changes).every((key) => ingoreRender.includes(key))) {
      this.cdr.detectChanges();
      return;
    }
    if (!this.delay) {
      this.refreshSchema();
    }
  }
  /** @internal */
  _addTpl(path, templateRef) {
    if (!this._inited) {
      return;
    }
    if (this._renders.has(path)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        console.warn(`Duplicate definition "${path}" custom widget`);
      }
      return;
    }
    this._renders.set(path, templateRef);
    this.attachCustomRender();
  }
  attachCustomRender() {
    this._renders.forEach((tpl, path) => {
      const property = this.rootProperty?.searchProperty(path);
      if (property == null) {
        return;
      }
      property.ui._render = tpl;
    });
  }
  /**
   * Validator the form is valid
   *
   * 校验表单是否有效
   * - `emitError` 当表单无效时是否触发 `formError` 事件，默认：`true`
   * - `onlyRoot` 只对根进行检验，不进行向下逐个递归，根已经包含整个 Json Schema，默认：`true`
   */
  validator(options = {
    emitError: true,
    onlyRoot: true
  }) {
    if (this.rootProperty == null || !this.platform.isBrowser) {
      return false;
    }
    const fn = (property) => {
      property._runValidation();
      if (!(property instanceof PropertyGroup) || !property.properties)
        return;
      if (Array.isArray(property.properties)) {
        property.properties.forEach((p) => fn(p));
      } else {
        Object.keys(property.properties).forEach((key) => fn(property.properties[key]));
      }
    };
    if (options.onlyRoot) {
      this.rootProperty._runValidation();
    } else {
      fn(this.rootProperty);
    }
    const errors = this.rootProperty.errors;
    this._valid = !(errors && errors.length);
    if (options.emitError && !this._valid)
      this.formError.emit(errors);
    this.cdr.detectChanges();
    return this._valid;
  }
  /**
   * Refresh the form Schema, when specifying `newSchema` means to replace the current Schema
   *
   * 刷新 Schema，当指定 `newSchema` 表示替换当前的 Schema
   *
   * 可以针对某个表单元素进行刷新，例如：
   * ```
   * // 获取某个元素
   * const statusProperty = this.sf.getProperty('/status')!;
   * // 重置 `schema` 或 `ui` 参数
   * statusProperty.schema.enum = ['1', '2', '3'];
   * // 调用 `reset` 重置初始值
   * statusProperty.widget.reset('2');
   * ```
   */
  refreshSchema(newSchema, newUI) {
    if (!this.platform.isBrowser) {
      return this;
    }
    if (newSchema)
      this.schema = newSchema;
    if (newUI)
      this.ui = newUI;
    if (!this.schema || typeof this.schema.properties === "undefined")
      throw new Error(`Invalid Schema`);
    if (this.schema.ui && typeof this.schema.ui === "string")
      throw new Error(`Don't support string with root ui property`);
    this.schema.type = "object";
    this._formData = __spreadValues({}, this.formData);
    if (this._inited)
      this.terminator.destroy();
    this.cleanRootSub();
    this.coverProperty();
    this.coverButtonProperty();
    this.rootProperty = this.formPropertyFactory.createProperty(this._schema, this._ui, this.formData);
    this.attachCustomRender();
    this.cdr.detectChanges();
    this.reset();
    let isFirst = true;
    this.rootProperty.valueChanges.subscribe((res) => {
      this._item = __spreadValues(__spreadValues({}, this.cleanValue ? null : this.formData), res.value);
      if (isFirst) {
        isFirst = false;
        return;
      }
      this.formChange.emit(this._item);
      this.formValueChange.emit({
        value: this._item,
        path: res.path,
        pathValue: res.pathValue
      });
    });
    this.rootProperty.errorsChanges.subscribe((errors) => {
      this._valid = !(errors && errors.length);
      this.formError.emit(errors);
      this.cdr.detectChanges();
    });
    return this;
  }
  /**
   * Reset form
   *
   * 重置表单
   *
   * @param [emit] 是否触发 `formReset` 事件，默认：`false`
   */
  reset(emit = false) {
    if (this.rootProperty == null || !this.platform.isBrowser) {
      return this;
    }
    this.rootProperty.resetValue(this.formData, false);
    Promise.resolve().then(() => this.cdr.detectChanges());
    if (emit) {
      this.formReset.emit(this.value);
    }
    return this;
  }
  cleanRootSub() {
    if (!this.rootProperty)
      return;
    this.rootProperty.errorsChanges.unsubscribe();
    this.rootProperty.valueChanges.unsubscribe();
  }
  ngOnDestroy() {
    this.cleanRootSub();
    this.terminator.destroy();
  }
};
_SFComponent.\u0275fac = function SFComponent_Factory(t) {
  return new (t || _SFComponent)(\u0275\u0275directiveInject(FormPropertyFactory), \u0275\u0275directiveInject(TerminatorService), \u0275\u0275directiveInject(DomSanitizer), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(DelonLocaleService), \u0275\u0275directiveInject(ACLService, 8), \u0275\u0275directiveInject(ALAIN_I18N_TOKEN, 8), \u0275\u0275directiveInject(AlainConfigService), \u0275\u0275directiveInject(Platform));
};
_SFComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SFComponent,
  selectors: [["sf"], ["", "sf", ""]],
  hostVars: 16,
  hostBindings: function SFComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("sf", true)("sf__inline", ctx.layout === "inline")("sf__horizontal", ctx.layout === "horizontal")("sf__search", ctx.mode === "search")("sf__edit", ctx.mode === "edit")("sf__no-error", ctx.onlyVisual)("sf__no-colon", ctx.noColon)("sf__compact", ctx.compact);
    }
  },
  inputs: {
    layout: "layout",
    schema: "schema",
    ui: "ui",
    formData: "formData",
    button: "button",
    liveValidate: "liveValidate",
    autocomplete: "autocomplete",
    firstVisual: "firstVisual",
    onlyVisual: "onlyVisual",
    compact: "compact",
    mode: "mode",
    loading: "loading",
    disabled: "disabled",
    noColon: "noColon",
    cleanValue: "cleanValue",
    delay: "delay"
  },
  outputs: {
    formValueChange: "formValueChange",
    formChange: "formChange",
    formSubmit: "formSubmit",
    formReset: "formReset",
    formError: "formError"
  },
  exportAs: ["sf"],
  features: [\u0275\u0275ProvidersFeature([WidgetFactory, {
    provide: FormPropertyFactory,
    useFactory,
    deps: [Injector, SchemaValidatorFactory, AlainConfigService]
  }, TerminatorService]), \u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c117,
  decls: 6,
  vars: 3,
  consts: [["con", ""], ["btnTpl", ""], ["nz-form", "", 3, "nzLayout", "submit"], [3, "formProperty", "footer"], ["class", "sf-btns", 3, "ngClass", "fixed-label"], [1, "sf-btns", 3, "ngClass", "fixed-label"], ["nz-col", "", 1, "ant-form-item-control", 3, "nzSpan", "nzOffset", "nzXs", "nzSm", "nzMd", "nzLg", "nzXl", "nzXXl"], [1, "ant-form-item-control-input"], [1, "ant-form-item-control-input-content"], ["type", "submit", "nz-button", "", "data-type", "submit", 3, "nzType", "nzSize", "nzLoading", "disabled"], ["nz-icon", "", 3, "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], ["type", "button", "nz-button", "", "data-type", "reset", 3, "nzType", "nzSize", "disabled"], ["type", "button", "nz-button", "", "data-type", "reset", 3, "nzType", "nzSize", "disabled", "click"], [3, "ngTemplateOutlet"]],
  template: function SFComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, SFComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, SFComponent_ng_template_2_Template, 2, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(4, "form", 2);
      \u0275\u0275listener("submit", function SFComponent_Template_form_submit_4_listener($event) {
        return ctx.onSubmit($event);
      });
      \u0275\u0275template(5, SFComponent_Conditional_5_Template, 1, 2, "sf-item", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(4);
      \u0275\u0275property("nzLayout", ctx.layout);
      \u0275\u0275attribute("autocomplete", ctx.autocomplete);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(5, ctx.rootProperty ? 5 : -1);
    }
  },
  dependencies: [NgClass, NgTemplateOutlet, \u0275NgNoValidate, NgControlStatusGroup, NgForm, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, NzColDirective, NzRowDirective, NzFormDirective, NzFormItemComponent, NzIconDirective, SFItemComponent, SFFixedDirective],
  encapsulation: 2,
  changeDetection: 0
});
var SFComponent = _SFComponent;
__decorate([InputBoolean2()], SFComponent.prototype, "liveValidate", void 0);
__decorate([InputBoolean2()], SFComponent.prototype, "firstVisual", void 0);
__decorate([InputBoolean2()], SFComponent.prototype, "onlyVisual", void 0);
__decorate([InputBoolean2()], SFComponent.prototype, "compact", void 0);
__decorate([InputBoolean2()], SFComponent.prototype, "loading", void 0);
__decorate([InputBoolean2()], SFComponent.prototype, "disabled", void 0);
__decorate([InputBoolean2()], SFComponent.prototype, "noColon", void 0);
__decorate([InputBoolean2()], SFComponent.prototype, "cleanValue", void 0);
__decorate([InputBoolean2()], SFComponent.prototype, "delay", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFComponent, [{
    type: Component,
    args: [{
      selector: "sf, [sf]",
      exportAs: "sf",
      providers: [WidgetFactory, {
        provide: FormPropertyFactory,
        useFactory,
        deps: [Injector, SchemaValidatorFactory, AlainConfigService]
      }, TerminatorService],
      host: {
        "[class.sf]": "true",
        "[class.sf__inline]": `layout === 'inline'`,
        "[class.sf__horizontal]": `layout === 'horizontal'`,
        "[class.sf__search]": `mode === 'search'`,
        "[class.sf__edit]": `mode === 'edit'`,
        "[class.sf__no-error]": `onlyVisual`,
        "[class.sf__no-colon]": `noColon`,
        "[class.sf__compact]": `compact`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<ng-template #con>
  <ng-content />
</ng-template>
<ng-template #btnTpl>
  @if (button !== 'none') {
    @if (_btn && _btn.render) {
      <nz-form-item [ngClass]="_btn.render!.class!" class="sf-btns" [fixed-label]="_btn.render!.spanLabelFixed!">
        <div
          nz-col
          class="ant-form-item-control"
          [nzSpan]="btnGrid.span"
          [nzOffset]="btnGrid.offset"
          [nzXs]="btnGrid.xs"
          [nzSm]="btnGrid.sm"
          [nzMd]="btnGrid.md"
          [nzLg]="btnGrid.lg"
          [nzXl]="btnGrid.xl"
          [nzXXl]="btnGrid.xxl"
        >
          <div class="ant-form-item-control-input">
            <div class="ant-form-item-control-input-content">
              @if (button) {
                <button
                  type="submit"
                  nz-button
                  data-type="submit"
                  [nzType]="_btn.submit_type!"
                  [nzSize]="_btn.render!.size!"
                  [nzLoading]="loading"
                  [disabled]="liveValidate && !valid"
                >
                  @if (_btn.submit_icon) {
                    <i
                      nz-icon
                      [nzType]="_btn.submit_icon.type!"
                      [nzTheme]="_btn.submit_icon.theme!"
                      [nzTwotoneColor]="_btn.submit_icon.twoToneColor!"
                      [nzIconfont]="_btn.submit_icon.iconfont!"
                    ></i>
                  }
                  {{ _btn.submit }}
                </button>
                @if (_btn.reset) {
                  <button
                    type="button"
                    nz-button
                    data-type="reset"
                    [nzType]="_btn.reset_type!"
                    [nzSize]="_btn.render!.size!"
                    [disabled]="loading"
                    (click)="reset(true)"
                  >
                    @if (_btn.reset_icon) {
                      <i
                        nz-icon
                        [nzType]="_btn.reset_icon.type!"
                        [nzTheme]="_btn.reset_icon.theme!"
                        [nzTwotoneColor]="_btn.reset_icon.twoToneColor!"
                        [nzIconfont]="_btn.reset_icon.iconfont!"
                      ></i>
                    }
                    {{ _btn.reset }}
                  </button>
                }
              } @else {
                <ng-template [ngTemplateOutlet]="con" />
              }
            </div>
          </div>
        </div>
      </nz-form-item>
    }
  } @else {
    <ng-template [ngTemplateOutlet]="con" />
  }
</ng-template>
<form nz-form [nzLayout]="layout" (submit)="onSubmit($event)" [attr.autocomplete]="autocomplete">
  @if (rootProperty) {
    <sf-item [formProperty]="rootProperty" [footer]="btnTpl" />
  }
</form>
`
    }]
  }], () => [{
    type: FormPropertyFactory
  }, {
    type: TerminatorService
  }, {
    type: DomSanitizer
  }, {
    type: ChangeDetectorRef
  }, {
    type: DelonLocaleService
  }, {
    type: ACLService,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ALAIN_I18N_TOKEN]
    }]
  }, {
    type: AlainConfigService
  }, {
    type: Platform
  }], {
    layout: [{
      type: Input
    }],
    schema: [{
      type: Input
    }],
    ui: [{
      type: Input
    }],
    formData: [{
      type: Input
    }],
    button: [{
      type: Input
    }],
    liveValidate: [{
      type: Input
    }],
    autocomplete: [{
      type: Input
    }],
    firstVisual: [{
      type: Input
    }],
    onlyVisual: [{
      type: Input
    }],
    compact: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    noColon: [{
      type: Input
    }],
    cleanValue: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    formValueChange: [{
      type: Output
    }],
    formChange: [{
      type: Output
    }],
    formSubmit: [{
      type: Output
    }],
    formReset: [{
      type: Output
    }],
    formError: [{
      type: Output
    }]
  });
})();
var _SFItemWrapComponent = class _SFItemWrapComponent {
  set showTitle(val) {
    this._showTitle = !!val;
  }
  get t() {
    return this.title === null ? this.schema.title : this.title;
  }
  get oh() {
    return this.ui.optionalHelp;
  }
  constructor(statusSrv) {
    this.statusSrv = statusSrv;
    this._showTitle = false;
    this.title = null;
  }
  ngOnChanges() {
    const hasError = !!this.error;
    this.statusSrv.formStatusChanges.next({
      status: hasError ? "error" : "",
      hasFeedback: !!this.ui.feedback
    });
  }
};
_SFItemWrapComponent.\u0275fac = function SFItemWrapComponent_Factory(t) {
  return new (t || _SFItemWrapComponent)(\u0275\u0275directiveInject(NzFormStatusService));
};
_SFItemWrapComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SFItemWrapComponent,
  selectors: [["sf-item-wrap"]],
  inputs: {
    id: "id",
    schema: "schema",
    ui: "ui",
    showError: "showError",
    error: "error",
    showTitle: "showTitle",
    title: "title"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c117,
  decls: 8,
  vars: 21,
  consts: [["nz-col", "", "class", "ant-form-item-label", 3, "nzSpan"], ["nz-col", "", 1, "ant-form-item-control", 3, "nzSpan", "nzOffset"], [1, "ant-form-item-control-input"], [1, "ant-form-item-control-input-content"], ["class", "ant-form-item-explain ant-form-item-explain-connected"], ["class", "ant-form-item-extra", 3, "innerHTML"], ["nz-col", "", 1, "ant-form-item-label", 3, "nzSpan"], [3, "ant-form-item-required"], [1, "sf__label-text"], ["class", "sf__optional"], [1, "sf__optional"], ["nz-tooltip", "", "nz-icon", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipColor", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [1, "ant-form-item-explain", "ant-form-item-explain-connected"], ["role", "alert", 1, "ant-form-item-explain-error"], [1, "ant-form-item-extra", 3, "innerHTML"]],
  template: function SFItemWrapComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "nz-form-item");
      \u0275\u0275template(1, SFItemWrapComponent_Conditional_1_Template, 2, 2, "div", 0);
      \u0275\u0275elementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      \u0275\u0275projection(5);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(6, SFItemWrapComponent_Conditional_6_Template, 3, 2, "div", 4)(7, SFItemWrapComponent_Conditional_7_Template, 1, 1, "div", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.ui.width, "px");
      \u0275\u0275classProp("ant-form-item-has-error", ctx.showError)("ant-form-item-with-help", ctx.showError)("ant-form-item-has-success", ctx.ui.feedback === "success")("ant-form-item-has-warning", ctx.ui.feedback === "warning")("ant-form-item-has-error", ctx.ui.feedback === "error")("ant-form-item-is-validating", ctx.ui.feedback === "validating")("ant-form-item-has-feedback", ctx.ui.feedback);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx._showTitle ? 1 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzSpan", ctx.ui.spanControl)("nzOffset", ctx.ui.offsetControl);
      \u0275\u0275advance(4);
      \u0275\u0275conditional(6, !ctx.ui.onlyVisual && ctx.showError ? 6 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(7, ctx.schema.description ? 7 : -1);
    }
  },
  dependencies: [NzTransitionPatchDirective, NzColDirective, NzRowDirective, NzFormItemComponent, NzIconDirective, NzTooltipDirective],
  encapsulation: 2,
  data: {
    animation: [helpMotion]
  }
});
var SFItemWrapComponent = _SFItemWrapComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFItemWrapComponent, [{
    type: Component,
    args: [{
      selector: "sf-item-wrap",
      animations: [helpMotion],
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      template: `<nz-form-item
  [style.width.px]="ui.width"
  [class.ant-form-item-has-error]="showError"
  [class.ant-form-item-with-help]="showError"
  [class.ant-form-item-has-success]="ui.feedback === 'success'"
  [class.ant-form-item-has-warning]="ui.feedback === 'warning'"
  [class.ant-form-item-has-error]="ui.feedback === 'error'"
  [class.ant-form-item-is-validating]="ui.feedback === 'validating'"
  [class.ant-form-item-has-feedback]="ui.feedback"
>
  @if (_showTitle) {
    <div nz-col [nzSpan]="ui.spanLabel!" class="ant-form-item-label">
      @if (t) {
        <label [attr.for]="id" [class.ant-form-item-required]="ui._required">
          <span class="sf__label-text">{{ t }}</span>
          @if (ui.optional || oh) {
            <span class="sf__optional">
              {{ ui.optional }}
              @if (oh) {
                <i
                  nz-tooltip
                  [nzTooltipTitle]="oh.text"
                  [nzTooltipPlacement]="oh.placement"
                  [nzTooltipTrigger]="oh.trigger"
                  [nzTooltipColor]="oh.bgColor"
                  [nzTooltipOverlayClassName]="oh.overlayClassName"
                  [nzTooltipOverlayStyle]="oh.overlayStyle"
                  [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                  [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                  nz-icon
                  [nzType]="oh.icon!"
                ></i>
              }
            </span>
          }
        </label>
      }
    </div>
  }
  <div nz-col class="ant-form-item-control" [nzSpan]="ui.spanControl!" [nzOffset]="ui.offsetControl!">
    <div class="ant-form-item-control-input">
      <div class="ant-form-item-control-input-content">
        <ng-content />
      </div>
    </div>
    @if (!ui.onlyVisual && showError) {
      <div @helpMotion class="ant-form-item-explain ant-form-item-explain-connected">
        <div role="alert" class="ant-form-item-explain-error">
          {{ error }}
        </div>
      </div>
    }
    @if (schema.description) {
      <div class="ant-form-item-extra" [innerHTML]="ui._description"></div>
    }
  </div>
</nz-form-item>
`
    }]
  }], () => [{
    type: NzFormStatusService
  }], {
    id: [{
      type: Input
    }],
    schema: [{
      type: Input
    }],
    ui: [{
      type: Input
    }],
    showError: [{
      type: Input
    }],
    error: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var _SFTemplateDirective = class _SFTemplateDirective {
  constructor(templateRef, table) {
    this.templateRef = templateRef;
    this.table = table;
  }
  ngOnInit() {
    this.table._addTpl(this.path.startsWith(SF_SEQ) ? this.path : SF_SEQ + this.path, this.templateRef);
  }
};
_SFTemplateDirective.\u0275fac = function SFTemplateDirective_Factory(t) {
  return new (t || _SFTemplateDirective)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(SFComponent));
};
_SFTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _SFTemplateDirective,
  selectors: [["", "sf-template", ""]],
  inputs: {
    path: ["sf-template", "path"]
  }
});
var SFTemplateDirective = _SFTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[sf-template]"
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: SFComponent
  }], {
    path: [{
      type: Input,
      args: ["sf-template"]
    }]
  });
})();
var _Widget = class _Widget {
  get cls() {
    return this.ui.class || "";
  }
  get disabled() {
    if (this.schema.readOnly === true || this.sfComp.disabled) {
      return true;
    }
    return false;
  }
  get l() {
    return this.formProperty.root.widget.sfComp.locale;
  }
  get oh() {
    return this.ui.optionalHelp;
  }
  get dom() {
    return this.injector.get(DomSanitizer);
  }
  get cleanValue() {
    return this.sfComp?.cleanValue;
  }
  constructor(cd, injector, sfItemComp, sfComp) {
    this.cd = cd;
    this.injector = injector;
    this.sfItemComp = sfItemComp;
    this.sfComp = sfComp;
    this.showError = false;
    this.id = "";
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe((errors) => {
      if (errors == null)
        return;
      di(this.ui, "errorsChanges", this.formProperty.path, errors);
      const firstVisual = this.sfComp?.firstVisual;
      if (firstVisual || !firstVisual && this.sfComp?._inited) {
        this.showError = errors.length > 0;
        this.error = this.showError ? errors[0].message : "";
        this.cd.detectChanges();
      }
    });
    this.afterViewInit();
  }
  setValue(value) {
    this.formProperty.setValue(value, false);
    di(this.ui, "valueChanges", this.formProperty.path, this.formProperty);
  }
  get value() {
    return this.formProperty.value;
  }
  detectChanges(onlySelf = false) {
    if (onlySelf) {
      this.cd.markForCheck();
    } else {
      this.formProperty.root.widget?.cd.markForCheck();
    }
  }
};
_Widget.\u0275fac = function Widget_Factory(t) {
  return new (t || _Widget)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Injector), \u0275\u0275directiveInject(SFItemComponent), \u0275\u0275directiveInject(SFComponent));
};
_Widget.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _Widget,
  hostVars: 2,
  hostBindings: function Widget_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classMap(ctx.cls);
    }
  }
});
var Widget = _Widget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Widget, [{
    type: Directive
  }], () => [{
    type: ChangeDetectorRef,
    decorators: [{
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: Injector,
    decorators: [{
      type: Inject,
      args: [Injector]
    }]
  }, {
    type: SFItemComponent,
    decorators: [{
      type: Inject,
      args: [SFItemComponent]
    }]
  }, {
    type: SFComponent,
    decorators: [{
      type: Inject,
      args: [SFComponent]
    }]
  }], {
    cls: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _ControlWidget = class _ControlWidget extends Widget {
  reset(_value) {
  }
  afterViewInit() {
  }
};
_ControlWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275ControlWidget_BaseFactory;
  return function ControlWidget_Factory(t) {
    return (\u0275ControlWidget_BaseFactory || (\u0275ControlWidget_BaseFactory = \u0275\u0275getInheritedFactory(_ControlWidget)))(t || _ControlWidget);
  };
})();
_ControlWidget.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _ControlWidget,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var ControlWidget = _ControlWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlWidget, [{
    type: Directive
  }], null, null);
})();
var _ControlUIWidget = class _ControlUIWidget extends Widget {
  reset(_value) {
  }
  afterViewInit() {
  }
};
_ControlUIWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275ControlUIWidget_BaseFactory;
  return function ControlUIWidget_Factory(t) {
    return (\u0275ControlUIWidget_BaseFactory || (\u0275ControlUIWidget_BaseFactory = \u0275\u0275getInheritedFactory(_ControlUIWidget)))(t || _ControlUIWidget);
  };
})();
_ControlUIWidget.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _ControlUIWidget,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var ControlUIWidget = _ControlUIWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlUIWidget, [{
    type: Directive
  }], null, null);
})();
var _ArrayLayoutWidget = class _ArrayLayoutWidget extends Widget {
  reset(_value) {
  }
  afterViewInit() {
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe(() => this.cd.detectChanges());
  }
};
_ArrayLayoutWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275ArrayLayoutWidget_BaseFactory;
  return function ArrayLayoutWidget_Factory(t) {
    return (\u0275ArrayLayoutWidget_BaseFactory || (\u0275ArrayLayoutWidget_BaseFactory = \u0275\u0275getInheritedFactory(_ArrayLayoutWidget)))(t || _ArrayLayoutWidget);
  };
})();
_ArrayLayoutWidget.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _ArrayLayoutWidget,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var ArrayLayoutWidget = _ArrayLayoutWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ArrayLayoutWidget, [{
    type: Directive
  }], null, null);
})();
var _ObjectLayoutWidget = class _ObjectLayoutWidget extends Widget {
  reset(_value) {
  }
  afterViewInit() {
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe(() => this.cd.detectChanges());
  }
};
_ObjectLayoutWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275ObjectLayoutWidget_BaseFactory;
  return function ObjectLayoutWidget_Factory(t) {
    return (\u0275ObjectLayoutWidget_BaseFactory || (\u0275ObjectLayoutWidget_BaseFactory = \u0275\u0275getInheritedFactory(_ObjectLayoutWidget)))(t || _ObjectLayoutWidget);
  };
})();
_ObjectLayoutWidget.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _ObjectLayoutWidget,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var ObjectLayoutWidget = _ObjectLayoutWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObjectLayoutWidget, [{
    type: Directive
  }], null, null);
})();
var _ArrayWidget = class _ArrayWidget extends ArrayLayoutWidget {
  constructor() {
    super(...arguments);
    this.arraySpan = 8;
  }
  get addDisabled() {
    return this.disabled || this.schema.maxItems != null && this.formProperty.properties.length >= this.schema.maxItems;
  }
  get showRemove() {
    if (this.disabled || !this.removeTitle)
      return false;
    if (this.schema.minItems != null && this.formProperty.properties.length <= this.schema.minItems)
      return false;
    return true;
  }
  ngOnInit() {
    const {
      grid,
      addTitle,
      addType,
      removable,
      removeTitle
    } = this.ui;
    if (grid && grid.arraySpan) {
      this.arraySpan = grid.arraySpan;
    }
    this.addTitle = this.dom.bypassSecurityTrustHtml(addTitle || this.l.addText);
    this.addType = addType || "dashed";
    this.removeTitle = removable === false ? null : removeTitle || this.l.removeText;
  }
  reValid() {
    this.formProperty.updateValueAndValidity({
      onlySelf: false,
      emitValueEvent: false,
      emitValidator: true
    });
  }
  addItem() {
    const property = this.formProperty.add({});
    this.reValid();
    this.ui.add?.(property);
  }
  removeItem(index) {
    this.formProperty.remove(index);
    this.reValid();
    this.ui.remove?.(index);
  }
};
_ArrayWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275ArrayWidget_BaseFactory;
  return function ArrayWidget_Factory(t) {
    return (\u0275ArrayWidget_BaseFactory || (\u0275ArrayWidget_BaseFactory = \u0275\u0275getInheritedFactory(_ArrayWidget)))(t || _ArrayWidget);
  };
})();
_ArrayWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ArrayWidget,
  selectors: [["sf-array"]],
  hostVars: 2,
  hostBindings: function ArrayWidget_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("sf__array", true);
    }
  },
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 8,
  vars: 10,
  consts: [["nz-col", "", "class", "ant-form-item-label", 3, "nzSpan"], ["nz-col", "", 1, "ant-form-item-control-wrapper", 3, "nzSpan", "nzOffset"], [1, "ant-form-item-control"], ["nz-row", "", 1, "sf__array-container"], [4, "ngFor", "ngForOf"], ["class", "ant-form-explain"], ["class", "ant-form-extra", 3, "innerHTML"], ["nz-col", "", 1, "ant-form-item-label", 3, "nzSpan"], [1, "sf__optional"], ["nz-tooltip", "", "nz-icon", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [1, "sf__array-add"], ["type", "button", "nz-button", "", 3, "nzType", "disabled", "innerHTML", "click"], ["nz-col", "", "class", "sf__array-item", 3, "nzSpan"], ["nz-col", "", 1, "sf__array-item", 3, "nzSpan"], [3, "formProperty"], ["class", "sf__array-remove"], [1, "sf__array-remove", 3, "click"], ["nz-icon", "", "nzType", "delete"], [1, "ant-form-explain"], [1, "ant-form-extra", 3, "innerHTML"]],
  template: function ArrayWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nz-form-item");
      \u0275\u0275template(1, ArrayWidget_Conditional_1_Template, 8, 9, "div", 0);
      \u0275\u0275elementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      \u0275\u0275template(5, ArrayWidget_ng_container_5_Template, 2, 1, "ng-container", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275template(6, ArrayWidget_Conditional_6_Template, 2, 1, "div", 5)(7, ArrayWidget_Conditional_7_Template, 1, 1, "div", 6);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-form-item-with-help", ctx.showError);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx.schema.title ? 1 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzSpan", ctx.ui.spanControl)("nzOffset", ctx.ui.offsetControl);
      \u0275\u0275advance(1);
      \u0275\u0275classProp("has-error", ctx.showError);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.formProperty.properties);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(6, !ctx.ui.onlyVisual && ctx.showError ? 6 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(7, ctx.schema.description ? 7 : -1);
    }
  },
  dependencies: [NgForOf, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, NzCardComponent, NzColDirective, NzRowDirective, NzFormItemComponent, NzIconDirective, NzTooltipDirective, SFItemComponent],
  encapsulation: 2
});
var ArrayWidget = _ArrayWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ArrayWidget, [{
    type: Component,
    args: [{
      selector: "sf-array",
      template: `<nz-form-item [class.ant-form-item-with-help]="showError">
    @if (schema.title) {
      <div nz-col [nzSpan]="ui.spanLabel!" class="ant-form-item-label">
        <label [class.ant-form-item-required]="ui.required">
          {{ schema.title }}
          <span class="sf__optional">
            {{ ui.optional }}
            @if (oh) {
              <i
                nz-tooltip
                [nzTooltipTitle]="oh.text"
                [nzTooltipPlacement]="oh.placement"
                [nzTooltipTrigger]="oh.trigger"
                [nzTooltipOverlayClassName]="oh.overlayClassName"
                [nzTooltipOverlayStyle]="oh.overlayStyle"
                [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                nz-icon
                [nzType]="oh.icon!"
              ></i>
            }
          </span>
        </label>
        <div class="sf__array-add">
          <button
            type="button"
            nz-button
            [nzType]="addType"
            [disabled]="addDisabled"
            (click)="addItem()"
            [innerHTML]="addTitle"
          ></button>
        </div>
      </div>
    }
    <div nz-col class="ant-form-item-control-wrapper" [nzSpan]="ui.spanControl!" [nzOffset]="ui.offsetControl!">
      <div class="ant-form-item-control" [class.has-error]="showError">
        <div nz-row class="sf__array-container">
          <ng-container *ngFor="let i of $any(formProperty).properties; let $index = index">
            @if (i.visible && !i.ui.hidden) {
              <div nz-col [nzSpan]="arraySpan" [attr.data-index]="$index" class="sf__array-item">
                <nz-card>
                  <sf-item [formProperty]="i" />
                  @if (showRemove) {
                    <span class="sf__array-remove" (click)="removeItem($index)" [attr.title]="removeTitle">
                      <i nz-icon nzType="delete"></i>
                    </span>
                  }
                </nz-card>
              </div>
            }
          </ng-container>
        </div>
        @if (!ui.onlyVisual && showError) {
          <div class="ant-form-explain">{{ error }}</div>
        }
        @if (schema.description) {
          <div [innerHTML]="ui._description" class="ant-form-extra"></div>
        }
      </div>
    </div>
  </nz-form-item>`,
      host: {
        "[class.sf__array]": "true"
      },
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _BooleanWidget = class _BooleanWidget extends ControlUIWidget {
};
_BooleanWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BooleanWidget_BaseFactory;
  return function BooleanWidget_Factory(t) {
    return (\u0275BooleanWidget_BaseFactory || (\u0275BooleanWidget_BaseFactory = \u0275\u0275getInheritedFactory(_BooleanWidget)))(t || _BooleanWidget);
  };
})();
_BooleanWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BooleanWidget,
  selectors: [["sf-boolean"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 12,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngModel", "nzDisabled", "nzSize", "nzCheckedChildren", "nzUnCheckedChildren", "nzLoading", "ngModelChange"]],
  template: function BooleanWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0)(1, "nz-switch", 1);
      \u0275\u0275listener("ngModelChange", function BooleanWidget_Template_nz_switch_ngModelChange_1_listener($event) {
        return ctx.setValue($event);
      });
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngModel", ctx.value)("nzDisabled", ctx.disabled)("nzSize", ctx.ui.size)("nzCheckedChildren", ctx.ui.checkedChildren)("nzUnCheckedChildren", ctx.ui.unCheckedChildren)("nzLoading", ctx.ui.loading);
    }
  },
  dependencies: [NgControlStatus, NgModel, NzSwitchComponent, SFItemWrapComponent],
  encapsulation: 2
});
var BooleanWidget = _BooleanWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanWidget, [{
    type: Component,
    args: [{
      selector: "sf-boolean",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-switch
      [ngModel]="value"
      (ngModelChange)="setValue($event)"
      [nzDisabled]="disabled"
      [nzSize]="ui.size!"
      [nzCheckedChildren]="ui.checkedChildren!"
      [nzUnCheckedChildren]="ui.unCheckedChildren!"
      [nzLoading]="ui.loading"
    />
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _CheckboxWidget = class _CheckboxWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.data = [];
    this.allChecked = false;
    this.indeterminate = false;
    this.labelTitle = ``;
    this.inited = false;
  }
  reset(value) {
    this.inited = false;
    getData(this.schema, this.ui, value).subscribe((list2) => {
      this.data = list2;
      this.allChecked = false;
      this.indeterminate = false;
      this.labelTitle = list2.length === 0 ? "" : this.schema.title;
      const {
        span
      } = this.ui;
      this.grid_span = span && span > 0 ? span : 0;
      this.updateAllChecked();
      this.inited = true;
      this.detectChanges();
    });
  }
  _setValue(value) {
    this.setValue(value);
    this.detectChanges();
    this.notifyChange(value);
  }
  notifySet() {
    const checkList = this.data.filter((w) => w.checked);
    this.updateAllChecked().setValue(checkList.map((item) => item.value));
    this.notifyChange(checkList);
  }
  groupInGridChange(values) {
    this.data.forEach((item) => item.checked = values.indexOf(item.value) !== -1);
    this.notifySet();
  }
  onAllChecked() {
    this.data.forEach((item) => item.checked = this.allChecked);
    this.notifySet();
  }
  updateAllChecked() {
    if (this.data.every((item) => item.checked !== true)) {
      this.allChecked = false;
      this.indeterminate = false;
    } else if (this.data.every((item) => item.checked === true)) {
      this.allChecked = true;
      this.indeterminate = false;
    } else {
      this.indeterminate = true;
    }
    this.detectChanges();
    return this;
  }
  notifyChange(res) {
    if (this.ui.change)
      this.ui.change(res);
  }
};
_CheckboxWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275CheckboxWidget_BaseFactory;
  return function CheckboxWidget_Factory(t) {
    return (\u0275CheckboxWidget_BaseFactory || (\u0275CheckboxWidget_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxWidget)))(t || _CheckboxWidget);
  };
})();
_CheckboxWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CheckboxWidget,
  selectors: [["sf-checkbox"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 4,
  vars: 8,
  consts: [["all", ""], [3, "id", "schema", "ui", "showError", "error", "showTitle", "title"], ["nz-checkbox", "", "class", "sf__checkbox-all mr-sm", 3, "ngModel", "nzIndeterminate"], ["nz-checkbox", "", 1, "sf__checkbox-all", "mr-sm", 3, "ngModel", "nzIndeterminate", "ngModelChange"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel", "ngModelChange"], [1, "sf__optional"], ["nz-tooltip", "", "nz-icon", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [3, "ngTemplateOutlet"], [3, "ngModel", "ngModelChange"], [1, "sf__checkbox-list", 3, "nzOnChange"], ["nz-row", ""], ["nz-col", "", 3, "nzSpan"], ["nz-checkbox", "", 3, "nzValue", "ngModel", "nzDisabled"]],
  template: function CheckboxWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, CheckboxWidget_ng_template_0_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(2, "sf-item-wrap", 1);
      \u0275\u0275template(3, CheckboxWidget_Conditional_3_Template, 2, 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", true)("title", ctx.labelTitle);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(3, ctx.inited ? 3 : -1);
    }
  },
  dependencies: [NgTemplateOutlet, NgControlStatus, NgModel, NzTransitionPatchDirective, NzCheckboxComponent, NzCheckboxGroupComponent, NzCheckboxWrapperComponent, NzColDirective, NzRowDirective, NzIconDirective, NzTooltipDirective, SFItemWrapComponent],
  encapsulation: 2
});
var CheckboxWidget = _CheckboxWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxWidget, [{
    type: Component,
    args: [{
      selector: "sf-checkbox",
      template: `<ng-template #all>
      @if (ui.checkAll) {
        <label
          nz-checkbox
          class="sf__checkbox-all mr-sm"
          [(ngModel)]="allChecked"
          (ngModelChange)="onAllChecked()"
          [nzIndeterminate]="indeterminate"
        >
          {{ ui.checkAllText || l.checkAllText }}
        </label>
      }
    </ng-template>
    <sf-item-wrap
      [id]="id"
      [schema]="schema"
      [ui]="ui"
      [showError]="showError"
      [error]="error"
      [showTitle]="true"
      [title]="labelTitle"
    >
      @if (inited) {
        @if (data.length === 0) {
          <label nz-checkbox [nzDisabled]="disabled" [ngModel]="value" (ngModelChange)="_setValue($event)">
            {{ schema.title }}
            <span class="sf__optional">
              {{ ui.optional }}
              @if (oh) {
                <i
                  nz-tooltip
                  [nzTooltipTitle]="oh.text"
                  [nzTooltipPlacement]="oh.placement"
                  [nzTooltipTrigger]="oh.trigger"
                  [nzTooltipOverlayClassName]="oh.overlayClassName"
                  [nzTooltipOverlayStyle]="oh.overlayStyle"
                  [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                  [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                  nz-icon
                  [nzType]="oh.icon!"
                ></i>
              }
            </span>
          </label>
        } @else {
          @if (grid_span === 0) {
            <ng-template [ngTemplateOutlet]="all" />
            <nz-checkbox-group [ngModel]="data" (ngModelChange)="notifySet()" />
          } @else {
            <nz-checkbox-wrapper class="sf__checkbox-list" (nzOnChange)="groupInGridChange($event)">
              <div nz-row>
                @if (ui.checkAll) {
                  <div nz-col [nzSpan]="grid_span">
                    <ng-template [ngTemplateOutlet]="all" />
                  </div>
                }
                @for (i of data; track $index) {
                  <div nz-col [nzSpan]="grid_span">
                    <label nz-checkbox [nzValue]="i.value" [ngModel]="i.checked" [nzDisabled]="i.disabled">
                      {{ i.label }}
                    </label>
                  </div>
                }
              </div>
            </nz-checkbox-wrapper>
          }
        }
      }
    </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _CustomWidget = class _CustomWidget extends ControlUIWidget {
};
_CustomWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275CustomWidget_BaseFactory;
  return function CustomWidget_Factory(t) {
    return (\u0275CustomWidget_BaseFactory || (\u0275CustomWidget_BaseFactory = \u0275\u0275getInheritedFactory(_CustomWidget)))(t || _CustomWidget);
  };
})();
_CustomWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CustomWidget,
  selectors: [["sf-custom"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 12,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function CustomWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0);
      \u0275\u0275template(1, CustomWidget_ng_template_1_Template, 0, 0, "ng-template", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngTemplateOutlet", ctx.ui._render)("ngTemplateOutletContext", \u0275\u0275pureFunction3(8, _c214, ctx, ctx.schema, ctx.ui));
    }
  },
  dependencies: [NgTemplateOutlet, SFItemWrapComponent],
  encapsulation: 2
});
var CustomWidget = _CustomWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomWidget, [{
    type: Component,
    args: [{
      selector: "sf-custom",
      template: `
    <sf-item-wrap
      [id]="id"
      [schema]="schema"
      [ui]="ui"
      [showError]="showError"
      [error]="error"
      [showTitle]="schema.title"
    >
      <ng-template
        [ngTemplateOutlet]="$any(ui)._render"
        [ngTemplateOutletContext]="{ $implicit: this, schema: schema, ui: ui }"
      />
    </sf-item-wrap>
  `,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _DateWidget = class _DateWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.flatRange = false;
    this.displayValue = null;
  }
  ngOnInit() {
    const {
      mode,
      end,
      displayFormat,
      allowClear,
      showToday
    } = this.ui;
    this.mode = mode || "date";
    this.flatRange = end != null;
    this.startFormat = this.ui._format;
    if (this.flatRange) {
      this.mode = "range";
      const endUi = this.endProperty.ui;
      this.endFormat = endUi.format ? endUi._format : this.startFormat;
    }
    if (!displayFormat) {
      switch (this.mode) {
        case "year":
          this.displayFormat = `yyyy`;
          break;
        case "month":
          this.displayFormat = `yyyy-MM`;
          break;
        case "week":
          this.displayFormat = `yyyy-ww`;
          break;
      }
    } else {
      this.displayFormat = displayFormat;
    }
    this.i = {
      allowClear: toBool(allowClear, true),
      // nz-date-picker
      showToday: toBool(showToday, true)
    };
  }
  reset(value) {
    const toDateOptions = {
      formatString: this.startFormat,
      defaultValue: null
    };
    if (Array.isArray(value)) {
      value = value.map((v) => toDate(v, toDateOptions));
    } else {
      value = toDate(value, toDateOptions);
    }
    if (this.flatRange) {
      const endValue = toDate(this.endProperty.formData, {
        formatString: this.endFormat || this.startFormat,
        defaultValue: null
      });
      this.displayValue = value == null || endValue == null ? [] : [value, endValue];
    } else {
      this.displayValue = value;
    }
    this.detectChanges();
    if (this.displayValue) {
      setTimeout(() => this._change(this.displayValue, false));
    }
  }
  _change(value, emitModelChange = true) {
    if (emitModelChange && this.ui.change) {
      this.ui.change(value);
    }
    if (value == null || Array.isArray(value) && value.length < 2) {
      this.setValue(null);
      this.setEnd(null);
      return;
    }
    const res = Array.isArray(value) ? [format(value[0], this.startFormat), format(value[1], this.endFormat || this.startFormat)] : format(value, this.startFormat);
    if (this.flatRange) {
      this.setValue(res[0]);
      this.setEnd(res[1]);
    } else {
      this.setValue(res);
    }
  }
  _openChange(status) {
    if (this.ui.onOpenChange)
      this.ui.onOpenChange(status);
  }
  _ok(value) {
    if (this.ui.onOk)
      this.ui.onOk(value);
  }
  get endProperty() {
    return this.formProperty.parent.properties[this.ui.end];
  }
  setEnd(value) {
    if (!this.flatRange)
      return;
    this.endProperty.setValue(value, true);
    this.endProperty.updateValueAndValidity();
  }
};
_DateWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275DateWidget_BaseFactory;
  return function DateWidget_Factory(t) {
    return (\u0275DateWidget_BaseFactory || (\u0275DateWidget_BaseFactory = \u0275\u0275getInheritedFactory(_DateWidget)))(t || _DateWidget);
  };
})();
_DateWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _DateWidget,
  selectors: [["sf-date"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 6,
  vars: 7,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "ngClass", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzRenderExtraFooter", "nzInputReadOnly", "nzInline", "ngModelChange", "nzOnOpenChange"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "ngClass", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzInputReadOnly", "nzInline", "ngModelChange", "nzOnOpenChange"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "ngClass", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzDisabledTime", "nzRenderExtraFooter", "nzRanges", "nzShowTime", "nzSeparator", "nzShowWeekNumber", "nzMode", "nzInputReadOnly", "nzInline", "ngModelChange", "nzOnOpenChange", "nzOnOk"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "ngClass", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzDisabledTime", "nzRenderExtraFooter", "nzShowTime", "nzShowToday", "nzShowWeekNumber", "nzInputReadOnly", "nzInline", "ngModelChange", "nzOnOpenChange", "nzOnOk"]],
  template: function DateWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0);
      \u0275\u0275template(1, DateWidget_Case_1_Template, 1, 15)(2, DateWidget_Case_2_Template, 1, 15)(3, DateWidget_Case_3_Template, 1, 14)(4, DateWidget_Case_4_Template, 1, 21)(5, DateWidget_Case_5_Template, 1, 19);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      let DateWidget_contFlowTmp;
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, (DateWidget_contFlowTmp = ctx.mode) === "year" ? 1 : DateWidget_contFlowTmp === "month" ? 2 : DateWidget_contFlowTmp === "week" ? 3 : DateWidget_contFlowTmp === "range" ? 4 : 5);
    }
  },
  dependencies: [NgClass, NgControlStatus, NgModel, NzDatePickerComponent, NzRangePickerComponent, NzMonthPickerComponent, NzYearPickerComponent, NzWeekPickerComponent, SFItemWrapComponent],
  encapsulation: 2
});
var DateWidget = _DateWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateWidget, [{
    type: Component,
    args: [{
      selector: "sf-date",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    @switch (mode) {
      @case ('year') {
        <nz-year-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
        />
      }
      @case ('month') {
        <nz-month-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
        />
      }
      @case ('week') {
        <nz-week-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOpenChange)="_openChange($event)"
        />
      }
      @case ('range') {
        <nz-range-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzDisabledTime]="ui.disabledTime"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzRanges]="ui.ranges"
          [nzShowTime]="ui.showTime"
          [nzSeparator]="ui.separator"
          [nzShowWeekNumber]="ui.showWeekNumber || false"
          [nzMode]="ui.rangeMode"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOk)="_ok($event)"
        />
      }
      @default {
        <nz-date-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzDisabledTime]="ui.disabledTime"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzShowTime]="ui.showTime"
          [nzShowToday]="i.showToday"
          [nzShowWeekNumber]="ui.showWeekNumber || false"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOk)="_ok($event)"
        />
      }
    }
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _NumberWidget = class _NumberWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.formatter = (value) => value;
    this.parser = (value) => value;
    this.width = "";
  }
  ngOnInit() {
    const {
      minimum,
      exclusiveMinimum,
      maximum,
      exclusiveMaximum,
      multipleOf,
      type
    } = this.schema;
    this.step = multipleOf || 1;
    if (typeof minimum !== "undefined") {
      this.min = exclusiveMinimum ? minimum + this.step : minimum;
    }
    if (typeof maximum !== "undefined") {
      this.max = exclusiveMaximum ? maximum - this.step : maximum;
    }
    if (type === "integer") {
      this.min = Math.trunc(this.min);
      this.max = Math.trunc(this.max);
      this.step = Math.trunc(this.step);
    }
    const ui = this.ui;
    if (ui.prefix != null) {
      ui.formatter = (value) => value == null ? "" : `${ui.prefix} ${value}`;
      ui.parser = (value) => value.replace(`${ui.prefix} `, "");
    }
    if (ui.unit != null) {
      ui.formatter = (value) => value == null ? "" : `${value} ${ui.unit}`;
      ui.parser = (value) => value.replace(` ${ui.unit}`, "");
    }
    if (ui.formatter)
      this.formatter = ui.formatter;
    if (ui.parser)
      this.parser = ui.parser;
    this.width = typeof ui.widgetWidth === "number" ? `${ui.widgetWidth}px` : ui.widgetWidth ?? "90px";
  }
  _setValue(val) {
    this.setValue(this.schema.type === "integer" ? Math.floor(val) : val);
    if (this.ui.change)
      this.ui.change(this.value);
  }
};
_NumberWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NumberWidget_BaseFactory;
  return function NumberWidget_Factory(t) {
    return (\u0275NumberWidget_BaseFactory || (\u0275NumberWidget_BaseFactory = \u0275\u0275getInheritedFactory(_NumberWidget)))(t || _NumberWidget);
  };
})();
_NumberWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NumberWidget,
  selectors: [["sf-number"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 2,
  vars: 22,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzId", "ngModel", "nzDisabled", "nzSize", "nzMin", "nzMax", "nzStep", "nzFormatter", "nzParser", "nzPrecision", "nzPlaceHolder", "ngClass", "ngModelChange"]],
  template: function NumberWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0)(1, "nz-input-number", 1);
      \u0275\u0275listener("ngModelChange", function NumberWidget_Template_nz_input_number_ngModelChange_1_listener($event) {
        return ctx._setValue($event);
      });
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(1);
      \u0275\u0275styleProp("width", ctx.width);
      \u0275\u0275property("nzId", ctx.id)("ngModel", ctx.value)("nzDisabled", ctx.disabled)("nzSize", ctx.ui.size)("nzMin", ctx.min)("nzMax", ctx.max)("nzStep", ctx.step)("nzFormatter", ctx.formatter)("nzParser", ctx.parser)("nzPrecision", ctx.ui.precision)("nzPlaceHolder", ctx.ui.placeholder || "")("ngClass", \u0275\u0275pureFunction1(20, _c310, ctx.ui.hideStep));
    }
  },
  dependencies: [NgClass, NgControlStatus, NgModel, NzInputNumberComponent, SFItemWrapComponent],
  encapsulation: 2
});
var NumberWidget = _NumberWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberWidget, [{
    type: Component,
    args: [{
      selector: "sf-number",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-input-number
      [nzId]="id"
      [ngModel]="value"
      (ngModelChange)="_setValue($event)"
      [nzDisabled]="disabled"
      [nzSize]="ui.size!"
      [nzMin]="min"
      [nzMax]="max"
      [nzStep]="step"
      [nzFormatter]="formatter"
      [nzParser]="parser"
      [nzPrecision]="ui.precision"
      [nzPlaceHolder]="ui.placeholder || ''"
      [style.width]="width"
      [ngClass]="{ 'ant-input-number__hide-step': ui.hideStep }"
    />
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _ObjectWidget = class _ObjectWidget extends ObjectLayoutWidget {
  constructor() {
    super(...arguments);
    this.type = "default";
    this.list = [];
    this.showExpand = true;
    this.expand = true;
  }
  ngOnInit() {
    const {
      formProperty,
      ui
    } = this;
    const {
      grid,
      showTitle,
      type
    } = ui;
    this.showExpand = toBool(ui.showExpand, true);
    this.expand = toBool(ui.expand, true);
    this.type = type ?? "default";
    if (this.type === "card" || !formProperty.isRoot() && !(formProperty.parent instanceof ArrayProperty) && showTitle === true) {
      this.title = this.schema.title;
    }
    this.grid = grid;
    const list2 = [];
    for (const key of formProperty.propertiesId) {
      const property = formProperty.properties[key];
      const item = {
        property,
        grid: property.ui.grid || grid || {},
        spanLabelFixed: property.ui.spanLabelFixed,
        show: property.ui.hidden === false
      };
      list2.push(item);
    }
    this.list = list2;
  }
  changeExpand() {
    if (!this.showExpand) {
      return;
    }
    this.expand = !this.expand;
    this.detectChanges(true);
  }
};
_ObjectWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275ObjectWidget_BaseFactory;
  return function ObjectWidget_Factory(t) {
    return (\u0275ObjectWidget_BaseFactory || (\u0275ObjectWidget_BaseFactory = \u0275\u0275getInheritedFactory(_ObjectWidget)))(t || _ObjectWidget);
  };
})();
_ObjectWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ObjectWidget,
  selectors: [["sf-object"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 4,
  vars: 1,
  consts: [["default", ""], ["class", "sf__object-card", 3, "nzTitle", "nzExtra", "nzSize", "nzActions", "nzBodyStyle", "nzBordered", "nzBorderless", "sf__object-card-fold"], ["class", "sf__title"], ["nz-row", "", 3, "nzGutter"], [1, "sf__title"], ["nz-col", "", 3, "nzSpan", "nzOffset", "nzXs", "nzSm", "nzMd", "nzLg", "nzXl", "nzXXl"], [3, "formProperty", "fixed-label"], [1, "sf__object-card", 3, "nzTitle", "nzExtra", "nzSize", "nzActions", "nzBodyStyle", "nzBordered", "nzBorderless"], ["cardTitleTpl", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "click"], ["nz-icon", "", "class", "mr-xs text-xs", 3, "nzType"], ["class", "sf__optional"], ["nz-icon", "", 1, "mr-xs", "text-xs", 3, "nzType"], [1, "sf__optional"], ["s", "", "nz-tooltip", "", "nz-icon", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipColor", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [3, "ngTemplateOutlet"]],
  template: function ObjectWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, ObjectWidget_ng_template_0_Template, 3, 2, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, ObjectWidget_Conditional_2_Template, 4, 13, "nz-card", 1)(3, ObjectWidget_Conditional_3_Template, 1, 1);
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275conditional(2, ctx.type === "card" ? 2 : 3);
    }
  },
  dependencies: [NgTemplateOutlet, NzTransitionPatchDirective, NzCardComponent, NzColDirective, NzRowDirective, NzIconDirective, NzTooltipDirective, SFItemComponent, SFFixedDirective],
  encapsulation: 2
});
var ObjectWidget = _ObjectWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObjectWidget, [{
    type: Component,
    args: [{
      selector: "sf-object",
      template: `<ng-template #default let-noTitle>
      @if (!noTitle && title) {
        <div class="sf__title">{{ title }}</div>
      }
      @if (grid) {
        <div nz-row [nzGutter]="grid.gutter">
          @for (i of list; track $index) {
            @if (i.property.visible && i.show) {
              <div
                nz-col
                [nzSpan]="i.grid.span"
                [nzOffset]="i.grid.offset"
                [nzXs]="i.grid.xs"
                [nzSm]="i.grid.sm"
                [nzMd]="i.grid.md"
                [nzLg]="i.grid.lg"
                [nzXl]="i.grid.xl"
                [nzXXl]="i.grid.xxl"
              >
                <sf-item [formProperty]="i.property" [fixed-label]="i.spanLabelFixed" />
              </div>
            }
          }
        </div>
      } @else {
        @for (i of list; track $index) {
          @if (i.property.visible && i.show) {
            <sf-item [formProperty]="i.property" [fixed-label]="i.spanLabelFixed" />
          }
        }
      }
    </ng-template>
    @if (type === 'card') {
      <nz-card
        [nzTitle]="cardTitleTpl"
        [nzExtra]="ui.cardExtra"
        [nzSize]="ui.cardSize || 'small'"
        [nzActions]="ui.cardActions || []"
        [nzBodyStyle]="ui.cardBodyStyle!"
        [nzBordered]="ui.cardBordered || true"
        [nzBorderless]="ui.cardBorderless || false"
        class="sf__object-card"
        [class.sf__object-card-fold]="!expand"
      >
        <ng-template #cardTitleTpl>
          <div [class.point]="showExpand" (click)="changeExpand()">
            @if (showExpand) {
              <i nz-icon [nzType]="expand ? 'down' : 'up'" class="mr-xs text-xs"></i>
            }
            {{ title }}
            @if (ui.optional || oh) {
              <span class="sf__optional">
                {{ ui.optional }}
                @if (oh) {
                  <i
                    s
                    nz-tooltip
                    [nzTooltipTitle]="oh.text"
                    [nzTooltipPlacement]="oh.placement"
                    [nzTooltipTrigger]="oh.trigger"
                    [nzTooltipColor]="oh.bgColor"
                    [nzTooltipOverlayClassName]="oh.overlayClassName"
                    [nzTooltipOverlayStyle]="oh.overlayStyle"
                    [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                    [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                    nz-icon
                    [nzType]="oh.icon!"
                  ></i>
                }
              </span>
            }
          </div>
        </ng-template>
        <ng-template [ngTemplateOutlet]="default" [ngTemplateOutletContext]="{ $implicit: true }" />
      </nz-card>
    } @else {
      <ng-template [ngTemplateOutlet]="default" />
    }`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _RadioWidget = class _RadioWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  reset(value) {
    this.styleType = (this.ui.styleType || "default") === "default";
    getData(this.schema, this.ui, value).subscribe((list2) => {
      this.data = list2;
      this.detectChanges();
    });
  }
  _setValue(value) {
    this.setValue(value);
    if (this.ui.change)
      this.ui.change(value);
  }
};
_RadioWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275RadioWidget_BaseFactory;
  return function RadioWidget_Factory(t) {
    return (\u0275RadioWidget_BaseFactory || (\u0275RadioWidget_BaseFactory = \u0275\u0275getInheritedFactory(_RadioWidget)))(t || _RadioWidget);
  };
})();
_RadioWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _RadioWidget,
  selectors: [["sf-radio"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 4,
  vars: 11,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzSize", "nzName", "ngModel", "nzButtonStyle", "ngModelChange"], ["nz-radio", "", 3, "nzValue", "nzDisabled"], [3, "innerHTML"], ["nz-radio-button", "", 3, "nzValue", "nzDisabled"]],
  template: function RadioWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0)(1, "nz-radio-group", 1);
      \u0275\u0275listener("ngModelChange", function RadioWidget_Template_nz_radio_group_ngModelChange_1_listener($event) {
        return ctx._setValue($event);
      });
      \u0275\u0275template(2, RadioWidget_Conditional_2_Template, 2, 0)(3, RadioWidget_Conditional_3_Template, 2, 0);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzSize", ctx.ui.size)("nzName", ctx.id)("ngModel", ctx.value)("nzButtonStyle", ctx.ui.buttonStyle || "outline");
      \u0275\u0275advance(1);
      \u0275\u0275conditional(2, ctx.styleType ? 2 : 3);
    }
  },
  dependencies: [NgControlStatus, NgModel, NzRadioComponent, NzRadioButtonDirective, NzRadioGroupComponent, SFItemWrapComponent],
  encapsulation: 2
});
var RadioWidget = _RadioWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioWidget, [{
    type: Component,
    args: [{
      selector: "sf-radio",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-radio-group
      [nzSize]="ui.size!"
      [nzName]="id"
      [ngModel]="value"
      (ngModelChange)="_setValue($event)"
      [nzButtonStyle]="ui.buttonStyle || 'outline'"
    >
      @if (styleType) {
        @for (option of data; track $index) {
          <label nz-radio [nzValue]="option.value" [nzDisabled]="disabled || option.disabled">
            <span [innerHTML]="option.label"></span>
          </label>
        }
      } @else {
        @for (option of data; track $index) {
          <label nz-radio-button [nzValue]="option.value" [nzDisabled]="disabled || option.disabled">
            <span [innerHTML]="option.label"></span>
          </label>
        }
      }
    </nz-radio-group>
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _SelectWidget = class _SelectWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.search$ = new Subject();
    this.data = [];
    this.hasGroup = false;
    this.loading = false;
  }
  checkGroup(list2) {
    this.hasGroup = (list2 || []).filter((w) => w.group === true).length > 0;
  }
  ngOnInit() {
    const {
      autoClearSearchValue,
      borderless,
      autoFocus,
      dropdownMatchSelectWidth,
      serverSearch,
      maxMultipleCount,
      mode,
      showSearch,
      tokenSeparators,
      maxTagCount,
      compareWith,
      optionHeightPx,
      optionOverflowSize,
      showArrow
    } = this.ui;
    this.i = {
      autoClearSearchValue: toBool(autoClearSearchValue, true),
      borderless: toBool(borderless, false),
      autoFocus: toBool(autoFocus, false),
      dropdownMatchSelectWidth: toBool(dropdownMatchSelectWidth, true),
      serverSearch: toBool(serverSearch, false),
      maxMultipleCount: maxMultipleCount || Infinity,
      mode: mode || "default",
      showSearch: toBool(showSearch, true),
      tokenSeparators: tokenSeparators || [],
      maxTagCount: maxTagCount || void 0,
      optionHeightPx: optionHeightPx || 32,
      optionOverflowSize: optionOverflowSize || 8,
      showArrow: typeof showArrow !== "boolean" ? void 0 : showArrow,
      compareWith: compareWith || ((o1, o2) => o1 === o2)
    };
    const onSearch = this.ui.onSearch;
    if (onSearch) {
      this.search$.pipe(takeUntil(this.sfItemComp.destroy$), distinctUntilChanged(), debounceTime(this.ui.searchDebounceTime || 300), switchMap((text) => onSearch(text)), catchError(() => [])).subscribe((list2) => {
        this.data = list2;
        this.checkGroup(list2);
        this.loading = false;
        this.detectChanges();
      });
    }
  }
  reset(value) {
    const onSearch = this.ui.onSearch;
    getData(this.schema, this.ui, value).subscribe((list2) => {
      this._value = value;
      if (onSearch == null)
        this.data = list2;
      this.checkGroup(list2);
      this.detectChanges();
    });
    if (value && onSearch != null)
      this.search$.next(value);
  }
  change(values) {
    if (this.ui.change) {
      this.ui.change(values, this.getOrgData(values));
    }
    this.setValue(values == null ? void 0 : values);
  }
  getOrgData(values) {
    const srv = this.injector.get(ArrayService);
    if (!Array.isArray(values)) {
      return srv.findTree(this.data, (item) => item.value === values);
    }
    return values.map((value) => srv.findTree(this.data, (item) => item.value === value));
  }
  openChange(status) {
    if (this.ui.openChange) {
      this.ui.openChange(status);
    }
  }
  scrollToBottom() {
    if (this.ui.scrollToBottom) {
      this.ui.scrollToBottom();
    }
  }
  onSearch(value) {
    if (this.ui.onSearch) {
      this.loading = true;
      this.search$.next(value);
    }
  }
};
_SelectWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275SelectWidget_BaseFactory;
  return function SelectWidget_Factory(t) {
    return (\u0275SelectWidget_BaseFactory || (\u0275SelectWidget_BaseFactory = \u0275\u0275getInheritedFactory(_SelectWidget)))(t || _SelectWidget);
  };
})();
_SelectWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SelectWidget,
  selectors: [["sf-select"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 5,
  vars: 39,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzId", "nzDisabled", "ngModel", "nzSize", "nzPlaceHolder", "nzNotFoundContent", "nzDropdownClassName", "nzAllowClear", "nzDropdownStyle", "nzCustomTemplate", "nzSuffixIcon", "nzRemoveIcon", "nzClearIcon", "nzMenuItemSelectedIcon", "nzMaxTagPlaceholder", "nzDropdownRender", "nzAutoClearSearchValue", "nzBorderless", "nzAutoFocus", "nzDropdownMatchSelectWidth", "nzServerSearch", "nzMaxMultipleCount", "nzMode", "nzShowSearch", "nzShowArrow", "nzTokenSeparators", "nzMaxTagCount", "compareWith", "nzOptionHeightPx", "nzOptionOverflowSize", "ngModelChange", "nzOpenChange", "nzOnSearch", "nzScrollToBottom"], ["nzDisabled", "", "nzCustomContent", ""], [3, "nzLabel", "nzValue", "nzHide", "nzDisabled"], [3, "nzLabel"], [3, "nzLabel", "nzValue", "nzDisabled", "nzHide"], ["nz-icon", "", "nzType", "loading"]],
  template: function SelectWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0)(1, "nz-select", 1);
      \u0275\u0275listener("ngModelChange", function SelectWidget_Template_nz_select_ngModelChange_1_listener($event) {
        return ctx._value = $event;
      })("ngModelChange", function SelectWidget_Template_nz_select_ngModelChange_1_listener($event) {
        return ctx.change($event);
      })("nzOpenChange", function SelectWidget_Template_nz_select_nzOpenChange_1_listener($event) {
        return ctx.openChange($event);
      })("nzOnSearch", function SelectWidget_Template_nz_select_nzOnSearch_1_listener($event) {
        return ctx.onSearch($event);
      })("nzScrollToBottom", function SelectWidget_Template_nz_select_nzScrollToBottom_1_listener() {
        return ctx.scrollToBottom();
      });
      \u0275\u0275template(2, SelectWidget_Conditional_2_Template, 2, 0)(3, SelectWidget_Conditional_3_Template, 2, 0)(4, SelectWidget_Conditional_4_Template, 3, 1, "nz-option", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzId", ctx.id)("nzDisabled", ctx.disabled)("ngModel", ctx._value)("nzSize", ctx.ui.size)("nzPlaceHolder", ctx.ui.placeholder)("nzNotFoundContent", ctx.ui.notFoundContent)("nzDropdownClassName", ctx.ui.dropdownClassName)("nzAllowClear", ctx.ui.allowClear)("nzDropdownStyle", ctx.ui.dropdownStyle)("nzCustomTemplate", ctx.ui.customTemplate)("nzSuffixIcon", ctx.ui.suffixIcon)("nzRemoveIcon", ctx.ui.removeIcon)("nzClearIcon", ctx.ui.clearIcon)("nzMenuItemSelectedIcon", ctx.ui.menuItemSelectedIcon)("nzMaxTagPlaceholder", ctx.ui.maxTagPlaceholder)("nzDropdownRender", ctx.ui.dropdownRender)("nzAutoClearSearchValue", ctx.i.autoClearSearchValue)("nzBorderless", ctx.i.borderless)("nzAutoFocus", ctx.i.autoFocus)("nzDropdownMatchSelectWidth", ctx.i.dropdownMatchSelectWidth)("nzServerSearch", ctx.i.serverSearch)("nzMaxMultipleCount", ctx.i.maxMultipleCount)("nzMode", ctx.i.mode)("nzShowSearch", ctx.i.showSearch)("nzShowArrow", ctx.i.showArrow)("nzTokenSeparators", ctx.i.tokenSeparators)("nzMaxTagCount", ctx.i.maxTagCount)("compareWith", ctx.i.compareWith)("nzOptionHeightPx", ctx.i.optionHeightPx)("nzOptionOverflowSize", ctx.i.optionOverflowSize);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(2, !ctx.loading && !ctx.hasGroup ? 2 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(3, !ctx.loading && ctx.hasGroup ? 3 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(4, ctx.loading ? 4 : -1);
    }
  },
  dependencies: [NgControlStatus, NgModel, NzTransitionPatchDirective, NzIconDirective, NzOptionComponent, NzSelectComponent, NzOptionGroupComponent, SFItemWrapComponent],
  encapsulation: 2
});
var SelectWidget = _SelectWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectWidget, [{
    type: Component,
    args: [{
      selector: "sf-select",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-select
      [nzId]="id"
      [nzDisabled]="disabled"
      [(ngModel)]="_value"
      (ngModelChange)="change($event)"
      [nzSize]="ui.size!"
      [nzPlaceHolder]="ui.placeholder!"
      [nzNotFoundContent]="ui.notFoundContent"
      [nzDropdownClassName]="ui.dropdownClassName!"
      [nzAllowClear]="ui.allowClear"
      [nzDropdownStyle]="ui.dropdownStyle!"
      [nzCustomTemplate]="ui.customTemplate!"
      [nzSuffixIcon]="ui.suffixIcon!"
      [nzRemoveIcon]="ui.removeIcon!"
      [nzClearIcon]="ui.clearIcon!"
      [nzMenuItemSelectedIcon]="ui.menuItemSelectedIcon!"
      [nzMaxTagPlaceholder]="ui.maxTagPlaceholder!"
      [nzDropdownRender]="ui.dropdownRender!"
      [nzAutoClearSearchValue]="i.autoClearSearchValue"
      [nzBorderless]="i.borderless"
      [nzAutoFocus]="i.autoFocus"
      [nzDropdownMatchSelectWidth]="i.dropdownMatchSelectWidth!"
      [nzServerSearch]="i.serverSearch"
      [nzMaxMultipleCount]="i.maxMultipleCount!"
      [nzMode]="i.mode!"
      [nzShowSearch]="i.showSearch"
      [nzShowArrow]="i.showArrow!"
      [nzTokenSeparators]="i.tokenSeparators!"
      [nzMaxTagCount]="i.maxTagCount!"
      [compareWith]="i.compareWith!"
      [nzOptionHeightPx]="i.optionHeightPx!"
      [nzOptionOverflowSize]="i.optionOverflowSize!"
      (nzOpenChange)="openChange($event)"
      (nzOnSearch)="onSearch($event)"
      (nzScrollToBottom)="scrollToBottom()"
    >
      @if (!loading && !hasGroup) {
        @for (o of data; track $index) {
          <nz-option [nzLabel]="o.label" [nzValue]="o.value" [nzHide]="o.hide" [nzDisabled]="o.disabled" />
        }
      }
      @if (!loading && hasGroup) {
        @for (i of data; track $index) {
          <nz-option-group [nzLabel]="i.label">
            @for (o of i.children; track $index) {
              <nz-option [nzLabel]="o.label" [nzValue]="o.value" [nzDisabled]="o.disabled" [nzHide]="o.hide" />
            }
          </nz-option-group>
        }
      }
      @if (loading) {
        <nz-option nzDisabled nzCustomContent>
          <i nz-icon nzType="loading"></i>
          {{ ui.searchLoadingText }}
        </nz-option>
      }
    </nz-select>
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _StringWidget = class _StringWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.change$ = null;
  }
  ngOnInit() {
    const {
      addOnAfter,
      addOnAfterIcon,
      addOnBefore,
      addOnBeforeIcon,
      prefix,
      prefixIcon,
      suffix,
      suffixIcon,
      autofocus
    } = this.ui;
    this.type = !!(addOnAfter || addOnBefore || addOnAfterIcon || addOnBeforeIcon || prefix || prefixIcon || suffix || suffixIcon) ? "addon" : "";
    if (autofocus === true) {
      setTimeout(() => {
        this.injector.get(ElementRef).nativeElement.querySelector(`#${this.id}`).focus();
      }, 20);
    }
    this.initChange();
  }
  reset(value) {
    if (!value && this.schema.format === "color") {
      this.setValue("#000000");
    }
  }
  initChange() {
    const dueTime = this.ui.changeDebounceTime;
    const changeFn = this.ui.change;
    if (dueTime == null || dueTime <= 0 || changeFn == null)
      return;
    this.change$ = new BehaviorSubject(this.value);
    let obs = this.change$.asObservable().pipe(debounceTime(dueTime), takeUntil(this.sfItemComp.destroy$));
    if (this.ui.changeMap != null) {
      obs = obs.pipe(switchMap(this.ui.changeMap));
    }
    obs.subscribe((val) => changeFn(val));
  }
  change(val) {
    this.setValue(val);
    if (this.change$ != null) {
      this.change$.next(val);
      return;
    }
    if (this.ui.change)
      this.ui.change(val);
  }
  focus(e) {
    if (this.ui.focus)
      this.ui.focus(e);
  }
  blur(e) {
    if (this.ui.blur)
      this.ui.blur(e);
  }
  enter(e) {
    if (this.ui.enter)
      this.ui.enter(e);
  }
};
_StringWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275StringWidget_BaseFactory;
  return function StringWidget_Factory(t) {
    return (\u0275StringWidget_BaseFactory || (\u0275StringWidget_BaseFactory = \u0275\u0275getInheritedFactory(_StringWidget)))(t || _StringWidget);
  };
})();
_StringWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _StringWidget,
  selectors: [["sf-string"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 5,
  vars: 7,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], ["ipt", ""], [3, "nzAddOnBefore", "nzAddOnAfter", "nzAddOnBeforeIcon", "nzAddOnAfterIcon", "nzPrefix", "nzPrefixIcon", "nzSuffix", "nzSuffixIcon"], ["nz-input", "", 3, "disabled", "nzSize", "nzBorderless", "ngModel", "ngModelChange", "keyup.enter", "focus", "blur"], [3, "ngTemplateOutlet"]],
  template: function StringWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0);
      \u0275\u0275template(1, StringWidget_ng_template_1_Template, 1, 11, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, StringWidget_Conditional_3_Template, 2, 9, "nz-input-group", 2)(4, StringWidget_Conditional_4_Template, 1, 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(3);
      \u0275\u0275conditional(3, ctx.type === "addon" ? 3 : 4);
    }
  },
  dependencies: [NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, NzTransitionPatchDirective, NzInputDirective, NzInputGroupComponent, NzInputGroupWhitSuffixOrPrefixDirective, SFItemWrapComponent],
  encapsulation: 2
});
var StringWidget = _StringWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringWidget, [{
    type: Component,
    args: [{
      selector: "sf-string",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <ng-template #ipt>
      <input
        nz-input
        [attr.id]="id"
        [disabled]="disabled"
        [attr.disabled]="disabled"
        [nzSize]="ui.size!"
        [nzBorderless]="ui.borderless"
        [ngModel]="value"
        (ngModelChange)="change($event)"
        [attr.maxLength]="schema.maxLength || null"
        [attr.type]="ui.type || 'text'"
        [attr.placeholder]="ui.placeholder"
        [attr.autocomplete]="ui.autocomplete"
        [attr.autoFocus]="ui.autofocus"
        (keyup.enter)="enter($event)"
        (focus)="focus($event)"
        (blur)="blur($event)"
      />
    </ng-template>

    @if (type === 'addon') {
      <nz-input-group
        [nzAddOnBefore]="ui.addOnBefore"
        [nzAddOnAfter]="ui.addOnAfter"
        [nzAddOnBeforeIcon]="ui.addOnBeforeIcon"
        [nzAddOnAfterIcon]="ui.addOnAfterIcon"
        [nzPrefix]="ui.prefix"
        [nzPrefixIcon]="ui.prefixIcon"
        [nzSuffix]="ui.suffix"
        [nzSuffixIcon]="ui.suffixIcon"
      >
        <ng-template [ngTemplateOutlet]="ipt" />
      </nz-input-group>
    } @else {
      <ng-template [ngTemplateOutlet]="ipt" />
    }
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _TextWidget = class _TextWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  ngOnInit() {
    this.ui._required = false;
    this.ui.html = toBool(this.ui.html, true);
  }
  reset(value) {
    this.text = value || this.ui.defaultText || "-";
  }
};
_TextWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275TextWidget_BaseFactory;
  return function TextWidget_Factory(t) {
    return (\u0275TextWidget_BaseFactory || (\u0275TextWidget_BaseFactory = \u0275\u0275getInheritedFactory(_TextWidget)))(t || _TextWidget);
  };
})();
_TextWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TextWidget,
  selectors: [["sf-text"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 3,
  vars: 9,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "innerHTML"], [3, "innerText"]],
  template: function TextWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0);
      \u0275\u0275template(1, TextWidget_Conditional_1_Template, 1, 1, "span", 1)(2, TextWidget_Conditional_2_Template, 1, 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("sf__text-html", ctx.ui.html);
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx.ui.html ? 1 : 2);
    }
  },
  dependencies: [SFItemWrapComponent],
  encapsulation: 2
});
var TextWidget = _TextWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextWidget, [{
    type: Component,
    args: [{
      selector: "sf-text",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
    [class.sf__text-html]="ui.html"
  >
    @if (ui.html) {
      <span [innerHTML]="text"></span>
    } @else {
      <span [innerText]="text"></span>
    }
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _TextareaWidget = class _TextareaWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.autosize = true;
  }
  ngOnInit() {
    if (this.ui.autosize != null) {
      this.autosize = this.ui.autosize;
    }
    if (this.ui.computeCharacterCount == null) {
      this.ui.computeCharacterCount = (v) => v.length;
    }
  }
  change(val) {
    this.setValue(val);
    if (this.ui.change)
      this.ui.change(val);
  }
  focus(e) {
    if (this.ui.focus)
      this.ui.focus(e);
  }
  blur(e) {
    if (this.ui.blur)
      this.ui.blur(e);
  }
};
_TextareaWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275TextareaWidget_BaseFactory;
  return function TextareaWidget_Factory(t) {
    return (\u0275TextareaWidget_BaseFactory || (\u0275TextareaWidget_BaseFactory = \u0275\u0275getInheritedFactory(_TextareaWidget)))(t || _TextareaWidget);
  };
})();
_TextareaWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TextareaWidget,
  selectors: [["sf-textarea"]],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 5,
  vars: 7,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], ["ipt", ""], [3, "nzMaxCharacterCount", "nzComputeCharacterCount"], ["nz-input", "", 3, "disabled", "nzSize", "ngModel", "nzAutosize", "nzBorderless", "ngModelChange", "focus", "blur"], [3, "ngTemplateOutlet"]],
  template: function TextareaWidget_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "sf-item-wrap", 0);
      \u0275\u0275template(1, TextareaWidget_ng_template_1_Template, 2, 9, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, TextareaWidget_Conditional_3_Template, 3, 11, "nz-textarea-count", 2)(4, TextareaWidget_Conditional_4_Template, 1, 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      \u0275\u0275advance(3);
      \u0275\u0275conditional(3, ctx.ui.maxCharacterCount ? 3 : 4);
    }
  },
  dependencies: [NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, NzTextareaCountComponent, NzInputDirective, NzAutosizeDirective, SFItemWrapComponent],
  encapsulation: 2
});
var TextareaWidget = _TextareaWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextareaWidget, [{
    type: Component,
    args: [{
      selector: "sf-textarea",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <ng-template #ipt>
      <textarea
        nz-input
        [attr.id]="id"
        [disabled]="disabled"
        [attr.disabled]="disabled"
        [nzSize]="ui.size!"
        [ngModel]="value"
        (ngModelChange)="change($event)"
        [attr.maxLength]="schema.maxLength || null"
        [attr.placeholder]="ui.placeholder"
        [nzAutosize]="autosize"
        [nzBorderless]="ui.borderless"
        (focus)="focus($event)"
        (blur)="blur($event)"
      >
      </textarea>
    </ng-template>

    @if (ui.maxCharacterCount) {
      <nz-textarea-count
        [nzMaxCharacterCount]="ui.maxCharacterCount"
        [nzComputeCharacterCount]="ui.computeCharacterCount!"
      >
        <textarea
          nz-input
          [attr.id]="id"
          [disabled]="disabled"
          [attr.disabled]="disabled"
          [nzSize]="ui.size!"
          [ngModel]="value"
          (ngModelChange)="change($event)"
          [attr.maxLength]="schema.maxLength || null"
          [attr.placeholder]="ui.placeholder"
          [nzAutosize]="autosize"
          [nzBorderless]="ui.borderless"
          (focus)="focus($event)"
          (blur)="blur($event)"
        >
        </textarea>
      </nz-textarea-count>
    } @else {
      <ng-template [ngTemplateOutlet]="ipt" />
    }
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var NzWidgetRegistry = class extends WidgetRegistry {
  constructor() {
    super();
    this.register("object", ObjectWidget);
    this.register("array", ArrayWidget);
    this.register("text", TextWidget);
    this.register("string", StringWidget);
    this.register("number", NumberWidget);
    this.register("integer", NumberWidget);
    this.register("date", DateWidget);
    this.register("radio", RadioWidget);
    this.register("checkbox", CheckboxWidget);
    this.register("boolean", BooleanWidget);
    this.register("textarea", TextareaWidget);
    this.register("select", SelectWidget);
    this.register("custom", CustomWidget);
    this.setDefault(StringWidget);
  }
};
var ZORROS = [NzButtonModule, NzCardModule, NzCheckboxModule, NzDatePickerModule, NzFormModule, NzGridModule, NzIconModule, NzInputModule, NzInputNumberModule, NzModalModule, NzRadioModule, NzSelectModule, NzSwitchModule, NzToolTipModule];
var COMPONENTS3 = [SFComponent, SFItemComponent, SFItemWrapComponent, SFTemplateDirective, SFFixedDirective];
var WIDGETS = [ObjectWidget, ArrayWidget, StringWidget, NumberWidget, DateWidget, RadioWidget, CheckboxWidget, BooleanWidget, TextareaWidget, SelectWidget, CustomWidget, TextWidget];
var _DelonFormModule = class _DelonFormModule {
  static forRoot() {
    return {
      ngModule: _DelonFormModule,
      providers: [{
        provide: SchemaValidatorFactory,
        useClass: AjvSchemaValidatorFactory,
        deps: [AlainConfigService, NgZone]
      }, {
        provide: WidgetRegistry,
        useClass: NzWidgetRegistry
      }]
    };
  }
};
_DelonFormModule.\u0275fac = function DelonFormModule_Factory(t) {
  return new (t || _DelonFormModule)();
};
_DelonFormModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _DelonFormModule
});
_DelonFormModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, FormsModule, DelonLocaleModule, ZORROS]
});
var DelonFormModule = _DelonFormModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DelonFormModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, DelonLocaleModule, ...ZORROS],
      declarations: [...COMPONENTS3, ...WIDGETS],
      exports: COMPONENTS3
    }]
  }], null, null);
})();
function provideSFConfig(options) {
  const provides = [{
    provide: SchemaValidatorFactory,
    useClass: AjvSchemaValidatorFactory,
    deps: [AlainConfigService, NgZone]
  }, {
    provide: WidgetRegistry,
    useClass: NzWidgetRegistry
  }];
  if (options?.widgets) {
    provides.push({
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useValue: () => {
        const srv = inject(WidgetRegistry);
        options?.widgets?.forEach((widget) => srv.register(widget.KEY, widget.type));
      }
    });
  }
  return makeEnvironmentProviders(provides);
}

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-tabs.mjs
function NzTabAddButtonComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const icon_r1 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", icon_r1);
  }
}
function NzTabNavOperationComponent_ul_5_li_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r5 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", item_r5.tab.label, " ");
  }
}
var _c025 = () => ({
  visible: false
});
function NzTabNavOperationComponent_ul_5_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 8);
    \u0275\u0275listener("click", function NzTabNavOperationComponent_ul_5_li_1_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r9);
      const item_r5 = restoredCtx.$implicit;
      const ctx_r8 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r8.onSelect(item_r5));
    })("contextmenu", function NzTabNavOperationComponent_ul_5_li_1_Template_li_contextmenu_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r9);
      const item_r5 = restoredCtx.$implicit;
      const ctx_r10 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r10.onContextmenu(item_r5, $event));
    });
    \u0275\u0275template(1, NzTabNavOperationComponent_ul_5_li_1_ng_container_1_Template, 2, 1, "ng-container", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    \u0275\u0275classProp("ant-tabs-dropdown-menu-item-disabled", item_r5.disabled);
    \u0275\u0275property("nzSelected", item_r5.active)("nzDisabled", item_r5.disabled);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", item_r5.tab.label)("nzStringTemplateOutletContext", \u0275\u0275pureFunction0(6, _c025));
  }
}
function NzTabNavOperationComponent_ul_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 6);
    \u0275\u0275template(1, NzTabNavOperationComponent_ul_5_li_1_Template, 2, 7, "li", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r2.items);
  }
}
function NzTabNavOperationComponent_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 10);
    \u0275\u0275listener("click", function NzTabNavOperationComponent_button_6_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11.addClicked.emit());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("addIcon", ctx_r3.addIcon);
  }
}
var _c118 = () => ({
  minWidth: "46px"
});
var _c215 = ["navWarp"];
var _c311 = ["navList"];
function NzTabNavBarComponent_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 8);
    \u0275\u0275listener("click", function NzTabNavBarComponent_button_5_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.addClicked.emit());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("addIcon", ctx_r2.addIcon);
    \u0275\u0275attribute("tabindex", -1);
  }
}
function NzTabNavBarComponent_div_8_ng_template_1_Template(rf, ctx) {
}
function NzTabNavBarComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275template(1, NzTabNavBarComponent_div_8_ng_template_1_Template, 0, 0, "ng-template", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.extraTemplate);
  }
}
var _c49 = ["*"];
var _c56 = ["nz-tab-body", ""];
function NzTabBodyComponent_ng_container_0_ng_template_1_Template(rf, ctx) {
}
function NzTabBodyComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTabBodyComponent_ng_container_0_ng_template_1_Template, 0, 0, "ng-template", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.content);
  }
}
function NzTabCloseButtonComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const icon_r1 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", icon_r1);
  }
}
var _c65 = ["contentTemplate"];
function NzTabComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
function NzTabComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0, 1);
  }
}
var _c74 = [[["", "nz-tab-link", ""]], "*"];
var _c84 = ["[nz-tab-link]", "*"];
function NzTabSetComponent_nz_tabs_nav_0_div_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tab_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(tab_r3.label);
  }
}
function NzTabSetComponent_nz_tabs_nav_0_div_1_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 10);
    \u0275\u0275listener("click", function NzTabSetComponent_nz_tabs_nav_0_div_1_button_3_Template_button_click_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const i_r4 = \u0275\u0275nextContext().index;
      const ctx_r8 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r8.onClose(i_r4, $event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tab_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("closeIcon", tab_r3.nzCloseIcon);
  }
}
var _c94 = () => ({
  visible: true
});
function NzTabSetComponent_nz_tabs_nav_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275listener("click", function NzTabSetComponent_nz_tabs_nav_0_div_1_Template_div_click_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r13);
      const tab_r3 = restoredCtx.$implicit;
      const i_r4 = restoredCtx.index;
      const ctx_r12 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r12.clickNavItem(tab_r3, i_r4, $event));
    })("contextmenu", function NzTabSetComponent_nz_tabs_nav_0_div_1_Template_div_contextmenu_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r13);
      const tab_r3 = restoredCtx.$implicit;
      const ctx_r14 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r14.contextmenuNavItem(tab_r3, $event));
    });
    \u0275\u0275elementStart(1, "button", 7);
    \u0275\u0275template(2, NzTabSetComponent_nz_tabs_nav_0_div_1_ng_container_2_Template, 2, 1, "ng-container", 8)(3, NzTabSetComponent_nz_tabs_nav_0_div_1_button_3_Template, 1, 1, "button", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const tab_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("margin-right", ctx_r2.position === "horizontal" ? ctx_r2.nzTabBarGutter : null, "px")("margin-bottom", ctx_r2.position === "vertical" ? ctx_r2.nzTabBarGutter : null, "px");
    \u0275\u0275classProp("ant-tabs-tab-active", ctx_r2.nzSelectedIndex === i_r4)("ant-tabs-tab-disabled", tab_r3.nzDisabled);
    \u0275\u0275advance(1);
    \u0275\u0275property("id", ctx_r2.getTabContentId(i_r4))("disabled", tab_r3.nzDisabled)("tab", tab_r3)("active", ctx_r2.nzSelectedIndex === i_r4);
    \u0275\u0275attribute("tabIndex", ctx_r2.getTabIndex(tab_r3, i_r4))("aria-disabled", tab_r3.nzDisabled)("aria-selected", ctx_r2.nzSelectedIndex === i_r4 && !ctx_r2.nzHideAll)("aria-controls", ctx_r2.getTabContentId(i_r4));
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", tab_r3.label)("nzStringTemplateOutletContext", \u0275\u0275pureFunction0(19, _c94));
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", tab_r3.nzClosable && ctx_r2.closable && !tab_r3.nzDisabled);
  }
}
function NzTabSetComponent_nz_tabs_nav_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-tabs-nav", 4);
    \u0275\u0275listener("tabScroll", function NzTabSetComponent_nz_tabs_nav_0_Template_nz_tabs_nav_tabScroll_0_listener($event) {
      \u0275\u0275restoreView(_r16);
      const ctx_r15 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r15.nzTabListScroll.emit($event));
    })("selectFocusedIndex", function NzTabSetComponent_nz_tabs_nav_0_Template_nz_tabs_nav_selectFocusedIndex_0_listener($event) {
      \u0275\u0275restoreView(_r16);
      const ctx_r17 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r17.setSelectedIndex($event));
    })("addClicked", function NzTabSetComponent_nz_tabs_nav_0_Template_nz_tabs_nav_addClicked_0_listener() {
      \u0275\u0275restoreView(_r16);
      const ctx_r18 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r18.onAdd());
    });
    \u0275\u0275template(1, NzTabSetComponent_nz_tabs_nav_0_div_1_Template, 4, 20, "div", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngStyle", ctx_r0.nzTabBarStyle)("selectedIndex", ctx_r0.nzSelectedIndex || 0)("inkBarAnimated", ctx_r0.inkBarAnimated)("addable", ctx_r0.addable)("addIcon", ctx_r0.nzAddIcon)("hideBar", ctx_r0.nzHideAll)("position", ctx_r0.position)("extraTemplate", ctx_r0.nzTabBarExtraContent);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.tabs);
  }
}
function NzTabSetComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 11);
  }
  if (rf & 2) {
    const tab_r19 = ctx.$implicit;
    const i_r20 = ctx.index;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("id", ctx_r1.getTabContentId(i_r20))("active", ctx_r1.nzSelectedIndex === i_r20 && !ctx_r1.nzHideAll)("content", tab_r19.content)("forceRender", tab_r19.nzForceRender)("tabPaneAnimated", ctx_r1.tabPaneAnimated);
    \u0275\u0275attribute("aria-labelledby", ctx_r1.getTabContentId(i_r20));
  }
}
var _NzTabAddButtonComponent = class _NzTabAddButtonComponent {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.addIcon = "plus";
    this.element = this.elementRef.nativeElement;
  }
  getElementWidth() {
    return this.element?.offsetWidth || 0;
  }
  getElementHeight() {
    return this.element?.offsetHeight || 0;
  }
};
_NzTabAddButtonComponent.\u0275fac = function NzTabAddButtonComponent_Factory(t) {
  return new (t || _NzTabAddButtonComponent)(\u0275\u0275directiveInject(ElementRef));
};
_NzTabAddButtonComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTabAddButtonComponent,
  selectors: [["nz-tab-add-button"], ["button", "nz-tab-add-button", ""]],
  hostAttrs: ["aria-label", "Add tab", "type", "button", 1, "ant-tabs-nav-add"],
  inputs: {
    addIcon: "addIcon"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 1,
  consts: [[4, "nzStringTemplateOutlet"], ["nz-icon", "", "nzTheme", "outline", 3, "nzType"]],
  template: function NzTabAddButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTabAddButtonComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("nzStringTemplateOutlet", ctx.addIcon);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective, NzIconModule, NzIconDirective],
  encapsulation: 2
});
var NzTabAddButtonComponent = _NzTabAddButtonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabAddButtonComponent, [{
    type: Component,
    args: [{
      selector: "nz-tab-add-button, button[nz-tab-add-button]",
      template: `
    <ng-container *nzStringTemplateOutlet="addIcon; let icon">
      <span nz-icon [nzType]="icon" nzTheme="outline"></span>
    </ng-container>
  `,
      host: {
        class: "ant-tabs-nav-add",
        "aria-label": "Add tab",
        type: "button"
      },
      imports: [NzOutletModule, NzIconModule],
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], {
    addIcon: [{
      type: Input
    }]
  });
})();
var _NzTabsInkBarDirective = class _NzTabsInkBarDirective {
  get _animated() {
    return this.animationMode !== "NoopAnimations" && this.animated;
  }
  constructor(elementRef, ngZone, animationMode) {
    this.elementRef = elementRef;
    this.ngZone = ngZone;
    this.animationMode = animationMode;
    this.position = "horizontal";
    this.animated = true;
  }
  alignToElement(element) {
    this.ngZone.runOutsideAngular(() => {
      reqAnimFrame(() => this.setStyles(element));
    });
  }
  setStyles(element) {
    const inkBar = this.elementRef.nativeElement;
    if (this.position === "horizontal") {
      inkBar.style.top = "";
      inkBar.style.height = "";
      inkBar.style.left = this.getLeftPosition(element);
      inkBar.style.width = this.getElementWidth(element);
    } else {
      inkBar.style.left = "";
      inkBar.style.width = "";
      inkBar.style.top = this.getTopPosition(element);
      inkBar.style.height = this.getElementHeight(element);
    }
  }
  getLeftPosition(element) {
    return element ? `${element.offsetLeft || 0}px` : "0";
  }
  getElementWidth(element) {
    return element ? `${element.offsetWidth || 0}px` : "0";
  }
  getTopPosition(element) {
    return element ? `${element.offsetTop || 0}px` : "0";
  }
  getElementHeight(element) {
    return element ? `${element.offsetHeight || 0}px` : "0";
  }
};
_NzTabsInkBarDirective.\u0275fac = function NzTabsInkBarDirective_Factory(t) {
  return new (t || _NzTabsInkBarDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ANIMATION_MODULE_TYPE, 8));
};
_NzTabsInkBarDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTabsInkBarDirective,
  selectors: [["nz-tabs-ink-bar"], ["", "nz-tabs-ink-bar", ""]],
  hostAttrs: [1, "ant-tabs-ink-bar"],
  hostVars: 2,
  hostBindings: function NzTabsInkBarDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-tabs-ink-bar-animated", ctx._animated);
    }
  },
  inputs: {
    position: "position",
    animated: "animated"
  },
  standalone: true
});
var NzTabsInkBarDirective = _NzTabsInkBarDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabsInkBarDirective, [{
    type: Directive,
    args: [{
      selector: "nz-tabs-ink-bar, [nz-tabs-ink-bar]",
      host: {
        class: "ant-tabs-ink-bar",
        "[class.ant-tabs-ink-bar-animated]": "_animated"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ANIMATION_MODULE_TYPE]
    }]
  }], {
    position: [{
      type: Input
    }],
    animated: [{
      type: Input
    }]
  });
})();
var _NzTabNavItemDirective = class _NzTabNavItemDirective {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.disabled = false;
    this.active = false;
    this.el = elementRef.nativeElement;
    this.parentElement = this.el.parentElement;
  }
  focus() {
    this.el.focus();
  }
  get width() {
    return this.parentElement.offsetWidth;
  }
  get height() {
    return this.parentElement.offsetHeight;
  }
  get left() {
    return this.parentElement.offsetLeft;
  }
  get top() {
    return this.parentElement.offsetTop;
  }
};
_NzTabNavItemDirective.\u0275fac = function NzTabNavItemDirective_Factory(t) {
  return new (t || _NzTabNavItemDirective)(\u0275\u0275directiveInject(ElementRef));
};
_NzTabNavItemDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTabNavItemDirective,
  selectors: [["", "nzTabNavItem", ""]],
  inputs: {
    disabled: "disabled",
    tab: "tab",
    active: "active"
  },
  standalone: true
});
var NzTabNavItemDirective = _NzTabNavItemDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabNavItemDirective, [{
    type: Directive,
    args: [{
      selector: "[nzTabNavItem]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], {
    disabled: [{
      type: Input
    }],
    tab: [{
      type: Input
    }],
    active: [{
      type: Input
    }]
  });
})();
var _NzTabNavOperationComponent = class _NzTabNavOperationComponent {
  constructor(cdr, elementRef) {
    this.cdr = cdr;
    this.elementRef = elementRef;
    this.items = [];
    this.addable = false;
    this.addIcon = "plus";
    this.addClicked = new EventEmitter();
    this.selected = new EventEmitter();
    this.closeAnimationWaitTimeoutId = -1;
    this.menuOpened = false;
    this.element = this.elementRef.nativeElement;
  }
  onSelect(item) {
    if (!item.disabled) {
      item.tab.nzClick.emit();
      this.selected.emit(item);
    }
  }
  onContextmenu(item, e) {
    if (!item.disabled) {
      item.tab.nzContextmenu.emit(e);
    }
  }
  showItems() {
    clearTimeout(this.closeAnimationWaitTimeoutId);
    this.menuOpened = true;
    this.cdr.markForCheck();
  }
  menuVisChange(visible) {
    if (!visible) {
      this.closeAnimationWaitTimeoutId = setTimeout(() => {
        this.menuOpened = false;
        this.cdr.markForCheck();
      }, 150);
    }
  }
  getElementWidth() {
    return this.element?.offsetWidth || 0;
  }
  getElementHeight() {
    return this.element?.offsetHeight || 0;
  }
  ngOnDestroy() {
    clearTimeout(this.closeAnimationWaitTimeoutId);
  }
};
_NzTabNavOperationComponent.\u0275fac = function NzTabNavOperationComponent_Factory(t) {
  return new (t || _NzTabNavOperationComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef));
};
_NzTabNavOperationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTabNavOperationComponent,
  selectors: [["nz-tab-nav-operation"]],
  hostAttrs: [1, "ant-tabs-nav-operations"],
  hostVars: 2,
  hostBindings: function NzTabNavOperationComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-tabs-nav-operations-hidden", ctx.items.length === 0);
    }
  },
  inputs: {
    items: "items",
    addable: "addable",
    addIcon: "addIcon"
  },
  outputs: {
    addClicked: "addClicked",
    selected: "selected"
  },
  exportAs: ["nzTabNavOperation"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 7,
  vars: 6,
  consts: [["nz-dropdown", "", "type", "button", "tabindex", "-1", "aria-hidden", "true", "nzOverlayClassName", "nz-tabs-dropdown", 1, "ant-tabs-nav-more", 3, "nzDropdownMenu", "nzOverlayStyle", "nzMatchWidthElement", "nzVisibleChange", "mouseenter"], ["dropdownTrigger", "nzDropdown"], ["nz-icon", "", "nzType", "ellipsis"], ["menu", "nzDropdownMenu"], ["nz-menu", "", 4, "ngIf"], ["nz-tab-add-button", "", 3, "addIcon", "click", 4, "ngIf"], ["nz-menu", ""], ["nz-menu-item", "", "class", "ant-tabs-dropdown-menu-item", 3, "ant-tabs-dropdown-menu-item-disabled", "nzSelected", "nzDisabled", "click", "contextmenu", 4, "ngFor", "ngForOf"], ["nz-menu-item", "", 1, "ant-tabs-dropdown-menu-item", 3, "nzSelected", "nzDisabled", "click", "contextmenu"], [4, "nzStringTemplateOutlet", "nzStringTemplateOutletContext"], ["nz-tab-add-button", "", 3, "addIcon", "click"]],
  template: function NzTabNavOperationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0, 1);
      \u0275\u0275listener("nzVisibleChange", function NzTabNavOperationComponent_Template_button_nzVisibleChange_0_listener($event) {
        return ctx.menuVisChange($event);
      })("mouseenter", function NzTabNavOperationComponent_Template_button_mouseenter_0_listener() {
        return ctx.showItems();
      });
      \u0275\u0275element(2, "span", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "nz-dropdown-menu", null, 3);
      \u0275\u0275template(5, NzTabNavOperationComponent_ul_5_Template, 2, 1, "ul", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275template(6, NzTabNavOperationComponent_button_6_Template, 1, 1, "button", 5);
    }
    if (rf & 2) {
      const _r1 = \u0275\u0275reference(4);
      \u0275\u0275property("nzDropdownMenu", _r1)("nzOverlayStyle", \u0275\u0275pureFunction0(5, _c118))("nzMatchWidthElement", null);
      \u0275\u0275advance(5);
      \u0275\u0275property("ngIf", ctx.menuOpened);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.addable);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NgIf, NgForOf, NzOutletModule, NzStringTemplateOutletDirective, NzTabAddButtonComponent, NzDropdownMenuComponent, NzMenuModule, NzMenuDirective, NzMenuItemComponent, NzDropDownDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzTabNavOperationComponent = _NzTabNavOperationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabNavOperationComponent, [{
    type: Component,
    args: [{
      selector: "nz-tab-nav-operation",
      exportAs: "nzTabNavOperation",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <button
      nz-dropdown
      class="ant-tabs-nav-more"
      type="button"
      tabindex="-1"
      aria-hidden="true"
      nzOverlayClassName="nz-tabs-dropdown"
      #dropdownTrigger="nzDropdown"
      [nzDropdownMenu]="menu"
      [nzOverlayStyle]="{ minWidth: '46px' }"
      [nzMatchWidthElement]="null"
      (nzVisibleChange)="menuVisChange($event)"
      (mouseenter)="showItems()"
    >
      <span nz-icon nzType="ellipsis"></span>
    </button>
    <nz-dropdown-menu #menu="nzDropdownMenu">
      <ul nz-menu *ngIf="menuOpened">
        <li
          nz-menu-item
          *ngFor="let item of items"
          class="ant-tabs-dropdown-menu-item"
          [class.ant-tabs-dropdown-menu-item-disabled]="item.disabled"
          [nzSelected]="item.active"
          [nzDisabled]="item.disabled"
          (click)="onSelect(item)"
          (contextmenu)="onContextmenu(item, $event)"
        >
          <ng-container *nzStringTemplateOutlet="item.tab.label; context: { visible: false }">
            {{ item.tab.label }}
          </ng-container>
        </li>
      </ul>
    </nz-dropdown-menu>
    <button *ngIf="addable" nz-tab-add-button [addIcon]="addIcon" (click)="addClicked.emit()"></button>
  `,
      host: {
        class: "ant-tabs-nav-operations",
        "[class.ant-tabs-nav-operations-hidden]": "items.length === 0"
      },
      imports: [NzIconModule, NgIf, NgForOf, NzOutletModule, NzTabAddButtonComponent, NzDropdownMenuComponent, NzMenuModule, NzDropDownDirective],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }], {
    items: [{
      type: Input
    }],
    addable: [{
      type: Input
    }],
    addIcon: [{
      type: Input
    }],
    addClicked: [{
      type: Output
    }],
    selected: [{
      type: Output
    }]
  });
})();
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = 0.995 ** REFRESH_INTERVAL;
var _NzTabScrollListDirective = class _NzTabScrollListDirective {
  constructor(ngZone, elementRef) {
    this.ngZone = ngZone;
    this.elementRef = elementRef;
    this.lastWheelDirection = null;
    this.lastWheelTimestamp = 0;
    this.lastTimestamp = 0;
    this.lastTimeDiff = 0;
    this.lastMixedWheel = 0;
    this.lastWheelPrevent = false;
    this.touchPosition = null;
    this.lastOffset = null;
    this.motion = -1;
    this.unsubscribe = () => void 0;
    this.offsetChange = new EventEmitter();
    this.tabScroll = new EventEmitter();
    this.onTouchEnd = (e) => {
      if (!this.touchPosition) {
        return;
      }
      const lastOffset = this.lastOffset;
      const lastTimeDiff = this.lastTimeDiff;
      this.lastOffset = this.touchPosition = null;
      if (lastOffset) {
        const distanceX = lastOffset.x / lastTimeDiff;
        const distanceY = lastOffset.y / lastTimeDiff;
        const absX = Math.abs(distanceX);
        const absY = Math.abs(distanceY);
        if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) {
          return;
        }
        let currentX = distanceX;
        let currentY = distanceY;
        this.motion = window.setInterval(() => {
          if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
            window.clearInterval(this.motion);
            return;
          }
          currentX *= SPEED_OFF_MULTIPLE;
          currentY *= SPEED_OFF_MULTIPLE;
          this.onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL, e);
        }, REFRESH_INTERVAL);
      }
    };
    this.onTouchMove = (e) => {
      if (!this.touchPosition) {
        return;
      }
      e.preventDefault();
      const {
        screenX,
        screenY
      } = e.touches[0];
      const offsetX = screenX - this.touchPosition.x;
      const offsetY = screenY - this.touchPosition.y;
      this.onOffset(offsetX, offsetY, e);
      const now = Date.now();
      this.lastTimeDiff = now - this.lastTimestamp;
      this.lastTimestamp = now;
      this.lastOffset = {
        x: offsetX,
        y: offsetY
      };
      this.touchPosition = {
        x: screenX,
        y: screenY
      };
    };
    this.onTouchStart = (e) => {
      const {
        screenX,
        screenY
      } = e.touches[0];
      this.touchPosition = {
        x: screenX,
        y: screenY
      };
      window.clearInterval(this.motion);
    };
    this.onWheel = (e) => {
      const {
        deltaX,
        deltaY
      } = e;
      let mixed;
      const absX = Math.abs(deltaX);
      const absY = Math.abs(deltaY);
      if (absX === absY) {
        mixed = this.lastWheelDirection === "x" ? deltaX : deltaY;
      } else if (absX > absY) {
        mixed = deltaX;
        this.lastWheelDirection = "x";
      } else {
        mixed = deltaY;
        this.lastWheelDirection = "y";
      }
      const now = Date.now();
      const absMixed = Math.abs(mixed);
      if (now - this.lastWheelTimestamp > 100 || absMixed - this.lastMixedWheel > 10) {
        this.lastWheelPrevent = false;
      }
      this.onOffset(-mixed, -mixed, e);
      if (e.defaultPrevented || this.lastWheelPrevent) {
        this.lastWheelPrevent = true;
      }
      this.lastWheelTimestamp = now;
      this.lastMixedWheel = absMixed;
    };
  }
  ngOnInit() {
    this.unsubscribe = this.ngZone.runOutsideAngular(() => {
      const el = this.elementRef.nativeElement;
      const wheel$ = fromEvent(el, "wheel");
      const touchstart$ = fromEvent(el, "touchstart");
      const touchmove$ = fromEvent(el, "touchmove");
      const touchend$ = fromEvent(el, "touchend");
      const subscription = new Subscription();
      subscription.add(this.subscribeWrap("wheel", wheel$, this.onWheel));
      subscription.add(this.subscribeWrap("touchstart", touchstart$, this.onTouchStart));
      subscription.add(this.subscribeWrap("touchmove", touchmove$, this.onTouchMove));
      subscription.add(this.subscribeWrap("touchend", touchend$, this.onTouchEnd));
      return () => {
        subscription.unsubscribe();
      };
    });
  }
  subscribeWrap(type, observable, handler) {
    return observable.subscribe((event) => {
      this.tabScroll.emit({
        type,
        event
      });
      if (!event.defaultPrevented) {
        handler(event);
      }
    });
  }
  onOffset(x, y, event) {
    this.ngZone.run(() => {
      this.offsetChange.emit({
        x,
        y,
        event
      });
    });
  }
  ngOnDestroy() {
    this.unsubscribe();
  }
};
_NzTabScrollListDirective.\u0275fac = function NzTabScrollListDirective_Factory(t) {
  return new (t || _NzTabScrollListDirective)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef));
};
_NzTabScrollListDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTabScrollListDirective,
  selectors: [["", "nzTabScrollList", ""]],
  outputs: {
    offsetChange: "offsetChange",
    tabScroll: "tabScroll"
  },
  standalone: true
});
var NzTabScrollListDirective = _NzTabScrollListDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabScrollListDirective, [{
    type: Directive,
    args: [{
      selector: "[nzTabScrollList]",
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }], {
    offsetChange: [{
      type: Output
    }],
    tabScroll: [{
      type: Output
    }]
  });
})();
var RESIZE_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var CSS_TRANSFORM_TIME = 150;
var _NzTabNavBarComponent = class _NzTabNavBarComponent {
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(value) {
    const newValue = coerceNumberProperty(value);
    if (this._selectedIndex !== newValue) {
      this._selectedIndex = value;
      this.selectedIndexChanged = true;
      if (this.keyManager) {
        this.keyManager.updateActiveItem(value);
      }
    }
  }
  /** Tracks which element has focus; used for keyboard navigation */
  get focusIndex() {
    return this.keyManager ? this.keyManager.activeItemIndex : 0;
  }
  /** When the focus index is set, we must manually send focus to the correct label */
  set focusIndex(value) {
    if (!this.isValidIndex(value) || this.focusIndex === value || !this.keyManager) {
      return;
    }
    this.keyManager.setActiveItem(value);
  }
  get showAddButton() {
    return this.hiddenItems.length === 0 && this.addable;
  }
  constructor(cdr, ngZone, viewportRuler, nzResizeObserver, dir) {
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.viewportRuler = viewportRuler;
    this.nzResizeObserver = nzResizeObserver;
    this.dir = dir;
    this.indexFocused = new EventEmitter();
    this.selectFocusedIndex = new EventEmitter();
    this.addClicked = new EventEmitter();
    this.tabScroll = new EventEmitter();
    this.position = "horizontal";
    this.addable = false;
    this.hideBar = false;
    this.addIcon = "plus";
    this.inkBarAnimated = true;
    this.translate = null;
    this.transformX = 0;
    this.transformY = 0;
    this.pingLeft = false;
    this.pingRight = false;
    this.pingTop = false;
    this.pingBottom = false;
    this.hiddenItems = [];
    this.destroy$ = new Subject();
    this._selectedIndex = 0;
    this.wrapperWidth = 0;
    this.wrapperHeight = 0;
    this.scrollListWidth = 0;
    this.scrollListHeight = 0;
    this.operationWidth = 0;
    this.operationHeight = 0;
    this.addButtonWidth = 0;
    this.addButtonHeight = 0;
    this.selectedIndexChanged = false;
    this.lockAnimationTimeoutId = -1;
    this.cssTransformTimeWaitingId = -1;
  }
  ngAfterViewInit() {
    const dirChange = this.dir ? this.dir.change.asObservable() : of(null);
    const resize = this.viewportRuler.change(150);
    const realign = () => {
      this.updateScrollListPosition();
      this.alignInkBarToSelectedTab();
    };
    this.keyManager = new FocusKeyManager(this.items).withHorizontalOrientation(this.getLayoutDirection()).withWrap();
    this.keyManager.updateActiveItem(this.selectedIndex);
    reqAnimFrame(realign);
    merge(this.nzResizeObserver.observe(this.navWarpRef), this.nzResizeObserver.observe(this.navListRef)).pipe(takeUntil(this.destroy$), auditTime(16, RESIZE_SCHEDULER)).subscribe(() => {
      realign();
    });
    merge(dirChange, resize, this.items.changes).pipe(takeUntil(this.destroy$)).subscribe(() => {
      Promise.resolve().then(realign);
      this.keyManager.withHorizontalOrientation(this.getLayoutDirection());
    });
    this.keyManager.change.pipe(takeUntil(this.destroy$)).subscribe((newFocusIndex) => {
      this.indexFocused.emit(newFocusIndex);
      this.setTabFocus(newFocusIndex);
      this.scrollToTab(this.keyManager.activeItem);
    });
  }
  ngAfterContentChecked() {
    if (this.selectedIndexChanged) {
      this.updateScrollListPosition();
      this.alignInkBarToSelectedTab();
      this.selectedIndexChanged = false;
      this.cdr.markForCheck();
    }
  }
  ngOnDestroy() {
    clearTimeout(this.lockAnimationTimeoutId);
    clearTimeout(this.cssTransformTimeWaitingId);
    this.destroy$.next();
    this.destroy$.complete();
  }
  onSelectedFromMenu(tab) {
    const tabIndex = this.items.toArray().findIndex((e) => e === tab);
    if (tabIndex !== -1) {
      this.keyManager.updateActiveItem(tabIndex);
      if (this.focusIndex !== this.selectedIndex) {
        this.selectFocusedIndex.emit(this.focusIndex);
        this.scrollToTab(tab);
      }
    }
  }
  onOffsetChange(e) {
    if (this.position === "horizontal") {
      if (this.lockAnimationTimeoutId === -1) {
        if (this.transformX >= 0 && e.x > 0) {
          return;
        }
        if (this.transformX <= this.wrapperWidth - this.scrollListWidth && e.x < 0) {
          return;
        }
      }
      e.event.preventDefault();
      this.transformX = this.clampTransformX(this.transformX + e.x);
      this.setTransform(this.transformX, 0);
    } else {
      if (this.lockAnimationTimeoutId === -1) {
        if (this.transformY >= 0 && e.y > 0) {
          return;
        }
        if (this.transformY <= this.wrapperHeight - this.scrollListHeight && e.y < 0) {
          return;
        }
      }
      e.event.preventDefault();
      this.transformY = this.clampTransformY(this.transformY + e.y);
      this.setTransform(0, this.transformY);
    }
    this.lockAnimation();
    this.setVisibleRange();
    this.setPingStatus();
  }
  handleKeydown(event) {
    const inNavigationList = this.navWarpRef.nativeElement.contains(event.target);
    if (hasModifierKey(event) || !inNavigationList) {
      return;
    }
    switch (event.keyCode) {
      case LEFT_ARROW:
      case UP_ARROW:
      case RIGHT_ARROW:
      case DOWN_ARROW:
        this.lockAnimation();
        this.keyManager.onKeydown(event);
        break;
      case ENTER:
      case SPACE:
        if (this.focusIndex !== this.selectedIndex) {
          this.selectFocusedIndex.emit(this.focusIndex);
        }
        break;
      default:
        this.keyManager.onKeydown(event);
    }
  }
  isValidIndex(index) {
    if (!this.items) {
      return true;
    }
    const tab = this.items ? this.items.toArray()[index] : null;
    return !!tab && !tab.disabled;
  }
  scrollToTab(tab) {
    if (!this.items.find((e) => e === tab)) {
      return;
    }
    const tabs = this.items.toArray();
    if (this.position === "horizontal") {
      let newTransform = this.transformX;
      if (this.getLayoutDirection() === "rtl") {
        const right = tabs[0].left + tabs[0].width - tab.left - tab.width;
        if (right < this.transformX) {
          newTransform = right;
        } else if (right + tab.width > this.transformX + this.wrapperWidth) {
          newTransform = right + tab.width - this.wrapperWidth;
        }
      } else if (tab.left < -this.transformX) {
        newTransform = -tab.left;
      } else if (tab.left + tab.width > -this.transformX + this.wrapperWidth) {
        newTransform = -(tab.left + tab.width - this.wrapperWidth);
      }
      this.transformX = newTransform;
      this.transformY = 0;
      this.setTransform(newTransform, 0);
    } else {
      let newTransform = this.transformY;
      if (tab.top < -this.transformY) {
        newTransform = -tab.top;
      } else if (tab.top + tab.height > -this.transformY + this.wrapperHeight) {
        newTransform = -(tab.top + tab.height - this.wrapperHeight);
      }
      this.transformY = newTransform;
      this.transformX = 0;
      this.setTransform(0, newTransform);
    }
    clearTimeout(this.cssTransformTimeWaitingId);
    this.cssTransformTimeWaitingId = setTimeout(() => {
      this.setVisibleRange();
    }, CSS_TRANSFORM_TIME);
  }
  lockAnimation() {
    if (this.lockAnimationTimeoutId === -1) {
      this.ngZone.runOutsideAngular(() => {
        this.navListRef.nativeElement.style.transition = "none";
        this.lockAnimationTimeoutId = setTimeout(() => {
          this.navListRef.nativeElement.style.transition = "";
          this.lockAnimationTimeoutId = -1;
        }, CSS_TRANSFORM_TIME);
      });
    }
  }
  setTransform(x, y) {
    this.navListRef.nativeElement.style.transform = `translate(${x}px, ${y}px)`;
  }
  clampTransformX(transform) {
    const scrollWidth = this.wrapperWidth - this.scrollListWidth;
    if (this.getLayoutDirection() === "rtl") {
      return Math.max(Math.min(scrollWidth, transform), 0);
    } else {
      return Math.min(Math.max(scrollWidth, transform), 0);
    }
  }
  clampTransformY(transform) {
    return Math.min(Math.max(this.wrapperHeight - this.scrollListHeight, transform), 0);
  }
  updateScrollListPosition() {
    this.resetSizes();
    this.transformX = this.clampTransformX(this.transformX);
    this.transformY = this.clampTransformY(this.transformY);
    this.setVisibleRange();
    this.setPingStatus();
    if (this.keyManager) {
      this.keyManager.updateActiveItem(this.keyManager.activeItemIndex);
      if (this.keyManager.activeItem) {
        this.scrollToTab(this.keyManager.activeItem);
      }
    }
  }
  resetSizes() {
    this.addButtonWidth = this.addBtnRef ? this.addBtnRef.getElementWidth() : 0;
    this.addButtonHeight = this.addBtnRef ? this.addBtnRef.getElementHeight() : 0;
    this.operationWidth = this.operationRef.getElementWidth();
    this.operationHeight = this.operationRef.getElementHeight();
    this.wrapperWidth = this.navWarpRef.nativeElement.offsetWidth || 0;
    this.wrapperHeight = this.navWarpRef.nativeElement.offsetHeight || 0;
    this.scrollListHeight = this.navListRef.nativeElement.offsetHeight || 0;
    this.scrollListWidth = this.navListRef.nativeElement.offsetWidth || 0;
  }
  alignInkBarToSelectedTab() {
    const selectedItem = this.items && this.items.length ? this.items.toArray()[this.selectedIndex] : null;
    const selectedItemElement = selectedItem ? selectedItem.elementRef.nativeElement : null;
    if (selectedItemElement) {
      this.inkBar.alignToElement(selectedItemElement.parentElement);
    }
  }
  setPingStatus() {
    const ping = {
      top: false,
      right: false,
      bottom: false,
      left: false
    };
    const navWarp = this.navWarpRef.nativeElement;
    if (this.position === "horizontal") {
      if (this.getLayoutDirection() === "rtl") {
        ping.right = this.transformX > 0;
        ping.left = this.transformX + this.wrapperWidth < this.scrollListWidth;
      } else {
        ping.left = this.transformX < 0;
        ping.right = -this.transformX + this.wrapperWidth < this.scrollListWidth;
      }
    } else {
      ping.top = this.transformY < 0;
      ping.bottom = -this.transformY + this.wrapperHeight < this.scrollListHeight;
    }
    Object.keys(ping).forEach((pos) => {
      const className = `ant-tabs-nav-wrap-ping-${pos}`;
      if (ping[pos]) {
        navWarp.classList.add(className);
      } else {
        navWarp.classList.remove(className);
      }
    });
  }
  setVisibleRange() {
    let unit;
    let position;
    let transformSize;
    let basicSize;
    let tabContentSize;
    let addSize;
    const tabs = this.items.toArray();
    const DEFAULT_SIZE = {
      width: 0,
      height: 0,
      left: 0,
      top: 0,
      right: 0
    };
    const getOffset2 = (index) => {
      let offset;
      const size = tabs[index] || DEFAULT_SIZE;
      if (position === "right") {
        offset = tabs[0].left + tabs[0].width - tabs[index].left - tabs[index].width;
      } else {
        offset = size[position];
      }
      return offset;
    };
    if (this.position === "horizontal") {
      unit = "width";
      basicSize = this.wrapperWidth;
      tabContentSize = this.scrollListWidth - (this.hiddenItems.length ? this.operationWidth : 0);
      addSize = this.addButtonWidth;
      transformSize = Math.abs(this.transformX);
      if (this.getLayoutDirection() === "rtl") {
        position = "right";
        this.pingRight = this.transformX > 0;
        this.pingLeft = this.transformX + this.wrapperWidth < this.scrollListWidth;
      } else {
        this.pingLeft = this.transformX < 0;
        this.pingRight = -this.transformX + this.wrapperWidth < this.scrollListWidth;
        position = "left";
      }
    } else {
      unit = "height";
      basicSize = this.wrapperHeight;
      tabContentSize = this.scrollListHeight - (this.hiddenItems.length ? this.operationHeight : 0);
      addSize = this.addButtonHeight;
      position = "top";
      transformSize = -this.transformY;
      this.pingTop = this.transformY < 0;
      this.pingBottom = -this.transformY + this.wrapperHeight < this.scrollListHeight;
    }
    let mergedBasicSize = basicSize;
    if (tabContentSize + addSize > basicSize) {
      mergedBasicSize = basicSize - addSize;
    }
    if (!tabs.length) {
      this.hiddenItems = [];
      this.cdr.markForCheck();
      return;
    }
    const len = tabs.length;
    let endIndex = len;
    for (let i = 0; i < len; i += 1) {
      const offset = getOffset2(i);
      const size = tabs[i] || DEFAULT_SIZE;
      if (offset + size[unit] > transformSize + mergedBasicSize) {
        endIndex = i - 1;
        break;
      }
    }
    let startIndex = 0;
    for (let i = len - 1; i >= 0; i -= 1) {
      const offset = getOffset2(i);
      if (offset < transformSize) {
        startIndex = i + 1;
        break;
      }
    }
    const startHiddenTabs = tabs.slice(0, startIndex);
    const endHiddenTabs = tabs.slice(endIndex + 1);
    this.hiddenItems = [...startHiddenTabs, ...endHiddenTabs];
    this.cdr.markForCheck();
  }
  getLayoutDirection() {
    return this.dir && this.dir.value === "rtl" ? "rtl" : "ltr";
  }
  setTabFocus(_tabIndex) {
  }
  ngOnChanges(changes) {
    const {
      position
    } = changes;
    if (position && !position.isFirstChange()) {
      this.alignInkBarToSelectedTab();
      this.lockAnimation();
      this.updateScrollListPosition();
    }
  }
};
_NzTabNavBarComponent.\u0275fac = function NzTabNavBarComponent_Factory(t) {
  return new (t || _NzTabNavBarComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ViewportRuler), \u0275\u0275directiveInject(NzResizeObserver), \u0275\u0275directiveInject(Directionality, 8));
};
_NzTabNavBarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTabNavBarComponent,
  selectors: [["nz-tabs-nav"]],
  contentQueries: function NzTabNavBarComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzTabNavItemDirective, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.items = _t);
    }
  },
  viewQuery: function NzTabNavBarComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c215, 7);
      \u0275\u0275viewQuery(_c311, 7);
      \u0275\u0275viewQuery(NzTabNavOperationComponent, 7);
      \u0275\u0275viewQuery(NzTabAddButtonComponent, 5);
      \u0275\u0275viewQuery(NzTabsInkBarDirective, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.navWarpRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.navListRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.operationRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.addBtnRef = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inkBar = _t.first);
    }
  },
  hostAttrs: [1, "ant-tabs-nav"],
  hostBindings: function NzTabNavBarComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("keydown", function NzTabNavBarComponent_keydown_HostBindingHandler($event) {
        return ctx.handleKeydown($event);
      });
    }
  },
  inputs: {
    position: "position",
    addable: "addable",
    hideBar: "hideBar",
    addIcon: "addIcon",
    inkBarAnimated: "inkBarAnimated",
    extraTemplate: "extraTemplate",
    selectedIndex: "selectedIndex"
  },
  outputs: {
    indexFocused: "indexFocused",
    selectFocusedIndex: "selectFocusedIndex",
    addClicked: "addClicked",
    tabScroll: "tabScroll"
  },
  exportAs: ["nzTabsNav"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c49,
  decls: 9,
  vars: 16,
  consts: [[1, "ant-tabs-nav-wrap"], ["navWarp", ""], ["nzTabScrollList", "", "role", "tablist", 1, "ant-tabs-nav-list", 3, "offsetChange", "tabScroll"], ["navList", ""], ["role", "tab", "nz-tab-add-button", "", 3, "addIcon", "click", 4, "ngIf"], ["nz-tabs-ink-bar", "", 3, "hidden", "position", "animated"], [3, "addIcon", "addable", "items", "addClicked", "selected"], ["class", "ant-tabs-extra-content", 4, "ngIf"], ["role", "tab", "nz-tab-add-button", "", 3, "addIcon", "click"], [1, "ant-tabs-extra-content"], [3, "ngTemplateOutlet"]],
  template: function NzTabNavBarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0, 1)(2, "div", 2, 3);
      \u0275\u0275listener("offsetChange", function NzTabNavBarComponent_Template_div_offsetChange_2_listener($event) {
        return ctx.onOffsetChange($event);
      })("tabScroll", function NzTabNavBarComponent_Template_div_tabScroll_2_listener($event) {
        return ctx.tabScroll.emit($event);
      });
      \u0275\u0275projection(4);
      \u0275\u0275template(5, NzTabNavBarComponent_button_5_Template, 1, 2, "button", 4);
      \u0275\u0275element(6, "div", 5);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(7, "nz-tab-nav-operation", 6);
      \u0275\u0275listener("addClicked", function NzTabNavBarComponent_Template_nz_tab_nav_operation_addClicked_7_listener() {
        return ctx.addClicked.emit();
      })("selected", function NzTabNavBarComponent_Template_nz_tab_nav_operation_selected_7_listener($event) {
        return ctx.onSelectedFromMenu($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(8, NzTabNavBarComponent_div_8_Template, 2, 1, "div", 7);
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-tabs-nav-wrap-ping-left", ctx.pingLeft)("ant-tabs-nav-wrap-ping-right", ctx.pingRight)("ant-tabs-nav-wrap-ping-top", ctx.pingTop)("ant-tabs-nav-wrap-ping-bottom", ctx.pingBottom);
      \u0275\u0275advance(5);
      \u0275\u0275property("ngIf", ctx.showAddButton);
      \u0275\u0275advance(1);
      \u0275\u0275property("hidden", ctx.hideBar)("position", ctx.position)("animated", ctx.inkBarAnimated);
      \u0275\u0275advance(1);
      \u0275\u0275property("addIcon", ctx.addIcon)("addable", ctx.addable)("items", ctx.hiddenItems);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.extraTemplate);
    }
  },
  dependencies: [NzTabScrollListDirective, NgIf, NzTabAddButtonComponent, NzTabsInkBarDirective, NzTabNavOperationComponent, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzTabNavBarComponent = _NzTabNavBarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabNavBarComponent, [{
    type: Component,
    args: [{
      selector: "nz-tabs-nav",
      exportAs: "nzTabsNav",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `
    <div
      class="ant-tabs-nav-wrap"
      [class.ant-tabs-nav-wrap-ping-left]="pingLeft"
      [class.ant-tabs-nav-wrap-ping-right]="pingRight"
      [class.ant-tabs-nav-wrap-ping-top]="pingTop"
      [class.ant-tabs-nav-wrap-ping-bottom]="pingBottom"
      #navWarp
    >
      <div
        class="ant-tabs-nav-list"
        #navList
        nzTabScrollList
        (offsetChange)="onOffsetChange($event)"
        (tabScroll)="tabScroll.emit($event)"
        role="tablist"
      >
        <ng-content></ng-content>
        <button
          role="tab"
          [attr.tabindex]="-1"
          *ngIf="showAddButton"
          nz-tab-add-button
          [addIcon]="addIcon"
          (click)="addClicked.emit()"
        ></button>
        <div nz-tabs-ink-bar [hidden]="hideBar" [position]="position" [animated]="inkBarAnimated"></div>
      </div>
    </div>
    <nz-tab-nav-operation
      (addClicked)="addClicked.emit()"
      (selected)="onSelectedFromMenu($event)"
      [addIcon]="addIcon"
      [addable]="addable"
      [items]="hiddenItems"
    ></nz-tab-nav-operation>
    <div class="ant-tabs-extra-content" *ngIf="extraTemplate">
      <ng-template [ngTemplateOutlet]="extraTemplate"></ng-template>
    </div>
  `,
      host: {
        class: "ant-tabs-nav",
        "(keydown)": "handleKeydown($event)"
      },
      imports: [NzTabScrollListDirective, NgIf, NzTabAddButtonComponent, NzTabsInkBarDirective, NzTabNavOperationComponent, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: ViewportRuler
  }, {
    type: NzResizeObserver
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    indexFocused: [{
      type: Output
    }],
    selectFocusedIndex: [{
      type: Output
    }],
    addClicked: [{
      type: Output
    }],
    tabScroll: [{
      type: Output
    }],
    position: [{
      type: Input
    }],
    addable: [{
      type: Input
    }],
    hideBar: [{
      type: Input
    }],
    addIcon: [{
      type: Input
    }],
    inkBarAnimated: [{
      type: Input
    }],
    extraTemplate: [{
      type: Input
    }],
    selectedIndex: [{
      type: Input
    }],
    navWarpRef: [{
      type: ViewChild,
      args: ["navWarp", {
        static: true
      }]
    }],
    navListRef: [{
      type: ViewChild,
      args: ["navList", {
        static: true
      }]
    }],
    operationRef: [{
      type: ViewChild,
      args: [NzTabNavOperationComponent, {
        static: true
      }]
    }],
    addBtnRef: [{
      type: ViewChild,
      args: [NzTabAddButtonComponent, {
        static: false
      }]
    }],
    inkBar: [{
      type: ViewChild,
      args: [NzTabsInkBarDirective, {
        static: true
      }]
    }],
    items: [{
      type: ContentChildren,
      args: [NzTabNavItemDirective, {
        descendants: true
      }]
    }]
  });
})();
var _NzTabBodyComponent = class _NzTabBodyComponent {
  constructor() {
    this.content = null;
    this.active = false;
    this.tabPaneAnimated = true;
    this.forceRender = false;
  }
};
_NzTabBodyComponent.\u0275fac = function NzTabBodyComponent_Factory(t) {
  return new (t || _NzTabBodyComponent)();
};
_NzTabBodyComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTabBodyComponent,
  selectors: [["", "nz-tab-body", ""]],
  hostAttrs: [1, "ant-tabs-tabpane"],
  hostVars: 12,
  hostBindings: function NzTabBodyComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("tabindex", ctx.active ? 0 : -1)("aria-hidden", !ctx.active);
      \u0275\u0275styleProp("visibility", ctx.tabPaneAnimated ? ctx.active ? null : "hidden" : null)("height", ctx.tabPaneAnimated ? ctx.active ? null : 0 : null)("overflow-y", ctx.tabPaneAnimated ? ctx.active ? null : "none" : null)("display", !ctx.tabPaneAnimated ? ctx.active ? null : "none" : null);
      \u0275\u0275classProp("ant-tabs-tabpane-active", ctx.active);
    }
  },
  inputs: {
    content: "content",
    active: "active",
    tabPaneAnimated: "tabPaneAnimated",
    forceRender: "forceRender"
  },
  exportAs: ["nzTabBody"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c56,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [3, "ngTemplateOutlet"]],
  template: function NzTabBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTabBodyComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.active || ctx.forceRender);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzTabBodyComponent = _NzTabBodyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabBodyComponent, [{
    type: Component,
    args: [{
      selector: "[nz-tab-body]",
      exportAs: "nzTabBody",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-container *ngIf="active || forceRender">
      <ng-template [ngTemplateOutlet]="content"></ng-template>
    </ng-container>
  `,
      host: {
        class: "ant-tabs-tabpane",
        "[class.ant-tabs-tabpane-active]": "active",
        "[attr.tabindex]": "active ? 0 : -1",
        "[attr.aria-hidden]": "!active",
        "[style.visibility]": 'tabPaneAnimated ? active ? null : "hidden" : null',
        "[style.height]": "tabPaneAnimated ? active ? null : 0 : null",
        "[style.overflow-y]": 'tabPaneAnimated ? active ? null : "none" : null',
        "[style.display]": '!tabPaneAnimated ? active ? null : "none" : null'
      },
      imports: [NgIf, NgTemplateOutlet],
      standalone: true
    }]
  }], null, {
    content: [{
      type: Input
    }],
    active: [{
      type: Input
    }],
    tabPaneAnimated: [{
      type: Input
    }],
    forceRender: [{
      type: Input
    }]
  });
})();
var _NzTabCloseButtonComponent = class _NzTabCloseButtonComponent {
  constructor() {
    this.closeIcon = "close";
  }
};
_NzTabCloseButtonComponent.\u0275fac = function NzTabCloseButtonComponent_Factory(t) {
  return new (t || _NzTabCloseButtonComponent)();
};
_NzTabCloseButtonComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTabCloseButtonComponent,
  selectors: [["nz-tab-close-button"], ["button", "nz-tab-close-button", ""]],
  hostAttrs: ["aria-label", "Close tab", "type", "button", 1, "ant-tabs-tab-remove"],
  inputs: {
    closeIcon: "closeIcon"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 1,
  consts: [[4, "nzStringTemplateOutlet"], ["nz-icon", "", "nzTheme", "outline", 3, "nzType"]],
  template: function NzTabCloseButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTabCloseButtonComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("nzStringTemplateOutlet", ctx.closeIcon);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective, NzIconModule, NzIconDirective],
  encapsulation: 2
});
var NzTabCloseButtonComponent = _NzTabCloseButtonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabCloseButtonComponent, [{
    type: Component,
    args: [{
      selector: "nz-tab-close-button, button[nz-tab-close-button]",
      template: `
    <ng-container *nzStringTemplateOutlet="closeIcon; let icon">
      <span nz-icon [nzType]="icon" nzTheme="outline"></span>
    </ng-container>
  `,
      host: {
        class: "ant-tabs-tab-remove",
        "aria-label": "Close tab",
        type: "button"
      },
      imports: [NzOutletModule, NzIconModule],
      standalone: true
    }]
  }], () => [], {
    closeIcon: [{
      type: Input
    }]
  });
})();
var _NzTabLinkTemplateDirective = class _NzTabLinkTemplateDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
_NzTabLinkTemplateDirective.\u0275fac = function NzTabLinkTemplateDirective_Factory(t) {
  return new (t || _NzTabLinkTemplateDirective)(\u0275\u0275directiveInject(TemplateRef, 1));
};
_NzTabLinkTemplateDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTabLinkTemplateDirective,
  selectors: [["ng-template", "nzTabLink", ""]],
  exportAs: ["nzTabLinkTemplate"],
  standalone: true
});
var NzTabLinkTemplateDirective = _NzTabLinkTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabLinkTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "ng-template[nzTabLink]",
      exportAs: "nzTabLinkTemplate",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef,
    decorators: [{
      type: Host
    }]
  }], null);
})();
var _NzTabLinkDirective = class _NzTabLinkDirective {
  constructor(elementRef, routerLink) {
    this.elementRef = elementRef;
    this.routerLink = routerLink;
  }
};
_NzTabLinkDirective.\u0275fac = function NzTabLinkDirective_Factory(t) {
  return new (t || _NzTabLinkDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RouterLink, 10));
};
_NzTabLinkDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTabLinkDirective,
  selectors: [["a", "nz-tab-link", ""]],
  exportAs: ["nzTabLink"],
  standalone: true
});
var NzTabLinkDirective = _NzTabLinkDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabLinkDirective, [{
    type: Directive,
    args: [{
      selector: "a[nz-tab-link]",
      exportAs: "nzTabLink",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: RouterLink,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var _NzTabDirective = class _NzTabDirective {
};
_NzTabDirective.\u0275fac = function NzTabDirective_Factory(t) {
  return new (t || _NzTabDirective)();
};
_NzTabDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzTabDirective,
  selectors: [["", "nz-tab", ""]],
  exportAs: ["nzTab"],
  standalone: true
});
var NzTabDirective = _NzTabDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-tab]",
      exportAs: "nzTab",
      standalone: true
    }]
  }], null, null);
})();
var NZ_TAB_SET = new InjectionToken("NZ_TAB_SET");
var _NzTabComponent = class _NzTabComponent {
  get content() {
    return this.template || this.contentTemplate;
  }
  get label() {
    return this.nzTitle || this.nzTabLinkTemplateDirective?.templateRef;
  }
  constructor(closestTabSet) {
    this.closestTabSet = closestTabSet;
    this.nzTitle = "";
    this.nzClosable = false;
    this.nzCloseIcon = "close";
    this.nzDisabled = false;
    this.nzForceRender = false;
    this.nzSelect = new EventEmitter();
    this.nzDeselect = new EventEmitter();
    this.nzClick = new EventEmitter();
    this.nzContextmenu = new EventEmitter();
    this.template = null;
    this.isActive = false;
    this.position = null;
    this.origin = null;
    this.stateChanges = new Subject();
  }
  ngOnChanges(changes) {
    const {
      nzTitle,
      nzDisabled,
      nzForceRender
    } = changes;
    if (nzTitle || nzDisabled || nzForceRender) {
      this.stateChanges.next();
    }
  }
  ngOnDestroy() {
    this.stateChanges.complete();
  }
};
_NzTabComponent.\u0275fac = function NzTabComponent_Factory(t) {
  return new (t || _NzTabComponent)(\u0275\u0275directiveInject(NZ_TAB_SET));
};
_NzTabComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTabComponent,
  selectors: [["nz-tab"]],
  contentQueries: function NzTabComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzTabLinkTemplateDirective, 5);
      \u0275\u0275contentQuery(dirIndex, NzTabDirective, 5, TemplateRef);
      \u0275\u0275contentQuery(dirIndex, NzTabLinkDirective, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzTabLinkTemplateDirective = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.template = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.linkDirective = _t.first);
    }
  },
  viewQuery: function NzTabComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c65, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentTemplate = _t.first);
    }
  },
  inputs: {
    nzTitle: "nzTitle",
    nzClosable: "nzClosable",
    nzCloseIcon: "nzCloseIcon",
    nzDisabled: "nzDisabled",
    nzForceRender: "nzForceRender"
  },
  outputs: {
    nzSelect: "nzSelect",
    nzDeselect: "nzDeselect",
    nzClick: "nzClick",
    nzContextmenu: "nzContextmenu"
  },
  exportAs: ["nzTab"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c84,
  decls: 4,
  vars: 0,
  consts: [["tabLinkTemplate", ""], ["contentTemplate", ""]],
  template: function NzTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c74);
      \u0275\u0275template(0, NzTabComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, NzTabComponent_ng_template_2_Template, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzTabComponent = _NzTabComponent;
__decorate([InputBoolean()], NzTabComponent.prototype, "nzClosable", void 0);
__decorate([InputBoolean()], NzTabComponent.prototype, "nzDisabled", void 0);
__decorate([InputBoolean()], NzTabComponent.prototype, "nzForceRender", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabComponent, [{
    type: Component,
    args: [{
      selector: "nz-tab",
      exportAs: "nzTab",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-template #tabLinkTemplate>
      <ng-content select="[nz-tab-link]"></ng-content>
    </ng-template>
    <ng-template #contentTemplate><ng-content></ng-content></ng-template>
  `,
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NZ_TAB_SET]
    }]
  }], {
    nzTitle: [{
      type: Input
    }],
    nzClosable: [{
      type: Input
    }],
    nzCloseIcon: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzForceRender: [{
      type: Input
    }],
    nzSelect: [{
      type: Output
    }],
    nzDeselect: [{
      type: Output
    }],
    nzClick: [{
      type: Output
    }],
    nzContextmenu: [{
      type: Output
    }],
    nzTabLinkTemplateDirective: [{
      type: ContentChild,
      args: [NzTabLinkTemplateDirective, {
        static: false
      }]
    }],
    template: [{
      type: ContentChild,
      args: [NzTabDirective, {
        static: false,
        read: TemplateRef
      }]
    }],
    linkDirective: [{
      type: ContentChild,
      args: [NzTabLinkDirective, {
        static: false
      }]
    }],
    contentTemplate: [{
      type: ViewChild,
      args: ["contentTemplate", {
        static: true
      }]
    }]
  });
})();
var NzTabChangeEvent = class {
};
var NZ_CONFIG_MODULE_NAME15 = "tabs";
var nextId = 0;
var _NzTabSetComponent = class _NzTabSetComponent {
  get nzSelectedIndex() {
    return this.selectedIndex;
  }
  set nzSelectedIndex(value) {
    this.indexToSelect = coerceNumberProperty(value, null);
  }
  get position() {
    return ["top", "bottom"].indexOf(this.nzTabPosition) === -1 ? "vertical" : "horizontal";
  }
  get addable() {
    return this.nzType === "editable-card" && !this.nzHideAdd;
  }
  get closable() {
    return this.nzType === "editable-card";
  }
  get line() {
    return this.nzType === "line";
  }
  get inkBarAnimated() {
    return this.line && (typeof this.nzAnimated === "boolean" ? this.nzAnimated : this.nzAnimated.inkBar);
  }
  get tabPaneAnimated() {
    return this.position === "horizontal" && this.line && (typeof this.nzAnimated === "boolean" ? this.nzAnimated : this.nzAnimated.tabPane);
  }
  constructor(nzConfigService, ngZone, cdr, directionality, router) {
    this.nzConfigService = nzConfigService;
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.directionality = directionality;
    this.router = router;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME15;
    this.nzTabPosition = "top";
    this.nzCanDeactivate = null;
    this.nzAddIcon = "plus";
    this.nzTabBarStyle = null;
    this.nzType = "line";
    this.nzSize = "default";
    this.nzAnimated = true;
    this.nzTabBarGutter = void 0;
    this.nzHideAdd = false;
    this.nzCentered = false;
    this.nzHideAll = false;
    this.nzLinkRouter = false;
    this.nzLinkExact = true;
    this.nzSelectChange = new EventEmitter(true);
    this.nzSelectedIndexChange = new EventEmitter();
    this.nzTabListScroll = new EventEmitter();
    this.nzClose = new EventEmitter();
    this.nzAdd = new EventEmitter();
    this.allTabs = new QueryList();
    this.tabs = new QueryList();
    this.dir = "ltr";
    this.destroy$ = new Subject();
    this.indexToSelect = 0;
    this.selectedIndex = null;
    this.tabLabelSubscription = Subscription.EMPTY;
    this.tabsSubscription = Subscription.EMPTY;
    this.canDeactivateSubscription = Subscription.EMPTY;
    this.tabSetId = nextId++;
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.tabs.destroy();
    this.tabLabelSubscription.unsubscribe();
    this.tabsSubscription.unsubscribe();
    this.canDeactivateSubscription.unsubscribe();
  }
  ngAfterContentInit() {
    this.ngZone.runOutsideAngular(() => {
      Promise.resolve().then(() => this.setUpRouter());
    });
    this.subscribeToTabLabels();
    this.subscribeToAllTabChanges();
    this.tabsSubscription = this.tabs.changes.subscribe(() => {
      const indexToSelect = this.clampTabIndex(this.indexToSelect);
      if (indexToSelect === this.selectedIndex) {
        const tabs = this.tabs.toArray();
        for (let i = 0; i < tabs.length; i++) {
          if (tabs[i].isActive) {
            this.indexToSelect = this.selectedIndex = i;
            break;
          }
        }
      }
      this.subscribeToTabLabels();
      this.cdr.markForCheck();
    });
  }
  ngAfterContentChecked() {
    const indexToSelect = this.indexToSelect = this.clampTabIndex(this.indexToSelect);
    if (this.selectedIndex !== indexToSelect) {
      const isFirstRun = this.selectedIndex == null;
      if (!isFirstRun) {
        this.nzSelectChange.emit(this.createChangeEvent(indexToSelect));
      }
      Promise.resolve().then(() => {
        this.tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);
        if (!isFirstRun) {
          this.nzSelectedIndexChange.emit(indexToSelect);
        }
      });
    }
    this.tabs.forEach((tab, index) => {
      tab.position = index - indexToSelect;
      if (this.selectedIndex != null && tab.position === 0 && !tab.origin) {
        tab.origin = indexToSelect - this.selectedIndex;
      }
    });
    if (this.selectedIndex !== indexToSelect) {
      this.selectedIndex = indexToSelect;
      this.cdr.markForCheck();
    }
  }
  onClose(index, e) {
    e.preventDefault();
    e.stopPropagation();
    this.nzClose.emit({
      index
    });
  }
  onAdd() {
    this.nzAdd.emit();
  }
  clampTabIndex(index) {
    return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
  }
  createChangeEvent(index) {
    const event = new NzTabChangeEvent();
    event.index = index;
    if (this.tabs && this.tabs.length) {
      event.tab = this.tabs.toArray()[index];
      this.tabs.forEach((tab, i) => {
        if (i !== index) {
          tab.nzDeselect.emit();
        }
      });
      event.tab.nzSelect.emit();
    }
    return event;
  }
  subscribeToTabLabels() {
    if (this.tabLabelSubscription) {
      this.tabLabelSubscription.unsubscribe();
    }
    this.tabLabelSubscription = merge(...this.tabs.map((tab) => tab.stateChanges)).subscribe(() => this.cdr.markForCheck());
  }
  subscribeToAllTabChanges() {
    this.allTabs.changes.pipe(startWith(this.allTabs)).subscribe((tabs) => {
      this.tabs.reset(tabs.filter((tab) => tab.closestTabSet === this));
      this.tabs.notifyOnChanges();
    });
  }
  canDeactivateFun(pre, next) {
    if (typeof this.nzCanDeactivate === "function") {
      const observable = wrapIntoObservable(this.nzCanDeactivate(pre, next));
      return observable.pipe(first(), takeUntil(this.destroy$));
    } else {
      return of(true);
    }
  }
  clickNavItem(tab, index, e) {
    if (!tab.nzDisabled) {
      tab.nzClick.emit();
      if (!this.isRouterLinkClickEvent(index, e)) {
        this.setSelectedIndex(index);
      }
    }
  }
  isRouterLinkClickEvent(index, event) {
    const target = event.target;
    if (this.nzLinkRouter) {
      return !!this.tabs.toArray()[index]?.linkDirective?.elementRef.nativeElement.contains(target);
    } else {
      return false;
    }
  }
  contextmenuNavItem(tab, e) {
    if (!tab.nzDisabled) {
      tab.nzContextmenu.emit(e);
    }
  }
  setSelectedIndex(index) {
    this.canDeactivateSubscription.unsubscribe();
    this.canDeactivateSubscription = this.canDeactivateFun(this.selectedIndex, index).subscribe((can) => {
      if (can) {
        this.nzSelectedIndex = index;
        this.tabNavBarRef.focusIndex = index;
        this.cdr.markForCheck();
      }
    });
  }
  getTabIndex(tab, index) {
    if (tab.nzDisabled) {
      return null;
    }
    return this.selectedIndex === index ? 0 : -1;
  }
  getTabContentId(i) {
    return `nz-tabs-${this.tabSetId}-tab-${i}`;
  }
  setUpRouter() {
    if (this.nzLinkRouter) {
      if (!this.router) {
        throw new Error(`${PREFIX} you should import 'RouterModule' if you want to use 'nzLinkRouter'!`);
      }
      this.router.events.pipe(takeUntil(this.destroy$), filter((e) => e instanceof NavigationEnd), startWith(true), delay(0)).subscribe(() => {
        this.updateRouterActive();
        this.cdr.markForCheck();
      });
    }
  }
  updateRouterActive() {
    if (this.router.navigated) {
      const index = this.findShouldActiveTabIndex();
      if (index !== this.selectedIndex) {
        this.setSelectedIndex(index);
      }
      this.nzHideAll = index === -1;
    }
  }
  findShouldActiveTabIndex() {
    const tabs = this.tabs.toArray();
    const isActive = this.isLinkActive(this.router);
    return tabs.findIndex((tab) => {
      const c = tab.linkDirective;
      return c ? isActive(c.routerLink) : false;
    });
  }
  isLinkActive(router) {
    return (link) => link ? router.isActive(link.urlTree || "", {
      paths: this.nzLinkExact ? "exact" : "subset",
      queryParams: this.nzLinkExact ? "exact" : "subset",
      fragment: "ignored",
      matrixParams: "ignored"
    }) : false;
  }
  getTabContentMarginValue() {
    return -(this.nzSelectedIndex || 0) * 100;
  }
  getTabContentMarginLeft() {
    if (this.tabPaneAnimated) {
      if (this.dir !== "rtl") {
        return `${this.getTabContentMarginValue()}%`;
      }
    }
    return "";
  }
  getTabContentMarginRight() {
    if (this.tabPaneAnimated) {
      if (this.dir === "rtl") {
        return `${this.getTabContentMarginValue()}%`;
      }
    }
    return "";
  }
};
_NzTabSetComponent.\u0275fac = function NzTabSetComponent_Factory(t) {
  return new (t || _NzTabSetComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(Router, 8));
};
_NzTabSetComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTabSetComponent,
  selectors: [["nz-tabset"]],
  contentQueries: function NzTabSetComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzTabComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.allTabs = _t);
    }
  },
  viewQuery: function NzTabSetComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(NzTabNavBarComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tabNavBarRef = _t.first);
    }
  },
  hostAttrs: [1, "ant-tabs"],
  hostVars: 24,
  hostBindings: function NzTabSetComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-tabs-card", ctx.nzType === "card" || ctx.nzType === "editable-card")("ant-tabs-editable", ctx.nzType === "editable-card")("ant-tabs-editable-card", ctx.nzType === "editable-card")("ant-tabs-centered", ctx.nzCentered)("ant-tabs-rtl", ctx.dir === "rtl")("ant-tabs-top", ctx.nzTabPosition === "top")("ant-tabs-bottom", ctx.nzTabPosition === "bottom")("ant-tabs-left", ctx.nzTabPosition === "left")("ant-tabs-right", ctx.nzTabPosition === "right")("ant-tabs-default", ctx.nzSize === "default")("ant-tabs-small", ctx.nzSize === "small")("ant-tabs-large", ctx.nzSize === "large");
    }
  },
  inputs: {
    nzSelectedIndex: "nzSelectedIndex",
    nzTabPosition: "nzTabPosition",
    nzTabBarExtraContent: "nzTabBarExtraContent",
    nzCanDeactivate: "nzCanDeactivate",
    nzAddIcon: "nzAddIcon",
    nzTabBarStyle: "nzTabBarStyle",
    nzType: "nzType",
    nzSize: "nzSize",
    nzAnimated: "nzAnimated",
    nzTabBarGutter: "nzTabBarGutter",
    nzHideAdd: "nzHideAdd",
    nzCentered: "nzCentered",
    nzHideAll: "nzHideAll",
    nzLinkRouter: "nzLinkRouter",
    nzLinkExact: "nzLinkExact"
  },
  outputs: {
    nzSelectChange: "nzSelectChange",
    nzSelectedIndexChange: "nzSelectedIndexChange",
    nzTabListScroll: "nzTabListScroll",
    nzClose: "nzClose",
    nzAdd: "nzAdd"
  },
  exportAs: ["nzTabset"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NZ_TAB_SET,
    useExisting: _NzTabSetComponent
  }]), \u0275\u0275StandaloneFeature],
  decls: 4,
  vars: 16,
  consts: [[3, "ngStyle", "selectedIndex", "inkBarAnimated", "addable", "addIcon", "hideBar", "position", "extraTemplate", "tabScroll", "selectFocusedIndex", "addClicked", 4, "ngIf"], [1, "ant-tabs-content-holder"], [1, "ant-tabs-content"], ["role", "tabpanel", "nz-tab-body", "", 3, "id", "active", "content", "forceRender", "tabPaneAnimated", 4, "ngFor", "ngForOf"], [3, "ngStyle", "selectedIndex", "inkBarAnimated", "addable", "addIcon", "hideBar", "position", "extraTemplate", "tabScroll", "selectFocusedIndex", "addClicked"], ["class", "ant-tabs-tab", 3, "margin-right", "margin-bottom", "ant-tabs-tab-active", "ant-tabs-tab-disabled", "click", "contextmenu", 4, "ngFor", "ngForOf"], [1, "ant-tabs-tab", 3, "click", "contextmenu"], ["role", "tab", "nzTabNavItem", "", "cdkMonitorElementFocus", "", 1, "ant-tabs-tab-btn", 3, "id", "disabled", "tab", "active"], [4, "nzStringTemplateOutlet", "nzStringTemplateOutletContext"], ["nz-tab-close-button", "", 3, "closeIcon", "click", 4, "ngIf"], ["nz-tab-close-button", "", 3, "closeIcon", "click"], ["role", "tabpanel", "nz-tab-body", "", 3, "id", "active", "content", "forceRender", "tabPaneAnimated"]],
  template: function NzTabSetComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzTabSetComponent_nz_tabs_nav_0_Template, 2, 9, "nz-tabs-nav", 0);
      \u0275\u0275elementStart(1, "div", 1)(2, "div", 2);
      \u0275\u0275template(3, NzTabSetComponent_div_3_Template, 1, 6, "div", 3);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.tabs.length || ctx.addable);
      \u0275\u0275advance(2);
      \u0275\u0275styleProp("margin-left", ctx.getTabContentMarginLeft())("margin-right", ctx.getTabContentMarginRight());
      \u0275\u0275classProp("ant-tabs-content-top", ctx.nzTabPosition === "top")("ant-tabs-content-bottom", ctx.nzTabPosition === "bottom")("ant-tabs-content-left", ctx.nzTabPosition === "left")("ant-tabs-content-right", ctx.nzTabPosition === "right")("ant-tabs-content-animated", ctx.tabPaneAnimated);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.tabs);
    }
  },
  dependencies: [NzTabNavBarComponent, NgIf, NgStyle, NgForOf, NzTabNavItemDirective, A11yModule, CdkMonitorFocus, NzOutletModule, NzStringTemplateOutletDirective, NzTabCloseButtonComponent, NzTabBodyComponent],
  encapsulation: 2
});
var NzTabSetComponent = _NzTabSetComponent;
__decorate([WithConfig()], NzTabSetComponent.prototype, "nzType", void 0);
__decorate([WithConfig()], NzTabSetComponent.prototype, "nzSize", void 0);
__decorate([WithConfig()], NzTabSetComponent.prototype, "nzAnimated", void 0);
__decorate([WithConfig()], NzTabSetComponent.prototype, "nzTabBarGutter", void 0);
__decorate([InputBoolean()], NzTabSetComponent.prototype, "nzHideAdd", void 0);
__decorate([InputBoolean()], NzTabSetComponent.prototype, "nzCentered", void 0);
__decorate([InputBoolean()], NzTabSetComponent.prototype, "nzHideAll", void 0);
__decorate([InputBoolean()], NzTabSetComponent.prototype, "nzLinkRouter", void 0);
__decorate([InputBoolean()], NzTabSetComponent.prototype, "nzLinkExact", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabSetComponent, [{
    type: Component,
    args: [{
      selector: "nz-tabset",
      exportAs: "nzTabset",
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      providers: [{
        provide: NZ_TAB_SET,
        useExisting: NzTabSetComponent
      }],
      template: `
    <nz-tabs-nav
      *ngIf="tabs.length || addable"
      [ngStyle]="nzTabBarStyle"
      [selectedIndex]="nzSelectedIndex || 0"
      [inkBarAnimated]="inkBarAnimated"
      [addable]="addable"
      [addIcon]="nzAddIcon"
      [hideBar]="nzHideAll"
      [position]="position"
      [extraTemplate]="nzTabBarExtraContent"
      (tabScroll)="nzTabListScroll.emit($event)"
      (selectFocusedIndex)="setSelectedIndex($event)"
      (addClicked)="onAdd()"
    >
      <div
        class="ant-tabs-tab"
        [style.margin-right.px]="position === 'horizontal' ? nzTabBarGutter : null"
        [style.margin-bottom.px]="position === 'vertical' ? nzTabBarGutter : null"
        [class.ant-tabs-tab-active]="nzSelectedIndex === i"
        [class.ant-tabs-tab-disabled]="tab.nzDisabled"
        (click)="clickNavItem(tab, i, $event)"
        (contextmenu)="contextmenuNavItem(tab, $event)"
        *ngFor="let tab of tabs; let i = index"
      >
        <button
          role="tab"
          [id]="getTabContentId(i)"
          [attr.tabIndex]="getTabIndex(tab, i)"
          [attr.aria-disabled]="tab.nzDisabled"
          [attr.aria-selected]="nzSelectedIndex === i && !nzHideAll"
          [attr.aria-controls]="getTabContentId(i)"
          [disabled]="tab.nzDisabled"
          [tab]="tab"
          [active]="nzSelectedIndex === i"
          class="ant-tabs-tab-btn"
          nzTabNavItem
          cdkMonitorElementFocus
        >
          <ng-container *nzStringTemplateOutlet="tab.label; context: { visible: true }">{{ tab.label }}</ng-container>
          <button
            nz-tab-close-button
            *ngIf="tab.nzClosable && closable && !tab.nzDisabled"
            [closeIcon]="tab.nzCloseIcon"
            (click)="onClose(i, $event)"
          ></button>
        </button>
      </div>
    </nz-tabs-nav>
    <div class="ant-tabs-content-holder">
      <div
        class="ant-tabs-content"
        [class.ant-tabs-content-top]="nzTabPosition === 'top'"
        [class.ant-tabs-content-bottom]="nzTabPosition === 'bottom'"
        [class.ant-tabs-content-left]="nzTabPosition === 'left'"
        [class.ant-tabs-content-right]="nzTabPosition === 'right'"
        [class.ant-tabs-content-animated]="tabPaneAnimated"
        [style.margin-left]="getTabContentMarginLeft()"
        [style.margin-right]="getTabContentMarginRight()"
      >
        <div
          role="tabpanel"
          [id]="getTabContentId(i)"
          [attr.aria-labelledby]="getTabContentId(i)"
          nz-tab-body
          *ngFor="let tab of tabs; let i = index"
          [active]="nzSelectedIndex === i && !nzHideAll"
          [content]="tab.content"
          [forceRender]="tab.nzForceRender"
          [tabPaneAnimated]="tabPaneAnimated"
        ></div>
      </div>
    </div>
  `,
      host: {
        class: "ant-tabs",
        "[class.ant-tabs-card]": `nzType === 'card' || nzType === 'editable-card'`,
        "[class.ant-tabs-editable]": `nzType === 'editable-card'`,
        "[class.ant-tabs-editable-card]": `nzType === 'editable-card'`,
        "[class.ant-tabs-centered]": `nzCentered`,
        "[class.ant-tabs-rtl]": `dir === 'rtl'`,
        "[class.ant-tabs-top]": `nzTabPosition === 'top'`,
        "[class.ant-tabs-bottom]": `nzTabPosition === 'bottom'`,
        "[class.ant-tabs-left]": `nzTabPosition === 'left'`,
        "[class.ant-tabs-right]": `nzTabPosition === 'right'`,
        "[class.ant-tabs-default]": `nzSize === 'default'`,
        "[class.ant-tabs-small]": `nzSize === 'small'`,
        "[class.ant-tabs-large]": `nzSize === 'large'`
      },
      imports: [NzTabNavBarComponent, NgIf, NgStyle, NgForOf, NzTabNavItemDirective, A11yModule, NzOutletModule, NzTabCloseButtonComponent, NzTabBodyComponent],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: Router,
    decorators: [{
      type: Optional
    }]
  }], {
    nzSelectedIndex: [{
      type: Input
    }],
    nzTabPosition: [{
      type: Input
    }],
    nzTabBarExtraContent: [{
      type: Input
    }],
    nzCanDeactivate: [{
      type: Input
    }],
    nzAddIcon: [{
      type: Input
    }],
    nzTabBarStyle: [{
      type: Input
    }],
    nzType: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzAnimated: [{
      type: Input
    }],
    nzTabBarGutter: [{
      type: Input
    }],
    nzHideAdd: [{
      type: Input
    }],
    nzCentered: [{
      type: Input
    }],
    nzHideAll: [{
      type: Input
    }],
    nzLinkRouter: [{
      type: Input
    }],
    nzLinkExact: [{
      type: Input
    }],
    nzSelectChange: [{
      type: Output
    }],
    nzSelectedIndexChange: [{
      type: Output
    }],
    nzTabListScroll: [{
      type: Output
    }],
    nzClose: [{
      type: Output
    }],
    nzAdd: [{
      type: Output
    }],
    allTabs: [{
      type: ContentChildren,
      args: [NzTabComponent, {
        descendants: true
      }]
    }],
    tabNavBarRef: [{
      type: ViewChild,
      args: [NzTabNavBarComponent, {
        static: false
      }]
    }]
  });
})();
var DIRECTIVES2 = [NzTabSetComponent, NzTabComponent, NzTabNavBarComponent, NzTabNavItemDirective, NzTabsInkBarDirective, NzTabScrollListDirective, NzTabNavOperationComponent, NzTabAddButtonComponent, NzTabCloseButtonComponent, NzTabDirective, NzTabBodyComponent, NzTabLinkDirective, NzTabLinkTemplateDirective];
var _NzTabsModule = class _NzTabsModule {
};
_NzTabsModule.\u0275fac = function NzTabsModule_Factory(t) {
  return new (t || _NzTabsModule)();
};
_NzTabsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzTabsModule
});
_NzTabsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzTabSetComponent, NzTabNavBarComponent, NzTabNavOperationComponent, NzTabAddButtonComponent, NzTabCloseButtonComponent]
});
var NzTabsModule = _NzTabsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTabsModule, [{
    type: NgModule,
    args: [{
      imports: [DIRECTIVES2],
      exports: [DIRECTIVES2]
    }]
  }], null, null);
})();

// node_modules/@delon/abc/fesm2022/reuse-tab.mjs
function ReuseTabContextMenuComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 5);
    \u0275\u0275listener("click", function ReuseTabContextMenuComponent_Conditional_1_Template_li_click_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.click($event, "refresh"));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r0.i18n.refresh, \u0275\u0275sanitizeHtml);
  }
}
function ReuseTabContextMenuComponent_Conditional_5_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 7);
    \u0275\u0275listener("click", function ReuseTabContextMenuComponent_Conditional_5_For_2_Template_li_click_0_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r11);
      const i_r5 = restoredCtx.$implicit;
      const ctx_r10 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r10.click($event, "custom", i_r5));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r5 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzDisabled", ctx_r4.isDisabled(i_r5))("innerHTML", i_r5.title, \u0275\u0275sanitizeHtml);
    \u0275\u0275attribute("data-type", i_r5.id);
  }
}
function ReuseTabContextMenuComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "li", 6);
    \u0275\u0275repeaterCreate(1, ReuseTabContextMenuComponent_Conditional_5_For_2_Template, 1, 3, "li", 8, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r1.customContextMenu);
  }
}
var _c026 = ["tabset"];
function ReuseTabComponent_For_3_ng_template_1_Conditional_2_ng_template_0_Template(rf, ctx) {
}
var _c119 = (a0) => ({
  $implicit: a0
});
function ReuseTabComponent_For_3_ng_template_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ReuseTabComponent_For_3_ng_template_1_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const i_r2 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r9 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r9.titleRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c119, i_r2));
  }
}
function ReuseTabComponent_For_3_ng_template_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const i_r2 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275textInterpolate1(" ", i_r2.title, " ");
  }
}
function ReuseTabComponent_For_3_ng_template_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "i", 8);
    \u0275\u0275listener("click", function ReuseTabComponent_For_3_ng_template_1_Conditional_4_Template_i_click_0_listener($event) {
      \u0275\u0275restoreView(_r17);
      const $index_r3 = \u0275\u0275nextContext(2).$index;
      const ctx_r15 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r15._close($event, $index_r3, false));
    });
    \u0275\u0275elementEnd();
  }
}
function ReuseTabComponent_For_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5)(1, "span");
    \u0275\u0275template(2, ReuseTabComponent_For_3_ng_template_1_Conditional_2_Template, 1, 4, null, 6)(3, ReuseTabComponent_For_3_ng_template_1_Conditional_3_Template, 1, 1);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(4, ReuseTabComponent_For_3_ng_template_1_Conditional_4_Template, 1, 0, "i", 7);
  }
  if (rf & 2) {
    const i_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r7 = \u0275\u0275nextContext();
    \u0275\u0275property("reuse-tab-context-menu", i_r2)("customContextMenu", ctx_r7.customContextMenu);
    \u0275\u0275attribute("title", i_r2.title);
    \u0275\u0275advance(1);
    \u0275\u0275styleProp("max-width", ctx_r7.tabMaxWidth, "px");
    \u0275\u0275classProp("reuse-tab__name-width", ctx_r7.tabMaxWidth);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, ctx_r7.titleRender ? 2 : 3);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(4, i_r2.closable ? 4 : -1);
  }
}
function ReuseTabComponent_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-tab", 3);
    \u0275\u0275listener("nzClick", function ReuseTabComponent_For_3_Template_nz_tab_nzClick_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r20);
      const $index_r3 = restoredCtx.$index;
      const ctx_r19 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r19._to($index_r3));
    });
    \u0275\u0275template(1, ReuseTabComponent_For_3_ng_template_1_Template, 5, 9, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _r8 = \u0275\u0275reference(2);
    \u0275\u0275property("nzTitle", _r8);
  }
}
var _ReuseTabContextMenuComponent = class _ReuseTabContextMenuComponent {
  set i18n(value) {
    this._i18n = __spreadValues(__spreadValues({}, this.i18nSrv.getData("reuseTab")), value);
  }
  get i18n() {
    return this._i18n;
  }
  get includeNonCloseable() {
    return this.event.ctrlKey;
  }
  constructor(i18nSrv) {
    this.i18nSrv = i18nSrv;
    this.close = new EventEmitter();
  }
  notify(type) {
    this.close.next({
      type,
      item: this.item,
      includeNonCloseable: this.includeNonCloseable
    });
  }
  ngOnInit() {
    if (this.includeNonCloseable)
      this.item.closable = true;
  }
  click(e, type, custom) {
    e.preventDefault();
    e.stopPropagation();
    if (type === "close" && !this.item.closable)
      return;
    if (type === "closeRight" && this.item.last)
      return;
    if (custom) {
      if (this.isDisabled(custom))
        return;
      custom.fn(this.item, custom);
    }
    this.notify(type);
  }
  isDisabled(custom) {
    return custom.disabled ? custom.disabled(this.item) : false;
  }
  closeMenu(event) {
    if (event.type === "click" && event.button === 2)
      return;
    this.notify(null);
  }
};
_ReuseTabContextMenuComponent.\u0275fac = function ReuseTabContextMenuComponent_Factory(t) {
  return new (t || _ReuseTabContextMenuComponent)(\u0275\u0275directiveInject(DelonLocaleService));
};
_ReuseTabContextMenuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ReuseTabContextMenuComponent,
  selectors: [["reuse-tab-context-menu"]],
  hostBindings: function ReuseTabContextMenuComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function ReuseTabContextMenuComponent_click_HostBindingHandler($event) {
        return ctx.closeMenu($event);
      }, false, \u0275\u0275resolveDocument)("contextmenu", function ReuseTabContextMenuComponent_contextmenu_HostBindingHandler($event) {
        return ctx.closeMenu($event);
      }, false, \u0275\u0275resolveDocument);
    }
  },
  inputs: {
    i18n: "i18n",
    item: "item",
    event: "event",
    customContextMenu: "customContextMenu"
  },
  outputs: {
    close: "close"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 6,
  vars: 7,
  consts: [["nz-menu", ""], ["nz-menu-item", "", "data-type", "refresh", 3, "innerHTML"], ["nz-menu-item", "", "data-type", "close", 3, "nzDisabled", "innerHTML", "click"], ["nz-menu-item", "", "data-type", "closeOther", 3, "innerHTML", "click"], ["nz-menu-item", "", "data-type", "closeRight", 3, "nzDisabled", "innerHTML", "click"], ["nz-menu-item", "", "data-type", "refresh", 3, "innerHTML", "click"], ["nz-menu-divider", ""], ["nz-menu-item", "", 3, "nzDisabled", "innerHTML", "click"], ["nz-menu-item", "", 3, "nzDisabled", "innerHTML"]],
  template: function ReuseTabContextMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ul", 0);
      \u0275\u0275template(1, ReuseTabContextMenuComponent_Conditional_1_Template, 1, 1, "li", 1);
      \u0275\u0275elementStart(2, "li", 2);
      \u0275\u0275listener("click", function ReuseTabContextMenuComponent_Template_li_click_2_listener($event) {
        return ctx.click($event, "close");
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "li", 3);
      \u0275\u0275listener("click", function ReuseTabContextMenuComponent_Template_li_click_3_listener($event) {
        return ctx.click($event, "closeOther");
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "li", 4);
      \u0275\u0275listener("click", function ReuseTabContextMenuComponent_Template_li_click_4_listener($event) {
        return ctx.click($event, "closeRight");
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(5, ReuseTabContextMenuComponent_Conditional_5_Template, 3, 0);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx.item.active ? 1 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzDisabled", !ctx.item.closable)("innerHTML", ctx.i18n.close, \u0275\u0275sanitizeHtml);
      \u0275\u0275advance(1);
      \u0275\u0275property("innerHTML", ctx.i18n.closeOther, \u0275\u0275sanitizeHtml);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzDisabled", ctx.item.last)("innerHTML", ctx.i18n.closeRight, \u0275\u0275sanitizeHtml);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(5, ctx.customContextMenu.length > 0 ? 5 : -1);
    }
  },
  dependencies: [NzMenuModule, NzMenuDirective, NzMenuItemComponent, NzMenuDividerDirective],
  encapsulation: 2,
  changeDetection: 0
});
var ReuseTabContextMenuComponent = _ReuseTabContextMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReuseTabContextMenuComponent, [{
    type: Component,
    args: [{
      selector: "reuse-tab-context-menu",
      host: {
        "(document:click)": "closeMenu($event)",
        "(document:contextmenu)": "closeMenu($event)"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [NzMenuModule],
      template: `<ul nz-menu>
  @if (item.active) {
    <li nz-menu-item (click)="click($event, 'refresh')" data-type="refresh" [innerHTML]="i18n.refresh"></li>
  }
  <li
    nz-menu-item
    (click)="click($event, 'close')"
    data-type="close"
    [nzDisabled]="!item.closable"
    [innerHTML]="i18n.close"
  ></li>
  <li nz-menu-item (click)="click($event, 'closeOther')" data-type="closeOther" [innerHTML]="i18n.closeOther"></li>
  <li
    nz-menu-item
    (click)="click($event, 'closeRight')"
    data-type="closeRight"
    [nzDisabled]="item.last"
    [innerHTML]="i18n.closeRight"
  ></li>
  @if (customContextMenu!.length > 0) {
    <li nz-menu-divider></li>
    @for (i of customContextMenu; track $index) {
      <li
        nz-menu-item
        [attr.data-type]="i.id"
        [nzDisabled]="isDisabled(i)"
        (click)="click($event, 'custom', i)"
        [innerHTML]="i.title"
      ></li>
    }
  }
</ul>
`
    }]
  }], () => [{
    type: DelonLocaleService
  }], {
    i18n: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    event: [{
      type: Input
    }],
    customContextMenu: [{
      type: Input
    }],
    close: [{
      type: Output
    }]
  });
})();
var _ReuseTabContextService = class _ReuseTabContextService {
  constructor(overlay) {
    this.overlay = overlay;
    this.ref = null;
    this.show = new Subject();
    this.close = new Subject();
  }
  remove() {
    if (!this.ref)
      return;
    this.ref.detach();
    this.ref.dispose();
    this.ref = null;
  }
  open(context) {
    this.remove();
    const {
      event,
      item,
      customContextMenu
    } = context;
    const {
      x,
      y
    } = event;
    const positions = [new ConnectionPositionPair({
      originX: "start",
      originY: "bottom"
    }, {
      overlayX: "start",
      overlayY: "top"
    }), new ConnectionPositionPair({
      originX: "start",
      originY: "top"
    }, {
      overlayX: "start",
      overlayY: "bottom"
    })];
    const positionStrategy = this.overlay.position().flexibleConnectedTo({
      x,
      y
    }).withPositions(positions);
    this.ref = this.overlay.create({
      positionStrategy,
      panelClass: "reuse-tab__cm",
      scrollStrategy: this.overlay.scrollStrategies.close()
    });
    const comp = this.ref.attach(new ComponentPortal(ReuseTabContextMenuComponent));
    const instance = comp.instance;
    instance.i18n = this.i18n;
    instance.item = __spreadValues({}, item);
    instance.customContextMenu = customContextMenu;
    instance.event = event;
    const sub$ = new Subscription();
    sub$.add(instance.close.subscribe((res) => {
      this.close.next(res);
      this.remove();
    }));
    comp.onDestroy(() => sub$.unsubscribe());
  }
};
_ReuseTabContextService.\u0275fac = function ReuseTabContextService_Factory(t) {
  return new (t || _ReuseTabContextService)(\u0275\u0275inject(Overlay));
};
_ReuseTabContextService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ReuseTabContextService,
  factory: _ReuseTabContextService.\u0275fac
});
var ReuseTabContextService = _ReuseTabContextService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReuseTabContextService, [{
    type: Injectable
  }], () => [{
    type: Overlay
  }], null);
})();
var _ReuseTabContextComponent = class _ReuseTabContextComponent {
  set i18n(value) {
    this.srv.i18n = value;
  }
  constructor(srv) {
    this.srv = srv;
    this.sub$ = new Subscription();
    this.change = new EventEmitter();
    this.sub$.add(srv.show.subscribe((context) => this.srv.open(context)));
    this.sub$.add(srv.close.subscribe((res) => this.change.emit(res)));
  }
  ngOnDestroy() {
    this.sub$.unsubscribe();
  }
};
_ReuseTabContextComponent.\u0275fac = function ReuseTabContextComponent_Factory(t) {
  return new (t || _ReuseTabContextComponent)(\u0275\u0275directiveInject(ReuseTabContextService));
};
_ReuseTabContextComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ReuseTabContextComponent,
  selectors: [["reuse-tab-context"]],
  inputs: {
    i18n: "i18n"
  },
  outputs: {
    change: "change"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 0,
  vars: 0,
  template: function ReuseTabContextComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var ReuseTabContextComponent = _ReuseTabContextComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReuseTabContextComponent, [{
    type: Component,
    args: [{
      selector: "reuse-tab-context",
      template: ``,
      standalone: true
    }]
  }], () => [{
    type: ReuseTabContextService
  }], {
    i18n: [{
      type: Input
    }],
    change: [{
      type: Output
    }]
  });
})();
var _ReuseTabContextDirective = class _ReuseTabContextDirective {
  constructor(srv) {
    this.srv = srv;
  }
  _onContextMenu(event) {
    this.srv.show.next({
      event,
      item: this.item,
      customContextMenu: this.customContextMenu
    });
    event.preventDefault();
    event.stopPropagation();
  }
};
_ReuseTabContextDirective.\u0275fac = function ReuseTabContextDirective_Factory(t) {
  return new (t || _ReuseTabContextDirective)(\u0275\u0275directiveInject(ReuseTabContextService));
};
_ReuseTabContextDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _ReuseTabContextDirective,
  selectors: [["", "reuse-tab-context-menu", ""]],
  hostBindings: function ReuseTabContextDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("contextmenu", function ReuseTabContextDirective_contextmenu_HostBindingHandler($event) {
        return ctx._onContextMenu($event);
      });
    }
  },
  inputs: {
    item: ["reuse-tab-context-menu", "item"],
    customContextMenu: "customContextMenu"
  },
  exportAs: ["reuseTabContextMenu"],
  standalone: true
});
var ReuseTabContextDirective = _ReuseTabContextDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReuseTabContextDirective, [{
    type: Directive,
    args: [{
      selector: "[reuse-tab-context-menu]",
      exportAs: "reuseTabContextMenu",
      host: {
        "(contextmenu)": "_onContextMenu($event)"
      },
      standalone: true
    }]
  }], () => [{
    type: ReuseTabContextService
  }], {
    item: [{
      type: Input,
      args: ["reuse-tab-context-menu"]
    }],
    customContextMenu: [{
      type: Input
    }]
  });
})();
var ReuseTabMatchMode;
(function(ReuseTabMatchMode2) {
  ReuseTabMatchMode2[ReuseTabMatchMode2["Menu"] = 0] = "Menu";
  ReuseTabMatchMode2[ReuseTabMatchMode2["MenuForce"] = 1] = "MenuForce";
  ReuseTabMatchMode2[ReuseTabMatchMode2["URL"] = 2] = "URL";
})(ReuseTabMatchMode || (ReuseTabMatchMode = {}));
var REUSE_TAB_STORAGE_KEY = new InjectionToken("REUSE_TAB_STORAGE_KEY");
var REUSE_TAB_STORAGE_STATE = new InjectionToken("REUSE_TAB_STORAGE_STATE");
var ReuseTabLocalStorageState = class {
  get(key) {
    return JSON.parse(localStorage.getItem(key) || "[]") || [];
  }
  update(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  }
  remove(key) {
    localStorage.removeItem(key);
  }
};
var REUSE_TAB_CACHED_MANAGER = new InjectionToken("REUSE_TAB_CACHED_MANAGER");
var ReuseTabCachedManagerFactory = class {
  constructor() {
    this.list = [];
    this.title = {};
    this.closable = {};
  }
};
var _ReuseTabService = class _ReuseTabService {
  get snapshot() {
    return this.injector.get(ActivatedRoute).snapshot;
  }
  // #region public
  /**
   * Get init status
   *
   * 是否已经初始化完成
   */
  get inited() {
    return this._inited;
  }
  /**
   * Current routing address
   *
   * 当前路由地址
   */
  get curUrl() {
    return this.getUrl(this.snapshot);
  }
  /**
   * 允许最多复用多少个页面，取值范围 `2-100`，值发生变更时会强制关闭且忽略可关闭条件
   */
  set max(value) {
    this._max = Math.min(Math.max(value, 2), 100);
    for (let i = this.cached.list.length; i > this._max; i--) {
      this.cached.list.pop();
    }
  }
  set keepingScroll(value) {
    this._keepingScroll = value;
    this.initScroll();
  }
  get keepingScroll() {
    return this._keepingScroll;
  }
  /** 获取已缓存的路由 */
  get items() {
    return this.cached.list;
  }
  /** 获取当前缓存的路由总数 */
  get count() {
    return this.cached.list.length;
  }
  /** 订阅缓存变更通知 */
  get change() {
    return this._cachedChange.asObservable();
  }
  /** 自定义当前标题 */
  set title(value) {
    const url = this.curUrl;
    if (typeof value === "string")
      value = {
        text: value
      };
    this.cached.title[url] = value;
    this.di("update current tag title: ", value);
    this._cachedChange.next({
      active: "title",
      url,
      title: value,
      list: this.cached.list
    });
  }
  /** 获取指定路径缓存所在位置，`-1` 表示无缓存 */
  index(url) {
    return this.cached.list.findIndex((w) => w.url === url);
  }
  /** 获取指定路径缓存是否存在 */
  exists(url) {
    return this.index(url) !== -1;
  }
  /** 获取指定路径缓存 */
  get(url) {
    return url ? this.cached.list.find((w) => w.url === url) || null : null;
  }
  remove(url, includeNonCloseable) {
    const idx = typeof url === "string" ? this.index(url) : url;
    const item = idx !== -1 ? this.cached.list[idx] : null;
    if (!item || !includeNonCloseable && !item.closable)
      return false;
    this.destroy(item._handle);
    this.cached.list.splice(idx, 1);
    delete this.cached.title[url];
    return true;
  }
  /**
   * 根据URL移除标签
   *
   * @param [includeNonCloseable=false] 是否强制包含不可关闭
   */
  close(url, includeNonCloseable = false) {
    this.removeUrlBuffer = url;
    this.remove(url, includeNonCloseable);
    this._cachedChange.next({
      active: "close",
      url,
      list: this.cached.list
    });
    this.di("close tag", url);
    return true;
  }
  /**
   * 清除右边
   *
   * @param [includeNonCloseable=false] 是否强制包含不可关闭
   */
  closeRight(url, includeNonCloseable = false) {
    const start = this.index(url);
    for (let i = this.count - 1; i > start; i--) {
      this.remove(i, includeNonCloseable);
    }
    this.removeUrlBuffer = null;
    this._cachedChange.next({
      active: "closeRight",
      url,
      list: this.cached.list
    });
    this.di("close right tages", url);
    return true;
  }
  /**
   * 清除所有缓存
   *
   * @param [includeNonCloseable=false] 是否强制包含不可关闭
   */
  clear(includeNonCloseable = false) {
    this.cached.list.forEach((w) => {
      if (!includeNonCloseable && w.closable)
        this.destroy(w._handle);
    });
    this.cached.list = this.cached.list.filter((w) => !includeNonCloseable && !w.closable);
    this.removeUrlBuffer = null;
    this._cachedChange.next({
      active: "clear",
      list: this.cached.list
    });
    this.di("clear all catch");
  }
  /**
   * 移动缓存数据
   *
   * @param url 要移动的URL地址
   * @param position 新位置，下标从 `0` 开始
   *
   * @example
   * ```
   * // source
   * [ '/a/1', '/a/2', '/a/3', '/a/4', '/a/5' ]
   * move('/a/1', 2);
   * // output
   * [ '/a/2', '/a/3', '/a/1', '/a/4', '/a/5' ]
   * move('/a/1', -1);
   * // output
   * [ '/a/2', '/a/3', '/a/4', '/a/5', '/a/1' ]
   * ```
   */
  move(url, position) {
    const start = this.cached.list.findIndex((w) => w.url === url);
    if (start === -1)
      return;
    const data = this.cached.list.slice();
    data.splice(position < 0 ? data.length + position : position, 0, data.splice(start, 1)[0]);
    this.cached.list = data;
    this._cachedChange.next({
      active: "move",
      url,
      position,
      list: this.cached.list
    });
  }
  /**
   * 强制关闭当前路由（包含不可关闭状态），并重新导航至 `newUrl` 路由
   */
  replace(newUrl) {
    const url = this.curUrl;
    if (this.exists(url)) {
      this.close(url, true);
    } else {
      this.removeUrlBuffer = url;
    }
    this.injector.get(Router).navigateByUrl(newUrl);
  }
  /**
   * 获取标题，顺序如下：
   *
   * 1. 组件内使用 `ReuseTabService.title = 'new title'` 重新指定文本
   * 2. 路由配置中 data 属性中包含 titleI18n > title
   * 3. 菜单数据中 text 属性
   *
   * @param url 指定URL
   * @param route 指定路由快照
   */
  getTitle(url, route) {
    if (this.cached.title[url]) {
      return this.cached.title[url];
    }
    if (route && route.data && (route.data.titleI18n || route.data.title)) {
      return {
        text: route.data.title,
        i18n: route.data.titleI18n
      };
    }
    const menu = this.getMenu(url);
    return menu ? {
      text: menu.text,
      i18n: menu.i18n
    } : {
      text: url
    };
  }
  /**
   * 清除标题缓存
   */
  clearTitleCached() {
    this.cached.title = {};
  }
  /** 自定义当前 `closable` 状态 */
  set closable(value) {
    const url = this.curUrl;
    this.cached.closable[url] = value;
    this.di("update current tag closable: ", value);
    this._cachedChange.next({
      active: "closable",
      closable: value,
      list: this.cached.list
    });
  }
  /**
   * 获取 `closable` 状态，顺序如下：
   *
   * 1. 组件内使用 `ReuseTabService.closable = true` 重新指定 `closable` 状态
   * 2. 路由配置中 data 属性中包含 `reuseClosable`
   * 3. 菜单数据中 `reuseClosable` 属性
   *
   * @param url 指定URL
   * @param route 指定路由快照
   */
  getClosable(url, route) {
    if (typeof this.cached.closable[url] !== "undefined")
      return this.cached.closable[url];
    if (route && route.data && typeof route.data.reuseClosable === "boolean")
      return route.data.reuseClosable;
    const menu = this.mode !== ReuseTabMatchMode.URL ? this.getMenu(url) : null;
    if (menu && typeof menu.reuseClosable === "boolean")
      return menu.reuseClosable;
    return true;
  }
  /**
   * 清空 `closable` 缓存
   */
  clearClosableCached() {
    this.cached.closable = {};
  }
  getTruthRoute(route) {
    let next = route;
    while (next.firstChild)
      next = next.firstChild;
    return next;
  }
  /**
   * 根据快照获取URL地址
   */
  getUrl(route) {
    let next = this.getTruthRoute(route);
    const segments = [];
    while (next) {
      segments.push(next.url.join("/"));
      next = next.parent;
    }
    const url = `/${segments.filter((i) => i).reverse().join("/")}`;
    return url;
  }
  /**
   * 检查快照是否允许被复用
   */
  can(route) {
    const url = this.getUrl(route);
    if (url === this.removeUrlBuffer)
      return false;
    if (route.data && typeof route.data.reuse === "boolean")
      return route.data.reuse;
    if (this.mode !== ReuseTabMatchMode.URL) {
      const menu = this.getMenu(url);
      if (!menu)
        return false;
      if (this.mode === ReuseTabMatchMode.Menu) {
        if (menu.reuse === false)
          return false;
      } else {
        if (!menu.reuse || menu.reuse !== true)
          return false;
      }
      return true;
    }
    return !this.isExclude(url);
  }
  isExclude(url) {
    return this.excludes.findIndex((r) => r.test(url)) !== -1;
  }
  /**
   * 刷新，触发一个 refresh 类型事件
   */
  refresh(data) {
    this._cachedChange.next({
      active: "refresh",
      data
    });
  }
  // #endregion
  // #region privates
  destroy(_handle) {
    if (_handle && _handle.componentRef && _handle.componentRef.destroy)
      _handle.componentRef.destroy();
  }
  di(...args) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!this.debug)
        return;
      console.warn(...args);
    }
  }
  // #endregion
  constructor(injector, menuService, cached, stateKey, stateSrv) {
    this.injector = injector;
    this.menuService = menuService;
    this.cached = cached;
    this.stateKey = stateKey;
    this.stateSrv = stateSrv;
    this._inited = false;
    this._max = 10;
    this._keepingScroll = false;
    this._cachedChange = new BehaviorSubject(null);
    this.removeUrlBuffer = null;
    this.positionBuffer = {};
    this.debug = false;
    this.routeParamMatchMode = "strict";
    this.mode = ReuseTabMatchMode.Menu;
    this.excludes = [];
    this.storageState = false;
    if (this.cached == null) {
      this.cached = {
        list: [],
        title: {},
        closable: {}
      };
    }
  }
  init() {
    this.initScroll();
    this._inited = true;
    this.loadState();
  }
  loadState() {
    if (!this.storageState)
      return;
    this.cached.list = this.stateSrv.get(this.stateKey).map((v) => ({
      title: {
        text: v.title
      },
      url: v.url,
      position: v.position
    }));
    this._cachedChange.next({
      active: "loadState"
    });
  }
  getMenu(url) {
    const menus = this.menuService.getPathByUrl(url);
    if (!menus || menus.length === 0)
      return null;
    return menus.pop();
  }
  runHook(method, comp, type = "init") {
    if (typeof comp === "number") {
      const item = this.cached.list[comp];
      comp = item._handle?.componentRef;
    }
    if (comp == null || !comp.instance) {
      return;
    }
    const compThis = comp.instance;
    const fn = compThis[method];
    if (typeof fn !== "function") {
      return;
    }
    if (method === "_onReuseInit") {
      fn.call(compThis, type);
    } else {
      fn.call(compThis);
    }
  }
  hasInValidRoute(route) {
    return !route.routeConfig || !!route.routeConfig.loadChildren || !!route.routeConfig.children;
  }
  /**
   * 决定是否允许路由复用，若 `true` 会触发 `store`
   */
  shouldDetach(route) {
    if (this.hasInValidRoute(route))
      return false;
    this.di("#shouldDetach", this.can(route), this.getUrl(route));
    return this.can(route);
  }
  /**
   * 存储
   */
  store(_snapshot, _handle) {
    const url = this.getUrl(_snapshot);
    const idx = this.index(url);
    const isAdd = idx === -1;
    const item = {
      title: this.getTitle(url, _snapshot),
      closable: this.getClosable(url, _snapshot),
      position: this.getKeepingScroll(url, _snapshot) ? this.positionBuffer[url] : null,
      url,
      _snapshot,
      _handle
    };
    if (isAdd) {
      if (this.count >= this._max) {
        const closeIdx = this.cached.list.findIndex((w) => w.closable);
        if (closeIdx !== -1)
          this.remove(closeIdx, false);
      }
      this.cached.list.push(item);
    } else {
      const cahcedComponentRef = this.cached.list[idx]._handle?.componentRef;
      if (_handle == null && cahcedComponentRef != null) {
        timer(100).subscribe(() => this.runHook("_onReuseInit", cahcedComponentRef));
      }
      this.cached.list[idx] = item;
    }
    this.removeUrlBuffer = null;
    this.di("#store", isAdd ? "[new]" : "[override]", url);
    if (_handle && _handle.componentRef) {
      this.runHook("_onReuseDestroy", _handle.componentRef);
    }
    if (!isAdd) {
      this._cachedChange.next({
        active: "override",
        item,
        list: this.cached.list
      });
    }
  }
  /**
   * 决定是否允许应用缓存数据
   */
  shouldAttach(route) {
    if (this.hasInValidRoute(route))
      return false;
    const url = this.getUrl(route);
    const data = this.get(url);
    const ret = !!(data && data._handle);
    this.di("#shouldAttach", ret, url);
    if (!ret) {
      this._cachedChange.next({
        active: "add",
        url,
        list: this.cached.list
      });
    }
    return ret;
  }
  /**
   * 提取复用数据
   */
  retrieve(route) {
    if (this.hasInValidRoute(route))
      return null;
    const url = this.getUrl(route);
    const data = this.get(url);
    const ret = data && data._handle || null;
    this.di("#retrieve", url, ret);
    return ret;
  }
  /**
   * 决定是否应该进行复用路由处理
   */
  shouldReuseRoute(future, curr) {
    let ret = future.routeConfig === curr.routeConfig;
    if (!ret)
      return false;
    const path = future.routeConfig && future.routeConfig.path || "";
    if (path.length > 0 && ~path.indexOf(":")) {
      if (this.routeParamMatchMode === "strict") {
        ret = this.getUrl(future) === this.getUrl(curr);
      } else {
        ret = path === (curr.routeConfig && curr.routeConfig.path || "");
      }
    }
    this.di("=====================");
    this.di("#shouldReuseRoute", ret, `${this.getUrl(curr)}=>${this.getUrl(future)}`, future, curr);
    return ret;
  }
  // #region scroll
  /**
   * 获取 `keepingScroll` 状态，顺序如下：
   *
   * 1. 路由配置中 data 属性中包含 `keepingScroll`
   * 2. 菜单数据中 `keepingScroll` 属性
   * 3. 组件 `keepingScroll` 值
   */
  getKeepingScroll(url, route) {
    if (route && route.data && typeof route.data.keepingScroll === "boolean")
      return route.data.keepingScroll;
    const menu = this.mode !== ReuseTabMatchMode.URL ? this.getMenu(url) : null;
    if (menu && typeof menu.keepingScroll === "boolean")
      return menu.keepingScroll;
    return this.keepingScroll;
  }
  get isDisabledInRouter() {
    const routerConfig = this.injector.get(ROUTER_CONFIGURATION, {});
    return routerConfig.scrollPositionRestoration === "disabled";
  }
  get ss() {
    return this.injector.get(ScrollService);
  }
  initScroll() {
    if (this._router$) {
      this._router$.unsubscribe();
    }
    this._router$ = this.injector.get(Router).events.subscribe((e) => {
      if (e instanceof NavigationStart) {
        const url = this.curUrl;
        if (this.getKeepingScroll(url, this.getTruthRoute(this.snapshot))) {
          this.positionBuffer[url] = this.ss.getScrollPosition(this.keepingScrollContainer);
        } else {
          delete this.positionBuffer[url];
        }
      } else if (e instanceof NavigationEnd) {
        const url = this.curUrl;
        const item = this.get(url);
        if (item && item.position && this.getKeepingScroll(url, this.getTruthRoute(this.snapshot))) {
          if (this.isDisabledInRouter) {
            this.ss.scrollToPosition(this.keepingScrollContainer, item.position);
          } else {
            setTimeout(() => this.ss.scrollToPosition(this.keepingScrollContainer, item.position), 1);
          }
        }
      }
    });
  }
  // #endregion
  ngOnDestroy() {
    const {
      _cachedChange,
      _router$
    } = this;
    this.clear();
    this.cached.list = [];
    _cachedChange.complete();
    if (_router$) {
      _router$.unsubscribe();
    }
  }
};
_ReuseTabService.\u0275fac = function ReuseTabService_Factory(t) {
  return new (t || _ReuseTabService)(\u0275\u0275inject(Injector), \u0275\u0275inject(MenuService), \u0275\u0275inject(REUSE_TAB_CACHED_MANAGER, 8), \u0275\u0275inject(REUSE_TAB_STORAGE_KEY, 8), \u0275\u0275inject(REUSE_TAB_STORAGE_STATE, 8));
};
_ReuseTabService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ReuseTabService,
  factory: _ReuseTabService.\u0275fac,
  providedIn: "root"
});
var ReuseTabService = _ReuseTabService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReuseTabService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Injector
  }, {
    type: MenuService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [REUSE_TAB_CACHED_MANAGER]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [REUSE_TAB_STORAGE_KEY]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [REUSE_TAB_STORAGE_STATE]
    }]
  }], null);
})();
var _ReuseTabComponent = class _ReuseTabComponent {
  set keepingScrollContainer(value) {
    this._keepingScrollContainer = typeof value === "string" ? this.doc.querySelector(value) : value;
  }
  // #endregion
  constructor(srv, cdr, router, route, i18nSrv, doc, platform, directionality, stateKey, stateSrv) {
    this.srv = srv;
    this.cdr = cdr;
    this.router = router;
    this.route = route;
    this.i18nSrv = i18nSrv;
    this.doc = doc;
    this.platform = platform;
    this.directionality = directionality;
    this.stateKey = stateKey;
    this.stateSrv = stateSrv;
    this.destroy$ = inject(DestroyRef);
    this.list = [];
    this.pos = 0;
    this.dir = "ltr";
    this.mode = ReuseTabMatchMode.Menu;
    this.debug = false;
    this.allowClose = true;
    this.keepingScroll = false;
    this.storageState = false;
    this.customContextMenu = [];
    this.tabBarStyle = null;
    this.tabType = "line";
    this.routeParamMatchMode = "strict";
    this.disabled = false;
    this.change = new EventEmitter();
    this.close = new EventEmitter();
  }
  genTit(title) {
    return title.i18n && this.i18nSrv ? this.i18nSrv.fanyi(title.i18n) : title.text;
  }
  get curUrl() {
    return this.srv.getUrl(this.route.snapshot);
  }
  genCurItem() {
    const url = this.curUrl;
    const snapshotTrue = this.srv.getTruthRoute(this.route.snapshot);
    return {
      url,
      title: this.genTit(this.srv.getTitle(url, snapshotTrue)),
      closable: this.allowClose && this.srv.count > 0 && this.srv.getClosable(url, snapshotTrue),
      active: false,
      last: false,
      index: 0
    };
  }
  genList(notify) {
    const ls = this.srv.items.map((item, index) => ({
      url: item.url,
      title: this.genTit(item.title),
      closable: this.allowClose && item.closable && this.srv.count > 0,
      position: item.position,
      index,
      active: false,
      last: false
    }));
    const url = this.curUrl;
    let addCurrent = ls.findIndex((w) => w.url === url) === -1;
    if (notify && notify.active === "close" && notify.url === url) {
      addCurrent = false;
      let toPos = 0;
      const curItem = this.list.find((w) => w.url === url);
      if (curItem.index === ls.length) {
        toPos = ls.length - 1;
      } else if (curItem.index < ls.length) {
        toPos = Math.max(0, curItem.index);
      }
      this.router.navigateByUrl(ls[toPos].url);
    }
    if (addCurrent) {
      ls.splice(this.pos + 1, 0, this.genCurItem());
    }
    ls.forEach((item, index) => item.index = index);
    if (ls.length === 1) {
      ls[0].closable = false;
    }
    this.list = ls;
    this.cdr.detectChanges();
    this.updatePos();
  }
  updateTitle(res) {
    const item = this.list.find((w) => w.url === res.url);
    if (!item)
      return;
    item.title = this.genTit(res.title);
    this.cdr.detectChanges();
  }
  refresh(item) {
    this.srv.runHook("_onReuseInit", this.pos === item.index ? this.srv.componentRef : item.index, "refresh");
  }
  saveState() {
    if (!this.srv.inited || !this.storageState)
      return;
    this.stateSrv.update(this.stateKey, this.list);
  }
  // #region UI
  contextMenuChange(res) {
    let fn = null;
    switch (res.type) {
      case "refresh":
        this.refresh(res.item);
        break;
      case "close":
        this._close(null, res.item.index, res.includeNonCloseable);
        break;
      case "closeRight":
        fn = () => {
          this.srv.closeRight(res.item.url, res.includeNonCloseable);
          this.close.emit(null);
        };
        break;
      case "closeOther":
        fn = () => {
          this.srv.clear(res.includeNonCloseable);
          this.close.emit(null);
        };
        break;
    }
    if (!fn) {
      return;
    }
    if (!res.item.active && res.item.index <= this.list.find((w) => w.active).index) {
      this._to(res.item.index, fn);
    } else {
      fn();
    }
  }
  _to(index, cb) {
    index = Math.max(0, Math.min(index, this.list.length - 1));
    const item = this.list[index];
    this.router.navigateByUrl(item.url).then((res) => {
      if (!res)
        return;
      this.item = item;
      this.change.emit(item);
      if (cb) {
        cb();
      }
    });
  }
  _close(e, idx, includeNonCloseable) {
    if (e != null) {
      e.preventDefault();
      e.stopPropagation();
    }
    const item = this.list[idx];
    (this.canClose ? this.canClose({
      item,
      includeNonCloseable
    }) : of(true)).pipe(filter((v) => v)).subscribe(() => {
      this.srv.close(item.url, includeNonCloseable);
      this.close.emit(item);
      this.cdr.detectChanges();
    });
    return false;
  }
  /**
   * 设置激活路由的实例，在 `src/app/layout/basic/basic.component.ts` 修改：
   *
   * @example
   * <reuse-tab #reuseTab></reuse-tab>
   * <router-outlet (activate)="reuseTab.activate($event)" (attach)="reuseTab.activate($event)"></router-outlet>
   */
  activate(instance) {
    this.srv.componentRef = {
      instance
    };
  }
  updatePos() {
    const url = this.srv.getUrl(this.route.snapshot);
    const ls = this.list.filter((w) => w.url === url || !this.srv.isExclude(w.url));
    if (ls.length === 0) {
      return;
    }
    const last = ls[ls.length - 1];
    const item = ls.find((w) => w.url === url);
    last.last = true;
    const pos = item == null ? last.index : item.index;
    ls.forEach((i, idx) => i.active = pos === idx);
    this.pos = pos;
    this.tabset.nzSelectedIndex = pos;
    this.list = ls;
    this.cdr.detectChanges();
    this.saveState();
  }
  // #endregion
  ngOnInit() {
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntilDestroyed(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    if (!this.platform.isBrowser) {
      return;
    }
    this.srv.change.pipe(takeUntilDestroyed(this.destroy$)).subscribe((res) => {
      switch (res?.active) {
        case "title":
          this.updateTitle(res);
          return;
        case "override":
          if (res?.list?.length === this.list.length) {
            this.updatePos();
            return;
          }
          break;
      }
      this.genList(res);
    });
    this.i18nSrv.change.pipe(filter(() => this.srv.inited), takeUntilDestroyed(this.destroy$), debounceTime(100)).subscribe(() => this.genList({
      active: "title"
    }));
    this.srv.init();
  }
  ngOnChanges(changes) {
    if (!this.platform.isBrowser) {
      return;
    }
    if (changes.max)
      this.srv.max = this.max;
    if (changes.excludes)
      this.srv.excludes = this.excludes;
    if (changes.mode)
      this.srv.mode = this.mode;
    if (changes.routeParamMatchMode)
      this.srv.routeParamMatchMode = this.routeParamMatchMode;
    if (changes.keepingScroll) {
      this.srv.keepingScroll = this.keepingScroll;
      this.srv.keepingScrollContainer = this._keepingScrollContainer;
    }
    if (changes.storageState)
      this.srv.storageState = this.storageState;
    this.srv.debug = this.debug;
    this.cdr.detectChanges();
  }
};
_ReuseTabComponent.\u0275fac = function ReuseTabComponent_Factory(t) {
  return new (t || _ReuseTabComponent)(\u0275\u0275directiveInject(ReuseTabService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(ALAIN_I18N_TOKEN, 8), \u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(REUSE_TAB_STORAGE_KEY, 8), \u0275\u0275directiveInject(REUSE_TAB_STORAGE_STATE, 8));
};
_ReuseTabComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ReuseTabComponent,
  selectors: [["reuse-tab"], ["", "reuse-tab", ""]],
  viewQuery: function ReuseTabComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c026, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tabset = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function ReuseTabComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("reuse-tab", true)("reuse-tab__line", ctx.tabType === "line")("reuse-tab__card", ctx.tabType === "card")("reuse-tab__disabled", ctx.disabled)("reuse-tab-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    mode: "mode",
    i18n: "i18n",
    debug: "debug",
    max: "max",
    tabMaxWidth: "tabMaxWidth",
    excludes: "excludes",
    allowClose: "allowClose",
    keepingScroll: "keepingScroll",
    storageState: "storageState",
    keepingScrollContainer: "keepingScrollContainer",
    customContextMenu: "customContextMenu",
    tabBarExtraContent: "tabBarExtraContent",
    tabBarGutter: "tabBarGutter",
    tabBarStyle: "tabBarStyle",
    tabType: "tabType",
    routeParamMatchMode: "routeParamMatchMode",
    disabled: "disabled",
    titleRender: "titleRender",
    canClose: "canClose"
  },
  outputs: {
    change: "change",
    close: "close"
  },
  exportAs: ["reuseTab"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([ReuseTabContextService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 5,
  vars: 7,
  consts: [[3, "nzSelectedIndex", "nzAnimated", "nzType", "nzTabBarExtraContent", "nzTabBarGutter", "nzTabBarStyle"], ["tabset", ""], [3, "i18n", "change"], [3, "nzTitle", "nzClick"], ["titleTemplate", ""], [1, "reuse-tab__name", 3, "reuse-tab-context-menu", "customContextMenu"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["nz-icon", "", "nzType", "close", "class", "reuse-tab__op"], ["nz-icon", "", "nzType", "close", 1, "reuse-tab__op", 3, "click"], [3, "nzTitle"]],
  template: function ReuseTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nz-tabset", 0, 1);
      \u0275\u0275repeaterCreate(2, ReuseTabComponent_For_3_Template, 3, 1, "nz-tab", 9, \u0275\u0275repeaterTrackByIndex);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "reuse-tab-context", 2);
      \u0275\u0275listener("change", function ReuseTabComponent_Template_reuse_tab_context_change_4_listener($event) {
        return ctx.contextMenuChange($event);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("nzSelectedIndex", ctx.pos)("nzAnimated", false)("nzType", ctx.tabType)("nzTabBarExtraContent", ctx.tabBarExtraContent)("nzTabBarGutter", ctx.tabBarGutter)("nzTabBarStyle", ctx.tabBarStyle);
      \u0275\u0275advance(2);
      \u0275\u0275repeater(ctx.list);
      \u0275\u0275advance(2);
      \u0275\u0275property("i18n", ctx.i18n);
    }
  },
  dependencies: [NgTemplateOutlet, NzTabsModule, NzTabSetComponent, NzTabComponent, ReuseTabContextDirective, ReuseTabContextComponent, NzIconModule, NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var ReuseTabComponent = _ReuseTabComponent;
__decorate([InputBoolean2()], ReuseTabComponent.prototype, "debug", void 0);
__decorate([InputNumber2()], ReuseTabComponent.prototype, "max", void 0);
__decorate([InputNumber2()], ReuseTabComponent.prototype, "tabMaxWidth", void 0);
__decorate([InputBoolean2()], ReuseTabComponent.prototype, "allowClose", void 0);
__decorate([InputBoolean2()], ReuseTabComponent.prototype, "keepingScroll", void 0);
__decorate([InputBoolean2()], ReuseTabComponent.prototype, "storageState", void 0);
__decorate([InputBoolean2()], ReuseTabComponent.prototype, "disabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReuseTabComponent, [{
    type: Component,
    args: [{
      selector: "reuse-tab, [reuse-tab]",
      exportAs: "reuseTab",
      host: {
        "[class.reuse-tab]": "true",
        "[class.reuse-tab__line]": `tabType === 'line'`,
        "[class.reuse-tab__card]": `tabType === 'card'`,
        "[class.reuse-tab__disabled]": `disabled`,
        "[class.reuse-tab-rtl]": `dir === 'rtl'`
      },
      providers: [ReuseTabContextService],
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [NgTemplateOutlet, NzTabsModule, ReuseTabContextMenuComponent, ReuseTabContextDirective, ReuseTabContextComponent, NzIconModule],
      template: '<nz-tabset\n  #tabset\n  [nzSelectedIndex]="pos"\n  [nzAnimated]="false"\n  [nzType]="tabType"\n  [nzTabBarExtraContent]="tabBarExtraContent"\n  [nzTabBarGutter]="tabBarGutter"\n  [nzTabBarStyle]="tabBarStyle"\n>\n  @for (i of list; track $index) {\n    <nz-tab [nzTitle]="titleTemplate" (nzClick)="_to($index)">\n      <ng-template #titleTemplate>\n        <div\n          [reuse-tab-context-menu]="i"\n          [customContextMenu]="customContextMenu"\n          class="reuse-tab__name"\n          [attr.title]="i.title"\n        >\n          <span [class.reuse-tab__name-width]="tabMaxWidth" [style.max-width.px]="tabMaxWidth">\n            @if (titleRender) {\n              <ng-template [ngTemplateOutlet]="titleRender" [ngTemplateOutletContext]="{ $implicit: i }" />\n            } @else {\n              {{ i.title }}\n            }\n          </span>\n        </div>\n        @if (i.closable) {\n          <i nz-icon nzType="close" class="reuse-tab__op" (click)="_close($event, $index, false)"></i>\n        }\n      </ng-template>\n    </nz-tab>\n  }\n</nz-tabset>\n<reuse-tab-context [i18n]="i18n" (change)="contextMenuChange($event)" />\n'
    }]
  }], () => [{
    type: ReuseTabService
  }, {
    type: ChangeDetectorRef
  }, {
    type: Router
  }, {
    type: ActivatedRoute
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ALAIN_I18N_TOKEN]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [REUSE_TAB_STORAGE_KEY]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [REUSE_TAB_STORAGE_STATE]
    }]
  }], {
    tabset: [{
      type: ViewChild,
      args: ["tabset"]
    }],
    mode: [{
      type: Input
    }],
    i18n: [{
      type: Input
    }],
    debug: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    tabMaxWidth: [{
      type: Input
    }],
    excludes: [{
      type: Input
    }],
    allowClose: [{
      type: Input
    }],
    keepingScroll: [{
      type: Input
    }],
    storageState: [{
      type: Input
    }],
    keepingScrollContainer: [{
      type: Input
    }],
    customContextMenu: [{
      type: Input
    }],
    tabBarExtraContent: [{
      type: Input
    }],
    tabBarGutter: [{
      type: Input
    }],
    tabBarStyle: [{
      type: Input
    }],
    tabType: [{
      type: Input
    }],
    routeParamMatchMode: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    titleRender: [{
      type: Input
    }],
    canClose: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    close: [{
      type: Output
    }]
  });
})();
var COMPONENTS4 = [ReuseTabComponent];
var NOEXPORTS = [ReuseTabContextMenuComponent, ReuseTabContextComponent, ReuseTabContextDirective];
var _ReuseTabModule = class _ReuseTabModule {
};
_ReuseTabModule.\u0275fac = function ReuseTabModule_Factory(t) {
  return new (t || _ReuseTabModule)();
};
_ReuseTabModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ReuseTabModule
});
_ReuseTabModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [{
    provide: REUSE_TAB_STORAGE_KEY,
    useValue: "_reuse-tab-state"
  }, {
    provide: REUSE_TAB_STORAGE_STATE,
    useFactory: () => new ReuseTabLocalStorageState()
  }, {
    provide: REUSE_TAB_CACHED_MANAGER,
    useFactory: () => new ReuseTabCachedManagerFactory()
  }],
  imports: [CommonModule, RouterModule, DelonLocaleModule, NzMenuModule, NzTabsModule, NzIconModule, OverlayModule, COMPONENTS4, ReuseTabContextMenuComponent]
});
var ReuseTabModule = _ReuseTabModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReuseTabModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, DelonLocaleModule, NzMenuModule, NzTabsModule, NzIconModule, OverlayModule, ...COMPONENTS4, ...NOEXPORTS],
      providers: [{
        provide: REUSE_TAB_STORAGE_KEY,
        useValue: "_reuse-tab-state"
      }, {
        provide: REUSE_TAB_STORAGE_STATE,
        useFactory: () => new ReuseTabLocalStorageState()
      }, {
        provide: REUSE_TAB_CACHED_MANAGER,
        useFactory: () => new ReuseTabCachedManagerFactory()
      }],
      exports: COMPONENTS4
    }]
  }], null, null);
})();
var ReuseTabFeatureKind;
(function(ReuseTabFeatureKind2) {
  ReuseTabFeatureKind2[ReuseTabFeatureKind2["CacheManager"] = 0] = "CacheManager";
  ReuseTabFeatureKind2[ReuseTabFeatureKind2["Store"] = 1] = "Store";
})(ReuseTabFeatureKind || (ReuseTabFeatureKind = {}));

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-affix.mjs
var _c027 = ["fixedEl"];
var _c120 = ["*"];
var AffixRespondEvents;
(function(AffixRespondEvents2) {
  AffixRespondEvents2["resize"] = "resize";
  AffixRespondEvents2["scroll"] = "scroll";
  AffixRespondEvents2["touchstart"] = "touchstart";
  AffixRespondEvents2["touchmove"] = "touchmove";
  AffixRespondEvents2["touchend"] = "touchend";
  AffixRespondEvents2["pageshow"] = "pageshow";
  AffixRespondEvents2["load"] = "LOAD";
})(AffixRespondEvents || (AffixRespondEvents = {}));
function isTargetWindow(target) {
  return typeof window !== "undefined" && target === window;
}
function getTargetRect(target) {
  return !isTargetWindow(target) ? target.getBoundingClientRect() : {
    top: 0,
    left: 0,
    bottom: 0
  };
}
var NZ_CONFIG_MODULE_NAME16 = "affix";
var NZ_AFFIX_CLS_PREFIX = "ant-affix";
var NZ_AFFIX_DEFAULT_SCROLL_TIME = 20;
var _NzAffixComponent = class _NzAffixComponent {
  get target() {
    const el = this.nzTarget;
    return (typeof el === "string" ? this.document.querySelector(el) : el) || window;
  }
  constructor(el, doc, nzConfigService, scrollSrv, ngZone, platform, renderer, nzResizeObserver, cdr, directionality) {
    this.nzConfigService = nzConfigService;
    this.scrollSrv = scrollSrv;
    this.ngZone = ngZone;
    this.platform = platform;
    this.renderer = renderer;
    this.nzResizeObserver = nzResizeObserver;
    this.cdr = cdr;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME16;
    this.nzChange = new EventEmitter();
    this.dir = "ltr";
    this.positionChangeSubscription = Subscription.EMPTY;
    this.offsetChanged$ = new ReplaySubject(1);
    this.destroy$ = new Subject();
    this.placeholderNode = el.nativeElement;
    this.document = doc;
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.registerListeners();
      this.updatePosition({});
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnChanges(changes) {
    const {
      nzOffsetBottom,
      nzOffsetTop,
      nzTarget
    } = changes;
    if (nzOffsetBottom || nzOffsetTop) {
      this.offsetChanged$.next();
    }
    if (nzTarget) {
      this.registerListeners();
    }
  }
  ngAfterViewInit() {
    this.registerListeners();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  registerListeners() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.removeListeners();
    const el = this.target === window ? this.document.body : this.target;
    this.positionChangeSubscription = this.ngZone.runOutsideAngular(() => merge(...Object.keys(AffixRespondEvents).map((evName) => fromEvent(this.target, evName)), this.offsetChanged$.pipe(map(() => ({}))), this.nzResizeObserver.observe(el)).pipe(throttleTime(NZ_AFFIX_DEFAULT_SCROLL_TIME, void 0, {
      trailing: true
    }), takeUntil(this.destroy$)).subscribe((e) => this.updatePosition(e)));
    this.timeout = setTimeout(() => this.updatePosition({}));
  }
  removeListeners() {
    clearTimeout(this.timeout);
    this.positionChangeSubscription.unsubscribe();
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  getOffset(element, target) {
    const elemRect = element.getBoundingClientRect();
    const targetRect = getTargetRect(target);
    const scrollTop = this.scrollSrv.getScroll(target, true);
    const scrollLeft = this.scrollSrv.getScroll(target, false);
    const docElem = this.document.body;
    const clientTop = docElem.clientTop || 0;
    const clientLeft = docElem.clientLeft || 0;
    return {
      top: elemRect.top - targetRect.top + scrollTop - clientTop,
      left: elemRect.left - targetRect.left + scrollLeft - clientLeft,
      width: elemRect.width,
      height: elemRect.height
    };
  }
  setAffixStyle(e, affixStyle) {
    const originalAffixStyle = this.affixStyle;
    const isWindow = this.target === window;
    if (e.type === "scroll" && originalAffixStyle && affixStyle && isWindow) {
      return;
    }
    if (shallowEqual(originalAffixStyle, affixStyle)) {
      return;
    }
    const fixed = !!affixStyle;
    const wrapEl = this.fixedEl.nativeElement;
    this.renderer.setStyle(wrapEl, "cssText", getStyleAsText(affixStyle));
    this.affixStyle = affixStyle;
    if (fixed) {
      wrapEl.classList.add(NZ_AFFIX_CLS_PREFIX);
    } else {
      wrapEl.classList.remove(NZ_AFFIX_CLS_PREFIX);
    }
    this.updateRtlClass();
    if (affixStyle && !originalAffixStyle || !affixStyle && originalAffixStyle) {
      this.nzChange.emit(fixed);
    }
  }
  setPlaceholderStyle(placeholderStyle) {
    const originalPlaceholderStyle = this.placeholderStyle;
    if (shallowEqual(placeholderStyle, originalPlaceholderStyle)) {
      return;
    }
    this.renderer.setStyle(this.placeholderNode, "cssText", getStyleAsText(placeholderStyle));
    this.placeholderStyle = placeholderStyle;
  }
  syncPlaceholderStyle(e) {
    if (!this.affixStyle) {
      return;
    }
    this.renderer.setStyle(this.placeholderNode, "cssText", "");
    this.placeholderStyle = void 0;
    const styleObj = {
      width: this.placeholderNode.offsetWidth,
      height: this.fixedEl.nativeElement.offsetHeight
    };
    this.setAffixStyle(e, __spreadValues(__spreadValues({}, this.affixStyle), styleObj));
    this.setPlaceholderStyle(styleObj);
  }
  updatePosition(e) {
    if (!this.platform.isBrowser) {
      return;
    }
    const targetNode = this.target;
    let offsetTop = this.nzOffsetTop;
    const scrollTop = this.scrollSrv.getScroll(targetNode, true);
    const elemOffset = this.getOffset(this.placeholderNode, targetNode);
    const fixedNode = this.fixedEl.nativeElement;
    const elemSize = {
      width: fixedNode.offsetWidth,
      height: fixedNode.offsetHeight
    };
    const offsetMode = {
      top: false,
      bottom: false
    };
    if (typeof offsetTop !== "number" && typeof this.nzOffsetBottom !== "number") {
      offsetMode.top = true;
      offsetTop = 0;
    } else {
      offsetMode.top = typeof offsetTop === "number";
      offsetMode.bottom = typeof this.nzOffsetBottom === "number";
    }
    const targetRect = getTargetRect(targetNode);
    const targetInnerHeight = targetNode.innerHeight || targetNode.clientHeight;
    if (scrollTop >= elemOffset.top - offsetTop && offsetMode.top) {
      const width = elemOffset.width;
      const top = targetRect.top + offsetTop;
      this.setAffixStyle(e, {
        position: "fixed",
        top,
        left: targetRect.left + elemOffset.left,
        width
      });
      this.setPlaceholderStyle({
        width,
        height: elemSize.height
      });
    } else if (scrollTop <= elemOffset.top + elemSize.height + this.nzOffsetBottom - targetInnerHeight && offsetMode.bottom) {
      const targetBottomOffset = targetNode === window ? 0 : window.innerHeight - targetRect.bottom;
      const width = elemOffset.width;
      this.setAffixStyle(e, {
        position: "fixed",
        bottom: targetBottomOffset + this.nzOffsetBottom,
        left: targetRect.left + elemOffset.left,
        width
      });
      this.setPlaceholderStyle({
        width,
        height: elemOffset.height
      });
    } else {
      if (e.type === AffixRespondEvents.resize && this.affixStyle && this.affixStyle.position === "fixed" && this.placeholderNode.offsetWidth) {
        this.setAffixStyle(e, __spreadProps(__spreadValues({}, this.affixStyle), {
          width: this.placeholderNode.offsetWidth
        }));
      } else {
        this.setAffixStyle(e);
      }
      this.setPlaceholderStyle();
    }
    if (e.type === "resize") {
      this.syncPlaceholderStyle(e);
    }
  }
  updateRtlClass() {
    const wrapEl = this.fixedEl.nativeElement;
    if (this.dir === "rtl") {
      if (wrapEl.classList.contains(NZ_AFFIX_CLS_PREFIX)) {
        wrapEl.classList.add(`${NZ_AFFIX_CLS_PREFIX}-rtl`);
      } else {
        wrapEl.classList.remove(`${NZ_AFFIX_CLS_PREFIX}-rtl`);
      }
    } else {
      wrapEl.classList.remove(`${NZ_AFFIX_CLS_PREFIX}-rtl`);
    }
  }
};
_NzAffixComponent.\u0275fac = function NzAffixComponent_Factory(t) {
  return new (t || _NzAffixComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(NzScrollService), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzResizeObserver), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzAffixComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzAffixComponent,
  selectors: [["nz-affix"]],
  viewQuery: function NzAffixComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c027, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.fixedEl = _t.first);
    }
  },
  inputs: {
    nzTarget: "nzTarget",
    nzOffsetTop: "nzOffsetTop",
    nzOffsetBottom: "nzOffsetBottom"
  },
  outputs: {
    nzChange: "nzChange"
  },
  exportAs: ["nzAffix"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c120,
  decls: 3,
  vars: 0,
  consts: [["fixedEl", ""]],
  template: function NzAffixComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", null, 0);
      \u0275\u0275projection(2);
      \u0275\u0275elementEnd();
    }
  },
  dependencies: [BidiModule, PlatformModule],
  encapsulation: 2,
  changeDetection: 0
});
var NzAffixComponent = _NzAffixComponent;
__decorate([WithConfig(), InputNumber(void 0)], NzAffixComponent.prototype, "nzOffsetTop", void 0);
__decorate([WithConfig(), InputNumber(void 0)], NzAffixComponent.prototype, "nzOffsetBottom", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAffixComponent, [{
    type: Component,
    args: [{
      selector: "nz-affix",
      exportAs: "nzAffix",
      standalone: true,
      imports: [BidiModule, PlatformModule],
      template: `
    <div #fixedEl>
      <ng-content></ng-content>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NzConfigService
  }, {
    type: NzScrollService
  }, {
    type: NgZone
  }, {
    type: Platform
  }, {
    type: Renderer2
  }, {
    type: NzResizeObserver
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    fixedEl: [{
      type: ViewChild,
      args: ["fixedEl", {
        static: true
      }]
    }],
    nzTarget: [{
      type: Input
    }],
    nzOffsetTop: [{
      type: Input
    }],
    nzOffsetBottom: [{
      type: Input
    }],
    nzChange: [{
      type: Output
    }]
  });
})();
var _NzAffixModule = class _NzAffixModule {
};
_NzAffixModule.\u0275fac = function NzAffixModule_Factory(t) {
  return new (t || _NzAffixModule)();
};
_NzAffixModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzAffixModule
});
_NzAffixModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzAffixComponent]
});
var NzAffixModule = _NzAffixModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAffixModule, [{
    type: NgModule,
    args: [{
      exports: [NzAffixComponent],
      imports: [NzAffixComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-skeleton.mjs
var _c028 = ["nzType", "button"];
var _c121 = ["nzType", "avatar"];
var _c216 = ["nzType", "input"];
var _c312 = ["nzType", "image"];
function NzSkeletonComponent_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275element(1, "nz-skeleton-element", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzSize", ctx_r2.avatar.size || "default")("nzShape", ctx_r2.avatar.shape || "circle");
  }
}
function NzSkeletonComponent_ng_container_0_h3_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "h3", 7);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("width", ctx_r3.toCSSUnit(ctx_r3.title.width));
  }
}
function NzSkeletonComponent_ng_container_0_ul_4_li_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "li");
  }
  if (rf & 2) {
    const i_r7 = ctx.index;
    const ctx_r5 = \u0275\u0275nextContext(3);
    \u0275\u0275styleProp("width", ctx_r5.toCSSUnit(ctx_r5.widthList[i_r7]));
  }
}
function NzSkeletonComponent_ng_container_0_ul_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 8);
    \u0275\u0275template(1, NzSkeletonComponent_ng_container_0_ul_4_li_1_Template, 1, 2, "li", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r4.rowsList);
  }
}
function NzSkeletonComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzSkeletonComponent_ng_container_0_div_1_Template, 2, 2, "div", 1);
    \u0275\u0275elementStart(2, "div", 2);
    \u0275\u0275template(3, NzSkeletonComponent_ng_container_0_h3_3_Template, 1, 2, "h3", 3)(4, NzSkeletonComponent_ng_container_0_ul_4_Template, 2, 1, "ul", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !!ctx_r0.nzAvatar);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !!ctx_r0.nzTitle);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !!ctx_r0.nzParagraph);
  }
}
function NzSkeletonComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275projection(1);
    \u0275\u0275elementContainerEnd();
  }
}
var _c410 = ["*"];
var _NzSkeletonElementDirective = class _NzSkeletonElementDirective {
  constructor() {
    this.nzActive = false;
    this.nzBlock = false;
  }
};
_NzSkeletonElementDirective.\u0275fac = function NzSkeletonElementDirective_Factory(t) {
  return new (t || _NzSkeletonElementDirective)();
};
_NzSkeletonElementDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzSkeletonElementDirective,
  selectors: [["nz-skeleton-element"]],
  hostAttrs: [1, "ant-skeleton", "ant-skeleton-element"],
  hostVars: 4,
  hostBindings: function NzSkeletonElementDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-skeleton-active", ctx.nzActive)("ant-skeleton-block", ctx.nzBlock);
    }
  },
  inputs: {
    nzActive: "nzActive",
    nzType: "nzType",
    nzBlock: "nzBlock"
  },
  standalone: true
});
var NzSkeletonElementDirective = _NzSkeletonElementDirective;
__decorate([InputBoolean()], NzSkeletonElementDirective.prototype, "nzBlock", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSkeletonElementDirective, [{
    type: Directive,
    args: [{
      selector: "nz-skeleton-element",
      host: {
        class: "ant-skeleton ant-skeleton-element",
        "[class.ant-skeleton-active]": "nzActive",
        "[class.ant-skeleton-block]": "nzBlock"
      },
      standalone: true
    }]
  }], () => [], {
    nzActive: [{
      type: Input
    }],
    nzType: [{
      type: Input
    }],
    nzBlock: [{
      type: Input
    }]
  });
})();
var _NzSkeletonElementButtonComponent = class _NzSkeletonElementButtonComponent {
  constructor() {
    this.nzShape = "default";
    this.nzSize = "default";
  }
};
_NzSkeletonElementButtonComponent.\u0275fac = function NzSkeletonElementButtonComponent_Factory(t) {
  return new (t || _NzSkeletonElementButtonComponent)();
};
_NzSkeletonElementButtonComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSkeletonElementButtonComponent,
  selectors: [["nz-skeleton-element", "nzType", "button"]],
  inputs: {
    nzShape: "nzShape",
    nzSize: "nzSize"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c028,
  decls: 1,
  vars: 8,
  consts: [[1, "ant-skeleton-button"]],
  template: function NzSkeletonElementButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "span", 0);
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-skeleton-button-round", ctx.nzShape === "round")("ant-skeleton-button-circle", ctx.nzShape === "circle")("ant-skeleton-button-lg", ctx.nzSize === "large")("ant-skeleton-button-sm", ctx.nzSize === "small");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzSkeletonElementButtonComponent = _NzSkeletonElementButtonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSkeletonElementButtonComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'nz-skeleton-element[nzType="button"]',
      template: `
    <span
      class="ant-skeleton-button"
      [class.ant-skeleton-button-round]="nzShape === 'round'"
      [class.ant-skeleton-button-circle]="nzShape === 'circle'"
      [class.ant-skeleton-button-lg]="nzSize === 'large'"
      [class.ant-skeleton-button-sm]="nzSize === 'small'"
    ></span>
  `,
      standalone: true
    }]
  }], null, {
    nzShape: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }]
  });
})();
var _NzSkeletonElementAvatarComponent = class _NzSkeletonElementAvatarComponent {
  constructor() {
    this.nzShape = "circle";
    this.nzSize = "default";
    this.styleMap = {};
  }
  ngOnChanges(changes) {
    if (changes.nzSize && typeof this.nzSize === "number") {
      const sideLength = `${this.nzSize}px`;
      this.styleMap = {
        width: sideLength,
        height: sideLength,
        "line-height": sideLength
      };
    } else {
      this.styleMap = {};
    }
  }
};
_NzSkeletonElementAvatarComponent.\u0275fac = function NzSkeletonElementAvatarComponent_Factory(t) {
  return new (t || _NzSkeletonElementAvatarComponent)();
};
_NzSkeletonElementAvatarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSkeletonElementAvatarComponent,
  selectors: [["nz-skeleton-element", "nzType", "avatar"]],
  inputs: {
    nzShape: "nzShape",
    nzSize: "nzSize"
  },
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  attrs: _c121,
  decls: 1,
  vars: 9,
  consts: [[1, "ant-skeleton-avatar", 3, "ngStyle"]],
  template: function NzSkeletonElementAvatarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "span", 0);
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-skeleton-avatar-square", ctx.nzShape === "square")("ant-skeleton-avatar-circle", ctx.nzShape === "circle")("ant-skeleton-avatar-lg", ctx.nzSize === "large")("ant-skeleton-avatar-sm", ctx.nzSize === "small");
      \u0275\u0275property("ngStyle", ctx.styleMap);
    }
  },
  dependencies: [NgStyle],
  encapsulation: 2,
  changeDetection: 0
});
var NzSkeletonElementAvatarComponent = _NzSkeletonElementAvatarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSkeletonElementAvatarComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'nz-skeleton-element[nzType="avatar"]',
      template: `
    <span
      class="ant-skeleton-avatar"
      [class.ant-skeleton-avatar-square]="nzShape === 'square'"
      [class.ant-skeleton-avatar-circle]="nzShape === 'circle'"
      [class.ant-skeleton-avatar-lg]="nzSize === 'large'"
      [class.ant-skeleton-avatar-sm]="nzSize === 'small'"
      [ngStyle]="styleMap"
    ></span>
  `,
      imports: [NgStyle],
      standalone: true
    }]
  }], null, {
    nzShape: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }]
  });
})();
var _NzSkeletonElementInputComponent = class _NzSkeletonElementInputComponent {
  constructor() {
    this.nzSize = "default";
  }
};
_NzSkeletonElementInputComponent.\u0275fac = function NzSkeletonElementInputComponent_Factory(t) {
  return new (t || _NzSkeletonElementInputComponent)();
};
_NzSkeletonElementInputComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSkeletonElementInputComponent,
  selectors: [["nz-skeleton-element", "nzType", "input"]],
  inputs: {
    nzSize: "nzSize"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c216,
  decls: 1,
  vars: 4,
  consts: [[1, "ant-skeleton-input"]],
  template: function NzSkeletonElementInputComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "span", 0);
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-skeleton-input-lg", ctx.nzSize === "large")("ant-skeleton-input-sm", ctx.nzSize === "small");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzSkeletonElementInputComponent = _NzSkeletonElementInputComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSkeletonElementInputComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'nz-skeleton-element[nzType="input"]',
      template: `
    <span
      class="ant-skeleton-input"
      [class.ant-skeleton-input-lg]="nzSize === 'large'"
      [class.ant-skeleton-input-sm]="nzSize === 'small'"
    ></span>
  `,
      standalone: true
    }]
  }], null, {
    nzSize: [{
      type: Input
    }]
  });
})();
var _NzSkeletonElementImageComponent = class _NzSkeletonElementImageComponent {
};
_NzSkeletonElementImageComponent.\u0275fac = function NzSkeletonElementImageComponent_Factory(t) {
  return new (t || _NzSkeletonElementImageComponent)();
};
_NzSkeletonElementImageComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSkeletonElementImageComponent,
  selectors: [["nz-skeleton-element", "nzType", "image"]],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  attrs: _c312,
  decls: 3,
  vars: 0,
  consts: [[1, "ant-skeleton-image"], ["viewBox", "0 0 1098 1024", "xmlns", "http://www.w3.org/2000/svg", 1, "ant-skeleton-image-svg"], ["d", "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z", 1, "ant-skeleton-image-path"]],
  template: function NzSkeletonElementImageComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "svg", 1);
      \u0275\u0275element(2, "path", 2);
      \u0275\u0275elementEnd()();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzSkeletonElementImageComponent = _NzSkeletonElementImageComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSkeletonElementImageComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'nz-skeleton-element[nzType="image"]',
      template: `
    <span class="ant-skeleton-image">
      <svg class="ant-skeleton-image-svg" viewBox="0 0 1098 1024" xmlns="http://www.w3.org/2000/svg">
        <path
          d="M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z"
          class="ant-skeleton-image-path"
        />
      </svg>
    </span>
  `,
      standalone: true
    }]
  }], null, null);
})();
var _NzSkeletonComponent = class _NzSkeletonComponent {
  constructor(cdr) {
    this.cdr = cdr;
    this.nzActive = false;
    this.nzLoading = true;
    this.nzRound = false;
    this.nzTitle = true;
    this.nzAvatar = false;
    this.nzParagraph = true;
    this.rowsList = [];
    this.widthList = [];
  }
  toCSSUnit(value = "") {
    return toCssPixel(value);
  }
  getTitleProps() {
    const hasAvatar = !!this.nzAvatar;
    const hasParagraph = !!this.nzParagraph;
    let width = "";
    if (!hasAvatar && hasParagraph) {
      width = "38%";
    } else if (hasAvatar && hasParagraph) {
      width = "50%";
    }
    return __spreadValues({
      width
    }, this.getProps(this.nzTitle));
  }
  getAvatarProps() {
    const shape = !!this.nzTitle && !this.nzParagraph ? "square" : "circle";
    const size = "large";
    return __spreadValues({
      shape,
      size
    }, this.getProps(this.nzAvatar));
  }
  getParagraphProps() {
    const hasAvatar = !!this.nzAvatar;
    const hasTitle = !!this.nzTitle;
    const basicProps = {};
    if (!hasAvatar || !hasTitle) {
      basicProps.width = "61%";
    }
    if (!hasAvatar && hasTitle) {
      basicProps.rows = 3;
    } else {
      basicProps.rows = 2;
    }
    return __spreadValues(__spreadValues({}, basicProps), this.getProps(this.nzParagraph));
  }
  getProps(prop) {
    return prop && typeof prop === "object" ? prop : {};
  }
  getWidthList() {
    const {
      width,
      rows
    } = this.paragraph;
    let widthList = [];
    if (width && Array.isArray(width)) {
      widthList = width;
    } else if (width && !Array.isArray(width)) {
      widthList = [];
      widthList[rows - 1] = width;
    }
    return widthList;
  }
  updateProps() {
    this.title = this.getTitleProps();
    this.avatar = this.getAvatarProps();
    this.paragraph = this.getParagraphProps();
    this.rowsList = [...Array(this.paragraph.rows)];
    this.widthList = this.getWidthList();
    this.cdr.markForCheck();
  }
  ngOnInit() {
    this.updateProps();
  }
  ngOnChanges(changes) {
    if (changes.nzTitle || changes.nzAvatar || changes.nzParagraph) {
      this.updateProps();
    }
  }
};
_NzSkeletonComponent.\u0275fac = function NzSkeletonComponent_Factory(t) {
  return new (t || _NzSkeletonComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_NzSkeletonComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSkeletonComponent,
  selectors: [["nz-skeleton"]],
  hostAttrs: [1, "ant-skeleton"],
  hostVars: 6,
  hostBindings: function NzSkeletonComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-skeleton-with-avatar", !!ctx.nzAvatar)("ant-skeleton-active", ctx.nzActive)("ant-skeleton-round", !!ctx.nzRound);
    }
  },
  inputs: {
    nzActive: "nzActive",
    nzLoading: "nzLoading",
    nzRound: "nzRound",
    nzTitle: "nzTitle",
    nzAvatar: "nzAvatar",
    nzParagraph: "nzParagraph"
  },
  exportAs: ["nzSkeleton"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c410,
  decls: 2,
  vars: 2,
  consts: [[4, "ngIf"], ["class", "ant-skeleton-header", 4, "ngIf"], [1, "ant-skeleton-content"], ["class", "ant-skeleton-title", 3, "width", 4, "ngIf"], ["class", "ant-skeleton-paragraph", 4, "ngIf"], [1, "ant-skeleton-header"], ["nzType", "avatar", 3, "nzSize", "nzShape"], [1, "ant-skeleton-title"], [1, "ant-skeleton-paragraph"], [3, "width", 4, "ngFor", "ngForOf"]],
  template: function NzSkeletonComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzSkeletonComponent_ng_container_0_Template, 5, 3, "ng-container", 0)(1, NzSkeletonComponent_ng_container_1_Template, 2, 0, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.nzLoading);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.nzLoading);
    }
  },
  dependencies: [NzSkeletonElementDirective, NzSkeletonElementAvatarComponent, NgIf, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzSkeletonComponent = _NzSkeletonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSkeletonComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-skeleton",
      exportAs: "nzSkeleton",
      host: {
        class: "ant-skeleton",
        "[class.ant-skeleton-with-avatar]": "!!nzAvatar",
        "[class.ant-skeleton-active]": "nzActive",
        "[class.ant-skeleton-round]": "!!nzRound"
      },
      template: `
    <ng-container *ngIf="nzLoading">
      <div class="ant-skeleton-header" *ngIf="!!nzAvatar">
        <nz-skeleton-element
          nzType="avatar"
          [nzSize]="avatar.size || 'default'"
          [nzShape]="avatar.shape || 'circle'"
        ></nz-skeleton-element>
      </div>
      <div class="ant-skeleton-content">
        <h3 *ngIf="!!nzTitle" class="ant-skeleton-title" [style.width]="toCSSUnit(title.width)"></h3>
        <ul *ngIf="!!nzParagraph" class="ant-skeleton-paragraph">
          <li *ngFor="let row of rowsList; let i = index" [style.width]="toCSSUnit(widthList[i])"></li>
        </ul>
      </div>
    </ng-container>
    <ng-container *ngIf="!nzLoading">
      <ng-content></ng-content>
    </ng-container>
  `,
      imports: [NzSkeletonElementDirective, NzSkeletonElementAvatarComponent, NgIf, NgForOf],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    nzActive: [{
      type: Input
    }],
    nzLoading: [{
      type: Input
    }],
    nzRound: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    nzAvatar: [{
      type: Input
    }],
    nzParagraph: [{
      type: Input
    }]
  });
})();
var _NzSkeletonModule = class _NzSkeletonModule {
};
_NzSkeletonModule.\u0275fac = function NzSkeletonModule_Factory(t) {
  return new (t || _NzSkeletonModule)();
};
_NzSkeletonModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzSkeletonModule
});
_NzSkeletonModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzSkeletonModule = _NzSkeletonModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSkeletonModule, [{
    type: NgModule,
    args: [{
      imports: [NzSkeletonElementDirective, NzSkeletonComponent, NzSkeletonElementButtonComponent, NzSkeletonElementAvatarComponent, NzSkeletonElementImageComponent, NzSkeletonElementInputComponent],
      exports: [NzSkeletonElementDirective, NzSkeletonComponent, NzSkeletonElementButtonComponent, NzSkeletonElementAvatarComponent, NzSkeletonElementImageComponent, NzSkeletonElementInputComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-breadcrumb.mjs
var _c029 = ["*"];
function NzBreadCrumbItemComponent_ng_container_0_ng_template_2_Template(rf, ctx) {
}
function NzBreadCrumbItemComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "span", 3);
    \u0275\u0275template(2, NzBreadCrumbItemComponent_ng_container_0_ng_template_2_Template, 0, 0, "ng-template", 4);
    \u0275\u0275element(3, "span", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const _r2 = \u0275\u0275reference(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzDropdownMenu", ctx_r0.nzOverlay);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r2);
  }
}
function NzBreadCrumbItemComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 6);
    \u0275\u0275projection(1);
    \u0275\u0275elementEnd();
  }
}
function NzBreadCrumbItemComponent_nz_breadcrumb_separator_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r5.nzBreadCrumbComponent.nzSeparator, " ");
  }
}
function NzBreadCrumbItemComponent_nz_breadcrumb_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-breadcrumb-separator");
    \u0275\u0275template(1, NzBreadCrumbItemComponent_nz_breadcrumb_separator_3_ng_container_1_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.nzBreadCrumbComponent.nzSeparator);
  }
}
function NzBreadCrumbComponent_ng_container_1_nz_breadcrumb_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-breadcrumb-item")(1, "a", 2);
    \u0275\u0275listener("click", function NzBreadCrumbComponent_ng_container_1_nz_breadcrumb_item_1_Template_a_click_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r4);
      const breadcrumb_r2 = restoredCtx.$implicit;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.navigate(breadcrumb_r2.url, $event));
    });
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const breadcrumb_r2 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275attribute("href", breadcrumb_r2.url, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(breadcrumb_r2.label);
  }
}
function NzBreadCrumbComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzBreadCrumbComponent_ng_container_1_nz_breadcrumb_item_1_Template, 3, 2, "nz-breadcrumb-item", 1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r0.breadcrumbs);
  }
}
var _NzBreadCrumbSeparatorComponent = class _NzBreadCrumbSeparatorComponent {
};
_NzBreadCrumbSeparatorComponent.\u0275fac = function NzBreadCrumbSeparatorComponent_Factory(t) {
  return new (t || _NzBreadCrumbSeparatorComponent)();
};
_NzBreadCrumbSeparatorComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzBreadCrumbSeparatorComponent,
  selectors: [["nz-breadcrumb-separator"]],
  hostAttrs: [1, "ant-breadcrumb-separator"],
  exportAs: ["nzBreadcrumbSeparator"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c029,
  decls: 1,
  vars: 0,
  template: function NzBreadCrumbSeparatorComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var NzBreadCrumbSeparatorComponent = _NzBreadCrumbSeparatorComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzBreadCrumbSeparatorComponent, [{
    type: Component,
    args: [{
      selector: "nz-breadcrumb-separator",
      exportAs: "nzBreadcrumbSeparator",
      standalone: true,
      template: `<ng-content></ng-content>`,
      host: {
        class: "ant-breadcrumb-separator"
      }
    }]
  }], null, null);
})();
var NzBreadcrumb = class {
};
var _NzBreadCrumbItemComponent = class _NzBreadCrumbItemComponent {
  constructor(nzBreadCrumbComponent) {
    this.nzBreadCrumbComponent = nzBreadCrumbComponent;
  }
};
_NzBreadCrumbItemComponent.\u0275fac = function NzBreadCrumbItemComponent_Factory(t) {
  return new (t || _NzBreadCrumbItemComponent)(\u0275\u0275directiveInject(NzBreadcrumb));
};
_NzBreadCrumbItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzBreadCrumbItemComponent,
  selectors: [["nz-breadcrumb-item"]],
  inputs: {
    nzOverlay: "nzOverlay"
  },
  exportAs: ["nzBreadcrumbItem"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c029,
  decls: 4,
  vars: 3,
  consts: [[4, "ngIf", "ngIfElse"], ["noMenuTpl", ""], [4, "ngIf"], ["nz-dropdown", "", 1, "ant-breadcrumb-overlay-link", 3, "nzDropdownMenu"], [3, "ngTemplateOutlet"], ["nz-icon", "", "nzType", "down"], [1, "ant-breadcrumb-link"], [4, "nzStringTemplateOutlet"]],
  template: function NzBreadCrumbItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzBreadCrumbItemComponent_ng_container_0_Template, 4, 2, "ng-container", 0)(1, NzBreadCrumbItemComponent_ng_template_1_Template, 2, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, NzBreadCrumbItemComponent_nz_breadcrumb_separator_3_Template, 2, 1, "nz-breadcrumb-separator", 2);
    }
    if (rf & 2) {
      const _r2 = \u0275\u0275reference(2);
      \u0275\u0275property("ngIf", !!ctx.nzOverlay)("ngIfElse", _r2);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.nzBreadCrumbComponent.nzSeparator);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NzBreadCrumbSeparatorComponent, NzDropDownModule, NzDropDownDirective, NzIconModule, NzIconDirective, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzBreadCrumbItemComponent = _NzBreadCrumbItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzBreadCrumbItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-breadcrumb-item",
      exportAs: "nzBreadcrumbItem",
      preserveWhitespaces: false,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, NzBreadCrumbSeparatorComponent, NzDropDownModule, NzIconModule, NzOutletModule],
      template: `
    <ng-container *ngIf="!!nzOverlay; else noMenuTpl">
      <span class="ant-breadcrumb-overlay-link" nz-dropdown [nzDropdownMenu]="nzOverlay">
        <ng-template [ngTemplateOutlet]="noMenuTpl"></ng-template>
        <span nz-icon nzType="down"></span>
      </span>
    </ng-container>

    <ng-template #noMenuTpl>
      <span class="ant-breadcrumb-link">
        <ng-content></ng-content>
      </span>
    </ng-template>

    <nz-breadcrumb-separator *ngIf="nzBreadCrumbComponent.nzSeparator">
      <ng-container *nzStringTemplateOutlet="nzBreadCrumbComponent.nzSeparator">
        {{ nzBreadCrumbComponent.nzSeparator }}
      </ng-container>
    </nz-breadcrumb-separator>
  `
    }]
  }], () => [{
    type: NzBreadcrumb
  }], {
    nzOverlay: [{
      type: Input
    }]
  });
})();
var _NzBreadCrumbComponent = class _NzBreadCrumbComponent {
  constructor(injector, cdr, elementRef, renderer, directionality) {
    this.injector = injector;
    this.cdr = cdr;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.directionality = directionality;
    this.nzAutoGenerate = false;
    this.nzSeparator = "/";
    this.nzRouteLabel = "breadcrumb";
    this.nzRouteLabelFn = (label) => label;
    this.breadcrumbs = [];
    this.dir = "ltr";
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    if (this.nzAutoGenerate) {
      this.registerRouterChange();
    }
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.prepareComponentForRtl();
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.prepareComponentForRtl();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  navigate(url, e) {
    e.preventDefault();
    this.injector.get(Router).navigateByUrl(url);
  }
  registerRouterChange() {
    try {
      const router = this.injector.get(Router);
      const activatedRoute = this.injector.get(ActivatedRoute);
      router.events.pipe(
        filter((e) => e instanceof NavigationEnd),
        takeUntil(this.destroy$),
        startWith(true)
        // trigger initial render
      ).subscribe(() => {
        this.breadcrumbs = this.getBreadcrumbs(activatedRoute.root);
        this.cdr.markForCheck();
      });
    } catch (e) {
      throw new Error(`${PREFIX} You should import RouterModule if you want to use 'NzAutoGenerate'.`);
    }
  }
  getBreadcrumbs(route, url = "", breadcrumbs = []) {
    const children = route.children;
    if (children.length === 0) {
      return breadcrumbs;
    }
    for (const child of children) {
      if (child.outlet === PRIMARY_OUTLET) {
        const routeUrl = child.snapshot.url.map((segment) => segment.path).filter((path) => path).join("/");
        const nextUrl = routeUrl ? `${url}/${routeUrl}` : url;
        const breadcrumbLabel = this.nzRouteLabelFn(child.snapshot.data[this.nzRouteLabel]);
        if (routeUrl && breadcrumbLabel) {
          const breadcrumb = {
            label: breadcrumbLabel,
            params: child.snapshot.params,
            url: nextUrl
          };
          breadcrumbs.push(breadcrumb);
        }
        return this.getBreadcrumbs(child, nextUrl, breadcrumbs);
      }
    }
    return breadcrumbs;
  }
  prepareComponentForRtl() {
    if (this.dir === "rtl") {
      this.renderer.addClass(this.elementRef.nativeElement, "ant-breadcrumb-rtl");
    } else {
      this.renderer.removeClass(this.elementRef.nativeElement, "ant-breadcrumb-rtl");
    }
  }
};
_NzBreadCrumbComponent.\u0275fac = function NzBreadCrumbComponent_Factory(t) {
  return new (t || _NzBreadCrumbComponent)(\u0275\u0275directiveInject(Injector), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(Directionality, 8));
};
_NzBreadCrumbComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzBreadCrumbComponent,
  selectors: [["nz-breadcrumb"]],
  hostAttrs: [1, "ant-breadcrumb"],
  inputs: {
    nzAutoGenerate: "nzAutoGenerate",
    nzSeparator: "nzSeparator",
    nzRouteLabel: "nzRouteLabel",
    nzRouteLabelFn: "nzRouteLabelFn"
  },
  exportAs: ["nzBreadcrumb"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NzBreadcrumb,
    useExisting: _NzBreadCrumbComponent
  }]), \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c029,
  decls: 2,
  vars: 1,
  consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], [3, "click"]],
  template: function NzBreadCrumbComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
      \u0275\u0275template(1, NzBreadCrumbComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzAutoGenerate && ctx.breadcrumbs.length);
    }
  },
  dependencies: [NgForOf, NgIf, NzBreadCrumbItemComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NzBreadCrumbComponent = _NzBreadCrumbComponent;
__decorate([InputBoolean()], NzBreadCrumbComponent.prototype, "nzAutoGenerate", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzBreadCrumbComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-breadcrumb",
      exportAs: "nzBreadcrumb",
      preserveWhitespaces: false,
      providers: [{
        provide: NzBreadcrumb,
        useExisting: NzBreadCrumbComponent
      }],
      standalone: true,
      imports: [NgForOf, NgIf, NzBreadCrumbItemComponent],
      template: `
    <ng-content></ng-content>
    <ng-container *ngIf="nzAutoGenerate && breadcrumbs.length">
      <nz-breadcrumb-item *ngFor="let breadcrumb of breadcrumbs">
        <a [attr.href]="breadcrumb.url" (click)="navigate(breadcrumb.url, $event)">{{ breadcrumb.label }}</a>
      </nz-breadcrumb-item>
    </ng-container>
  `,
      host: {
        class: "ant-breadcrumb"
      }
    }]
  }], () => [{
    type: Injector
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzAutoGenerate: [{
      type: Input
    }],
    nzSeparator: [{
      type: Input
    }],
    nzRouteLabel: [{
      type: Input
    }],
    nzRouteLabelFn: [{
      type: Input
    }]
  });
})();
var _NzBreadCrumbModule = class _NzBreadCrumbModule {
};
_NzBreadCrumbModule.\u0275fac = function NzBreadCrumbModule_Factory(t) {
  return new (t || _NzBreadCrumbModule)();
};
_NzBreadCrumbModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzBreadCrumbModule
});
_NzBreadCrumbModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzBreadCrumbComponent, NzBreadCrumbItemComponent]
});
var NzBreadCrumbModule = _NzBreadCrumbModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzBreadCrumbModule, [{
    type: NgModule,
    args: [{
      imports: [NzBreadCrumbComponent, NzBreadCrumbItemComponent, NzBreadCrumbSeparatorComponent],
      exports: [NzBreadCrumbComponent, NzBreadCrumbItemComponent, NzBreadCrumbSeparatorComponent]
    }]
  }], null, null);
})();

// node_modules/@delon/abc/fesm2022/page-header.mjs
var _c030 = ["conTpl"];
var _c123 = ["affix"];
function PageHeaderComponent_Conditional_0_ng_template_2_Template(rf, ctx) {
}
function PageHeaderComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-affix", 0, 2);
    \u0275\u0275template(2, PageHeaderComponent_Conditional_0_ng_template_2_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275property("nzOffsetTop", ctx_r0.fixedOffsetTop);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", _r3);
  }
}
function PageHeaderComponent_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function PageHeaderComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PageHeaderComponent_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275property("ngTemplateOutlet", _r3);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function PageHeaderComponent_ng_template_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PageHeaderComponent_ng_template_2_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r7.breadcrumb);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_4_Conditional_0_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r19 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("routerLink", i_r19.link);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(i_r19.title);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_4_Conditional_0_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const i_r19 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", i_r19.title, " ");
  }
}
function PageHeaderComponent_ng_template_2_Conditional_4_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-breadcrumb-item");
    \u0275\u0275template(1, PageHeaderComponent_ng_template_2_Conditional_4_Conditional_0_For_2_Conditional_1_Template, 2, 2, "a", 16)(2, PageHeaderComponent_ng_template_2_Conditional_4_Conditional_0_For_2_Conditional_2_Template, 1, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r19 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, i_r19.link ? 1 : 2);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-breadcrumb");
    \u0275\u0275repeaterCreate(1, PageHeaderComponent_ng_template_2_Conditional_4_Conditional_0_For_2_Template, 3, 1, "nz-breadcrumb-item", null, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r17 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r17.paths);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PageHeaderComponent_ng_template_2_Conditional_4_Conditional_0_Template, 3, 0, "nz-breadcrumb");
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(0, ctx_r8.paths && ctx_r8.paths.length > 0 ? 0 : -1);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_6_ng_template_1_Template(rf, ctx) {
}
function PageHeaderComponent_ng_template_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275template(1, PageHeaderComponent_ng_template_2_Conditional_6_ng_template_1_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r9.logo);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_9_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function PageHeaderComponent_ng_template_2_Conditional_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PageHeaderComponent_ng_template_2_Conditional_9_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r29 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r29._titleTpl);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_9_Conditional_2_Conditional_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r33 = \u0275\u0275nextContext(5);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r33.titleSub);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_9_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "small");
    \u0275\u0275template(1, PageHeaderComponent_ng_template_2_Conditional_9_Conditional_2_Conditional_1_ng_container_1_Template, 2, 1, "ng-container", 19);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r32 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r32.titleSub);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_9_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275template(1, PageHeaderComponent_ng_template_2_Conditional_9_Conditional_2_Conditional_1_Template, 2, 1, "small");
  }
  if (rf & 2) {
    const ctx_r30 = \u0275\u0275nextContext(3);
    \u0275\u0275textInterpolate1(" ", ctx_r30._titleVal, " ");
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r30.titleSub ? 1 : -1);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "h1", 18);
    \u0275\u0275template(1, PageHeaderComponent_ng_template_2_Conditional_9_Conditional_1_Template, 1, 1, null, 3)(2, PageHeaderComponent_ng_template_2_Conditional_9_Conditional_2_Template, 2, 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r10._titleTpl ? 1 : 2);
  }
}
function PageHeaderComponent_ng_template_2_Conditional_10_ng_template_1_Template(rf, ctx) {
}
function PageHeaderComponent_ng_template_2_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20);
    \u0275\u0275template(1, PageHeaderComponent_ng_template_2_Conditional_10_ng_template_1_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r11 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r11.action);
  }
}
function PageHeaderComponent_ng_template_2_ng_template_15_Template(rf, ctx) {
}
function PageHeaderComponent_ng_template_2_Conditional_16_ng_template_1_Template(rf, ctx) {
}
function PageHeaderComponent_ng_template_2_Conditional_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275template(1, PageHeaderComponent_ng_template_2_Conditional_16_ng_template_1_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r14 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r14.extra);
  }
}
function PageHeaderComponent_ng_template_2_ng_template_17_Template(rf, ctx) {
}
var _c217 = (a0) => ({
  "page-header__wide": a0
});
var _c313 = () => ({
  rows: 3
});
var _c411 = () => ({
  size: "large",
  shape: "circle"
});
function PageHeaderComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5)(2, "nz-skeleton", 6);
    \u0275\u0275template(3, PageHeaderComponent_ng_template_2_Conditional_3_Template, 1, 1, null, 3)(4, PageHeaderComponent_ng_template_2_Conditional_4_Template, 1, 1);
    \u0275\u0275elementStart(5, "div", 7);
    \u0275\u0275template(6, PageHeaderComponent_ng_template_2_Conditional_6_Template, 2, 1, "div", 8);
    \u0275\u0275elementStart(7, "div", 9)(8, "div", 10);
    \u0275\u0275template(9, PageHeaderComponent_ng_template_2_Conditional_9_Template, 3, 1, "h1", 11)(10, PageHeaderComponent_ng_template_2_Conditional_10_Template, 2, 1, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "div", 10)(12, "div", 13, 14);
    \u0275\u0275listener("cdkObserveContent", function PageHeaderComponent_ng_template_2_Template_div_cdkObserveContent_12_listener() {
      \u0275\u0275restoreView(_r37);
      const ctx_r36 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r36.checkContent());
    });
    \u0275\u0275projection(14);
    \u0275\u0275template(15, PageHeaderComponent_ng_template_2_ng_template_15_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275template(16, PageHeaderComponent_ng_template_2_Conditional_16_Template, 2, 1, "div", 15);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(17, PageHeaderComponent_ng_template_2_ng_template_17_Template, 0, 0, "ng-template", 3);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classProp("page-header-rtl", ctx_r2.dir === "rtl");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(15, _c217, ctx_r2.wide));
    \u0275\u0275advance(1);
    \u0275\u0275property("nzLoading", ctx_r2.loading)("nzTitle", false)("nzActive", true)("nzParagraph", \u0275\u0275pureFunction0(17, _c313))("nzAvatar", \u0275\u0275pureFunction0(18, _c411));
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, ctx_r2.breadcrumb ? 3 : 4);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(6, ctx_r2.logo ? 6 : -1);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(9, ctx_r2._titleVal || ctx_r2._titleTpl ? 9 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(10, ctx_r2.action ? 10 : -1);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.content);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(16, ctx_r2.extra ? 16 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.tab);
  }
}
var _c57 = ["*"];
var _PageHeaderComponent = class _PageHeaderComponent {
  get menus() {
    return this.menuSrv.getPathByUrl(this.router.url, this.recursiveBreadcrumb);
  }
  set title(value) {
    if (value instanceof TemplateRef) {
      this._title = null;
      this._titleTpl = value;
      this._titleVal = "";
    } else {
      this._title = value;
      this._titleVal = this._title;
    }
  }
  // #endregion
  constructor(settings, renderer, router, menuSrv, i18nSrv, titleSrv, reuseSrv, cdr, configSrv, platform, directionality) {
    this.renderer = renderer;
    this.router = router;
    this.menuSrv = menuSrv;
    this.i18nSrv = i18nSrv;
    this.titleSrv = titleSrv;
    this.reuseSrv = reuseSrv;
    this.cdr = cdr;
    this.directionality = directionality;
    this.dir$ = this.directionality.change?.pipe(takeUntilDestroyed());
    this.inited = false;
    this.isBrowser = true;
    this.dir = "ltr";
    this._titleVal = "";
    this.paths = [];
    this._title = null;
    this._titleTpl = null;
    this.loading = false;
    this.wide = false;
    this.breadcrumb = null;
    this.logo = null;
    this.action = null;
    this.content = null;
    this.extra = null;
    this.tab = null;
    this.isBrowser = platform.isBrowser;
    configSrv.attach(this, "pageHeader", {
      home: "\u9996\u9875",
      homeLink: "/",
      autoBreadcrumb: true,
      recursiveBreadcrumb: false,
      autoTitle: true,
      syncTitle: true,
      fixed: false,
      fixedOffsetTop: 64
    });
    settings.notify.pipe(takeUntilDestroyed(), filter((w) => this.affix && w.type === "layout" && w.name === "collapsed")).subscribe(() => this.affix.updatePosition({}));
    merge(menuSrv.change, router.events.pipe(filter((ev) => ev instanceof NavigationEnd)), i18nSrv.change).pipe(takeUntilDestroyed(), filter(() => this.inited)).subscribe(() => this.refresh());
  }
  refresh() {
    this.setTitle().genBreadcrumb();
    this.cdr.detectChanges();
  }
  genBreadcrumb() {
    if (this.breadcrumb || !this.autoBreadcrumb || this.menus.length <= 0) {
      this.paths = [];
      return;
    }
    const paths = [];
    this.menus.forEach((item) => {
      if (typeof item.hideInBreadcrumb !== "undefined" && item.hideInBreadcrumb)
        return;
      let title = item.text;
      if (item.i18n && this.i18nSrv)
        title = this.i18nSrv.fanyi(item.i18n);
      paths.push({
        title,
        link: item.link && [item.link]
      });
    });
    if (this.home) {
      paths.splice(0, 0, {
        title: this.homeI18n && this.i18nSrv && this.i18nSrv.fanyi(this.homeI18n) || this.home,
        link: [this.homeLink]
      });
    }
    this.paths = paths;
  }
  setTitle() {
    if (this._title == null && this._titleTpl == null && this.autoTitle && this.menus.length > 0) {
      const item = this.menus[this.menus.length - 1];
      let title = item.text;
      if (item.i18n && this.i18nSrv) {
        title = this.i18nSrv.fanyi(item.i18n);
      }
      this._titleVal = title;
    }
    if (this._titleVal && this.syncTitle) {
      if (this.titleSrv) {
        this.titleSrv.setTitle(this._titleVal);
      }
      if (!this.inited && this.reuseSrv) {
        this.reuseSrv.title = this._titleVal;
      }
    }
    return this;
  }
  checkContent() {
    if (isEmpty(this.conTpl.nativeElement)) {
      this.renderer.setAttribute(this.conTpl.nativeElement, "hidden", "");
    } else {
      this.renderer.removeAttribute(this.conTpl.nativeElement, "hidden");
    }
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.dir$.subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.refresh();
    this.inited = true;
  }
  ngAfterViewInit() {
    this.checkContent();
  }
  ngOnChanges() {
    if (this.inited) {
      this.refresh();
    }
  }
};
_PageHeaderComponent.\u0275fac = function PageHeaderComponent_Factory(t) {
  return new (t || _PageHeaderComponent)(\u0275\u0275directiveInject(SettingsService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(MenuService), \u0275\u0275directiveInject(ALAIN_I18N_TOKEN, 8), \u0275\u0275directiveInject(TitleService, 8), \u0275\u0275directiveInject(ReuseTabService, 8), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(AlainConfigService), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(Directionality, 8));
};
_PageHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PageHeaderComponent,
  selectors: [["page-header"]],
  viewQuery: function PageHeaderComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c030, 5);
      \u0275\u0275viewQuery(_c123, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.conTpl = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.affix = _t.first);
    }
  },
  inputs: {
    title: "title",
    titleSub: "titleSub",
    loading: "loading",
    wide: "wide",
    home: "home",
    homeLink: "homeLink",
    homeI18n: "homeI18n",
    autoBreadcrumb: "autoBreadcrumb",
    autoTitle: "autoTitle",
    syncTitle: "syncTitle",
    fixed: "fixed",
    fixedOffsetTop: "fixedOffsetTop",
    breadcrumb: "breadcrumb",
    recursiveBreadcrumb: "recursiveBreadcrumb",
    logo: "logo",
    action: "action",
    content: "content",
    extra: "extra",
    tab: "tab"
  },
  exportAs: ["pageHeader"],
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c57,
  decls: 4,
  vars: 1,
  consts: [[3, "nzOffsetTop"], ["phTpl", ""], ["affix", ""], [3, "ngTemplateOutlet"], [1, "page-header"], [3, "ngClass"], [1, "d-block", 3, "nzLoading", "nzTitle", "nzActive", "nzParagraph", "nzAvatar"], [1, "page-header__detail"], ["class", "page-header__logo"], [1, "page-header__main"], [1, "page-header__row"], ["class", "page-header__title"], ["class", "page-header__action"], [1, "page-header__desc", 3, "cdkObserveContent"], ["conTpl", ""], ["class", "page-header__extra"], [3, "routerLink"], [1, "page-header__logo"], [1, "page-header__title"], [4, "nzStringTemplateOutlet"], [1, "page-header__action"], [1, "page-header__extra"]],
  template: function PageHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, PageHeaderComponent_Conditional_0_Template, 3, 2, "nz-affix", 0)(1, PageHeaderComponent_Conditional_1_Template, 1, 1)(2, PageHeaderComponent_ng_template_2_Template, 18, 19, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, ctx.isBrowser && ctx.fixed ? 0 : 1);
    }
  },
  dependencies: [NgClass, NgTemplateOutlet, RouterLink, CdkObserveContent, NzAffixComponent, NzSkeletonComponent, NzBreadCrumbComponent, NzBreadCrumbItemComponent, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var PageHeaderComponent = _PageHeaderComponent;
__decorate([InputBoolean2()], PageHeaderComponent.prototype, "loading", void 0);
__decorate([InputBoolean2()], PageHeaderComponent.prototype, "wide", void 0);
__decorate([InputBoolean2()], PageHeaderComponent.prototype, "autoBreadcrumb", void 0);
__decorate([InputBoolean2()], PageHeaderComponent.prototype, "autoTitle", void 0);
__decorate([InputBoolean2()], PageHeaderComponent.prototype, "syncTitle", void 0);
__decorate([InputBoolean2()], PageHeaderComponent.prototype, "fixed", void 0);
__decorate([InputNumber2()], PageHeaderComponent.prototype, "fixedOffsetTop", void 0);
__decorate([InputBoolean2()], PageHeaderComponent.prototype, "recursiveBreadcrumb", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageHeaderComponent, [{
    type: Component,
    args: [{
      selector: "page-header",
      exportAs: "pageHeader",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `@if (isBrowser && fixed) {
  <nz-affix #affix [nzOffsetTop]="fixedOffsetTop">
    <ng-template [ngTemplateOutlet]="phTpl" />
  </nz-affix>
} @else {
  <ng-template [ngTemplateOutlet]="phTpl" />
}
<ng-template #phTpl>
  <div class="page-header" [class.page-header-rtl]="dir === 'rtl'">
    <div [ngClass]="{ 'page-header__wide': wide }">
      <nz-skeleton
        [nzLoading]="loading"
        [nzTitle]="false"
        [nzActive]="true"
        [nzParagraph]="{ rows: 3 }"
        [nzAvatar]="{ size: 'large', shape: 'circle' }"
        class="d-block"
      >
        @if (breadcrumb) {
          <ng-template [ngTemplateOutlet]="breadcrumb" />
        } @else {
          @if (paths && paths.length > 0) {
            <nz-breadcrumb>
              @for (i of paths; track $index) {
                <nz-breadcrumb-item>
                  @if (i.link) {
                    <a [routerLink]="i.link">{{ i.title }}</a>
                  } @else {
                    {{ i.title }}
                  }
                </nz-breadcrumb-item>
              }
            </nz-breadcrumb>
          }
        }
        <div class="page-header__detail">
          @if (logo) {
            <div class="page-header__logo">
              <ng-template [ngTemplateOutlet]="logo" />
            </div>
          }
          <div class="page-header__main">
            <div class="page-header__row">
              @if (_titleVal || _titleTpl) {
                <h1 class="page-header__title">
                  @if (_titleTpl) {
                    <ng-template [ngTemplateOutlet]="_titleTpl" />
                  } @else {
                    {{ _titleVal }}
                    @if (titleSub) {
                      <small>
                        <ng-container *nzStringTemplateOutlet="titleSub">{{ titleSub }}</ng-container>
                      </small>
                    }
                  }
                </h1>
              }
              @if (action) {
                <div class="page-header__action">
                  <ng-template [ngTemplateOutlet]="action" />
                </div>
              }
            </div>
            <div class="page-header__row">
              <div class="page-header__desc" (cdkObserveContent)="checkContent()" #conTpl>
                <ng-content />
                <ng-template [ngTemplateOutlet]="content!" />
              </div>
              @if (extra) {
                <div class="page-header__extra">
                  <ng-template [ngTemplateOutlet]="extra" />
                </div>
              }
            </div>
          </div>
        </div>
        <ng-template [ngTemplateOutlet]="tab!" />
      </nz-skeleton>
    </div>
  </div>
</ng-template>
`
    }]
  }], () => [{
    type: SettingsService
  }, {
    type: Renderer2
  }, {
    type: Router
  }, {
    type: MenuService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ALAIN_I18N_TOKEN]
    }]
  }, {
    type: TitleService,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [TitleService]
    }]
  }, {
    type: ReuseTabService,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ReuseTabService]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: AlainConfigService
  }, {
    type: Platform
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    conTpl: [{
      type: ViewChild,
      args: ["conTpl", {
        static: false
      }]
    }],
    affix: [{
      type: ViewChild,
      args: ["affix", {
        static: false
      }]
    }],
    title: [{
      type: Input
    }],
    titleSub: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    wide: [{
      type: Input
    }],
    home: [{
      type: Input
    }],
    homeLink: [{
      type: Input
    }],
    homeI18n: [{
      type: Input
    }],
    autoBreadcrumb: [{
      type: Input
    }],
    autoTitle: [{
      type: Input
    }],
    syncTitle: [{
      type: Input
    }],
    fixed: [{
      type: Input
    }],
    fixedOffsetTop: [{
      type: Input
    }],
    breadcrumb: [{
      type: Input
    }],
    recursiveBreadcrumb: [{
      type: Input
    }],
    logo: [{
      type: Input
    }],
    action: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    tab: [{
      type: Input
    }]
  });
})();
var COMPONENTS5 = [PageHeaderComponent];
var _PageHeaderModule = class _PageHeaderModule {
};
_PageHeaderModule.\u0275fac = function PageHeaderModule_Factory(t) {
  return new (t || _PageHeaderModule)();
};
_PageHeaderModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PageHeaderModule
});
_PageHeaderModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule, ObserversModule, NzAffixModule, NzSkeletonModule, NzBreadCrumbModule, NzOutletModule]
});
var PageHeaderModule = _PageHeaderModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageHeaderModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, ObserversModule, NzAffixModule, NzSkeletonModule, NzBreadCrumbModule, NzOutletModule],
      declarations: COMPONENTS5,
      exports: COMPONENTS5
    }]
  }], null, null);
})();

// node_modules/@delon/abc/fesm2022/result.mjs
function ResultComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r0.title);
  }
}
function ResultComponent_Conditional_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r3.description);
  }
}
function ResultComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275template(1, ResultComponent_Conditional_4_ng_container_1_Template, 2, 1, "ng-container", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r1.description);
  }
}
function ResultComponent_Conditional_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r4.extra);
  }
}
function ResultComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275template(1, ResultComponent_Conditional_5_ng_container_1_Template, 2, 1, "ng-container", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2.extra);
  }
}
var _c031 = ["*"];
var _ResultComponent = class _ResultComponent {
  set type(value) {
    this._type = value;
    switch (value) {
      case "success":
        this._icon = "check-circle";
        break;
      case "error":
        this._icon = "close-circle";
        break;
      default:
        this._icon = value;
        break;
    }
  }
  constructor(directionality, cdr) {
    this.directionality = directionality;
    this.cdr = cdr;
    this.dir$ = this.directionality.change?.pipe(takeUntilDestroyed());
    this._type = "";
    this._icon = "";
    this.dir = "ltr";
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.dir$.subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
  }
};
_ResultComponent.\u0275fac = function ResultComponent_Factory(t) {
  return new (t || _ResultComponent)(\u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_ResultComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ResultComponent,
  selectors: [["result"]],
  hostVars: 4,
  hostBindings: function ResultComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("result", true)("result-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    type: "type",
    title: "title",
    description: "description",
    extra: "extra"
  },
  exportAs: ["result"],
  ngContentSelectors: _c031,
  decls: 8,
  vars: 7,
  consts: [[1, "result__icon"], ["nz-icon", "", 3, "nzType"], [1, "result__title"], [4, "nzStringTemplateOutlet"], ["class", "result__desc"], ["class", "result__extra"], [1, "result__actions"], [1, "result__desc"], [1, "result__extra"]],
  template: function ResultComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275element(1, "i", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "div", 2);
      \u0275\u0275template(3, ResultComponent_ng_container_3_Template, 2, 1, "ng-container", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, ResultComponent_Conditional_4_Template, 2, 1, "div", 4)(5, ResultComponent_Conditional_5_Template, 2, 1, "div", 5);
      \u0275\u0275elementStart(6, "div", 6);
      \u0275\u0275projection(7);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275classMapInterpolate1("result__icon-", ctx._type, "");
      \u0275\u0275property("nzType", ctx._icon);
      \u0275\u0275advance(2);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.title);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(4, ctx.description ? 4 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(5, ctx.extra ? 5 : -1);
    }
  },
  dependencies: [NzIconDirective, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var ResultComponent = _ResultComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResultComponent, [{
    type: Component,
    args: [{
      selector: "result",
      exportAs: "result",
      host: {
        "[class.result]": "true",
        "[class.result-rtl]": `dir === 'rtl'`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: '<div class="result__icon">\n  <i nz-icon [nzType]="_icon" class="result__icon-{{ _type }}"></i>\n</div>\n<div class="result__title">\n  <ng-container *nzStringTemplateOutlet="title">{{ title }}</ng-container>\n</div>\n@if (description) {\n  <div class="result__desc">\n    <ng-container *nzStringTemplateOutlet="description">{{ description }}</ng-container>\n  </div>\n}\n@if (extra) {\n  <div class="result__extra">\n    <ng-container *nzStringTemplateOutlet="extra">{{ extra }}</ng-container>\n  </div>\n}\n<div class="result__actions">\n  <ng-content />\n</div>\n'
    }]
  }], () => [{
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    type: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    extra: [{
      type: Input
    }]
  });
})();
var COMPONENTS6 = [ResultComponent];
var _ResultModule = class _ResultModule {
};
_ResultModule.\u0275fac = function ResultModule_Factory(t) {
  return new (t || _ResultModule)();
};
_ResultModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ResultModule
});
_ResultModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzIconModule, NzOutletModule]
});
var ResultModule = _ResultModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResultModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzIconModule, NzOutletModule],
      declarations: COMPONENTS6,
      exports: COMPONENTS6
    }]
  }], null, null);
})();

// node_modules/@delon/abc/fesm2022/se.mjs
function SEContainerComponent_Conditional_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r1.title);
  }
}
function SEContainerComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275template(1, SEContainerComponent_Conditional_0_ng_container_1_Template, 2, 1, "ng-container", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.title);
  }
}
var _c032 = ["*"];
var _c124 = ["contentElement"];
function SEComponent_Conditional_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r4.label);
  }
}
function SEComponent_Conditional_1_Conditional_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r6.optional);
  }
}
function SEComponent_Conditional_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 12);
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(3);
    \u0275\u0275property("nzTooltipTitle", ctx_r7.optionalHelp)("nzTooltipColor", ctx_r7.optionalHelpColor);
  }
}
function SEComponent_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 11);
    \u0275\u0275template(1, SEComponent_Conditional_1_Conditional_3_ng_container_1_Template, 2, 1, "ng-container", 9)(2, SEComponent_Conditional_1_Conditional_3_Conditional_2_Template, 1, 2, "i", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("se__label-optional-no-text", !ctx_r5.optional);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r5.optional);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, ctx_r5.optionalHelp ? 2 : -1);
  }
}
var _c218 = (a0, a1) => ({
  "ant-form-item-required": a0,
  "se__no-colon": a1
});
function SEComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 7)(1, "span", 8);
    \u0275\u0275template(2, SEComponent_Conditional_1_ng_container_2_Template, 2, 1, "ng-container", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, SEComponent_Conditional_1_Conditional_3_Template, 3, 4, "span", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(4, _c218, ctx_r0.required, ctx_r0._noColon));
    \u0275\u0275attribute("for", ctx_r0._id);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.label);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, ctx_r0.optional || ctx_r0.optionalHelp ? 3 : -1);
  }
}
function SEComponent_Conditional_7_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r8._error);
  }
}
function SEComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13)(1, "div", 14);
    \u0275\u0275template(2, SEComponent_Conditional_7_ng_container_2_Template, 2, 1, "ng-container", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("@helpMotion", void 0);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2._error);
  }
}
function SEComponent_Conditional_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r9.extra);
  }
}
function SEComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275template(1, SEComponent_Conditional_8_ng_container_1_Template, 2, 1, "ng-container", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.extra);
  }
}
var _SEContainerComponent = class _SEContainerComponent {
  get gutter() {
    return this.nzLayout === "horizontal" ? this._gutter : 0;
  }
  set gutter(value) {
    this._gutter = toNumber2(value);
  }
  get nzLayout() {
    return this._nzLayout;
  }
  set nzLayout(value) {
    this._nzLayout = value;
    if (value === "inline") {
      this.size = "compact";
    }
  }
  set errors(val) {
    this.setErrors(val);
  }
  get margin() {
    return -(this.gutter / 2);
  }
  get errorNotify() {
    return this.errorNotify$.pipe(filter((v) => v != null));
  }
  constructor(configSrv) {
    this.errorNotify$ = new BehaviorSubject(null);
    this.noColon = false;
    this.line = false;
    configSrv.attach(this, "se", {
      size: "default",
      nzLayout: "horizontal",
      gutter: 32,
      col: 2,
      labelWidth: 150,
      firstVisual: false,
      ingoreDirty: false
    });
  }
  setErrors(errors) {
    for (const error of errors) {
      this.errorNotify$.next(error);
    }
  }
};
_SEContainerComponent.\u0275fac = function SEContainerComponent_Factory(t) {
  return new (t || _SEContainerComponent)(\u0275\u0275directiveInject(AlainConfigService));
};
_SEContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SEContainerComponent,
  selectors: [["se-container"], ["", "se-container", ""]],
  hostVars: 16,
  hostBindings: function SEContainerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("margin-left", ctx.margin, "px")("margin-right", ctx.margin, "px");
      \u0275\u0275classProp("ant-row", true)("se__container", true)("se__horizontal", ctx.nzLayout === "horizontal")("se__vertical", ctx.nzLayout === "vertical")("se__inline", ctx.nzLayout === "inline")("se__compact", ctx.size === "compact");
    }
  },
  inputs: {
    colInCon: ["se-container", "colInCon"],
    col: "col",
    labelWidth: "labelWidth",
    noColon: "noColon",
    title: "title",
    gutter: "gutter",
    nzLayout: "nzLayout",
    size: "size",
    firstVisual: "firstVisual",
    ingoreDirty: "ingoreDirty",
    line: "line",
    errors: "errors"
  },
  exportAs: ["seContainer"],
  ngContentSelectors: _c032,
  decls: 2,
  vars: 1,
  consts: [["se-title", ""], [4, "nzStringTemplateOutlet"]],
  template: function SEContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, SEContainerComponent_Conditional_0_Template, 2, 1, "div", 0);
      \u0275\u0275projection(1);
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, ctx.title ? 0 : -1);
    }
  },
  dependencies: () => [NzStringTemplateOutletDirective, SETitleComponent],
  encapsulation: 2,
  changeDetection: 0
});
var SEContainerComponent = _SEContainerComponent;
__decorate([InputNumber2(null)], SEContainerComponent.prototype, "colInCon", void 0);
__decorate([InputNumber2(null)], SEContainerComponent.prototype, "col", void 0);
__decorate([InputNumber2(null)], SEContainerComponent.prototype, "labelWidth", void 0);
__decorate([InputBoolean2()], SEContainerComponent.prototype, "noColon", void 0);
__decorate([InputBoolean2()], SEContainerComponent.prototype, "firstVisual", void 0);
__decorate([InputBoolean2()], SEContainerComponent.prototype, "ingoreDirty", void 0);
__decorate([InputBoolean2()], SEContainerComponent.prototype, "line", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SEContainerComponent, [{
    type: Component,
    args: [{
      selector: "se-container, [se-container]",
      exportAs: "seContainer",
      template: `
    @if (title) {
      <div se-title>
        <ng-container *nzStringTemplateOutlet="title">{{ title }}</ng-container>
      </div>
    }
    <ng-content />
  `,
      host: {
        "[class.ant-row]": `true`,
        "[class.se__container]": `true`,
        "[class.se__horizontal]": `nzLayout === 'horizontal'`,
        "[class.se__vertical]": `nzLayout === 'vertical'`,
        "[class.se__inline]": `nzLayout === 'inline'`,
        "[class.se__compact]": `size === 'compact'`,
        "[style.margin-left.px]": `margin`,
        "[style.margin-right.px]": `margin`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], () => [{
    type: AlainConfigService
  }], {
    colInCon: [{
      type: Input,
      args: ["se-container"]
    }],
    col: [{
      type: Input
    }],
    labelWidth: [{
      type: Input
    }],
    noColon: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    gutter: [{
      type: Input
    }],
    nzLayout: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    firstVisual: [{
      type: Input
    }],
    ingoreDirty: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    errors: [{
      type: Input
    }]
  });
})();
var _SETitleComponent = class _SETitleComponent {
  constructor(parent, el, ren) {
    this.parent = parent;
    this.ren = ren;
    if (parent == null) {
      throw new Error(`[se-title] must include 'se-container' component`);
    }
    this.el = el.nativeElement;
  }
  setClass() {
    const {
      el
    } = this;
    const gutter = this.parent.gutter;
    this.ren.setStyle(el, "padding-left", `${gutter / 2}px`);
    this.ren.setStyle(el, "padding-right", `${gutter / 2}px`);
  }
  ngOnInit() {
    this.setClass();
  }
};
_SETitleComponent.\u0275fac = function SETitleComponent_Factory(t) {
  return new (t || _SETitleComponent)(\u0275\u0275directiveInject(SEContainerComponent, 9), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
_SETitleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SETitleComponent,
  selectors: [["se-title"], ["", "se-title", ""]],
  hostVars: 2,
  hostBindings: function SETitleComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("se__title", true);
    }
  },
  exportAs: ["seTitle"],
  ngContentSelectors: _c032,
  decls: 1,
  vars: 0,
  template: function SETitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var SETitleComponent = _SETitleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SETitleComponent, [{
    type: Component,
    args: [{
      selector: "se-title, [se-title]",
      exportAs: "seTitle",
      template: "<ng-content />",
      host: {
        "[class.se__title]": "true"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], () => [{
    type: SEContainerComponent,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], null);
})();
var prefixCls = `se`;
var nextUniqueId2 = 0;
var _SEComponent = class _SEComponent {
  set error(val) {
    this.errorData = typeof val === "string" || val instanceof TemplateRef ? {
      "": val
    } : val;
  }
  set id(value) {
    this._id = value;
    this._autoId = false;
  }
  // #endregion
  get paddingValue() {
    return this.parent.gutter / 2;
  }
  get showErr() {
    return this.invalid && !!this._error && !this.compact;
  }
  get compact() {
    return this.parent.size === "compact";
  }
  get ngControl() {
    return this.ngModel || this.formControlName;
  }
  constructor(el, parent, statusSrv, rep, ren, cdr) {
    this.parent = parent;
    this.statusSrv = statusSrv;
    this.rep = rep;
    this.ren = ren;
    this.cdr = cdr;
    this.destroy$ = inject(DestroyRef);
    this.clsMap = [];
    this.inited = false;
    this.onceFlag = false;
    this.errorData = {};
    this.isBindModel = false;
    this.invalid = false;
    this._labelWidth = null;
    this._noColon = null;
    this.optional = null;
    this.optionalHelp = null;
    this.required = false;
    this.controlClass = "";
    this.hideLabel = false;
    this._id = `_se-${++nextUniqueId2}`;
    this._autoId = true;
    if (parent == null) {
      throw new Error(`[se] must include 'se-container' component`);
    }
    this.el = el.nativeElement;
    parent.errorNotify.pipe(takeUntilDestroyed(this.destroy$), filter((w) => this.inited && this.ngControl != null && this.ngControl.name === w.name)).subscribe((item) => {
      this.error = item.error;
      this.updateStatus(this.ngControl.invalid);
    });
  }
  setClass() {
    const {
      el,
      ren,
      clsMap,
      col,
      parent,
      cdr,
      line,
      labelWidth,
      rep,
      noColon
    } = this;
    this._noColon = noColon != null ? noColon : parent.noColon;
    this._labelWidth = parent.nzLayout === "horizontal" ? labelWidth != null ? labelWidth : parent.labelWidth : null;
    clsMap.forEach((cls) => ren.removeClass(el, cls));
    clsMap.length = 0;
    const parentCol = parent.colInCon || parent.col;
    const repCls = parent.nzLayout === "horizontal" ? rep.genCls(col != null ? col : parentCol, parentCol) : [];
    clsMap.push(`ant-form-item`, ...repCls, `${prefixCls}__item`);
    if (line || parent.line) {
      clsMap.push(`${prefixCls}__line`);
    }
    clsMap.forEach((cls) => ren.addClass(el, cls));
    cdr.detectChanges();
    return this;
  }
  bindModel() {
    if (!this.ngControl || this.isBindModel)
      return;
    this.isBindModel = true;
    this.ngControl.statusChanges.pipe(takeUntilDestroyed(this.destroy$)).subscribe((res) => this.updateStatus(res === "INVALID"));
    if (this._autoId) {
      const controlAccessor = this.ngControl.valueAccessor;
      const control = (controlAccessor?.elementRef || controlAccessor?._elementRef)?.nativeElement;
      if (!!control) {
        if (control.id) {
          this._id = control.id;
        } else {
          control.id = this._id;
        }
      }
    }
    if (this.required !== true) {
      let required = this.ngControl?.control?.hasValidator(Validators.required);
      if (required !== true) {
        const rawValidators = this.ngControl?._rawValidators;
        required = rawValidators.find((w) => w instanceof RequiredValidator) != null;
      }
      this.required = required;
      this.cdr.detectChanges();
    }
  }
  updateStatus(invalid) {
    if (this.ngControl?.disabled || this.ngControl?.isDisabled) {
      return;
    }
    this.invalid = !this.onceFlag && invalid && this.parent.ingoreDirty === false && !this.ngControl?.dirty ? false : invalid;
    const errors = this.ngControl?.errors;
    if (errors != null && Object.keys(errors).length > 0) {
      const key = Object.keys(errors)[0] || "";
      const err = this.errorData[key];
      this._error = err != null ? err : this.errorData[""] || "";
    }
    this.statusSrv.formStatusChanges.next({
      status: this.invalid ? "error" : "",
      hasFeedback: false
    });
    this.cdr.detectChanges();
  }
  checkContent() {
    const el = this.contentElement.nativeElement;
    const cls = `${prefixCls}__item-empty`;
    if (isEmpty(el)) {
      this.ren.addClass(el, cls);
    } else {
      this.ren.removeClass(el, cls);
    }
  }
  ngAfterContentInit() {
    this.checkContent();
  }
  ngOnChanges() {
    this.onceFlag = this.parent.firstVisual;
    if (this.inited) {
      this.setClass().bindModel();
    }
  }
  ngAfterViewInit() {
    this.setClass().bindModel();
    this.inited = true;
    if (this.onceFlag) {
      Promise.resolve().then(() => {
        this.updateStatus(this.ngControl?.invalid);
        this.onceFlag = false;
      });
    }
  }
};
_SEComponent.\u0275fac = function SEComponent_Factory(t) {
  return new (t || _SEComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(SEContainerComponent, 9), \u0275\u0275directiveInject(NzFormStatusService), \u0275\u0275directiveInject(ResponsiveService), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_SEComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SEComponent,
  selectors: [["se"]],
  contentQueries: function SEComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NgModel, 7);
      \u0275\u0275contentQuery(dirIndex, FormControlName, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ngModel = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.formControlName = _t.first);
    }
  },
  viewQuery: function SEComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c124, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentElement = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function SEComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("padding-left", ctx.paddingValue, "px")("padding-right", ctx.paddingValue, "px");
      \u0275\u0275classProp("se__hide-label", ctx.hideLabel)("ant-form-item-has-error", ctx.invalid)("ant-form-item-with-help", ctx.showErr);
    }
  },
  inputs: {
    optional: "optional",
    optionalHelp: "optionalHelp",
    optionalHelpColor: "optionalHelpColor",
    error: "error",
    extra: "extra",
    label: "label",
    col: "col",
    required: "required",
    controlClass: "controlClass",
    line: "line",
    labelWidth: "labelWidth",
    noColon: "noColon",
    hideLabel: "hideLabel",
    id: "id"
  },
  exportAs: ["se"],
  features: [\u0275\u0275ProvidersFeature([NzFormStatusService]), \u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c032,
  decls: 9,
  vars: 10,
  consts: [[1, "ant-form-item-label"], ["class", "se__label", 3, "ngClass"], [1, "ant-form-item-control", "se__control"], [1, "ant-form-item-control-input-content", 3, "cdkObserveContent"], ["contentElement", ""], ["class", "ant-form-item-explain ant-form-item-explain-connected"], ["class", "ant-form-item-extra"], [1, "se__label", 3, "ngClass"], [1, "se__label-text"], [4, "nzStringTemplateOutlet"], ["class", "se__label-optional", 3, "se__label-optional-no-text"], [1, "se__label-optional"], ["nz-tooltip", "", "nz-icon", "", "nzType", "question-circle", 3, "nzTooltipTitle", "nzTooltipColor"], [1, "ant-form-item-explain", "ant-form-item-explain-connected"], ["role", "alert", 1, "ant-form-item-explain-error"], [1, "ant-form-item-extra"]],
  template: function SEComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, SEComponent_Conditional_1_Template, 4, 7, "label", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "div", 2)(3, "div")(4, "div", 3, 4);
      \u0275\u0275listener("cdkObserveContent", function SEComponent_Template_div_cdkObserveContent_4_listener() {
        return ctx.checkContent();
      });
      \u0275\u0275projection(6);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(7, SEComponent_Conditional_7_Template, 3, 2, "div", 5)(8, SEComponent_Conditional_8_Template, 2, 1, "div", 6);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx._labelWidth, "px");
      \u0275\u0275classProp("se__nolabel", ctx.hideLabel || !ctx.label);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx.label ? 1 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275classMapInterpolate1("ant-form-item-control-input ", ctx.controlClass, "");
      \u0275\u0275advance(4);
      \u0275\u0275conditional(7, ctx.showErr ? 7 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(8, ctx.extra && !ctx.compact ? 8 : -1);
    }
  },
  dependencies: [NgClass, NzTooltipDirective, NzIconDirective, NzStringTemplateOutletDirective],
  encapsulation: 2,
  data: {
    animation: [helpMotion]
  },
  changeDetection: 0
});
var SEComponent = _SEComponent;
__decorate([InputNumber2(null)], SEComponent.prototype, "col", void 0);
__decorate([InputBoolean2()], SEComponent.prototype, "required", void 0);
__decorate([InputBoolean2(null)], SEComponent.prototype, "line", void 0);
__decorate([InputNumber2(null)], SEComponent.prototype, "labelWidth", void 0);
__decorate([InputBoolean2(null)], SEComponent.prototype, "noColon", void 0);
__decorate([InputBoolean2()], SEComponent.prototype, "hideLabel", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SEComponent, [{
    type: Component,
    args: [{
      selector: "se",
      exportAs: "se",
      host: {
        "[style.padding-left.px]": "paddingValue",
        "[style.padding-right.px]": "paddingValue",
        "[class.se__hide-label]": "hideLabel",
        "[class.ant-form-item-has-error]": "invalid",
        "[class.ant-form-item-with-help]": "showErr"
      },
      preserveWhitespaces: false,
      providers: [NzFormStatusService],
      animations: [helpMotion],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<div class="ant-form-item-label" [class.se__nolabel]="hideLabel || !label" [style.width.px]="_labelWidth">
  @if (label) {
    <label
      [attr.for]="_id"
      class="se__label"
      [ngClass]="{ 'ant-form-item-required': required, 'se__no-colon': _noColon }"
    >
      <span class="se__label-text">
        <ng-container *nzStringTemplateOutlet="label">{{ label }}</ng-container>
      </span>
      @if (optional || optionalHelp) {
        <span class="se__label-optional" [class.se__label-optional-no-text]="!optional">
          <ng-container *nzStringTemplateOutlet="optional">{{ optional }}</ng-container>
          @if (optionalHelp) {
            <i
              nz-tooltip
              [nzTooltipTitle]="optionalHelp"
              [nzTooltipColor]="optionalHelpColor"
              nz-icon
              nzType="question-circle"
            ></i>
          }
        </span>
      }
    </label>
  }
</div>
<div class="ant-form-item-control se__control">
  <div class="ant-form-item-control-input {{ controlClass }}">
    <div class="ant-form-item-control-input-content" (cdkObserveContent)="checkContent()" #contentElement>
      <ng-content />
    </div>
  </div>
  @if (showErr) {
    <div @helpMotion class="ant-form-item-explain ant-form-item-explain-connected">
      <div role="alert" class="ant-form-item-explain-error">
        <ng-container *nzStringTemplateOutlet="_error">{{ _error }}</ng-container>
      </div>
    </div>
  }
  @if (extra && !compact) {
    <div class="ant-form-item-extra">
      <ng-container *nzStringTemplateOutlet="extra">{{ extra }}</ng-container>
    </div>
  }
</div>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: SEContainerComponent,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: NzFormStatusService
  }, {
    type: ResponsiveService
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }], {
    ngModel: [{
      type: ContentChild,
      args: [NgModel, {
        static: true
      }]
    }],
    formControlName: [{
      type: ContentChild,
      args: [FormControlName, {
        static: true
      }]
    }],
    contentElement: [{
      type: ViewChild,
      args: ["contentElement", {
        static: true
      }]
    }],
    optional: [{
      type: Input
    }],
    optionalHelp: [{
      type: Input
    }],
    optionalHelpColor: [{
      type: Input
    }],
    error: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    col: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    controlClass: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    labelWidth: [{
      type: Input
    }],
    noColon: [{
      type: Input
    }],
    hideLabel: [{
      type: Input
    }],
    id: [{
      type: Input
    }]
  });
})();
var COMPONENTS7 = [SEContainerComponent, SEComponent, SETitleComponent];
var _SEModule = class _SEModule {
};
_SEModule.\u0275fac = function SEModule_Factory(t) {
  return new (t || _SEModule)();
};
_SEModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SEModule
});
_SEModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzToolTipModule, NzIconModule, NzOutletModule]
});
var SEModule = _SEModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SEModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzToolTipModule, NzIconModule, NzOutletModule],
      declarations: COMPONENTS7,
      exports: COMPONENTS7
    }]
  }], null, null);
})();

// node_modules/@delon/abc/fesm2022/sv.mjs
function SVContainerComponent_Conditional_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r1.title);
  }
}
function SVContainerComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "sv-title");
    \u0275\u0275template(1, SVContainerComponent_Conditional_1_ng_container_1_Template, 2, 1, "ng-container", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.title);
  }
}
var _c033 = ["*"];
function SVValueComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "em", 3);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r0.prefix, \u0275\u0275sanitizeHtml);
  }
}
function SVValueComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "em", 4);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r1.unit, \u0275\u0275sanitizeHtml);
  }
}
var _c125 = ["conEl"];
function SVComponent_Conditional_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r3.label);
  }
}
function SVComponent_Conditional_0_Conditional_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r5.optional);
  }
}
function SVComponent_Conditional_0_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 10);
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(3);
    \u0275\u0275property("nzTooltipTitle", ctx_r6.optionalHelp)("nzTooltipColor", ctx_r6.optionalHelpColor);
  }
}
function SVComponent_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275template(1, SVComponent_Conditional_0_Conditional_3_ng_container_1_Template, 2, 1, "ng-container", 7)(2, SVComponent_Conditional_0_Conditional_3_Conditional_2_Template, 1, 2, "i", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("sv__label-optional-no-text", !ctx_r4.optional);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r4.optional);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, ctx_r4.optionalHelp ? 2 : -1);
  }
}
function SVComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5)(1, "span", 6);
    \u0275\u0275template(2, SVComponent_Conditional_0_ng_container_2_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, SVComponent_Conditional_0_Conditional_3_Template, 3, 4, "span", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("width", ctx_r0.labelWidth, "px");
    \u0275\u0275classProp("sv__label-empty", !ctx_r0.label)("sv__label-width", ctx_r0.labelWidth !== null && ctx_r0.labelWidth !== void 0)("sv__no-colon", ctx_r0._noColon);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.label);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, ctx_r0.optional || ctx_r0.optionalHelp ? 3 : -1);
  }
}
function SVComponent_Conditional_5_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 12);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r7.unit);
  }
}
function SVComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SVComponent_Conditional_5_span_0_Template, 2, 1, "span", 11);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2.unit);
  }
}
var _SVContainerComponent = class _SVContainerComponent {
  get margin() {
    return this.bordered ? {} : {
      "margin-left.px": -(this.gutter / 2),
      "margin-right.px": -(this.gutter / 2)
    };
  }
  constructor(configSrv) {
    this.noColon = false;
    this.bordered = false;
    configSrv.attach(this, "sv", {
      size: "large",
      gutter: 32,
      layout: "horizontal",
      col: 3,
      default: true
    });
  }
};
_SVContainerComponent.\u0275fac = function SVContainerComponent_Factory(t) {
  return new (t || _SVContainerComponent)(\u0275\u0275directiveInject(AlainConfigService));
};
_SVContainerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SVContainerComponent,
  selectors: [["sv-container"], ["", "sv-container", ""]],
  hostVars: 14,
  hostBindings: function SVContainerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("sv__container", true)("sv__horizontal", ctx.layout === "horizontal")("sv__vertical", ctx.layout === "vertical")("sv__small", ctx.size === "small")("sv__large", ctx.size === "large")("sv__bordered", ctx.bordered)("clearfix", true);
    }
  },
  inputs: {
    colInCon: ["sv-container", "colInCon"],
    title: "title",
    size: "size",
    gutter: "gutter",
    layout: "layout",
    labelWidth: "labelWidth",
    col: "col",
    default: "default",
    noColon: "noColon",
    bordered: "bordered"
  },
  exportAs: ["svContainer"],
  ngContentSelectors: _c033,
  decls: 3,
  vars: 2,
  consts: [[1, "ant-row", 3, "ngStyle"], [4, "nzStringTemplateOutlet"]],
  template: function SVContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, SVContainerComponent_Conditional_1_Template, 2, 1, "sv-title");
      \u0275\u0275projection(2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngStyle", ctx.margin);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx.title ? 1 : -1);
    }
  },
  dependencies: () => [NgStyle, NzStringTemplateOutletDirective, SVTitleComponent],
  encapsulation: 2,
  changeDetection: 0
});
var SVContainerComponent = _SVContainerComponent;
__decorate([InputNumber2(null)], SVContainerComponent.prototype, "colInCon", void 0);
__decorate([InputNumber2()], SVContainerComponent.prototype, "gutter", void 0);
__decorate([InputNumber2()], SVContainerComponent.prototype, "labelWidth", void 0);
__decorate([InputNumber2()], SVContainerComponent.prototype, "col", void 0);
__decorate([InputBoolean2()], SVContainerComponent.prototype, "default", void 0);
__decorate([InputBoolean2()], SVContainerComponent.prototype, "noColon", void 0);
__decorate([InputBoolean2()], SVContainerComponent.prototype, "bordered", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVContainerComponent, [{
    type: Component,
    args: [{
      selector: "sv-container, [sv-container]",
      exportAs: "svContainer",
      template: `
    <div class="ant-row" [ngStyle]="margin">
      @if (title) {
        <sv-title>
          <ng-container *nzStringTemplateOutlet="title">{{ title }}</ng-container>
        </sv-title>
      }
      <ng-content />
    </div>
  `,
      host: {
        "[class.sv__container]": "true",
        "[class.sv__horizontal]": `layout === 'horizontal'`,
        "[class.sv__vertical]": `layout === 'vertical'`,
        "[class.sv__small]": `size === 'small'`,
        "[class.sv__large]": `size === 'large'`,
        "[class.sv__bordered]": `bordered`,
        "[class.clearfix]": `true`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], () => [{
    type: AlainConfigService
  }], {
    colInCon: [{
      type: Input,
      args: ["sv-container"]
    }],
    title: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    gutter: [{
      type: Input
    }],
    layout: [{
      type: Input
    }],
    labelWidth: [{
      type: Input
    }],
    col: [{
      type: Input
    }],
    default: [{
      type: Input
    }],
    noColon: [{
      type: Input
    }],
    bordered: [{
      type: Input
    }]
  });
})();
var _SVTitleComponent = class _SVTitleComponent {
  constructor(el, parent, ren) {
    this.el = el;
    this.parent = parent;
    this.ren = ren;
    if (parent == null) {
      throw new Error(`[sv-title] must include 'sv-container' component`);
    }
  }
  setClass() {
    const gutter = this.parent.gutter;
    const el = this.el.nativeElement;
    this.ren.setStyle(el, "padding-left", `${gutter / 2}px`);
    this.ren.setStyle(el, "padding-right", `${gutter / 2}px`);
  }
  ngOnInit() {
    this.setClass();
  }
};
_SVTitleComponent.\u0275fac = function SVTitleComponent_Factory(t) {
  return new (t || _SVTitleComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(SVContainerComponent, 9), \u0275\u0275directiveInject(Renderer2));
};
_SVTitleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SVTitleComponent,
  selectors: [["sv-title"], ["", "sv-title", ""]],
  hostVars: 2,
  hostBindings: function SVTitleComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("sv__title", true);
    }
  },
  exportAs: ["svTitle"],
  ngContentSelectors: _c033,
  decls: 1,
  vars: 0,
  template: function SVTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var SVTitleComponent = _SVTitleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVTitleComponent, [{
    type: Component,
    args: [{
      selector: "sv-title, [sv-title]",
      exportAs: "svTitle",
      template: "<ng-content />",
      host: {
        "[class.sv__title]": "true"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: SVContainerComponent,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: Renderer2
  }], null);
})();
var _SVValueComponent = class _SVValueComponent {
  constructor() {
    this.size = "default";
  }
};
_SVValueComponent.\u0275fac = function SVValueComponent_Factory(t) {
  return new (t || _SVValueComponent)();
};
_SVValueComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SVValueComponent,
  selectors: [["sv-value"], ["", "sv-value", ""]],
  hostVars: 6,
  hostBindings: function SVValueComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("sv__value", true)("sv__value-small", ctx.size === "small")("sv__value-large", ctx.size === "large");
    }
  },
  inputs: {
    prefix: "prefix",
    unit: "unit",
    tooltip: "tooltip",
    size: "size"
  },
  exportAs: ["svValue"],
  ngContentSelectors: _c033,
  decls: 4,
  vars: 3,
  consts: [["class", "sv__value-prefix", 3, "innerHTML"], ["nz-tooltip", "", 1, "sv__value-text", 3, "nzTooltipTitle"], ["class", "sv__value-unit", 3, "innerHTML"], [1, "sv__value-prefix", 3, "innerHTML"], [1, "sv__value-unit", 3, "innerHTML"]],
  template: function SVValueComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, SVValueComponent_Conditional_0_Template, 1, 1, "em", 0);
      \u0275\u0275elementStart(1, "span", 1);
      \u0275\u0275projection(2);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, SVValueComponent_Conditional_3_Template, 1, 1, "em", 2);
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, ctx.prefix ? 0 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzTooltipTitle", ctx.tooltip);
      \u0275\u0275advance(2);
      \u0275\u0275conditional(3, ctx.unit ? 3 : -1);
    }
  },
  dependencies: [NzTooltipDirective],
  encapsulation: 2,
  changeDetection: 0
});
var SVValueComponent = _SVValueComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVValueComponent, [{
    type: Component,
    args: [{
      selector: "sv-value, [sv-value]",
      exportAs: "svValue",
      template: `
    @if (prefix) {
      <em class="sv__value-prefix" [innerHTML]="prefix"></em>
    }
    <span nz-tooltip [nzTooltipTitle]="tooltip" class="sv__value-text"><ng-content /></span>
    @if (unit) {
      <em class="sv__value-unit" [innerHTML]="unit"></em>
    }
  `,
      host: {
        "[class.sv__value]": "true",
        "[class.sv__value-small]": `size === 'small'`,
        "[class.sv__value-large]": `size === 'large'`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, {
    prefix: [{
      type: Input
    }],
    unit: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var prefixCls2 = `sv`;
var _SVComponent = class _SVComponent {
  // #endregion
  get paddingValue() {
    if (this.parent.bordered)
      return null;
    return this.parent.gutter / 2;
  }
  get labelWidth() {
    const {
      labelWidth,
      layout
    } = this.parent;
    return layout === "horizontal" ? labelWidth : null;
  }
  constructor(el, parent, rep, ren) {
    this.el = el;
    this.parent = parent;
    this.rep = rep;
    this.ren = ren;
    this.clsMap = [];
    this._noColon = false;
    this.hideLabel = false;
    if (parent == null) {
      throw new Error(`[sv] must include 'sv-container' component`);
    }
  }
  setClass() {
    const {
      ren,
      col,
      clsMap,
      type,
      rep,
      noColon,
      parent
    } = this;
    const el = this.el.nativeElement;
    this._noColon = parent.bordered ? true : noColon != null ? noColon : parent.noColon;
    clsMap.forEach((cls) => ren.removeClass(el, cls));
    clsMap.length = 0;
    const parentCol = parent.colInCon || parent.col;
    clsMap.push(...rep.genCls(col != null ? col : parentCol, parentCol));
    clsMap.push(`${prefixCls2}__item`);
    if (this.parent.labelWidth)
      clsMap.push(`${prefixCls2}__item-fixed`);
    if (type)
      clsMap.push(`${prefixCls2}__type-${type}`);
    clsMap.forEach((cls) => ren.addClass(el, cls));
  }
  ngAfterViewInit() {
    this.setClass();
    this.checkContent();
  }
  ngOnChanges() {
    this.setClass();
  }
  checkContent() {
    const {
      conEl
    } = this;
    const def = this.default;
    if (!(def != null ? def : this.parent.default)) {
      return;
    }
    const el = conEl.nativeElement;
    const cls = `sv__default`;
    if (el.classList.contains(cls)) {
      el.classList.remove(cls);
    }
    if (isEmpty(el)) {
      el.classList.add(cls);
    }
  }
};
_SVComponent.\u0275fac = function SVComponent_Factory(t) {
  return new (t || _SVComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(SVContainerComponent, 9), \u0275\u0275directiveInject(ResponsiveService), \u0275\u0275directiveInject(Renderer2));
};
_SVComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SVComponent,
  selectors: [["sv"], ["", "sv", ""]],
  viewQuery: function SVComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c125, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.conEl = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function SVComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("padding-left", ctx.paddingValue, "px")("padding-right", ctx.paddingValue, "px");
    }
  },
  inputs: {
    optional: "optional",
    optionalHelp: "optionalHelp",
    optionalHelpColor: "optionalHelpColor",
    label: "label",
    unit: "unit",
    col: "col",
    default: "default",
    type: "type",
    noColon: "noColon",
    hideLabel: "hideLabel"
  },
  exportAs: ["sv"],
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c033,
  decls: 6,
  vars: 2,
  consts: [["class", "sv__label", 3, "sv__label-empty", "sv__label-width", "sv__no-colon", "width"], [1, "sv__detail"], [3, "cdkObserveContent"], ["conEl", ""], ["class", "sv__unit"], [1, "sv__label"], [1, "sv__label-text"], [4, "nzStringTemplateOutlet"], ["class", "sv__label-optional", 3, "sv__label-optional-no-text"], [1, "sv__label-optional"], ["nz-tooltip", "", "nz-icon", "", "nzType", "question-circle", 3, "nzTooltipTitle", "nzTooltipColor"], ["class", "sv__unit", 4, "nzStringTemplateOutlet"], [1, "sv__unit"]],
  template: function SVComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, SVComponent_Conditional_0_Template, 4, 10, "div", 0);
      \u0275\u0275elementStart(1, "div", 1)(2, "span", 2, 3);
      \u0275\u0275listener("cdkObserveContent", function SVComponent_Template_span_cdkObserveContent_2_listener() {
        return ctx.checkContent();
      });
      \u0275\u0275projection(4);
      \u0275\u0275elementEnd();
      \u0275\u0275template(5, SVComponent_Conditional_5_Template, 1, 1, "span", 4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, !ctx.hideLabel ? 0 : -1);
      \u0275\u0275advance(5);
      \u0275\u0275conditional(5, !!ctx.unit ? 5 : -1);
    }
  },
  dependencies: [CdkObserveContent, NzTooltipDirective, NzIconDirective, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var SVComponent = _SVComponent;
__decorate([InputNumber2(null)], SVComponent.prototype, "col", void 0);
__decorate([InputBoolean2(null)], SVComponent.prototype, "default", void 0);
__decorate([InputBoolean2(null)], SVComponent.prototype, "noColon", void 0);
__decorate([InputBoolean2()], SVComponent.prototype, "hideLabel", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVComponent, [{
    type: Component,
    args: [{
      selector: "sv, [sv]",
      exportAs: "sv",
      host: {
        "[style.padding-left.px]": "paddingValue",
        "[style.padding-right.px]": "paddingValue"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: '@if (!hideLabel) {\n  <div\n    class="sv__label"\n    [class.sv__label-empty]="!label"\n    [class.sv__label-width]="labelWidth !== null && labelWidth !== undefined"\n    [class.sv__no-colon]="_noColon"\n    [style.width.px]="labelWidth"\n  >\n    <span class="sv__label-text">\n      <ng-container *nzStringTemplateOutlet="label">{{ label }}</ng-container>\n    </span>\n    @if (optional || optionalHelp) {\n      <span class="sv__label-optional" [class.sv__label-optional-no-text]="!optional">\n        <ng-container *nzStringTemplateOutlet="optional">{{ optional }}</ng-container>\n        @if (optionalHelp) {\n          <i\n            nz-tooltip\n            [nzTooltipTitle]="optionalHelp"\n            [nzTooltipColor]="optionalHelpColor"\n            nz-icon\n            nzType="question-circle"\n          ></i>\n        }\n      </span>\n    }\n  </div>\n}\n<div class="sv__detail">\n  <span (cdkObserveContent)="checkContent()" #conEl>\n    <ng-content />\n  </span>\n  @if (!!unit) {\n    <span class="sv__unit" *nzStringTemplateOutlet="unit">{{ unit }}</span>\n  }\n</div>\n'
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: SVContainerComponent,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: ResponsiveService
  }, {
    type: Renderer2
  }], {
    conEl: [{
      type: ViewChild,
      args: ["conEl", {
        static: false
      }]
    }],
    optional: [{
      type: Input
    }],
    optionalHelp: [{
      type: Input
    }],
    optionalHelpColor: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    unit: [{
      type: Input
    }],
    col: [{
      type: Input
    }],
    default: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    noColon: [{
      type: Input
    }],
    hideLabel: [{
      type: Input
    }]
  });
})();
var COMPONENTS8 = [SVContainerComponent, SVComponent, SVTitleComponent, SVValueComponent];
var _SVModule = class _SVModule {
};
_SVModule.\u0275fac = function SVModule_Factory(t) {
  return new (t || _SVModule)();
};
_SVModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SVModule
});
_SVModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, ObserversModule, NzToolTipModule, NzIconModule, NzOutletModule]
});
var SVModule = _SVModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ObserversModule, NzToolTipModule, NzIconModule, NzOutletModule],
      declarations: COMPONENTS8,
      exports: COMPONENTS8
    }]
  }], null, null);
})();

// src/app/shared/shared-delon.module.ts
var SHARED_DELON_MODULES = [PageHeaderModule, STModule, SEModule, SVModule, ResultModule, DelonFormModule];

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-alert.mjs
function NzAlertComponent_Conditional_0_Conditional_1_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NzAlertComponent_Conditional_0_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzAlertComponent_Conditional_0_Conditional_1_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 7);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(3);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r5.nzIcon);
  }
}
function NzAlertComponent_Conditional_0_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(3);
    \u0275\u0275property("nzType", ctx_r6.nzIconType || ctx_r6.inferredIconType)("nzTheme", ctx_r6.iconTheme);
  }
}
function NzAlertComponent_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275template(1, NzAlertComponent_Conditional_0_Conditional_1_Conditional_1_Template, 1, 1, "ng-container")(2, NzAlertComponent_Conditional_0_Conditional_1_Conditional_2_Template, 1, 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r1.nzIcon ? 1 : 2);
  }
}
function NzAlertComponent_Conditional_0_Conditional_2_Conditional_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r10.nzMessage);
  }
}
function NzAlertComponent_Conditional_0_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 12);
    \u0275\u0275template(1, NzAlertComponent_Conditional_0_Conditional_2_Conditional_1_ng_container_1_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r8.nzMessage);
  }
}
function NzAlertComponent_Conditional_0_Conditional_2_Conditional_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r11 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r11.nzDescription);
  }
}
function NzAlertComponent_Conditional_0_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 13);
    \u0275\u0275template(1, NzAlertComponent_Conditional_0_Conditional_2_Conditional_2_ng_container_1_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r9.nzDescription);
  }
}
function NzAlertComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275template(1, NzAlertComponent_Conditional_0_Conditional_2_Conditional_1_Template, 2, 1, "span", 10)(2, NzAlertComponent_Conditional_0_Conditional_2_Conditional_2_Template, 2, 1, "span", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r2.nzMessage ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, ctx_r2.nzDescription ? 2 : -1);
  }
}
function NzAlertComponent_Conditional_0_Conditional_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r12 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r12.nzAction);
  }
}
function NzAlertComponent_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14);
    \u0275\u0275template(1, NzAlertComponent_Conditional_0_Conditional_3_ng_container_1_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.nzAction);
  }
}
function NzAlertComponent_Conditional_0_Conditional_4_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "span", 16);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r15 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r15.nzCloseText);
  }
}
function NzAlertComponent_Conditional_0_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzAlertComponent_Conditional_0_Conditional_4_Conditional_1_ng_container_0_Template, 3, 1, "ng-container", 7);
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext(3);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r13.nzCloseText);
  }
}
function NzAlertComponent_Conditional_0_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 17);
  }
}
function NzAlertComponent_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 15);
    \u0275\u0275listener("click", function NzAlertComponent_Conditional_0_Conditional_4_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r17);
      const ctx_r16 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r16.closeAlert());
    });
    \u0275\u0275template(1, NzAlertComponent_Conditional_0_Conditional_4_Conditional_1_Template, 1, 1, "ng-container")(2, NzAlertComponent_Conditional_0_Conditional_4_Conditional_2_Template, 1, 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r4.nzCloseText ? 1 : 2);
  }
}
function NzAlertComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("@slideAlertMotion.done", function NzAlertComponent_Conditional_0_Template_div_animation_slideAlertMotion_done_0_listener() {
      \u0275\u0275restoreView(_r19);
      const ctx_r18 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r18.onFadeAnimationDone());
    });
    \u0275\u0275template(1, NzAlertComponent_Conditional_0_Conditional_1_Template, 3, 1, "div", 2)(2, NzAlertComponent_Conditional_0_Conditional_2_Template, 3, 2, "div", 3)(3, NzAlertComponent_Conditional_0_Conditional_3_Template, 2, 1, "div", 4)(4, NzAlertComponent_Conditional_0_Conditional_4_Template, 3, 1, "button", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-alert-rtl", ctx_r0.dir === "rtl")("ant-alert-success", ctx_r0.nzType === "success")("ant-alert-info", ctx_r0.nzType === "info")("ant-alert-warning", ctx_r0.nzType === "warning")("ant-alert-error", ctx_r0.nzType === "error")("ant-alert-no-icon", !ctx_r0.nzShowIcon)("ant-alert-banner", ctx_r0.nzBanner)("ant-alert-closable", ctx_r0.nzCloseable)("ant-alert-with-description", !!ctx_r0.nzDescription);
    \u0275\u0275property("@.disabled", ctx_r0.nzNoAnimation)("@slideAlertMotion", void 0);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r0.nzShowIcon ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, ctx_r0.nzMessage || ctx_r0.nzDescription ? 2 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, ctx_r0.nzAction ? 3 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(4, ctx_r0.nzCloseable || ctx_r0.nzCloseText ? 4 : -1);
  }
}
var NZ_CONFIG_MODULE_NAME17 = "alert";
var _NzAlertComponent = class _NzAlertComponent {
  constructor(nzConfigService, cdr, directionality) {
    this.nzConfigService = nzConfigService;
    this.cdr = cdr;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME17;
    this.nzAction = null;
    this.nzCloseText = null;
    this.nzIconType = null;
    this.nzMessage = null;
    this.nzDescription = null;
    this.nzType = "info";
    this.nzCloseable = false;
    this.nzShowIcon = false;
    this.nzBanner = false;
    this.nzNoAnimation = false;
    this.nzIcon = null;
    this.nzOnClose = new EventEmitter();
    this.closed = false;
    this.iconTheme = "fill";
    this.inferredIconType = "info-circle";
    this.dir = "ltr";
    this.isTypeSet = false;
    this.isShowIconSet = false;
    this.destroy$ = new Subject();
    this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME17).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.cdr.markForCheck();
    });
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  closeAlert() {
    this.closed = true;
  }
  onFadeAnimationDone() {
    if (this.closed) {
      this.nzOnClose.emit(true);
    }
  }
  ngOnChanges(changes) {
    const {
      nzShowIcon,
      nzDescription,
      nzType,
      nzBanner
    } = changes;
    if (nzShowIcon) {
      this.isShowIconSet = true;
    }
    if (nzType) {
      this.isTypeSet = true;
      switch (this.nzType) {
        case "error":
          this.inferredIconType = "close-circle";
          break;
        case "success":
          this.inferredIconType = "check-circle";
          break;
        case "info":
          this.inferredIconType = "info-circle";
          break;
        case "warning":
          this.inferredIconType = "exclamation-circle";
          break;
      }
    }
    if (nzDescription) {
      this.iconTheme = this.nzDescription ? "outline" : "fill";
    }
    if (nzBanner) {
      if (!this.isTypeSet) {
        this.nzType = "warning";
      }
      if (!this.isShowIconSet) {
        this.nzShowIcon = true;
      }
    }
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_NzAlertComponent.\u0275fac = function NzAlertComponent_Factory(t) {
  return new (t || _NzAlertComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzAlertComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzAlertComponent,
  selectors: [["nz-alert"]],
  inputs: {
    nzAction: "nzAction",
    nzCloseText: "nzCloseText",
    nzIconType: "nzIconType",
    nzMessage: "nzMessage",
    nzDescription: "nzDescription",
    nzType: "nzType",
    nzCloseable: "nzCloseable",
    nzShowIcon: "nzShowIcon",
    nzBanner: "nzBanner",
    nzNoAnimation: "nzNoAnimation",
    nzIcon: "nzIcon"
  },
  outputs: {
    nzOnClose: "nzOnClose"
  },
  exportAs: ["nzAlert"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 1,
  vars: 1,
  consts: [["class", "ant-alert", 3, "ant-alert-rtl", "ant-alert-success", "ant-alert-info", "ant-alert-warning", "ant-alert-error", "ant-alert-no-icon", "ant-alert-banner", "ant-alert-closable", "ant-alert-with-description"], [1, "ant-alert"], ["class", "ant-alert-icon"], ["class", "ant-alert-content"], ["class", "ant-alert-action"], ["type", "button", "tabindex", "0", "class", "ant-alert-close-icon"], [1, "ant-alert-icon"], [4, "nzStringTemplateOutlet"], ["nz-icon", "", 3, "nzType", "nzTheme"], [1, "ant-alert-content"], ["class", "ant-alert-message"], ["class", "ant-alert-description"], [1, "ant-alert-message"], [1, "ant-alert-description"], [1, "ant-alert-action"], ["type", "button", "tabindex", "0", 1, "ant-alert-close-icon", 3, "click"], [1, "ant-alert-close-text"], ["nz-icon", "", "nzType", "close"]],
  template: function NzAlertComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzAlertComponent_Conditional_0_Template, 5, 24, "div", 0);
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, !ctx.closed ? 0 : -1);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  data: {
    animation: [slideAlertMotion]
  },
  changeDetection: 0
});
var NzAlertComponent = _NzAlertComponent;
__decorate([WithConfig(), InputBoolean()], NzAlertComponent.prototype, "nzCloseable", void 0);
__decorate([WithConfig(), InputBoolean()], NzAlertComponent.prototype, "nzShowIcon", void 0);
__decorate([InputBoolean()], NzAlertComponent.prototype, "nzBanner", void 0);
__decorate([InputBoolean()], NzAlertComponent.prototype, "nzNoAnimation", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAlertComponent, [{
    type: Component,
    args: [{
      selector: "nz-alert",
      exportAs: "nzAlert",
      animations: [slideAlertMotion],
      standalone: true,
      imports: [NzIconModule, NzOutletModule],
      template: `
    @if (!closed) {
      <div
        class="ant-alert"
        [class.ant-alert-rtl]="dir === 'rtl'"
        [class.ant-alert-success]="nzType === 'success'"
        [class.ant-alert-info]="nzType === 'info'"
        [class.ant-alert-warning]="nzType === 'warning'"
        [class.ant-alert-error]="nzType === 'error'"
        [class.ant-alert-no-icon]="!nzShowIcon"
        [class.ant-alert-banner]="nzBanner"
        [class.ant-alert-closable]="nzCloseable"
        [class.ant-alert-with-description]="!!nzDescription"
        [@.disabled]="nzNoAnimation"
        [@slideAlertMotion]
        (@slideAlertMotion.done)="onFadeAnimationDone()"
      >
        @if (nzShowIcon) {
          <div class="ant-alert-icon">
            @if (nzIcon) {
              <ng-container *nzStringTemplateOutlet="nzIcon"></ng-container>
            } @else {
              <span nz-icon [nzType]="nzIconType || inferredIconType" [nzTheme]="iconTheme"></span>
            }
          </div>
        }

        @if (nzMessage || nzDescription) {
          <div class="ant-alert-content">
            @if (nzMessage) {
              <span class="ant-alert-message">
                <ng-container *nzStringTemplateOutlet="nzMessage">{{ nzMessage }}</ng-container>
              </span>
            }
            @if (nzDescription) {
              <span class="ant-alert-description">
                <ng-container *nzStringTemplateOutlet="nzDescription">{{ nzDescription }}</ng-container>
              </span>
            }
          </div>
        }

        @if (nzAction) {
          <div class="ant-alert-action">
            <ng-container *nzStringTemplateOutlet="nzAction">{{ nzAction }}</ng-container>
          </div>
        }

        @if (nzCloseable || nzCloseText) {
          <button type="button" tabindex="0" class="ant-alert-close-icon" (click)="closeAlert()">
            @if (nzCloseText) {
              <ng-container *nzStringTemplateOutlet="nzCloseText">
                <span class="ant-alert-close-text">{{ nzCloseText }}</span>
              </ng-container>
            } @else {
              <span nz-icon nzType="close"></span>
            }
          </button>
        }
      </div>
    }
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      preserveWhitespaces: false
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzAction: [{
      type: Input
    }],
    nzCloseText: [{
      type: Input
    }],
    nzIconType: [{
      type: Input
    }],
    nzMessage: [{
      type: Input
    }],
    nzDescription: [{
      type: Input
    }],
    nzType: [{
      type: Input
    }],
    nzCloseable: [{
      type: Input
    }],
    nzShowIcon: [{
      type: Input
    }],
    nzBanner: [{
      type: Input
    }],
    nzNoAnimation: [{
      type: Input
    }],
    nzIcon: [{
      type: Input
    }],
    nzOnClose: [{
      type: Output
    }]
  });
})();
var _NzAlertModule = class _NzAlertModule {
};
_NzAlertModule.\u0275fac = function NzAlertModule_Factory(t) {
  return new (t || _NzAlertModule)();
};
_NzAlertModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzAlertModule
});
_NzAlertModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzAlertComponent]
});
var NzAlertModule = _NzAlertModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAlertModule, [{
    type: NgModule,
    args: [{
      exports: [NzAlertComponent],
      imports: [NzAlertComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-avatar.mjs
var _c034 = ["textEl"];
function NzAvatarComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzType", ctx_r0.nzIcon);
  }
}
function NzAvatarComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "img", 3);
    \u0275\u0275listener("error", function NzAvatarComponent_Conditional_1_Template_img_error_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.imgError($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("src", ctx_r1.nzSrc, \u0275\u0275sanitizeUrl);
    \u0275\u0275attribute("srcset", ctx_r1.nzSrcSet)("alt", ctx_r1.nzAlt);
  }
}
function NzAvatarComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 4, 5);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r2.nzText);
  }
}
var _c126 = ["*"];
var NZ_CONFIG_MODULE_NAME18 = "avatar";
var _NzAvatarComponent = class _NzAvatarComponent {
  constructor(nzConfigService, elementRef, cdr, platform, ngZone) {
    this.nzConfigService = nzConfigService;
    this.elementRef = elementRef;
    this.cdr = cdr;
    this.platform = platform;
    this.ngZone = ngZone;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME18;
    this.nzShape = "circle";
    this.nzSize = "default";
    this.nzGap = 4;
    this.nzError = new EventEmitter();
    this.hasText = false;
    this.hasSrc = true;
    this.hasIcon = false;
    this.classMap = {};
    this.customSize = null;
    this.el = this.elementRef.nativeElement;
  }
  imgError($event) {
    this.nzError.emit($event);
    if (!$event.defaultPrevented) {
      this.hasSrc = false;
      this.hasIcon = false;
      this.hasText = false;
      if (this.nzIcon) {
        this.hasIcon = true;
      } else if (this.nzText) {
        this.hasText = true;
      }
      this.cdr.detectChanges();
      this.setSizeStyle();
      this.notifyCalc();
    }
  }
  ngOnChanges() {
    this.hasText = !this.nzSrc && !!this.nzText;
    this.hasIcon = !this.nzSrc && !!this.nzIcon;
    this.hasSrc = !!this.nzSrc;
    this.setSizeStyle();
    this.notifyCalc();
  }
  calcStringSize() {
    if (!this.hasText) {
      return;
    }
    const textEl = this.textEl.nativeElement;
    const childrenWidth = textEl.offsetWidth;
    const avatarWidth = this.el.getBoundingClientRect().width;
    const offset = this.nzGap * 2 < avatarWidth ? this.nzGap * 2 : 8;
    const scale = avatarWidth - offset < childrenWidth ? (avatarWidth - offset) / childrenWidth : 1;
    textEl.style.transform = `scale(${scale}) translateX(-50%)`;
    textEl.style.lineHeight = this.customSize || "";
  }
  notifyCalc() {
    if (this.platform.isBrowser) {
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.calcStringSize();
        });
      });
    }
  }
  setSizeStyle() {
    if (typeof this.nzSize === "number") {
      this.customSize = `${this.nzSize}px`;
    } else {
      this.customSize = null;
    }
    this.cdr.markForCheck();
  }
};
_NzAvatarComponent.\u0275fac = function NzAvatarComponent_Factory(t) {
  return new (t || _NzAvatarComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(NgZone));
};
_NzAvatarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzAvatarComponent,
  selectors: [["nz-avatar"]],
  viewQuery: function NzAvatarComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c034, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.textEl = _t.first);
    }
  },
  hostAttrs: [1, "ant-avatar"],
  hostVars: 20,
  hostBindings: function NzAvatarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.customSize)("height", ctx.customSize)("line-height", ctx.customSize)("font-size", ctx.hasIcon && ctx.customSize ? ctx.nzSize / 2 : null, "px");
      \u0275\u0275classProp("ant-avatar-lg", ctx.nzSize === "large")("ant-avatar-sm", ctx.nzSize === "small")("ant-avatar-square", ctx.nzShape === "square")("ant-avatar-circle", ctx.nzShape === "circle")("ant-avatar-icon", ctx.nzIcon)("ant-avatar-image", ctx.hasSrc);
    }
  },
  inputs: {
    nzShape: "nzShape",
    nzSize: "nzSize",
    nzGap: "nzGap",
    nzText: "nzText",
    nzSrc: "nzSrc",
    nzSrcSet: "nzSrcSet",
    nzAlt: "nzAlt",
    nzIcon: "nzIcon"
  },
  outputs: {
    nzError: "nzError"
  },
  exportAs: ["nzAvatar"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 3,
  vars: 3,
  consts: [["nz-icon", "", 3, "nzType"], [3, "src"], ["class", "ant-avatar-string"], [3, "src", "error"], [1, "ant-avatar-string"], ["textEl", ""]],
  template: function NzAvatarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzAvatarComponent_Conditional_0_Template, 1, 1, "span", 0)(1, NzAvatarComponent_Conditional_1_Template, 1, 3, "img", 1)(2, NzAvatarComponent_Conditional_2_Template, 3, 1, "span", 2);
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, ctx.nzIcon && ctx.hasIcon ? 0 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx.nzSrc && ctx.hasSrc ? 1 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(2, ctx.nzText && ctx.hasText ? 2 : -1);
    }
  },
  dependencies: [NzIconModule, NzIconDirective, PlatformModule],
  encapsulation: 2,
  changeDetection: 0
});
var NzAvatarComponent = _NzAvatarComponent;
__decorate([WithConfig()], NzAvatarComponent.prototype, "nzShape", void 0);
__decorate([WithConfig()], NzAvatarComponent.prototype, "nzSize", void 0);
__decorate([WithConfig(), InputNumber()], NzAvatarComponent.prototype, "nzGap", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAvatarComponent, [{
    type: Component,
    args: [{
      selector: "nz-avatar",
      exportAs: "nzAvatar",
      standalone: true,
      imports: [NzIconModule, PlatformModule],
      template: `
    @if (nzIcon && hasIcon) {
      <span nz-icon [nzType]="nzIcon"></span>
    }
    @if (nzSrc && hasSrc) {
      <img [src]="nzSrc" [attr.srcset]="nzSrcSet" [attr.alt]="nzAlt" (error)="imgError($event)" />
    }
    @if (nzText && hasText) {
      <span class="ant-avatar-string" #textEl>{{ nzText }}</span>
    }
  `,
      host: {
        class: "ant-avatar",
        "[class.ant-avatar-lg]": `nzSize === 'large'`,
        "[class.ant-avatar-sm]": `nzSize === 'small'`,
        "[class.ant-avatar-square]": `nzShape === 'square'`,
        "[class.ant-avatar-circle]": `nzShape === 'circle'`,
        "[class.ant-avatar-icon]": `nzIcon`,
        "[class.ant-avatar-image]": `hasSrc `,
        "[style.width]": "customSize",
        "[style.height]": "customSize",
        "[style.line-height]": "customSize",
        // nzSize type is number when customSize is true
        "[style.font-size.px]": "(hasIcon && customSize) ? $any(nzSize) / 2 : null"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Platform
  }, {
    type: NgZone
  }], {
    nzShape: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzGap: [{
      type: Input
    }],
    nzText: [{
      type: Input
    }],
    nzSrc: [{
      type: Input
    }],
    nzSrcSet: [{
      type: Input
    }],
    nzAlt: [{
      type: Input
    }],
    nzIcon: [{
      type: Input
    }],
    nzError: [{
      type: Output
    }],
    textEl: [{
      type: ViewChild,
      args: ["textEl", {
        static: false
      }]
    }]
  });
})();
var _NzAvatarGroupComponent = class _NzAvatarGroupComponent {
};
_NzAvatarGroupComponent.\u0275fac = function NzAvatarGroupComponent_Factory(t) {
  return new (t || _NzAvatarGroupComponent)();
};
_NzAvatarGroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzAvatarGroupComponent,
  selectors: [["nz-avatar-group"]],
  hostAttrs: [1, "ant-avatar-group"],
  exportAs: ["nzAvatarGroup"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c126,
  decls: 1,
  vars: 0,
  template: function NzAvatarGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzAvatarGroupComponent = _NzAvatarGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAvatarGroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-avatar-group",
      exportAs: "nzAvatarGroup",
      standalone: true,
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "ant-avatar-group"
      }
    }]
  }], null, null);
})();
var _NzAvatarModule = class _NzAvatarModule {
};
_NzAvatarModule.\u0275fac = function NzAvatarModule_Factory(t) {
  return new (t || _NzAvatarModule)();
};
_NzAvatarModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzAvatarModule
});
_NzAvatarModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzAvatarComponent]
});
var NzAvatarModule = _NzAvatarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAvatarModule, [{
    type: NgModule,
    args: [{
      exports: [NzAvatarComponent, NzAvatarGroupComponent],
      imports: [NzAvatarComponent, NzAvatarGroupComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-popover.mjs
function NzPopoverComponent_ng_template_0_div_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r4.nzTitle);
  }
}
function NzPopoverComponent_ng_template_0_div_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275template(1, NzPopoverComponent_ng_template_0_div_6_ng_container_1_Template, 2, 1, "ng-container", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2.nzTitle);
  }
}
function NzPopoverComponent_ng_template_0_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r3.nzContent);
  }
}
function NzPopoverComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "div", 4);
    \u0275\u0275element(3, "span", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 6)(5, "div");
    \u0275\u0275template(6, NzPopoverComponent_ng_template_0_div_6_Template, 2, 1, "div", 7);
    \u0275\u0275elementStart(7, "div", 8);
    \u0275\u0275template(8, NzPopoverComponent_ng_template_0_ng_container_8_Template, 2, 1, "ng-container", 9);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-popover-rtl", ctx_r0.dir === "rtl");
    \u0275\u0275property("ngClass", ctx_r0._classMap)("ngStyle", ctx_r0.nzOverlayStyle)("@.disabled", !!(ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation))("nzNoAnimation", ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation)("@zoomBigMotion", "active");
    \u0275\u0275advance(6);
    \u0275\u0275property("ngIf", ctx_r0.nzTitle);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.nzContent);
  }
}
var NZ_CONFIG_MODULE_NAME19 = "popover";
var _NzPopoverDirective = class _NzPopoverDirective extends NzTooltipBaseDirective {
  getProxyPropertyMap() {
    return __spreadValues({
      nzPopoverBackdrop: ["nzBackdrop", () => this.nzPopoverBackdrop]
    }, super.getProxyPropertyMap());
  }
  constructor(elementRef, hostView, renderer, noAnimation, nzConfigService) {
    super(elementRef, hostView, renderer, noAnimation, nzConfigService);
    this._nzModuleName = NZ_CONFIG_MODULE_NAME19;
    this.trigger = "hover";
    this.placement = "top";
    this.nzPopoverBackdrop = false;
    this.visibleChange = new EventEmitter();
    this.componentRef = this.hostView.createComponent(NzPopoverComponent);
  }
};
_NzPopoverDirective.\u0275fac = function NzPopoverDirective_Factory(t) {
  return new (t || _NzPopoverDirective)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NzNoAnimationDirective, 9), \u0275\u0275directiveInject(NzConfigService));
};
_NzPopoverDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPopoverDirective,
  selectors: [["", "nz-popover", ""]],
  hostVars: 2,
  hostBindings: function NzPopoverDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-popover-open", ctx.visible);
    }
  },
  inputs: {
    arrowPointAtCenter: ["nzPopoverArrowPointAtCenter", "arrowPointAtCenter"],
    title: ["nzPopoverTitle", "title"],
    content: ["nzPopoverContent", "content"],
    directiveTitle: ["nz-popover", "directiveTitle"],
    trigger: ["nzPopoverTrigger", "trigger"],
    placement: ["nzPopoverPlacement", "placement"],
    origin: ["nzPopoverOrigin", "origin"],
    visible: ["nzPopoverVisible", "visible"],
    mouseEnterDelay: ["nzPopoverMouseEnterDelay", "mouseEnterDelay"],
    mouseLeaveDelay: ["nzPopoverMouseLeaveDelay", "mouseLeaveDelay"],
    overlayClassName: ["nzPopoverOverlayClassName", "overlayClassName"],
    overlayStyle: ["nzPopoverOverlayStyle", "overlayStyle"],
    nzPopoverBackdrop: "nzPopoverBackdrop"
  },
  outputs: {
    visibleChange: "nzPopoverVisibleChange"
  },
  exportAs: ["nzPopover"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature]
});
var NzPopoverDirective = _NzPopoverDirective;
__decorate([InputBoolean()], NzPopoverDirective.prototype, "arrowPointAtCenter", void 0);
__decorate([WithConfig()], NzPopoverDirective.prototype, "nzPopoverBackdrop", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPopoverDirective, [{
    type: Directive,
    args: [{
      selector: "[nz-popover]",
      exportAs: "nzPopover",
      host: {
        "[class.ant-popover-open]": "visible"
      },
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: Renderer2
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }, {
    type: NzConfigService
  }], {
    arrowPointAtCenter: [{
      type: Input,
      args: ["nzPopoverArrowPointAtCenter"]
    }],
    title: [{
      type: Input,
      args: ["nzPopoverTitle"]
    }],
    content: [{
      type: Input,
      args: ["nzPopoverContent"]
    }],
    directiveTitle: [{
      type: Input,
      args: ["nz-popover"]
    }],
    trigger: [{
      type: Input,
      args: ["nzPopoverTrigger"]
    }],
    placement: [{
      type: Input,
      args: ["nzPopoverPlacement"]
    }],
    origin: [{
      type: Input,
      args: ["nzPopoverOrigin"]
    }],
    visible: [{
      type: Input,
      args: ["nzPopoverVisible"]
    }],
    mouseEnterDelay: [{
      type: Input,
      args: ["nzPopoverMouseEnterDelay"]
    }],
    mouseLeaveDelay: [{
      type: Input,
      args: ["nzPopoverMouseLeaveDelay"]
    }],
    overlayClassName: [{
      type: Input,
      args: ["nzPopoverOverlayClassName"]
    }],
    overlayStyle: [{
      type: Input,
      args: ["nzPopoverOverlayStyle"]
    }],
    nzPopoverBackdrop: [{
      type: Input
    }],
    visibleChange: [{
      type: Output,
      args: ["nzPopoverVisibleChange"]
    }]
  });
})();
var _NzPopoverComponent = class _NzPopoverComponent extends NzToolTipComponent {
  constructor(cdr, directionality, noAnimation) {
    super(cdr, directionality, noAnimation);
    this._prefix = "ant-popover";
  }
  get hasBackdrop() {
    return this.nzTrigger === "click" ? this.nzBackdrop : false;
  }
  isEmpty() {
    return isTooltipEmpty(this.nzTitle) && isTooltipEmpty(this.nzContent);
  }
};
_NzPopoverComponent.\u0275fac = function NzPopoverComponent_Factory(t) {
  return new (t || _NzPopoverComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzPopoverComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzPopoverComponent,
  selectors: [["nz-popover"]],
  exportAs: ["nzPopoverComponent"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature],
  decls: 2,
  vars: 6,
  consts: [["cdkConnectedOverlay", "", "nzConnectedOverlay", "", 3, "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPush", "nzArrowPointAtCenter", "overlayOutsideClick", "detach", "positionChange"], ["overlay", "cdkConnectedOverlay"], [1, "ant-popover", 3, "ngClass", "ngStyle", "nzNoAnimation"], [1, "ant-popover-content"], [1, "ant-popover-arrow"], [1, "ant-popover-arrow-content"], ["role", "tooltip", 1, "ant-popover-inner"], ["class", "ant-popover-title", 4, "ngIf"], [1, "ant-popover-inner-content"], [4, "nzStringTemplateOutlet"], [1, "ant-popover-title"]],
  template: function NzPopoverComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzPopoverComponent_ng_template_0_Template, 9, 9, "ng-template", 0, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275listener("overlayOutsideClick", function NzPopoverComponent_Template_ng_template_overlayOutsideClick_0_listener($event) {
        return ctx.onClickOutside($event);
      })("detach", function NzPopoverComponent_Template_ng_template_detach_0_listener() {
        return ctx.hide();
      })("positionChange", function NzPopoverComponent_Template_ng_template_positionChange_0_listener($event) {
        return ctx.onPositionChange($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275property("cdkConnectedOverlayHasBackdrop", ctx.hasBackdrop)("cdkConnectedOverlayOrigin", ctx.origin)("cdkConnectedOverlayPositions", ctx._positions)("cdkConnectedOverlayOpen", ctx._visible)("cdkConnectedOverlayPush", ctx.cdkConnectedOverlayPush)("nzArrowPointAtCenter", ctx.nzArrowPointAtCenter);
    }
  },
  dependencies: [OverlayModule, CdkConnectedOverlay, NzOverlayModule, NzConnectedOverlayDirective, NgClass, NgStyle, NzNoAnimationDirective, NgIf, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  data: {
    animation: [zoomBigMotion]
  },
  changeDetection: 0
});
var NzPopoverComponent = _NzPopoverComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPopoverComponent, [{
    type: Component,
    args: [{
      selector: "nz-popover",
      exportAs: "nzPopoverComponent",
      animations: [zoomBigMotion],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      preserveWhitespaces: false,
      template: `
    <ng-template
      #overlay="cdkConnectedOverlay"
      cdkConnectedOverlay
      nzConnectedOverlay
      [cdkConnectedOverlayHasBackdrop]="hasBackdrop"
      [cdkConnectedOverlayOrigin]="origin"
      [cdkConnectedOverlayPositions]="_positions"
      [cdkConnectedOverlayOpen]="_visible"
      [cdkConnectedOverlayPush]="cdkConnectedOverlayPush"
      [nzArrowPointAtCenter]="nzArrowPointAtCenter"
      (overlayOutsideClick)="onClickOutside($event)"
      (detach)="hide()"
      (positionChange)="onPositionChange($event)"
    >
      <div
        class="ant-popover"
        [class.ant-popover-rtl]="dir === 'rtl'"
        [ngClass]="_classMap"
        [ngStyle]="nzOverlayStyle"
        [@.disabled]="!!noAnimation?.nzNoAnimation"
        [nzNoAnimation]="noAnimation?.nzNoAnimation"
        [@zoomBigMotion]="'active'"
      >
        <div class="ant-popover-content">
          <div class="ant-popover-arrow">
            <span class="ant-popover-arrow-content"></span>
          </div>
          <div class="ant-popover-inner" role="tooltip">
            <div>
              <div class="ant-popover-title" *ngIf="nzTitle">
                <ng-container *nzStringTemplateOutlet="nzTitle">{{ nzTitle }}</ng-container>
              </div>
              <div class="ant-popover-inner-content">
                <ng-container *nzStringTemplateOutlet="nzContent">{{ nzContent }}</ng-container>
              </div>
            </div>
          </div>
        </div>
      </div>
    </ng-template>
  `,
      imports: [OverlayModule, NzOverlayModule, NgClass, NgStyle, NzNoAnimationDirective, NgIf, NzOutletModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], null);
})();
var _NzPopoverModule = class _NzPopoverModule {
};
_NzPopoverModule.\u0275fac = function NzPopoverModule_Factory(t) {
  return new (t || _NzPopoverModule)();
};
_NzPopoverModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzPopoverModule
});
_NzPopoverModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzPopoverComponent]
});
var NzPopoverModule = _NzPopoverModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [NzPopoverDirective, NzPopoverComponent],
      exports: [NzPopoverDirective, NzPopoverComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-progress.mjs
function NzProgressComponent_ng_template_0_span_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 8);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", ctx_r5.icon);
  }
}
function NzProgressComponent_ng_template_0_span_0_ng_template_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const formatter_r9 = ctx.$implicit;
    const ctx_r8 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", formatter_r9(ctx_r8.nzPercent), " ");
  }
}
var _c035 = (a0) => ({
  $implicit: a0
});
function NzProgressComponent_ng_template_0_span_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzProgressComponent_ng_template_0_span_0_ng_template_2_ng_container_0_Template, 2, 1, "ng-container", 9);
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(3);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r6.formatter)("nzStringTemplateOutletContext", \u0275\u0275pureFunction1(2, _c035, ctx_r6.nzPercent));
  }
}
function NzProgressComponent_ng_template_0_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 5);
    \u0275\u0275template(1, NzProgressComponent_ng_template_0_span_0_ng_container_1_Template, 2, 1, "ng-container", 6)(2, NzProgressComponent_ng_template_0_span_0_ng_template_2_Template, 1, 4, "ng-template", null, 7, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _r7 = \u0275\u0275reference(3);
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", (ctx_r4.status === "exception" || ctx_r4.status === "success") && !ctx_r4.nzFormat)("ngIfElse", _r7);
  }
}
function NzProgressComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzProgressComponent_ng_template_0_span_0_Template, 4, 2, "span", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r0.nzShowInfo);
  }
}
function NzProgressComponent_div_3_ng_container_1_div_1_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 17);
  }
  if (rf & 2) {
    const ctx_r14 = \u0275\u0275nextContext(4);
    \u0275\u0275styleProp("width", ctx_r14.nzSuccessPercent, "%")("border-radius", ctx_r14.nzStrokeLinecap === "round" ? "100px" : "0")("height", ctx_r14.strokeWidth, "px");
  }
}
function NzProgressComponent_div_3_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13)(1, "div", 14);
    \u0275\u0275element(2, "div", 15);
    \u0275\u0275template(3, NzProgressComponent_div_3_ng_container_1_div_1_div_3_Template, 1, 6, "div", 16);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r12 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275styleProp("width", ctx_r12.nzPercent, "%")("border-radius", ctx_r12.nzStrokeLinecap === "round" ? "100px" : "0")("background", !ctx_r12.isGradient ? ctx_r12.nzStrokeColor : null)("background-image", ctx_r12.isGradient ? ctx_r12.lineGradient : null)("height", ctx_r12.strokeWidth, "px");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r12.nzSuccessPercent || ctx_r12.nzSuccessPercent === 0);
  }
}
function NzProgressComponent_div_3_ng_container_1_ng_template_2_Template(rf, ctx) {
}
function NzProgressComponent_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzProgressComponent_div_3_ng_container_1_div_1_Template, 4, 11, "div", 11)(2, NzProgressComponent_div_3_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 12);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r10.isSteps);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function NzProgressComponent_div_3_div_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 20);
  }
  if (rf & 2) {
    const step_r17 = ctx.$implicit;
    \u0275\u0275property("ngStyle", step_r17);
  }
}
function NzProgressComponent_div_3_div_2_ng_template_2_Template(rf, ctx) {
}
function NzProgressComponent_div_3_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18);
    \u0275\u0275template(1, NzProgressComponent_div_3_div_2_div_1_Template, 1, 1, "div", 19)(2, NzProgressComponent_div_3_div_2_ng_template_2_Template, 0, 0, "ng-template", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r11 = \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r11.steps);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function NzProgressComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275template(1, NzProgressComponent_div_3_ng_container_1_Template, 3, 2, "ng-container", 2)(2, NzProgressComponent_div_3_div_2_Template, 3, 2, "div", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r2.isSteps);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.isSteps);
  }
}
function NzProgressComponent_div_4__svg_defs_2__svg_stop_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "stop");
  }
  if (rf & 2) {
    const i_r23 = ctx.$implicit;
    \u0275\u0275attribute("offset", i_r23.offset)("stop-color", i_r23.color);
  }
}
function NzProgressComponent_div_4__svg_defs_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs")(1, "linearGradient", 24);
    \u0275\u0275template(2, NzProgressComponent_div_4__svg_defs_2__svg_stop_2_Template, 1, 2, "stop", 25);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r19 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("id", "gradient-" + ctx_r19.gradientId);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r19.circleGradient);
  }
}
function NzProgressComponent_div_4__svg_path_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "path", 26);
  }
  if (rf & 2) {
    const p_r24 = ctx.$implicit;
    const ctx_r20 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngStyle", p_r24.strokePathStyle);
    \u0275\u0275attribute("d", ctx_r20.pathString)("stroke-linecap", ctx_r20.nzStrokeLinecap)("stroke", p_r24.stroke)("stroke-width", ctx_r20.nzPercent ? ctx_r20.strokeWidth : 0);
  }
}
function NzProgressComponent_div_4_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
  }
}
function NzProgressComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14);
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(1, "svg", 21);
    \u0275\u0275template(2, NzProgressComponent_div_4__svg_defs_2_Template, 3, 2, "defs", 2);
    \u0275\u0275element(3, "path", 22);
    \u0275\u0275template(4, NzProgressComponent_div_4__svg_path_4_Template, 1, 5, "path", 23);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, NzProgressComponent_div_4_ng_template_5_Template, 0, 0, "ng-template", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275styleProp("width", ctx_r3.nzWidth, "px")("height", ctx_r3.nzWidth, "px")("font-size", ctx_r3.nzWidth * 0.15 + 6, "px");
    \u0275\u0275classProp("ant-progress-circle-gradient", ctx_r3.isGradient);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r3.isGradient);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngStyle", ctx_r3.trailPathStyle);
    \u0275\u0275attribute("stroke-width", ctx_r3.strokeWidth)("d", ctx_r3.pathString);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r3.progressCirclePath)("ngForTrackBy", ctx_r3.trackByFn);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1);
  }
}
function stripPercentToNumber(percent) {
  return +percent.replace("%", "");
}
var sortGradient = (gradients) => {
  let tempArr = [];
  Object.keys(gradients).forEach((key) => {
    const value = gradients[key];
    const formatKey = stripPercentToNumber(key);
    if (!isNaN(formatKey)) {
      tempArr.push({
        key: formatKey,
        value
      });
    }
  });
  tempArr = tempArr.sort((a, b) => a.key - b.key);
  return tempArr;
};
var handleCircleGradient = (strokeColor) => sortGradient(strokeColor).map(({
  key,
  value
}) => ({
  offset: `${key}%`,
  color: value
}));
var handleLinearGradient = (strokeColor) => {
  const _a = strokeColor, {
    from: from2 = "#1890ff",
    to = "#1890ff",
    direction = "to right"
  } = _a, rest = __objRest(_a, [
    "from",
    "to",
    "direction"
  ]);
  if (Object.keys(rest).length !== 0) {
    const sortedGradients = sortGradient(rest).map(({
      key,
      value
    }) => `${value} ${key}%`).join(", ");
    return `linear-gradient(${direction}, ${sortedGradients})`;
  }
  return `linear-gradient(${direction}, ${from2}, ${to})`;
};
var gradientIdSeed = 0;
var NZ_CONFIG_MODULE_NAME20 = "progress";
var statusIconNameMap = /* @__PURE__ */ new Map([["success", "check"], ["exception", "close"]]);
var statusColorMap = /* @__PURE__ */ new Map([["normal", "#108ee9"], ["exception", "#ff5500"], ["success", "#87d068"]]);
var defaultFormatter = (p) => `${p}%`;
var _NzProgressComponent = class _NzProgressComponent {
  get formatter() {
    return this.nzFormat || defaultFormatter;
  }
  get status() {
    return this.nzStatus || this.inferredStatus;
  }
  get strokeWidth() {
    return this.nzStrokeWidth || (this.nzType === "line" && this.nzSize !== "small" ? 8 : 6);
  }
  get isCircleStyle() {
    return this.nzType === "circle" || this.nzType === "dashboard";
  }
  constructor(cdr, nzConfigService, directionality) {
    this.cdr = cdr;
    this.nzConfigService = nzConfigService;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME20;
    this.nzShowInfo = true;
    this.nzWidth = 132;
    this.nzStrokeColor = void 0;
    this.nzSize = "default";
    this.nzPercent = 0;
    this.nzStrokeWidth = void 0;
    this.nzGapDegree = void 0;
    this.nzType = "line";
    this.nzGapPosition = "top";
    this.nzStrokeLinecap = "round";
    this.nzSteps = 0;
    this.steps = [];
    this.lineGradient = null;
    this.isGradient = false;
    this.isSteps = false;
    this.gradientId = gradientIdSeed++;
    this.progressCirclePath = [];
    this.trailPathStyle = null;
    this.dir = "ltr";
    this.trackByFn = (index) => `${index}`;
    this.cachedStatus = "normal";
    this.inferredStatus = "normal";
    this.destroy$ = new Subject();
  }
  ngOnChanges(changes) {
    const {
      nzSteps,
      nzGapPosition,
      nzStrokeLinecap,
      nzStrokeColor,
      nzGapDegree,
      nzType,
      nzStatus,
      nzPercent,
      nzSuccessPercent,
      nzStrokeWidth
    } = changes;
    if (nzStatus) {
      this.cachedStatus = this.nzStatus || this.cachedStatus;
    }
    if (nzPercent || nzSuccessPercent) {
      const fillAll = parseInt(this.nzPercent.toString(), 10) >= 100;
      if (fillAll) {
        if (isNotNil(this.nzSuccessPercent) && this.nzSuccessPercent >= 100 || this.nzSuccessPercent === void 0) {
          this.inferredStatus = "success";
        }
      } else {
        this.inferredStatus = this.cachedStatus;
      }
    }
    if (nzStatus || nzPercent || nzSuccessPercent || nzStrokeColor) {
      this.updateIcon();
    }
    if (nzStrokeColor) {
      this.setStrokeColor();
    }
    if (nzGapPosition || nzStrokeLinecap || nzGapDegree || nzType || nzPercent || nzStrokeColor || nzStrokeColor) {
      this.getCirclePaths();
    }
    if (nzPercent || nzSteps || nzStrokeWidth) {
      this.isSteps = this.nzSteps > 0;
      if (this.isSteps) {
        this.getSteps();
      }
    }
  }
  ngOnInit() {
    this.nzConfigService.getConfigChangeEventForComponent(NZ_CONFIG_MODULE_NAME20).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.updateIcon();
      this.setStrokeColor();
      this.getCirclePaths();
    });
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  updateIcon() {
    const ret = statusIconNameMap.get(this.status);
    this.icon = ret ? ret + (this.isCircleStyle ? "-o" : "-circle-fill") : "";
  }
  /**
   * Calculate step render configs.
   */
  getSteps() {
    const current = Math.floor(this.nzSteps * (this.nzPercent / 100));
    const stepWidth = this.nzSize === "small" ? 2 : 14;
    const steps = [];
    for (let i = 0; i < this.nzSteps; i++) {
      let color;
      if (i <= current - 1) {
        color = this.nzStrokeColor;
      }
      const stepStyle = {
        backgroundColor: `${color}`,
        width: `${stepWidth}px`,
        height: `${this.strokeWidth}px`
      };
      steps.push(stepStyle);
    }
    this.steps = steps;
  }
  /**
   * Calculate paths when the type is circle or dashboard.
   */
  getCirclePaths() {
    if (!this.isCircleStyle) {
      return;
    }
    const values = isNotNil(this.nzSuccessPercent) ? [this.nzSuccessPercent, this.nzPercent] : [this.nzPercent];
    const radius = 50 - this.strokeWidth / 2;
    const gapPosition = this.nzGapPosition || (this.nzType === "circle" ? "top" : "bottom");
    const len = Math.PI * 2 * radius;
    const gapDegree = this.nzGapDegree || (this.nzType === "circle" ? 0 : 75);
    let beginPositionX = 0;
    let beginPositionY = -radius;
    let endPositionX = 0;
    let endPositionY = radius * -2;
    switch (gapPosition) {
      case "left":
        beginPositionX = -radius;
        beginPositionY = 0;
        endPositionX = radius * 2;
        endPositionY = 0;
        break;
      case "right":
        beginPositionX = radius;
        beginPositionY = 0;
        endPositionX = radius * -2;
        endPositionY = 0;
        break;
      case "bottom":
        beginPositionY = radius;
        endPositionY = radius * 2;
        break;
      default:
    }
    this.pathString = `M 50,50 m ${beginPositionX},${beginPositionY}
       a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
       a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
    this.trailPathStyle = {
      strokeDasharray: `${len - gapDegree}px ${len}px`,
      strokeDashoffset: `-${gapDegree / 2}px`,
      transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s"
    };
    this.progressCirclePath = values.map((value, index) => {
      const isSuccessPercent = values.length === 2 && index === 0;
      return {
        stroke: this.isGradient && !isSuccessPercent ? `url(#gradient-${this.gradientId})` : null,
        strokePathStyle: {
          stroke: !this.isGradient ? isSuccessPercent ? statusColorMap.get("success") : this.nzStrokeColor : null,
          transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s",
          strokeDasharray: `${(value || 0) / 100 * (len - gapDegree)}px ${len}px`,
          strokeDashoffset: `-${gapDegree / 2}px`
        }
      };
    }).reverse();
  }
  setStrokeColor() {
    const color = this.nzStrokeColor;
    const isGradient = this.isGradient = !!color && typeof color !== "string";
    if (isGradient && !this.isCircleStyle) {
      this.lineGradient = handleLinearGradient(color);
    } else if (isGradient && this.isCircleStyle) {
      this.circleGradient = handleCircleGradient(this.nzStrokeColor);
    } else {
      this.lineGradient = null;
      this.circleGradient = [];
    }
  }
};
_NzProgressComponent.\u0275fac = function NzProgressComponent_Factory(t) {
  return new (t || _NzProgressComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(Directionality, 8));
};
_NzProgressComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzProgressComponent,
  selectors: [["nz-progress"]],
  inputs: {
    nzShowInfo: "nzShowInfo",
    nzWidth: "nzWidth",
    nzStrokeColor: "nzStrokeColor",
    nzSize: "nzSize",
    nzFormat: "nzFormat",
    nzSuccessPercent: "nzSuccessPercent",
    nzPercent: "nzPercent",
    nzStrokeWidth: "nzStrokeWidth",
    nzGapDegree: "nzGapDegree",
    nzStatus: "nzStatus",
    nzType: "nzType",
    nzGapPosition: "nzGapPosition",
    nzStrokeLinecap: "nzStrokeLinecap",
    nzSteps: "nzSteps"
  },
  exportAs: ["nzProgress"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 5,
  vars: 17,
  consts: [["progressInfoTemplate", ""], [3, "ngClass"], [4, "ngIf"], ["class", "ant-progress-inner", 3, "width", "height", "fontSize", "ant-progress-circle-gradient", 4, "ngIf"], ["class", "ant-progress-text", 4, "ngIf"], [1, "ant-progress-text"], [4, "ngIf", "ngIfElse"], ["formatTemplate", ""], ["nz-icon", "", 3, "nzType"], [4, "nzStringTemplateOutlet", "nzStringTemplateOutletContext"], ["class", "ant-progress-steps-outer", 4, "ngIf"], ["class", "ant-progress-outer", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "ant-progress-outer"], [1, "ant-progress-inner"], [1, "ant-progress-bg"], ["class", "ant-progress-success-bg", 3, "width", "border-radius", "height", 4, "ngIf"], [1, "ant-progress-success-bg"], [1, "ant-progress-steps-outer"], ["class", "ant-progress-steps-item", 3, "ngStyle", 4, "ngFor", "ngForOf"], [1, "ant-progress-steps-item", 3, "ngStyle"], ["viewBox", "0 0 100 100", 1, "ant-progress-circle"], ["stroke", "#f3f3f3", "fill-opacity", "0", 1, "ant-progress-circle-trail", 3, "ngStyle"], ["class", "ant-progress-circle-path", "fill-opacity", "0", 3, "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["x1", "100%", "y1", "0%", "x2", "0%", "y2", "0%", 3, "id"], [4, "ngFor", "ngForOf"], ["fill-opacity", "0", 1, "ant-progress-circle-path", 3, "ngStyle"]],
  template: function NzProgressComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzProgressComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(2, "div", 1);
      \u0275\u0275template(3, NzProgressComponent_div_3_Template, 3, 2, "div", 2)(4, NzProgressComponent_div_4_Template, 6, 15, "div", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275classProp("ant-progress-line", ctx.nzType === "line")("ant-progress-small", ctx.nzSize === "small")("ant-progress-default", ctx.nzSize === "default")("ant-progress-show-info", ctx.nzShowInfo)("ant-progress-circle", ctx.isCircleStyle)("ant-progress-steps", ctx.isSteps)("ant-progress-rtl", ctx.dir === "rtl");
      \u0275\u0275property("ngClass", "ant-progress ant-progress-status-" + ctx.status);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzType === "line");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.isCircleStyle);
    }
  },
  dependencies: [NgIf, NzIconModule, NzIconDirective, NzOutletModule, NzStringTemplateOutletDirective, NgClass, NgTemplateOutlet, NgForOf, NgStyle],
  encapsulation: 2,
  changeDetection: 0
});
var NzProgressComponent = _NzProgressComponent;
__decorate([WithConfig()], NzProgressComponent.prototype, "nzShowInfo", void 0);
__decorate([WithConfig()], NzProgressComponent.prototype, "nzStrokeColor", void 0);
__decorate([WithConfig()], NzProgressComponent.prototype, "nzSize", void 0);
__decorate([InputNumber()], NzProgressComponent.prototype, "nzSuccessPercent", void 0);
__decorate([InputNumber()], NzProgressComponent.prototype, "nzPercent", void 0);
__decorate([WithConfig(), InputNumber()], NzProgressComponent.prototype, "nzStrokeWidth", void 0);
__decorate([WithConfig(), InputNumber()], NzProgressComponent.prototype, "nzGapDegree", void 0);
__decorate([WithConfig()], NzProgressComponent.prototype, "nzGapPosition", void 0);
__decorate([WithConfig()], NzProgressComponent.prototype, "nzStrokeLinecap", void 0);
__decorate([InputNumber()], NzProgressComponent.prototype, "nzSteps", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzProgressComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-progress",
      exportAs: "nzProgress",
      preserveWhitespaces: false,
      standalone: true,
      imports: [NgIf, NzIconModule, NzOutletModule, NgClass, NgTemplateOutlet, NgForOf, NgStyle],
      template: `
    <ng-template #progressInfoTemplate>
      <span class="ant-progress-text" *ngIf="nzShowInfo">
        <ng-container *ngIf="(status === 'exception' || status === 'success') && !nzFormat; else formatTemplate">
          <span nz-icon [nzType]="icon"></span>
        </ng-container>
        <ng-template #formatTemplate>
          <ng-container *nzStringTemplateOutlet="formatter; context: { $implicit: nzPercent }; let formatter">
            {{ formatter(nzPercent) }}
          </ng-container>
        </ng-template>
      </span>
    </ng-template>

    <div
      [ngClass]="'ant-progress ant-progress-status-' + status"
      [class.ant-progress-line]="nzType === 'line'"
      [class.ant-progress-small]="nzSize === 'small'"
      [class.ant-progress-default]="nzSize === 'default'"
      [class.ant-progress-show-info]="nzShowInfo"
      [class.ant-progress-circle]="isCircleStyle"
      [class.ant-progress-steps]="isSteps"
      [class.ant-progress-rtl]="dir === 'rtl'"
    >
      <!-- line progress -->
      <div *ngIf="nzType === 'line'">
        <!-- normal line style -->
        <ng-container *ngIf="!isSteps">
          <div class="ant-progress-outer" *ngIf="!isSteps">
            <div class="ant-progress-inner">
              <div
                class="ant-progress-bg"
                [style.width.%]="nzPercent"
                [style.border-radius]="nzStrokeLinecap === 'round' ? '100px' : '0'"
                [style.background]="!isGradient ? nzStrokeColor : null"
                [style.background-image]="isGradient ? lineGradient : null"
                [style.height.px]="strokeWidth"
              ></div>
              <div
                *ngIf="nzSuccessPercent || nzSuccessPercent === 0"
                class="ant-progress-success-bg"
                [style.width.%]="nzSuccessPercent"
                [style.border-radius]="nzStrokeLinecap === 'round' ? '100px' : '0'"
                [style.height.px]="strokeWidth"
              ></div>
            </div>
          </div>
          <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
        </ng-container>
        <!-- step style -->
        <div class="ant-progress-steps-outer" *ngIf="isSteps">
          <div *ngFor="let step of steps; let i = index" class="ant-progress-steps-item" [ngStyle]="step"></div>
          <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
        </div>
      </div>

      <!-- circle / dashboard progress -->
      <div
        [style.width.px]="this.nzWidth"
        [style.height.px]="this.nzWidth"
        [style.fontSize.px]="this.nzWidth * 0.15 + 6"
        class="ant-progress-inner"
        [class.ant-progress-circle-gradient]="isGradient"
        *ngIf="isCircleStyle"
      >
        <svg class="ant-progress-circle " viewBox="0 0 100 100">
          <defs *ngIf="isGradient">
            <linearGradient [id]="'gradient-' + gradientId" x1="100%" y1="0%" x2="0%" y2="0%">
              <stop *ngFor="let i of circleGradient" [attr.offset]="i.offset" [attr.stop-color]="i.color"></stop>
            </linearGradient>
          </defs>
          <path
            class="ant-progress-circle-trail"
            stroke="#f3f3f3"
            fill-opacity="0"
            [attr.stroke-width]="strokeWidth"
            [attr.d]="pathString"
            [ngStyle]="trailPathStyle"
          ></path>
          <path
            *ngFor="let p of progressCirclePath; trackBy: trackByFn"
            class="ant-progress-circle-path"
            fill-opacity="0"
            [attr.d]="pathString"
            [attr.stroke-linecap]="nzStrokeLinecap"
            [attr.stroke]="p.stroke"
            [attr.stroke-width]="nzPercent ? strokeWidth : 0"
            [ngStyle]="p.strokePathStyle"
          ></path>
        </svg>
        <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template>
      </div>
    </div>
  `
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzConfigService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzShowInfo: [{
      type: Input
    }],
    nzWidth: [{
      type: Input
    }],
    nzStrokeColor: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzFormat: [{
      type: Input
    }],
    nzSuccessPercent: [{
      type: Input
    }],
    nzPercent: [{
      type: Input
    }],
    nzStrokeWidth: [{
      type: Input
    }],
    nzGapDegree: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzType: [{
      type: Input
    }],
    nzGapPosition: [{
      type: Input
    }],
    nzStrokeLinecap: [{
      type: Input
    }],
    nzSteps: [{
      type: Input
    }]
  });
})();
var _NzProgressModule = class _NzProgressModule {
};
_NzProgressModule.\u0275fac = function NzProgressModule_Factory(t) {
  return new (t || _NzProgressModule)();
};
_NzProgressModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzProgressModule
});
_NzProgressModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzProgressComponent]
});
var NzProgressModule = _NzProgressModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzProgressModule, [{
    type: NgModule,
    args: [{
      imports: [NzProgressComponent],
      exports: [NzProgressComponent]
    }]
  }], null, null);
})();

// src/app/shared/shared-zorro.module.ts
var SHARED_ZORRO_MODULES = [
  NzFormModule,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule
];

// src/app/shared/shared-imports.ts
var SHARED_IMPORTS = [
  FormsModule,
  ReactiveFormsModule,
  RouterLink,
  NgTemplateOutlet,
  NgClass,
  NgStyle,
  I18nPipe,
  DatePipe,
  ...SHARED_DELON_MODULES,
  ...SHARED_ZORRO_MODULES
];

// node_modules/ng-apexcharts/fesm2020/ng-apexcharts.mjs
var import_apexcharts = __toESM(require_apexcharts_common(), 1);
var _c036 = ["chart"];
var ChartComponent = class {
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.autoUpdateSeries = true;
  }
  ngOnChanges(changes) {
    asapScheduler.schedule(() => {
      if (this.autoUpdateSeries && Object.keys(changes).filter((c) => c !== "series").length === 0) {
        this.updateSeries(this.series, true);
        return;
      }
      this.createElement();
    });
  }
  ngOnDestroy() {
    if (this.chartObj) {
      this.chartObj.destroy();
    }
  }
  createElement() {
    const options = {};
    if (this.annotations) {
      options.annotations = this.annotations;
    }
    if (this.chart) {
      options.chart = this.chart;
    }
    if (this.colors) {
      options.colors = this.colors;
    }
    if (this.dataLabels) {
      options.dataLabels = this.dataLabels;
    }
    if (this.series) {
      options.series = this.series;
    }
    if (this.stroke) {
      options.stroke = this.stroke;
    }
    if (this.labels) {
      options.labels = this.labels;
    }
    if (this.legend) {
      options.legend = this.legend;
    }
    if (this.fill) {
      options.fill = this.fill;
    }
    if (this.tooltip) {
      options.tooltip = this.tooltip;
    }
    if (this.plotOptions) {
      options.plotOptions = this.plotOptions;
    }
    if (this.responsive) {
      options.responsive = this.responsive;
    }
    if (this.markers) {
      options.markers = this.markers;
    }
    if (this.noData) {
      options.noData = this.noData;
    }
    if (this.xaxis) {
      options.xaxis = this.xaxis;
    }
    if (this.yaxis) {
      options.yaxis = this.yaxis;
    }
    if (this.forecastDataPoints) {
      options.forecastDataPoints = this.forecastDataPoints;
    }
    if (this.grid) {
      options.grid = this.grid;
    }
    if (this.states) {
      options.states = this.states;
    }
    if (this.title) {
      options.title = this.title;
    }
    if (this.subtitle) {
      options.subtitle = this.subtitle;
    }
    if (this.theme) {
      options.theme = this.theme;
    }
    if (this.chartObj) {
      this.chartObj.destroy();
    }
    this.ngZone.runOutsideAngular(() => {
      this.chartObj = new import_apexcharts.default(this.chartElement.nativeElement, options);
    });
    this.render();
  }
  render() {
    return this.ngZone.runOutsideAngular(() => this.chartObj.render());
  }
  updateOptions(options, redrawPaths, animate2, updateSyncedCharts) {
    return this.ngZone.runOutsideAngular(() => this.chartObj.updateOptions(options, redrawPaths, animate2, updateSyncedCharts));
  }
  updateSeries(newSeries, animate2) {
    return this.ngZone.runOutsideAngular(() => this.chartObj.updateSeries(newSeries, animate2));
  }
  appendSeries(newSeries, animate2) {
    this.ngZone.runOutsideAngular(() => this.chartObj.appendSeries(newSeries, animate2));
  }
  appendData(newData) {
    this.ngZone.runOutsideAngular(() => this.chartObj.appendData(newData));
  }
  toggleSeries(seriesName) {
    return this.ngZone.runOutsideAngular(() => this.chartObj.toggleSeries(seriesName));
  }
  showSeries(seriesName) {
    this.ngZone.runOutsideAngular(() => this.chartObj.showSeries(seriesName));
  }
  hideSeries(seriesName) {
    this.ngZone.runOutsideAngular(() => this.chartObj.hideSeries(seriesName));
  }
  resetSeries() {
    this.ngZone.runOutsideAngular(() => this.chartObj.resetSeries());
  }
  zoomX(min, max) {
    this.ngZone.runOutsideAngular(() => this.chartObj.zoomX(min, max));
  }
  toggleDataPointSelection(seriesIndex, dataPointIndex) {
    this.ngZone.runOutsideAngular(() => this.chartObj.toggleDataPointSelection(seriesIndex, dataPointIndex));
  }
  destroy() {
    this.chartObj.destroy();
  }
  setLocale(localeName) {
    this.ngZone.runOutsideAngular(() => this.chartObj.setLocale(localeName));
  }
  paper() {
    this.ngZone.runOutsideAngular(() => this.chartObj.paper());
  }
  addXaxisAnnotation(options, pushToMemory, context) {
    this.ngZone.runOutsideAngular(() => this.chartObj.addXaxisAnnotation(options, pushToMemory, context));
  }
  addYaxisAnnotation(options, pushToMemory, context) {
    this.ngZone.runOutsideAngular(() => this.chartObj.addYaxisAnnotation(options, pushToMemory, context));
  }
  addPointAnnotation(options, pushToMemory, context) {
    this.ngZone.runOutsideAngular(() => this.chartObj.addPointAnnotation(options, pushToMemory, context));
  }
  removeAnnotation(id, options) {
    this.ngZone.runOutsideAngular(() => this.chartObj.removeAnnotation(id, options));
  }
  clearAnnotations(options) {
    this.ngZone.runOutsideAngular(() => this.chartObj.clearAnnotations(options));
  }
  dataURI(options) {
    return this.chartObj.dataURI(options);
  }
};
ChartComponent.\u0275fac = function ChartComponent_Factory(t) {
  return new (t || ChartComponent)(\u0275\u0275directiveInject(NgZone));
};
ChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: ChartComponent,
  selectors: [["apx-chart"]],
  viewQuery: function ChartComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c036, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chartElement = _t.first);
    }
  },
  inputs: {
    chart: "chart",
    annotations: "annotations",
    colors: "colors",
    dataLabels: "dataLabels",
    series: "series",
    stroke: "stroke",
    labels: "labels",
    legend: "legend",
    markers: "markers",
    noData: "noData",
    fill: "fill",
    tooltip: "tooltip",
    plotOptions: "plotOptions",
    responsive: "responsive",
    xaxis: "xaxis",
    yaxis: "yaxis",
    forecastDataPoints: "forecastDataPoints",
    grid: "grid",
    states: "states",
    title: "title",
    subtitle: "subtitle",
    theme: "theme",
    autoUpdateSeries: "autoUpdateSeries"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 2,
  vars: 0,
  consts: [["chart", ""]],
  template: function ChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "div", null, 0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartComponent, [{
    type: Component,
    args: [{
      selector: "apx-chart",
      template: `<div #chart></div>`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: NgZone
    }];
  }, {
    chart: [{
      type: Input
    }],
    annotations: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    dataLabels: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    stroke: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    markers: [{
      type: Input
    }],
    noData: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }],
    plotOptions: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    xaxis: [{
      type: Input
    }],
    yaxis: [{
      type: Input
    }],
    forecastDataPoints: [{
      type: Input
    }],
    grid: [{
      type: Input
    }],
    states: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    autoUpdateSeries: [{
      type: Input
    }],
    chartElement: [{
      type: ViewChild,
      args: ["chart", {
        static: true
      }]
    }]
  });
})();
window.ApexCharts = import_apexcharts.default;
var declerations = [ChartComponent];
var NgApexchartsModule = class {
};
NgApexchartsModule.\u0275fac = function NgApexchartsModule_Factory(t) {
  return new (t || NgApexchartsModule)();
};
NgApexchartsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: NgApexchartsModule
});
NgApexchartsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgApexchartsModule, [{
    type: NgModule,
    args: [{
      declarations: [...declerations],
      imports: [],
      exports: [...declerations]
    }]
  }], null, null);
})();

// src/app/shared/shared.module.ts
var THIRDMODULES = [];
var _SharedModule = class _SharedModule {
};
_SharedModule.\u0275fac = function SharedModule_Factory(t) {
  return new (t || _SharedModule)();
};
_SharedModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _SharedModule });
_SharedModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  CommonModule,
  FormsModule,
  NgApexchartsModule,
  RouterModule,
  ReactiveFormsModule,
  AlainThemeModule,
  DelonACLModule,
  DelonFormModule,
  SHARED_DELON_MODULES,
  SHARED_ZORRO_MODULES,
  THIRDMODULES,
  CommonModule,
  FormsModule,
  ReactiveFormsModule,
  RouterModule,
  AlainThemeModule,
  DelonACLModule,
  DelonFormModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule
] });
var SharedModule = _SharedModule;

// src/app/shared/json-schema/test/test.widget.ts
var _TestWidget = class _TestWidget extends ControlWidget {
  ngOnInit() {
    console.warn("init test widget");
  }
};
_TestWidget.KEY = "test";
_TestWidget.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275TestWidget_BaseFactory;
  return function TestWidget_Factory(t) {
    return (\u0275TestWidget_BaseFactory || (\u0275TestWidget_BaseFactory = \u0275\u0275getInheritedFactory(_TestWidget)))(t || _TestWidget);
  };
})();
_TestWidget.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _TestWidget, selectors: [["test"]], standalone: true, features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature], decls: 2, vars: 6, consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"]], template: function TestWidget_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "sf-item-wrap", 0);
    \u0275\u0275text(1, " test widget ");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
  }
}, dependencies: [DelonFormModule, SFItemWrapComponent], encapsulation: 2, changeDetection: 0 });
var TestWidget = _TestWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(TestWidget, { className: "TestWidget", filePath: "src\\app\\shared\\json-schema\\test\\test.widget.ts", lineNumber: 16 });
})();

// src/app/shared/json-schema/index.ts
var SF_WIDGETS = [{ KEY: TestWidget.KEY, type: TestWidget }];

// src/app/shared/st-widget/index.ts
var ST_WIDGETS = [];

// src/app/shared/cell-widget/index.ts
var CELL_WIDGETS = [];

// node_modules/@delon/abc/fesm2022/onboarding.mjs
var _c037 = ["popover"];
function OnboardingComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", function OnboardingComponent_Conditional_0_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.handleMask());
    });
    \u0275\u0275elementEnd();
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 13);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r7.item.content, \u0275\u0275sanitizeHtml);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(3);
    \u0275\u0275textInterpolate2(" ", ctx_r8.active + 1, "/", ctx_r8.max, " ");
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r13.item.skip);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 14);
    \u0275\u0275listener("click", function OnboardingComponent_Conditional_1_ng_template_2_Conditional_5_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r15);
      const ctx_r14 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r14.to("skip"));
    });
    \u0275\u0275template(1, OnboardingComponent_Conditional_1_ng_template_2_Conditional_5_ng_container_1_Template, 2, 1, "ng-container", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r9.item.skip);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r16 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r16.item.prev);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 15);
    \u0275\u0275listener("click", function OnboardingComponent_Conditional_1_ng_template_2_Conditional_6_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r18);
      const ctx_r17 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r17.to("prev"));
    });
    \u0275\u0275template(1, OnboardingComponent_Conditional_1_ng_template_2_Conditional_6_ng_container_1_Template, 2, 1, "ng-container", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r10.item.prev);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r19 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r19.item.next);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 16);
    \u0275\u0275listener("click", function OnboardingComponent_Conditional_1_ng_template_2_Conditional_7_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r21);
      const ctx_r20 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r20.to("next"));
    });
    \u0275\u0275template(1, OnboardingComponent_Conditional_1_ng_template_2_Conditional_7_ng_container_1_Template, 2, 1, "ng-container", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r11 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r11.item.next);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r22 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r22.item.done);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r24 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 17);
    \u0275\u0275listener("click", function OnboardingComponent_Conditional_1_ng_template_2_Conditional_8_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r24);
      const ctx_r23 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r23.to("done"));
    });
    \u0275\u0275template(1, OnboardingComponent_Conditional_1_ng_template_2_Conditional_8_ng_container_1_Template, 2, 1, "ng-container", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r12 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r12.item.done);
  }
}
function OnboardingComponent_Conditional_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, OnboardingComponent_Conditional_1_ng_template_2_ng_container_0_Template, 2, 1, "ng-container", 5);
    \u0275\u0275elementStart(1, "div", 6)(2, "span", 7);
    \u0275\u0275template(3, OnboardingComponent_Conditional_1_ng_template_2_Conditional_3_Template, 1, 2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 8);
    \u0275\u0275template(5, OnboardingComponent_Conditional_1_ng_template_2_Conditional_5_Template, 2, 1, "a", 9)(6, OnboardingComponent_Conditional_1_ng_template_2_Conditional_6_Template, 2, 1, "a", 10)(7, OnboardingComponent_Conditional_1_ng_template_2_Conditional_7_Template, 2, 1, "a", 11)(8, OnboardingComponent_Conditional_1_ng_template_2_Conditional_8_Template, 2, 1, "a", 12);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r5.item.content);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(3, ctx_r5.config.showTotal ? 3 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(5, !ctx_r5.last && ctx_r5.item.skip !== null && ctx_r5.item.skip !== void 0 ? 5 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(6, !ctx_r5.first && ctx_r5.item.prev !== null ? 6 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(7, !ctx_r5.last && ctx_r5.item.next !== null && ctx_r5.item.next !== void 0 ? 7 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(8, ctx_r5.last && ctx_r5.item.done !== null && ctx_r5.item.done !== void 0 ? 8 : -1);
  }
}
var _c127 = (a0, a1) => ({
  "max-width.px": a0,
  direction: a1
});
function OnboardingComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 2, 3);
    \u0275\u0275template(2, OnboardingComponent_Conditional_1_ng_template_2_Template, 9, 6, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const _r6 = \u0275\u0275reference(3);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("onboarding__light-hide", ctx_r1.running);
    \u0275\u0275property("nzPopoverTitle", ctx_r1.item.title)("nzPopoverContent", _r6)("nzPopoverVisible", !ctx_r1.running)("nzPopoverTrigger", null)("nzPopoverPlacement", ctx_r1.item.position)("nzPopoverOverlayClassName", ctx_r1.item.className)("nzPopoverOverlayStyle", \u0275\u0275pureFunction2(11, _c127, ctx_r1.item.width, ctx_r1.dir))("nzNoAnimation", true);
    \u0275\u0275attribute("style", ctx_r1.item.lightStyle, \u0275\u0275sanitizeStyle);
  }
}
var _OnboardingComponent = class _OnboardingComponent {
  get first() {
    return this.active === 0;
  }
  get last() {
    return this.active === this.max - 1;
  }
  _getDoc() {
    return this.doc;
  }
  _getWin() {
    return this._getDoc().defaultView || window;
  }
  constructor(el, doc, platform, cdr) {
    this.el = el;
    this.doc = doc;
    this.platform = platform;
    this.cdr = cdr;
    this.active = 0;
    this.max = 0;
    this.op = new EventEmitter();
    this.running = false;
    this.dir = "ltr";
  }
  getLightData() {
    const doc = this._getDoc();
    const win = this._getWin();
    const el = doc.querySelector(this.item.selectors);
    if (!el) {
      return null;
    }
    const scrollTop = win.scrollY || doc.documentElement.scrollTop || doc.body.scrollTop;
    const scrollLeft = win.scrollX || doc.documentElement.scrollLeft || doc.body.scrollLeft;
    const rect = el.getBoundingClientRect();
    const top = rect.top + scrollTop;
    const left = rect.left + scrollLeft;
    const padding = 8;
    const needPadding = top > padding && left > padding;
    const offsetPos = needPadding ? padding : 0;
    const offsetWH = needPadding ? padding * 2 : 0;
    return {
      top: top - offsetPos,
      left: left - offsetPos,
      width: rect.width + offsetWH,
      height: rect.height + offsetWH,
      el,
      clientWidth: doc.body.clientWidth,
      clientHeight: doc.body.clientHeight
    };
  }
  ngAfterViewInit() {
    this.popover.component.onClickOutside = () => {
    };
  }
  scroll(pos) {
    this.prevSelectorEl = pos.el;
    const scrollY = pos.top - (pos.clientHeight - pos.height) / 2;
    this._getWin().scrollTo({
      top: scrollY
    });
    this.updatePrevElStatus(true);
  }
  updateRunning(status) {
    this.running = status;
    this.cdr.detectChanges();
    if (!status) {
      this.updatePosition();
    }
  }
  updatePosition() {
    if (!this.platform.isBrowser) {
      return;
    }
    const pos = this.getLightData();
    if (pos == null) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        console.warn(`Did not matches selectors [${this.item.selectors}]`);
      }
      return;
    }
    const lightStyle = this.el.nativeElement.querySelector(".onboarding__light").style;
    lightStyle.top = `${pos.top}px`;
    lightStyle.left = `${pos.left}px`;
    lightStyle.width = `${pos.width}px`;
    lightStyle.height = `${pos.height}px`;
    this.updatePrevElStatus(false);
    this.scroll(pos);
  }
  updatePrevElStatus(status) {
    if (this.prevSelectorEl) {
      this.prevSelectorEl.classList[status ? "add" : "remove"]("onboarding__light-el");
    }
  }
  to(type) {
    this.op.emit(type);
  }
  handleMask() {
    if (this.config.maskClosable === true) {
      this.popover.component.hide();
      this.to("done");
    }
  }
  ngOnDestroy() {
    clearTimeout(this.time);
    this.updatePrevElStatus(false);
  }
};
_OnboardingComponent.\u0275fac = function OnboardingComponent_Factory(t) {
  return new (t || _OnboardingComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(DOCUMENT, 8), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_OnboardingComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _OnboardingComponent,
  selectors: [["onboarding"]],
  viewQuery: function OnboardingComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c037, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.popover = _t.first);
    }
  },
  hostVars: 5,
  hostBindings: function OnboardingComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("data-onboarding-active", ctx.active);
      \u0275\u0275classProp("onboarding", true)("onboarding-rtl", ctx.dir === "rtl");
    }
  },
  decls: 2,
  vars: 2,
  consts: [["class", "onboarding__mask"], [1, "onboarding__mask", 3, "click"], ["nz-popover", "", 1, "onboarding__light", 3, "nzPopoverTitle", "nzPopoverContent", "nzPopoverVisible", "nzPopoverTrigger", "nzPopoverPlacement", "nzPopoverOverlayClassName", "nzPopoverOverlayStyle", "nzNoAnimation"], ["popover", "nzPopover"], ["content", ""], [4, "nzStringTemplateOutlet"], [1, "flex-center-between", "onboarding__footer"], [1, "onboarding__total"], [1, "onboarding__btns"], ["nz-button", "", "nzType", "link", "nzSize", "small", "data-btnType", "skip"], ["nz-button", "", "nzSize", "small", "data-btnType", "prev"], ["nz-button", "", "nzType", "primary", "nzSize", "small", "data-btnType", "next"], ["nz-button", "", "nzType", "primary", "nzSize", "small", "data-btnType", "done"], [3, "innerHTML"], ["nz-button", "", "nzType", "link", "nzSize", "small", "data-btnType", "skip", 3, "click"], ["nz-button", "", "nzSize", "small", "data-btnType", "prev", 3, "click"], ["nz-button", "", "nzType", "primary", "nzSize", "small", "data-btnType", "next", 3, "click"], ["nz-button", "", "nzType", "primary", "nzSize", "small", "data-btnType", "done", 3, "click"]],
  template: function OnboardingComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, OnboardingComponent_Conditional_0_Template, 1, 0, "div", 0)(1, OnboardingComponent_Conditional_1_Template, 4, 14);
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, !ctx.running && ctx.config.mask ? 0 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx.item ? 1 : -1);
    }
  },
  dependencies: [NzPopoverDirective, NzStringTemplateOutletDirective, NzButtonComponent, NzTransitionPatchDirective, NzNoAnimationDirective],
  encapsulation: 2,
  changeDetection: 0
});
var OnboardingComponent = _OnboardingComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OnboardingComponent, [{
    type: Component,
    args: [{
      selector: "onboarding",
      host: {
        "[class.onboarding]": `true`,
        "[class.onboarding-rtl]": `dir === 'rtl'`,
        "[attr.data-onboarding-active]": `active`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `@if (!running && config.mask) {
  <div class="onboarding__mask" (click)="handleMask()"></div>
}
@if (item) {
  <div
    class="onboarding__light"
    [class.onboarding__light-hide]="running"
    [attr.style]="item.lightStyle"
    nz-popover
    #popover="nzPopover"
    [nzPopoverTitle]="item.title"
    [nzPopoverContent]="content"
    [nzPopoverVisible]="!running"
    [nzPopoverTrigger]="null"
    [nzPopoverPlacement]="item.position"
    [nzPopoverOverlayClassName]="item.className"
    [nzPopoverOverlayStyle]="{ 'max-width.px': item.width, direction: dir }"
    [nzNoAnimation]="true"
  ></div>
  <ng-template #content>
    <ng-container *nzStringTemplateOutlet="item.content">
      <div [innerHTML]="item.content"></div>
    </ng-container>
    <div class="flex-center-between onboarding__footer">
      <span class="onboarding__total">
        @if (config.showTotal) {
          {{ active + 1 }}/{{ max }}
        }
      </span>
      <div class="onboarding__btns">
        @if (!last && item.skip !== null && item.skip !== undefined) {
          <a nz-button nzType="link" (click)="to('skip')" nzSize="small" data-btnType="skip">
            <ng-container *nzStringTemplateOutlet="item.skip">{{ item.skip }}</ng-container>
          </a>
        }
        @if (!first && item.prev !== null) {
          <a nz-button (click)="to('prev')" nzSize="small" data-btnType="prev">
            <ng-container *nzStringTemplateOutlet="item.prev">{{ item.prev }}</ng-container>
          </a>
        }
        @if (!last && item.next !== null && item.next !== undefined) {
          <a nz-button (click)="to('next')" nzType="primary" nzSize="small" data-btnType="next">
            <ng-container *nzStringTemplateOutlet="item.next">{{ item.next }}</ng-container>
          </a>
        }
        @if (last && item.done !== null && item.done !== undefined) {
          <a nz-button (click)="to('done')" nzType="primary" nzSize="small" data-btnType="done">
            <ng-container *nzStringTemplateOutlet="item.done">{{ item.done }}</ng-container>
          </a>
        }
      </div>
    </div>
  </ng-template>
}
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }, {
    type: ChangeDetectorRef
  }], {
    popover: [{
      type: ViewChild,
      args: ["popover", {
        static: false
      }]
    }]
  });
})();
var ONBOARDING_STORE_TOKEN = new InjectionToken("ONBOARDING_STORE_TOKEN", {
  providedIn: "root",
  factory: ONBOARDING_STORE_TOKEN_FACTORY
});
function ONBOARDING_STORE_TOKEN_FACTORY() {
  return new LocalStorageStore();
}
var LocalStorageStore = class {
  get(key) {
    return localStorage.getItem(key);
  }
  set(key, version) {
    localStorage.setItem(key, `${version}`);
  }
};
var _OnboardingService = class _OnboardingService {
  _getDoc() {
    return this.doc;
  }
  /**
   * Get whether it is booting
   *
   * 获取是否正在引导中
   */
  get running() {
    return this._running;
  }
  constructor(i18n, appRef, router, doc, configSrv, keyStoreSrv, directionality) {
    this.i18n = i18n;
    this.appRef = appRef;
    this.router = router;
    this.doc = doc;
    this.configSrv = configSrv;
    this.keyStoreSrv = keyStoreSrv;
    this.directionality = directionality;
    this.active = 0;
    this.running$ = null;
    this._running = false;
    this.type = null;
  }
  attach() {
    const compRef = createComponent(OnboardingComponent, {
      environmentInjector: this.appRef.injector
    });
    this.compRef = compRef;
    this.appRef.attachView(compRef.hostView);
    const compNode = compRef.hostView.rootNodes[0];
    const doc = this._getDoc();
    const cdk = doc.querySelector(".cdk-overlay-container");
    if (cdk) {
      doc.body.insertBefore(compNode, cdk);
    } else {
      doc.body.appendChild(compNode);
    }
    this.op$ = this.compRef.instance.op.subscribe((type) => {
      switch (type) {
        case "next":
          this.next();
          break;
        case "prev":
          this.prev();
          break;
        default:
          this.done();
          break;
      }
    });
  }
  cancelRunning() {
    if (this.running$) {
      this.running$.unsubscribe();
      this.running$ = null;
    }
    return this;
  }
  updateRunning(status) {
    this._running = status;
    this.compRef.instance.updateRunning(status);
    return this;
  }
  destroy() {
    const storeKey = this.config?.key;
    if (storeKey != null) {
      this.keyStoreSrv.set(storeKey, this.config?.keyVersion);
    }
    this.cancelRunning();
    if (this.compRef) {
      this.appRef.detachView(this.compRef.hostView);
      this.compRef.destroy();
      this.op$.unsubscribe();
    }
  }
  showItem(isStart = false) {
    const items = this.config?.items;
    const item = __spreadValues(__spreadValues({
      position: "bottomLeft",
      before: of(true),
      after: of(true)
    }, this.i18n.getData("onboarding")), items[this.active]);
    const dir = this.configSrv.get("onboarding").direction || this.directionality.value;
    Object.assign(this.compRef.instance, {
      item,
      config: this.config,
      active: this.active,
      max: items.length,
      dir
    });
    const pipes = [switchMap(() => item.url ? this.router.navigateByUrl(item.url) : of(true)), switchMap(() => {
      const obs = this.type === "prev" ? item.after : item.before;
      return typeof obs === "number" ? of(true).pipe(delay(obs)) : obs;
    })];
    if (!isStart) {
      pipes.push(delay(1));
    }
    this.updateRunning(true);
    this.running$ = of(true).pipe(pipe.apply(this, pipes)).subscribe({
      next: () => this.cancelRunning().updateRunning(false),
      error: () => this.done()
    });
  }
  /**
   * Start a new user guidance
   *
   * 开启新的用户引导流程
   */
  start(config) {
    const cog = __spreadValues({
      keyVersion: "",
      items: [],
      mask: true,
      maskClosable: true,
      showTotal: false
    }, config);
    const storeKey = cog?.key;
    if (storeKey != null && this.keyStoreSrv.get(storeKey) === cog.keyVersion) {
      return;
    }
    if (this.running) {
      return;
    }
    this.destroy();
    this.config = cog;
    this.active = 0;
    this.type = null;
    this.attach();
    this.showItem(true);
  }
  /**
   * Next
   *
   * 下一步
   */
  next() {
    if (this._running || this.active + 1 >= this.config.items.length) {
      this.done();
      return;
    }
    this.type = "next";
    ++this.active;
    this.showItem();
  }
  /**
   * Prev
   *
   * 上一步
   */
  prev() {
    if (this._running || this.active - 1 < 0) {
      return;
    }
    this.type = "prev";
    --this.active;
    this.showItem();
  }
  /**
   * Done
   *
   * 完成
   */
  done() {
    this.type = "done";
    this.destroy();
  }
  ngOnDestroy() {
    this.destroy();
  }
};
_OnboardingService.\u0275fac = function OnboardingService_Factory(t) {
  return new (t || _OnboardingService)(\u0275\u0275inject(DelonLocaleService), \u0275\u0275inject(ApplicationRef), \u0275\u0275inject(Router), \u0275\u0275inject(DOCUMENT), \u0275\u0275inject(AlainConfigService), \u0275\u0275inject(ONBOARDING_STORE_TOKEN), \u0275\u0275inject(Directionality, 8));
};
_OnboardingService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _OnboardingService,
  factory: _OnboardingService.\u0275fac
});
var OnboardingService = _OnboardingService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OnboardingService, [{
    type: Injectable
  }], () => [{
    type: DelonLocaleService
  }, {
    type: ApplicationRef
  }, {
    type: Router
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: AlainConfigService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [ONBOARDING_STORE_TOKEN]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var COMPONENTS9 = [OnboardingComponent];
var _OnboardingModule = class _OnboardingModule {
};
_OnboardingModule.\u0275fac = function OnboardingModule_Factory(t) {
  return new (t || _OnboardingModule)();
};
_OnboardingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _OnboardingModule
});
_OnboardingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [OnboardingService],
  imports: [CommonModule, DelonLocaleModule, NzPopoverModule, NzOutletModule, NzButtonModule, NzNoAnimationModule]
});
var OnboardingModule = _OnboardingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OnboardingModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, DelonLocaleModule, NzPopoverModule, NzOutletModule, NzButtonModule, NzNoAnimationModule],
      declarations: COMPONENTS9,
      providers: [OnboardingService],
      exports: COMPONENTS9
    }]
  }], null, null);
})();

// node_modules/@delon/abc/fesm2022/quick-menu.mjs
function QuickMenuComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "i", 4);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", ctx_r0.icon);
  }
}
var _c038 = ["*"];
var _QuickMenuComponent = class _QuickMenuComponent {
  constructor(cdr, el, render) {
    this.cdr = cdr;
    this.el = el;
    this.render = render;
    this.ctrlStyle = {};
    this.icon = "question-circle";
    this.top = 120;
    this.width = 200;
    this.expand = false;
    this.expandChange = new EventEmitter();
    this.show = false;
    this.initFlag = false;
  }
  _click() {
    this.show = !this.show;
    this.expandChange.emit(this.show);
    this.setStyle();
  }
  setStyle() {
    this.ctrlStyle = {
      "background-color": this.bgColor,
      "border-color": this.borderColor
    };
    const res = [`top:${this.top}px`, `width:${this.width}px`, `margin-right:-${this.show ? 0 : this.width}px`];
    if (this.bgColor) {
      res.push(`background-color:${this.bgColor}`);
    }
    if (this.borderColor) {
      res.push(`border-color:${this.borderColor}`);
    }
    this.render.setAttribute(this.el.nativeElement, "style", res.join(";"));
    this.cdr.detectChanges();
  }
  ngOnInit() {
    this.initFlag = true;
    this.setStyle();
  }
  ngOnChanges() {
    this.show = this.expand;
    if (this.initFlag) {
      this.setStyle();
    }
  }
};
_QuickMenuComponent.\u0275fac = function QuickMenuComponent_Factory(t) {
  return new (t || _QuickMenuComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
_QuickMenuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _QuickMenuComponent,
  selectors: [["quick-menu"]],
  hostVars: 2,
  hostBindings: function QuickMenuComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function QuickMenuComponent_click_HostBindingHandler() {
        return ctx._click();
      });
    }
    if (rf & 2) {
      \u0275\u0275classProp("quick-menu", true);
    }
  },
  inputs: {
    icon: "icon",
    top: "top",
    width: "width",
    bgColor: "bgColor",
    borderColor: "borderColor",
    expand: "expand"
  },
  outputs: {
    expandChange: "expandChange"
  },
  exportAs: ["quickMenu"],
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c038,
  decls: 5,
  vars: 2,
  consts: [[1, "quick-menu__inner"], [1, "quick-menu__ctrl", 3, "ngStyle"], [1, "quick-menu__ctrl-icon"], [4, "nzStringTemplateOutlet"], ["nz-icon", "", 3, "nzType"]],
  template: function QuickMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2);
      \u0275\u0275template(3, QuickMenuComponent_ng_container_3_Template, 2, 1, "ng-container", 3);
      \u0275\u0275elementEnd()();
      \u0275\u0275projection(4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngStyle", ctx.ctrlStyle);
      \u0275\u0275advance(2);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.icon);
    }
  },
  dependencies: [NgStyle, NzIconDirective, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var QuickMenuComponent = _QuickMenuComponent;
__decorate([InputNumber2()], QuickMenuComponent.prototype, "top", void 0);
__decorate([InputNumber2()], QuickMenuComponent.prototype, "width", void 0);
__decorate([InputBoolean2()], QuickMenuComponent.prototype, "expand", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(QuickMenuComponent, [{
    type: Component,
    args: [{
      selector: "quick-menu",
      exportAs: "quickMenu",
      host: {
        "[class.quick-menu]": "true",
        "(click)": "_click()"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: '<div class="quick-menu__inner">\n  <div class="quick-menu__ctrl" [ngStyle]="ctrlStyle">\n    <div class="quick-menu__ctrl-icon">\n      <ng-container *nzStringTemplateOutlet="icon">\n        <i nz-icon [nzType]="$any(icon)"></i>\n      </ng-container>\n    </div>\n  </div>\n  <ng-content />\n</div>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    icon: [{
      type: Input
    }],
    top: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    bgColor: [{
      type: Input
    }],
    borderColor: [{
      type: Input
    }],
    expand: [{
      type: Input
    }],
    expandChange: [{
      type: Output
    }]
  });
})();
var COMPONENTS10 = [QuickMenuComponent];
var _QuickMenuModule = class _QuickMenuModule {
};
_QuickMenuModule.\u0275fac = function QuickMenuModule_Factory(t) {
  return new (t || _QuickMenuModule)();
};
_QuickMenuModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _QuickMenuModule
});
_QuickMenuModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzIconModule, NzOutletModule]
});
var QuickMenuModule = _QuickMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(QuickMenuModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzIconModule, NzOutletModule],
      declarations: COMPONENTS10,
      exports: COMPONENTS10
    }]
  }], null, null);
})();

// node_modules/@delon/chart/fesm2022/core.mjs
var _c039 = ["container"];
var _G2Service = class _G2Service {
  get cog() {
    return this._cog;
  }
  set cog(val) {
    this._cog = this.cogSrv.merge("chart", {
      theme: "",
      libs: ["https://gw.alipayobjects.com/os/lib/antv/g2/4.1.46/dist/g2.min.js", "https://gw.alipayobjects.com/os/lib/antv/data-set/0.11.8/dist/data-set.js"]
    }, val);
  }
  constructor(cogSrv, lazySrv) {
    this.cogSrv = cogSrv;
    this.lazySrv = lazySrv;
    this.loading = false;
    this.loaded = false;
    this.notify$ = new Subject();
    this.cog = {
      theme: ""
    };
  }
  libLoad() {
    if (this.loading) {
      if (this.loaded) {
        this.notify$.next();
      }
      return this;
    }
    this.loading = true;
    this.lazySrv.load(this.cog.libs).then(() => {
      this.loaded = true;
      this.notify$.next();
    });
    return this;
  }
  get notify() {
    return this.notify$.asObservable();
  }
  ngOnDestroy() {
    this.notify$.unsubscribe();
  }
};
_G2Service.\u0275fac = function G2Service_Factory(t) {
  return new (t || _G2Service)(\u0275\u0275inject(AlainConfigService), \u0275\u0275inject(LazyService));
};
_G2Service.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _G2Service,
  factory: _G2Service.\u0275fac,
  providedIn: "root"
});
var G2Service = _G2Service;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2Service, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AlainConfigService
  }, {
    type: LazyService
  }], null);
})();
var _G2BaseComponent = class _G2BaseComponent {
  get chart() {
    return this._chart;
  }
  get winG2() {
    return window.G2;
  }
  constructor(srv, el, ngZone, platform, cdr) {
    this.srv = srv;
    this.el = el;
    this.ngZone = ngZone;
    this.platform = platform;
    this.cdr = cdr;
    this.repaint = true;
    this.destroy$ = new Subject();
    this.loaded = false;
    this.delay = 0;
    this.ready = new EventEmitter();
    this.theme = srv.cog.theme;
    this.srv.notify.pipe(takeUntil(this.destroy$), filter(() => !this.loaded)).subscribe(() => this.load());
  }
  /** G2数据变更 */
  changeData() {
  }
  /** 等同 `ngOnInit` */
  onInit() {
  }
  /** 等同 `ngOnChanges` */
  onChanges(_) {
  }
  load() {
    this.ngZone.run(() => {
      this.loaded = true;
      this.cdr.detectChanges();
    });
    setTimeout(() => this.install(), this.delay);
  }
  ngOnInit() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.onInit();
    if (this.winG2) {
      this.load();
    } else {
      this.srv.libLoad();
    }
  }
  ngOnChanges(changes) {
    this.onChanges(changes);
    const isOnlyChangeData = this.onlyChangeData ? this.onlyChangeData(changes) : Object.keys(changes).length === 1 && !!changes.data;
    if (isOnlyChangeData) {
      this.changeData();
      return;
    }
    if (!this.chart || !this.repaint)
      return;
    this.ngZone.runOutsideAngular(() => {
      this.destroyChart().install();
    });
  }
  destroyChart() {
    if (this._chart) {
      this._chart.destroy();
    }
    return this;
  }
  ngOnDestroy() {
    if (this.resize$) {
      this.resize$.unsubscribe();
    }
    this.destroy$.next();
    this.destroy$.complete();
    this.destroyChart();
  }
};
_G2BaseComponent.\u0275fac = function G2BaseComponent_Factory(t) {
  return new (t || _G2BaseComponent)(\u0275\u0275directiveInject(G2Service), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_G2BaseComponent.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _G2BaseComponent,
  viewQuery: function G2BaseComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c039, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.node = _t.first);
    }
  },
  inputs: {
    repaint: "repaint",
    delay: "delay",
    theme: "theme"
  },
  outputs: {
    ready: "ready"
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var G2BaseComponent = _G2BaseComponent;
__decorate([InputBoolean2()], G2BaseComponent.prototype, "repaint", void 0);
__decorate([InputNumber2()], G2BaseComponent.prototype, "delay", void 0);
__decorate([ZoneOutside()], G2BaseComponent.prototype, "load", null);
__decorate([ZoneOutside()], G2BaseComponent.prototype, "destroyChart", null);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2BaseComponent, [{
    type: Directive
  }], () => [{
    type: G2Service
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: Platform
  }, {
    type: ChangeDetectorRef
  }], {
    repaint: [{
      type: Input
    }],
    node: [{
      type: ViewChild,
      args: ["container", {
        static: true
      }]
    }],
    delay: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    ready: [{
      type: Output
    }],
    load: [],
    destroyChart: []
  });
})();
function genMiniTooltipOptions(type, options) {
  const res = __spreadValues({
    showTitle: false,
    showMarkers: true,
    enterable: true,
    domStyles: {
      "g2-tooltip": {
        padding: "0px"
      },
      "g2-tooltip-title": {
        display: "none"
      },
      "g2-tooltip-list-item": {
        margin: "4px"
      }
    }
  }, options);
  if (type === "mini") {
    res.position = "top";
    res.domStyles["g2-tooltip"] = {
      padding: "0px",
      backgroundColor: "transparent",
      boxShadow: "none"
    };
    res.itemTpl = `<li>{value}</li>`;
    res.offset = 8;
  }
  return res;
}

// node_modules/@delon/chart/fesm2022/bar.mjs
function G2BarComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "h4", 2);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.title);
  }
}
function G2BarComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-skeleton");
  }
}
var TITLE_HEIGHT = 41;
var _G2BarComponent = class _G2BarComponent extends G2BaseComponent {
  constructor() {
    super(...arguments);
    this.color = "rgba(24, 144, 255, 0.85)";
    this.height = 0;
    this.padding = "auto";
    this.data = [];
    this.autoLabel = true;
    this.interaction = "none";
    this.clickItem = new EventEmitter();
  }
  // #endregion
  getHeight() {
    return this.title ? this.height - TITLE_HEIGHT : this.height;
  }
  install() {
    const {
      node,
      padding,
      interaction,
      theme
    } = this;
    const container = node.nativeElement;
    const chart = this._chart = new this.winG2.Chart({
      container,
      autoFit: true,
      height: this.getHeight(),
      padding,
      theme
    });
    this.updatelabel();
    chart.axis("y", {
      title: null,
      line: null,
      tickLine: null
    });
    chart.scale({
      x: {
        type: "cat"
      },
      y: {
        min: 0
      }
    });
    chart.tooltip({
      showTitle: false
    });
    if (interaction !== "none") {
      chart.interaction(interaction);
    }
    chart.legend(false);
    chart.interval().position("x*y").color("x*y", (x, y) => {
      const colorItem = this.data.find((w) => w.x === x && w.y === y);
      return colorItem && colorItem.color ? colorItem.color : this.color;
    }).tooltip("x*y", (x, y) => ({
      name: x,
      value: y
    }));
    chart.on(`interval:click`, (ev) => {
      this.ngZone.run(() => this.clickItem.emit({
        item: ev.data?.data,
        ev
      }));
    });
    this.ready.next(chart);
    this.changeData();
    chart.render();
    this.installResizeEvent();
  }
  changeData() {
    const {
      _chart,
      data
    } = this;
    if (!_chart || !Array.isArray(data) || data.length <= 0)
      return;
    _chart.changeData(data);
  }
  updatelabel() {
    const {
      node,
      data,
      _chart
    } = this;
    const canvasWidth = node.nativeElement.clientWidth;
    const minWidth = data.length * 30;
    _chart.axis("x", canvasWidth > minWidth).render();
  }
  installResizeEvent() {
    if (!this.autoLabel || this.resize$)
      return;
    this.resize$ = fromEvent(window, "resize").pipe(takeUntil(this.destroy$), filter(() => !!this._chart), debounceTime(200)).subscribe(() => this.ngZone.runOutsideAngular(() => this.updatelabel()));
  }
};
_G2BarComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275G2BarComponent_BaseFactory;
  return function G2BarComponent_Factory(t) {
    return (\u0275G2BarComponent_BaseFactory || (\u0275G2BarComponent_BaseFactory = \u0275\u0275getInheritedFactory(_G2BarComponent)))(t || _G2BarComponent);
  };
})();
_G2BarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _G2BarComponent,
  selectors: [["g2-bar"]],
  hostVars: 2,
  hostBindings: function G2BarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("height", ctx.height, "px");
    }
  },
  inputs: {
    title: "title",
    color: "color",
    height: "height",
    padding: "padding",
    data: "data",
    autoLabel: "autoLabel",
    interaction: "interaction"
  },
  outputs: {
    clickItem: "clickItem"
  },
  exportAs: ["g2Bar"],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 4,
  vars: 2,
  consts: [[4, "nzStringTemplateOutlet"], ["container", ""], [2, "margin-bottom", "20px"]],
  template: function G2BarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, G2BarComponent_ng_container_0_Template, 3, 1, "ng-container", 0)(1, G2BarComponent_Conditional_1_Template, 1, 0, "nz-skeleton");
      \u0275\u0275element(2, "div", null, 1);
    }
    if (rf & 2) {
      \u0275\u0275property("nzStringTemplateOutlet", ctx.title);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, !ctx.loaded ? 1 : -1);
    }
  },
  dependencies: [NzStringTemplateOutletDirective, NzSkeletonComponent],
  encapsulation: 2,
  changeDetection: 0
});
var G2BarComponent = _G2BarComponent;
__decorate([InputNumber2()], G2BarComponent.prototype, "height", void 0);
__decorate([InputBoolean2()], G2BarComponent.prototype, "autoLabel", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2BarComponent, [{
    type: Component,
    args: [{
      selector: "g2-bar",
      exportAs: "g2Bar",
      template: `
    <ng-container *nzStringTemplateOutlet="title">
      <h4 style="margin-bottom: 20px;">{{ title }}</h4>
    </ng-container>
    @if (!loaded) {
      <nz-skeleton />
    }
    <div #container></div>
  `,
      host: {
        "[style.height.px]": "height"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, {
    title: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    autoLabel: [{
      type: Input
    }],
    interaction: [{
      type: Input
    }],
    clickItem: [{
      type: Output
    }]
  });
})();
var COMPONENTS11 = [G2BarComponent];
var _G2BarModule = class _G2BarModule {
};
_G2BarModule.\u0275fac = function G2BarModule_Factory(t) {
  return new (t || _G2BarModule)();
};
_G2BarModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _G2BarModule
});
_G2BarModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzOutletModule, NzSkeletonModule]
});
var G2BarModule = _G2BarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2BarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzOutletModule, NzSkeletonModule],
      declarations: COMPONENTS11,
      exports: COMPONENTS11
    }]
  }], null, null);
})();

// node_modules/@delon/chart/fesm2022/mini-bar.mjs
var _G2MiniBarComponent = class _G2MiniBarComponent extends G2BaseComponent {
  constructor() {
    super(...arguments);
    this.color = "#1890FF";
    this.height = 0;
    this.borderWidth = 5;
    this.padding = [8, 8, 8, 8];
    this.data = [];
    this.yTooltipSuffix = "";
    this.tooltipType = "default";
    this.clickItem = new EventEmitter();
  }
  // #endregion
  install() {
    const {
      el,
      height,
      padding,
      yTooltipSuffix,
      tooltipType,
      theme,
      color,
      borderWidth
    } = this;
    const chart = this._chart = new this.winG2.Chart({
      container: el.nativeElement,
      autoFit: true,
      height,
      padding,
      theme
    });
    chart.scale({
      x: {
        type: "cat"
      },
      y: {
        min: 0
      }
    });
    chart.legend(false);
    chart.axis(false);
    chart.tooltip(genMiniTooltipOptions(tooltipType, {
      showCrosshairs: false
    }));
    chart.interval().position("x*y").color("x*y", (x, y) => {
      const colorItem = this.data.find((w) => w.x === x && w.y === y);
      return colorItem && colorItem.color ? colorItem.color : color;
    }).size(borderWidth).tooltip("x*y", (x, y) => ({
      name: x,
      value: y + yTooltipSuffix
    }));
    chart.on(`interval:click`, (ev) => {
      this.ngZone.run(() => this.clickItem.emit({
        item: ev.data?.data,
        ev
      }));
    });
    this.ready.next(chart);
    this.changeData();
    chart.render();
  }
  changeData() {
    const {
      _chart,
      data
    } = this;
    if (!_chart || !Array.isArray(data) || data.length <= 0)
      return;
    _chart.changeData(data);
  }
};
_G2MiniBarComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275G2MiniBarComponent_BaseFactory;
  return function G2MiniBarComponent_Factory(t) {
    return (\u0275G2MiniBarComponent_BaseFactory || (\u0275G2MiniBarComponent_BaseFactory = \u0275\u0275getInheritedFactory(_G2MiniBarComponent)))(t || _G2MiniBarComponent);
  };
})();
_G2MiniBarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _G2MiniBarComponent,
  selectors: [["g2-mini-bar"]],
  hostVars: 2,
  hostBindings: function G2MiniBarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("height", ctx.height, "px");
    }
  },
  inputs: {
    color: "color",
    height: "height",
    borderWidth: "borderWidth",
    padding: "padding",
    data: "data",
    yTooltipSuffix: "yTooltipSuffix",
    tooltipType: "tooltipType"
  },
  outputs: {
    clickItem: "clickItem"
  },
  exportAs: ["g2MiniBar"],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function G2MiniBarComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
var G2MiniBarComponent = _G2MiniBarComponent;
__decorate([InputNumber2()], G2MiniBarComponent.prototype, "height", void 0);
__decorate([InputNumber2()], G2MiniBarComponent.prototype, "borderWidth", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2MiniBarComponent, [{
    type: Component,
    args: [{
      selector: "g2-mini-bar",
      exportAs: "g2MiniBar",
      template: ``,
      host: {
        "[style.height.px]": "height"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, {
    color: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    borderWidth: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    yTooltipSuffix: [{
      type: Input
    }],
    tooltipType: [{
      type: Input
    }],
    clickItem: [{
      type: Output
    }]
  });
})();
var COMPONENTS12 = [G2MiniBarComponent];
var _G2MiniBarModule = class _G2MiniBarModule {
};
_G2MiniBarModule.\u0275fac = function G2MiniBarModule_Factory(t) {
  return new (t || _G2MiniBarModule)();
};
_G2MiniBarModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _G2MiniBarModule
});
_G2MiniBarModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var G2MiniBarModule = _G2MiniBarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2MiniBarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: COMPONENTS12,
      exports: COMPONENTS12
    }]
  }], null, null);
})();

// node_modules/@delon/chart/fesm2022/timeline.mjs
function G2TimelineComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "h4");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.title);
  }
}
function G2TimelineComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-skeleton");
  }
}
var _G2TimelineComponent = class _G2TimelineComponent extends G2BaseComponent {
  constructor() {
    super(...arguments);
    this.maxAxis = 2;
    this.data = [];
    this.colorMap = {
      y1: "#5B8FF9",
      y2: "#5AD8A6",
      y3: "#5D7092",
      y4: "#F6BD16",
      y5: "#E86452"
    };
    this.mask = "HH:mm";
    this.maskSlider = "HH:mm";
    this.position = "top";
    this.height = 450;
    this.padding = [40, 8, 64, 40];
    this.borderWidth = 2;
    this.slider = true;
    this.clickItem = new EventEmitter();
    this.onlyChangeData = (changes) => {
      const tm = changes.titleMap;
      return !(tm && !tm.firstChange && tm.currentValue !== tm.previousValue);
    };
  }
  install() {
    const {
      node,
      height,
      padding,
      slider,
      maxAxis,
      theme,
      maskSlider
    } = this;
    const chart = this._chart = new this.winG2.Chart({
      container: node.nativeElement,
      autoFit: true,
      height,
      padding,
      theme
    });
    chart.axis("time", {
      title: null
    });
    chart.axis("y1", {
      title: null
    });
    for (let i = 2; i <= maxAxis; i++) {
      chart.axis(`y${i}`, false);
    }
    chart.line().position("time*y1");
    for (let i = 2; i <= maxAxis; i++) {
      chart.line().position(`time*y${i}`);
    }
    chart.tooltip({
      showCrosshairs: true,
      shared: true
    });
    const sliderPadding = __spreadValues(__spreadValues({}, []), padding);
    sliderPadding[0] = 0;
    if (slider) {
      chart.option("slider", {
        height: 26,
        start: 0,
        end: 1,
        trendCfg: {
          isArea: false
        },
        minLimit: 2,
        formatter: (val) => format(val, maskSlider)
      });
    }
    chart.on(`plot:click`, (ev) => {
      const records = this._chart.getSnapRecords({
        x: ev.x,
        y: ev.y
      });
      this.ngZone.run(() => this.clickItem.emit({
        item: records[0]._origin,
        ev
      }));
    });
    chart.on(`legend-item:click`, (ev) => {
      const item = ev?.target?.get("delegateObject").item;
      const id = item?.id;
      const line = chart.geometries.find((w) => w.getAttribute("position").getFields()[1] === id);
      if (line) {
        line.changeVisible(!item.unchecked);
      }
    });
    this.ready.next(chart);
    this.changeData();
    chart.render();
  }
  changeData() {
    const {
      _chart,
      height,
      padding,
      mask,
      titleMap,
      position,
      colorMap,
      borderWidth,
      maxAxis
    } = this;
    let data = [...this.data];
    if (!_chart || data.length <= 0)
      return;
    const arrAxis = [...Array(maxAxis)].map((_, index) => index + 1);
    _chart.legend({
      position,
      custom: true,
      items: arrAxis.map((id) => {
        const key = `y${id}`;
        return {
          id: key,
          name: titleMap[key],
          value: key,
          marker: {
            style: {
              fill: colorMap[key]
            }
          }
        };
      })
    });
    _chart.geometries.forEach((v, idx) => {
      v.color(colorMap[`y${idx + 1}`]).size(borderWidth);
    });
    _chart.height = height;
    _chart.padding = padding;
    data = data.map((item) => {
      item.time = toDate(item.time);
      item._time = +item.time;
      return item;
    }).sort((a, b) => a._time - b._time);
    const max = Math.max(...arrAxis.map((id) => [...data].sort((a, b) => b[`y${id}`] - a[`y${id}`])[0][`y${id}`]));
    const scaleOptions = {};
    arrAxis.forEach((id) => {
      const key = `y${id}`;
      scaleOptions[key] = {
        alias: titleMap[key],
        max,
        min: 0
      };
    });
    _chart.scale(__spreadValues({
      time: {
        type: "time",
        mask,
        range: [0, 1]
      }
    }, scaleOptions));
    const initialRange = {
      start: data[0]._time,
      end: data[data.length - 1]._time
    };
    const filterData = data.filter((val) => val._time >= initialRange.start && val._time <= initialRange.end);
    _chart.changeData(filterData);
  }
};
_G2TimelineComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275G2TimelineComponent_BaseFactory;
  return function G2TimelineComponent_Factory(t) {
    return (\u0275G2TimelineComponent_BaseFactory || (\u0275G2TimelineComponent_BaseFactory = \u0275\u0275getInheritedFactory(_G2TimelineComponent)))(t || _G2TimelineComponent);
  };
})();
_G2TimelineComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _G2TimelineComponent,
  selectors: [["g2-timeline"]],
  inputs: {
    title: "title",
    maxAxis: "maxAxis",
    data: "data",
    titleMap: "titleMap",
    colorMap: "colorMap",
    mask: "mask",
    maskSlider: "maskSlider",
    position: "position",
    height: "height",
    padding: "padding",
    borderWidth: "borderWidth",
    slider: "slider"
  },
  outputs: {
    clickItem: "clickItem"
  },
  exportAs: ["g2Timeline"],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 4,
  vars: 2,
  consts: [[4, "nzStringTemplateOutlet"], ["container", ""]],
  template: function G2TimelineComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, G2TimelineComponent_ng_container_0_Template, 3, 1, "ng-container", 0)(1, G2TimelineComponent_Conditional_1_Template, 1, 0, "nz-skeleton");
      \u0275\u0275element(2, "div", null, 1);
    }
    if (rf & 2) {
      \u0275\u0275property("nzStringTemplateOutlet", ctx.title);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, !ctx.loaded ? 1 : -1);
    }
  },
  dependencies: [NzStringTemplateOutletDirective, NzSkeletonComponent],
  encapsulation: 2,
  changeDetection: 0
});
var G2TimelineComponent = _G2TimelineComponent;
__decorate([InputNumber2()], G2TimelineComponent.prototype, "maxAxis", void 0);
__decorate([InputNumber2()], G2TimelineComponent.prototype, "height", void 0);
__decorate([InputNumber2()], G2TimelineComponent.prototype, "borderWidth", void 0);
__decorate([InputBoolean2()], G2TimelineComponent.prototype, "slider", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2TimelineComponent, [{
    type: Component,
    args: [{
      selector: "g2-timeline",
      exportAs: "g2Timeline",
      template: `
    <ng-container *nzStringTemplateOutlet="title">
      <h4>{{ title }}</h4>
    </ng-container>
    @if (!loaded) {
      <nz-skeleton />
    }
    <div #container></div>
  `,
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, {
    title: [{
      type: Input
    }],
    maxAxis: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    titleMap: [{
      type: Input
    }],
    colorMap: [{
      type: Input
    }],
    mask: [{
      type: Input
    }],
    maskSlider: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    borderWidth: [{
      type: Input
    }],
    slider: [{
      type: Input
    }],
    clickItem: [{
      type: Output
    }]
  });
})();
var COMPONENTS13 = [G2TimelineComponent];
var _G2TimelineModule = class _G2TimelineModule {
};
_G2TimelineModule.\u0275fac = function G2TimelineModule_Factory(t) {
  return new (t || _G2TimelineModule)();
};
_G2TimelineModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _G2TimelineModule
});
_G2TimelineModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzOutletModule, NzSkeletonModule]
});
var G2TimelineModule = _G2TimelineModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2TimelineModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzOutletModule, NzSkeletonModule],
      declarations: COMPONENTS13,
      exports: COMPONENTS13
    }]
  }], null, null);
})();

// src/app/routes/dashboard/v1/charts/chart.component.ts
var _c040 = ["chart"];
var _LineChartComponent = class _LineChartComponent {
  constructor() {
    this.chartOptions = {
      series: [
        {
          name: "Desktops",
          data: [10, 41, 35, 51, 49, 62, 69, 91, 148]
        }
      ],
      chart: {
        height: 350,
        type: "area",
        zoom: {
          enabled: false
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        curve: "straight"
      },
      title: {
        align: "left"
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"],
          opacity: 0.5
        }
      },
      xaxis: {
        categories: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"]
      }
    };
  }
};
_LineChartComponent.\u0275fac = function LineChartComponent_Factory(t) {
  return new (t || _LineChartComponent)();
};
_LineChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LineChartComponent, selectors: [["chart-chart-echarts-on"]], viewQuery: function LineChartComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c040, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chart = _t.first);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 7, consts: [["id", "chart"], [3, "series", "chart", "xaxis", "dataLabels", "grid", "stroke", "title"]], template: function LineChartComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "apx-chart", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275property("series", ctx.chartOptions.series)("chart", ctx.chartOptions.chart)("xaxis", ctx.chartOptions.xaxis)("dataLabels", ctx.chartOptions.dataLabels)("grid", ctx.chartOptions.grid)("stroke", ctx.chartOptions.stroke)("title", ctx.chartOptions.title);
  }
}, dependencies: [CommonModule, NgApexchartsModule, ChartComponent], encapsulation: 2 });
var LineChartComponent = _LineChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LineChartComponent, { className: "LineChartComponent", filePath: "src\\app\\routes\\dashboard\\v1\\charts\\chart.component.ts", lineNumber: 42 });
})();

// src/app/routes/dashboard/v1/charts/pie.component.ts
var _c041 = ["chart"];
var _ChartPieBasicComponent = class _ChartPieBasicComponent {
  ngOnChanges(changes) {
    this.chartOptions = this.salesPieData;
  }
};
_ChartPieBasicComponent.\u0275fac = function ChartPieBasicComponent_Factory(t) {
  return new (t || _ChartPieBasicComponent)();
};
_ChartPieBasicComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartPieBasicComponent, selectors: [["chart-pie-basic"]], viewQuery: function ChartPieBasicComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c041, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chart = _t.first);
  }
}, inputs: { salesPieData: "salesPieData" }, standalone: true, features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature], decls: 2, vars: 6, consts: [["id", "chart"], [3, "series", "chart", "labels", "responsive", "dataLabels", "legend"]], template: function ChartPieBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "apx-chart", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275property("series", ctx.chartOptions == null ? null : ctx.chartOptions.series)("chart", ctx.chartOptions == null ? null : ctx.chartOptions.chart)("labels", ctx.chartOptions == null ? null : ctx.chartOptions.labels)("responsive", ctx.chartOptions == null ? null : ctx.chartOptions.responsive)("dataLabels", ctx.chartOptions == null ? null : ctx.chartOptions.dataLabels)("legend", ctx.chartOptions == null ? null : ctx.chartOptions.legend);
  }
}, dependencies: [CommonModule, NgApexchartsModule, ChartComponent], encapsulation: 2 });
var ChartPieBasicComponent = _ChartPieBasicComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartPieBasicComponent, { className: "ChartPieBasicComponent", filePath: "src\\app\\routes\\dashboard\\v1\\charts\\pie.component.ts", lineNumber: 29 });
})();

// src/app/routes/dashboard/v1/components/date.component.ts
var _NzDemoDatePickerPresettedRangesComponent = class _NzDemoDatePickerPresettedRangesComponent {
  constructor() {
    this.ranges = { Today: [/* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()], "This Month": [/* @__PURE__ */ new Date(), endOfMonth(/* @__PURE__ */ new Date())] };
  }
  onChange(result) {
    console.log("From: ", result[0], ", to: ", result[1]);
  }
};
_NzDemoDatePickerPresettedRangesComponent.\u0275fac = function NzDemoDatePickerPresettedRangesComponent_Factory(t) {
  return new (t || _NzDemoDatePickerPresettedRangesComponent)();
};
_NzDemoDatePickerPresettedRangesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoDatePickerPresettedRangesComponent, selectors: [["nz-demo-date-picker-presetted-ranges"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 1, consts: [["nzShowTime", "", "nzFormat", "yyyy/MM/dd HH:mm:ss", "ngModel", "", 3, "nzRanges"]], template: function NzDemoDatePickerPresettedRangesComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-range-picker", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("nzRanges", ctx.ranges);
  }
}, dependencies: [NzDatePickerModule, NzDatePickerComponent, NzRangePickerComponent], styles: ["\n\nnz-date-picker[_ngcontent-%COMP%], nz-range-picker[_ngcontent-%COMP%] {\n  margin: 0 8px 12px 0;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiZGF0ZS5jb21wb25lbnQudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIlxuICAgICAgbnotZGF0ZS1waWNrZXIsXG4gICAgICBuei1yYW5nZS1waWNrZXIge1xuICAgICAgICBtYXJnaW46IDAgOHB4IDEycHggMDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFBQTtBQUVFLFVBQUEsRUFBQSxJQUFBLEtBQUE7OyIsCiAgIm5hbWVzIjogW10KfQo= */"] });
var NzDemoDatePickerPresettedRangesComponent = _NzDemoDatePickerPresettedRangesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoDatePickerPresettedRangesComponent, { className: "NzDemoDatePickerPresettedRangesComponent", filePath: "src\\app\\routes\\dashboard\\v1\\components\\date.component.ts", lineNumber: 20 });
})();

// src/app/routes/dashboard/v1/components/model.ts
function NzDemoModalBasicComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "chart-pie-basic", 3);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx_r0.pie)("title", "Liquid Starch");
  }
}
var _NzDemoModalBasicComponent = class _NzDemoModalBasicComponent {
  constructor() {
    this.isVisible = false;
    this.pie = {
      series: [44, 55, 13, 43],
      chart: {
        type: "pie"
      },
      labels: ["Fructose Sugar", "Glucose ", "Srptol", "Dry Starch"],
      responsive: [
        {
          breakpoint: 480,
          options: {
            chart: {
              width: 200
            }
          }
        }
      ],
      legend: {
        show: false
      }
    };
  }
  showModal() {
    this.isVisible = true;
  }
  handleOk() {
    console.log("Button ok clicked!");
    this.isVisible = false;
  }
  handleCancel() {
    console.log("Button cancel clicked!");
    this.isVisible = false;
  }
};
_NzDemoModalBasicComponent.\u0275fac = function NzDemoModalBasicComponent_Factory(t) {
  return new (t || _NzDemoModalBasicComponent)();
};
_NzDemoModalBasicComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoModalBasicComponent, selectors: [["nz-demo-modal-basic"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 3, vars: 1, consts: [["nz-icon", "", "nzType", "info-circle", "nzTheme", "outline", 2, "cursor", "pointer", 3, "click"], ["nzTitle", "Liquid Starch Components\n", 3, "nzVisible", "nzVisibleChange", "nzOnCancel", "nzOnOk"], [4, "nzModalContent"], [3, "salesPieData", "title"]], template: function NzDemoModalBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 0);
    \u0275\u0275listener("click", function NzDemoModalBasicComponent_Template_span_click_0_listener() {
      return ctx.showModal();
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(1, "nz-modal", 1);
    \u0275\u0275listener("nzVisibleChange", function NzDemoModalBasicComponent_Template_nz_modal_nzVisibleChange_1_listener($event) {
      return ctx.isVisible = $event;
    })("nzOnCancel", function NzDemoModalBasicComponent_Template_nz_modal_nzOnCancel_1_listener() {
      return ctx.handleCancel();
    })("nzOnOk", function NzDemoModalBasicComponent_Template_nz_modal_nzOnOk_1_listener() {
      return ctx.handleOk();
    });
    \u0275\u0275template(2, NzDemoModalBasicComponent_ng_container_2_Template, 2, 2, "ng-container", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275property("nzVisible", ctx.isVisible);
  }
}, dependencies: [NzModalModule, NzModalComponent, NzModalContentDirective, CommonModule, NzIconModule, NzIconDirective, ChartPieBasicComponent], encapsulation: 2 });
var NzDemoModalBasicComponent = _NzDemoModalBasicComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoModalBasicComponent, { className: "NzDemoModalBasicComponent", filePath: "src\\app\\routes\\dashboard\\v1\\components\\model.ts", lineNumber: 28 });
})();

// src/app/routes/dashboard/v1/components/select.ts
var _NzDemoSelectSearchComponent = class _NzDemoSelectSearchComponent {
  constructor() {
    this.selectedValue = null;
    this.nzPlaceHolder = "";
  }
};
_NzDemoSelectSearchComponent.\u0275fac = function NzDemoSelectSearchComponent_Factory(t) {
  return new (t || _NzDemoSelectSearchComponent)();
};
_NzDemoSelectSearchComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoSelectSearchComponent, selectors: [["nz-demo-select-search"]], inputs: { nzPlaceHolder: "nzPlaceHolder" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 4, vars: 2, consts: [["nzShowSearch", "", "nzAllowClear", "", 2, "width", "100%", 3, "nzPlaceHolder", "ngModel", "ngModelChange"], ["nzLabel", "test-1", "nzValue", "test-1"], ["nzLabel", "test-2", "nzValue", "test-2"], ["nzLabel", "test-3", "nzValue", "test-3"]], template: function NzDemoSelectSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener($event) {
      return ctx.selectedValue = $event;
    });
    \u0275\u0275element(1, "nz-option", 1)(2, "nz-option", 2)(3, "nz-option", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPlaceHolder", ctx.nzPlaceHolder)("ngModel", ctx.selectedValue);
  }
}, dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, FormsModule, NgControlStatus, NgModel], styles: ["\n\nnz-select[_ngcontent-%COMP%] {\n  width: 200px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2VsZWN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIG56LXNlbGVjdCB7XG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxTQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoSelectSearchComponent = _NzDemoSelectSearchComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoSelectSearchComponent, { className: "NzDemoSelectSearchComponent", filePath: "src\\app\\routes\\dashboard\\v1\\components\\select.ts", lineNumber: 25 });
})();

// src/app/routes/dashboard/v1/components/table.ts
function NzDemoTableRowSelectionCustomComponent_tr_22_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr")(1, "td", 4);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_tr_22_Template_td_nzCheckedChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r4);
      const data_r2 = restoredCtx.$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onItemChecked(data_r2.id, $event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "td");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "td");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "td");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "td");
    \u0275\u0275text(9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "td");
    \u0275\u0275text(11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "td");
    \u0275\u0275element(13, "nz-badge", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "td");
    \u0275\u0275text(15);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "td");
    \u0275\u0275text(17);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzChecked", ctx_r1.setOfCheckedId.has(data_r2.id));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.Stage, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Input);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Production);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Waste);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Stops);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzSize", "small")("nzColor", data_r2.id > 2 ? "green" : "red")("nzText", data_r2.id > 2 ? data_r2.Status : "Off");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.ROP);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.TimeStamp);
  }
}
var _NzDemoTableRowSelectionCustomComponent = class _NzDemoTableRowSelectionCustomComponent {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
    this.pageSize = 5;
    this.pageIndex = 1;
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = new Array(200).fill(0).map((_, index) => ({
      id: index,
      Stage: `Stage  ${index}`,
      Input: "1000 kg",
      Production: "980 kg",
      Waste: `20 kg. ${index}`,
      Stops: `${index}`,
      Status: "On",
      ROP: "400 kg/h",
      TimeStamp: (/* @__PURE__ */ new Date()).toLocaleString()
    }));
  }
};
_NzDemoTableRowSelectionCustomComponent.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent)();
};
_NzDemoTableRowSelectionCustomComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent, selectors: [["nz-demo-table-row-selection-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 23, vars: 7, consts: [["nzShowSizeChanger", "", 3, "nzData", "nzPageSize", "nzPageIndex", "nzCurrentPageDataChange"], ["rowSelectionTable", ""], [3, "nzSelections", "nzChecked", "nzIndeterminate", "nzCheckedChange"], [4, "ngFor", "ngForOf"], [3, "nzChecked", "nzCheckedChange"], [3, "nzSize", "nzColor", "nzText"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1);
    \u0275\u0275listener("nzCurrentPageDataChange", function NzDemoTableRowSelectionCustomComponent_Template_nz_table_nzCurrentPageDataChange_0_listener($event) {
      return ctx.onCurrentPageDataChange($event);
    });
    \u0275\u0275elementStart(2, "thead")(3, "tr")(4, "th", 2);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.checked = $event;
    })("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.onAllChecked($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "th");
    \u0275\u0275text(6, "Stage");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "th");
    \u0275\u0275text(8, "Input");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "th");
    \u0275\u0275text(10, "Production");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "th");
    \u0275\u0275text(12, "Waste");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "th");
    \u0275\u0275text(14, "Stops");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "th");
    \u0275\u0275text(16, "Status");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "th");
    \u0275\u0275text(18, "ROP");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "th");
    \u0275\u0275text(20, "Time Stamp");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(21, "tbody");
    \u0275\u0275template(22, NzDemoTableRowSelectionCustomComponent_tr_22_Template, 18, 11, "tr", 3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzPageSize", ctx.pageSize)("nzPageIndex", ctx.pageIndex);
    \u0275\u0275advance(4);
    \u0275\u0275property("nzSelections", ctx.listOfSelection)("nzChecked", ctx.checked)("nzIndeterminate", ctx.indeterminate);
    \u0275\u0275advance(18);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzThSelectionComponent, CommonModule, NgForOf, NzAvatarModule, NzBadgeModule, NzBadgeComponent], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent = _NzDemoTableRowSelectionCustomComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\dashboard\\v1\\components\\table.ts", lineNumber: 73 });
})();

// src/libs/core/form/index.ts
var FormMode;
(function(FormMode2) {
  FormMode2[FormMode2["Add"] = 0] = "Add";
  FormMode2[FormMode2["Edit"] = 1] = "Edit";
})(FormMode || (FormMode = {}));

// src/libs/core/loading/loading.service.ts
var _LoadingService = class _LoadingService {
  constructor() {
    this.loading = false;
  }
  show() {
    this.loading = true;
  }
  hide() {
    this.loading = false;
  }
};
_LoadingService.\u0275fac = function LoadingService_Factory(t) {
  return new (t || _LoadingService)();
};
_LoadingService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _LoadingService, factory: _LoadingService.\u0275fac });
var LoadingService = _LoadingService;

// src/libs/core/loading/loading.interceptor.ts
var _LoadingInterceptor = class _LoadingInterceptor {
  constructor(loadingService) {
    this.loadingService = loadingService;
  }
  intercept(request, next) {
    this.loadingService.show();
    return next.handle(request).pipe(delay(1e3), finalize(() => {
      this.loadingService.hide();
    }));
  }
};
_LoadingInterceptor.\u0275fac = function LoadingInterceptor_Factory(t) {
  return new (t || _LoadingInterceptor)(\u0275\u0275inject(LoadingService));
};
_LoadingInterceptor.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _LoadingInterceptor, factory: _LoadingInterceptor.\u0275fac });
var LoadingInterceptor = _LoadingInterceptor;

// src/libs/core/loading/loading.module.ts
var _LoadingInterceptorModule = class _LoadingInterceptorModule {
};
_LoadingInterceptorModule.\u0275fac = function LoadingInterceptorModule_Factory(t) {
  return new (t || _LoadingInterceptorModule)();
};
_LoadingInterceptorModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _LoadingInterceptorModule });
_LoadingInterceptorModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ providers: [
  LoadingService,
  { provide: HTTP_INTERCEPTORS, useClass: LoadingInterceptor, multi: true }
] });
var LoadingInterceptorModule = _LoadingInterceptorModule;

// src/libs/core/page/index.ts
var _Page = class _Page {
  constructor() {
    this.i18n = inject(ALAIN_I18N_TOKEN);
    this.title = "";
    this.description = "";
  }
  ngOnChanges(changes) {
    if (changes["title"]) {
      this.title = this.i18n.fanyi(changes["title"].currentValue);
    }
    if (changes["description"]) {
      this.description = this.i18n.fanyi(changes["description"].currentValue);
    }
  }
};
_Page.\u0275fac = function Page_Factory(t) {
  return new (t || _Page)();
};
_Page.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _Page, selectors: [["fsi-ui-page"]], inputs: { title: "title", description: "description" }, standalone: true, features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature], decls: 2, vars: 2, consts: [[3, "title"]], template: function Page_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "page-header", 0);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("title", ctx.title);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx.description);
  }
}, dependencies: [PageHeaderModule, PageHeaderComponent], encapsulation: 2 });
var Page = _Page;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(Page, { className: "Page", filePath: "src\\libs\\core\\page\\index.ts", lineNumber: 13 });
})();

// src/libs/core/table/delete.drawer.ts
var _DeleteDrawerComponent = class _DeleteDrawerComponent {
  constructor(_ref, _msg, _i18n) {
    this._ref = _ref;
    this._msg = _msg;
    this._i18n = _i18n;
    this.reason = null;
  }
  ok() {
    if (!this.reason || this.reason == "") {
      this._msg.warning(this._i18n.fanyi("app.misc.specify_delete_reason"));
    } else {
      this._ref.close({
        reason: this.reason,
        id: this.record.id
      });
    }
  }
  cancel() {
    this._ref.close();
  }
};
_DeleteDrawerComponent.\u0275fac = function DeleteDrawerComponent_Factory(t) {
  return new (t || _DeleteDrawerComponent)(\u0275\u0275directiveInject(NzDrawerRef), \u0275\u0275directiveInject(NzMessageService), \u0275\u0275directiveInject(ALAIN_I18N_TOKEN));
};
_DeleteDrawerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _DeleteDrawerComponent, selectors: [["fsi-delete-drawer"]], inputs: { record: "record" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 8, vars: 8, consts: [["id", "reason", "rows", "4", "cols", "32", "nz-input", "", 3, "ngModel", "placeholder", "ngModelChange"], [1, "drawer-footer"], ["nz-button", "", "nzDanger", "", 3, "nzType", "click"]], template: function DeleteDrawerComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-form-item")(1, "nz-form-control")(2, "textarea", 0);
    \u0275\u0275listener("ngModelChange", function DeleteDrawerComponent_Template_textarea_ngModelChange_2_listener($event) {
      return ctx.reason = $event;
    });
    \u0275\u0275pipe(3, "i18n");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(4, "div", 1)(5, "button", 2);
    \u0275\u0275listener("click", function DeleteDrawerComponent_Template_button_click_5_listener() {
      return ctx.ok();
    });
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "i18n");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275property("ngModel", ctx.reason)("placeholder", \u0275\u0275pipeBind1(3, 4, "app.misc.reason_to_delete"));
    \u0275\u0275advance(3);
    \u0275\u0275property("nzType", "primary");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(7, 6, "app.misc.delete"), " ");
  }
}, dependencies: [FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, NzFormModule, NzColDirective, NzRowDirective, NzFormItemComponent, NzFormControlComponent, NzButtonModule, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, AlainThemeModule, I18nPipe], encapsulation: 2 });
var DeleteDrawerComponent = _DeleteDrawerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(DeleteDrawerComponent, { className: "DeleteDrawerComponent", filePath: "src\\libs\\core\\table\\delete.drawer.ts", lineNumber: 32 });
})();

// src/libs/core/table/ui-component.ts
var _c042 = ["st"];
function TableComponent_li_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 6);
    \u0275\u0275listener("click", function TableComponent_li_4_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r7);
      const c_r5 = restoredCtx.$implicit;
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.onChooseCriteria(c_r5));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r5 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", c_r5.title, " ");
  }
}
function TableComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7)(1, "div", 8)(2, "div")(3, "nz-button-group")(4, "button", 9);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 10);
    \u0275\u0275element(7, "span", 11);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(8, "div")(9, "input", 12);
    \u0275\u0275listener("input", function TableComponent_ng_template_5_Template_input_input_9_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r8 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r8._onKeywordChange($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "div")(11, "button", 13);
    \u0275\u0275listener("click", function TableComponent_ng_template_5_Template_button_click_11_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r10 = \u0275\u0275nextContext();
      const _r4 = \u0275\u0275reference(8);
      return \u0275\u0275resetView(ctx_r10.onSearch(_r4));
    });
    \u0275\u0275element(12, "span", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "div")(14, "button", 13);
    \u0275\u0275listener("click", function TableComponent_ng_template_5_Template_button_click_14_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r11 = \u0275\u0275nextContext();
      const _r4 = \u0275\u0275reference(8);
      return \u0275\u0275resetView(ctx_r11.onReset(_r4));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(15, "div")(16, "div")(17, "button", 13);
    \u0275\u0275listener("click", function TableComponent_ng_template_5_Template_button_click_17_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r12 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r12.onAddNew());
    });
    \u0275\u0275element(18, "span", 15);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    const _r0 = \u0275\u0275reference(2);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx_r2.displayedCriteria);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzDropdownMenu", _r0);
    \u0275\u0275advance(5);
    \u0275\u0275property("nzType", "primary");
    \u0275\u0275advance(3);
    \u0275\u0275property("nzType", "primary");
    \u0275\u0275advance(3);
    \u0275\u0275property("nzType", "primary");
  }
}
var _TableComponent = class _TableComponent {
  constructor() {
    this.columns = [];
    this.criteria = [];
    this.displayedCriteria = "";
    this.keyword = "";
    this.noResult = " ";
    this.page = {};
    this.request = {};
    this.response = {};
    this.url = "";
    this.addNew = new EventEmitter();
    this.ret = new EventEmitter();
    this.chooseCriteria = new EventEmitter();
    this.keywordChange = new EventEmitter();
    this.search = new EventEmitter();
    this.reset = new EventEmitter();
  }
  onChooseCriteria(c) {
    this.chooseCriteria.emit(c);
  }
  _onKeywordChange(event) {
    const value = event.target.value;
    this.keyword = value;
    this.keywordChange.emit(value);
  }
  onSearch(st) {
    this.search.emit(st);
  }
  onReset(st) {
    this.reset.emit(st);
  }
  onAddNew() {
    this.addNew.emit();
  }
  // eslint-disable-next-line @angular-eslint/no-empty-lifecycle-method
  ngOnChanges(_changes) {
  }
  change(ret) {
    this.ret.emit(ret);
  }
};
_TableComponent.\u0275fac = function TableComponent_Factory(t) {
  return new (t || _TableComponent)();
};
_TableComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _TableComponent, selectors: [["fsi-ui-table"]], viewQuery: function TableComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c042, 7);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.st = _t.first);
  }
}, inputs: { columns: "columns", contextMenuProvider: "contextMenuProvider", criteria: "criteria", displayedCriteria: "displayedCriteria", keyword: "keyword", noResult: "noResult", page: "page", pageIndex: "pageIndex", pageSize: "pageSize", total: "total", request: "request", response: "response", url: "url" }, outputs: { st: "st", addNew: "addNew", ret: "ret", chooseCriteria: "chooseCriteria", keywordChange: "keywordChange", search: "search", reset: "reset" }, exportAs: ["fsiTable"], standalone: true, features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature], decls: 9, vars: 13, consts: [["menu", "nzDropdownMenu"], ["nz-menu", ""], ["nz-menu-item", "", 3, "click", 4, "ngFor", "ngForOf"], ["header", ""], [3, "data", "columns", "contextmenu", "header", "loadingDelay", "noResult", "page", "pi", "ps", "req", "res", "total", "change"], ["st", ""], ["nz-menu-item", "", 3, "click"], [1, "header-tools-wrapper"], [1, "search-criteria-wrapper"], ["nz-button", ""], ["nz-button", "", "nz-dropdown", "", 3, "nzDropdownMenu"], ["nz-icon", "", "nzType", "ellipsis"], ["nz-input", "", "name", "keyword", 3, "input"], ["type", "button", "nz-button", "", 1, "header-button", 3, "nzType", "click"], ["nz-icon", "", "nzType", "search"], ["nz-icon", "", "nzType", "plus"]], template: function TableComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-card")(1, "nz-dropdown-menu", null, 0)(3, "ul", 1);
    \u0275\u0275template(4, TableComponent_li_4_Template, 2, 1, "li", 2);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(5, TableComponent_ng_template_5_Template, 19, 5, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementStart(7, "st", 4, 5);
    \u0275\u0275listener("change", function TableComponent_Template_st_change_7_listener($event) {
      return ctx.change($event);
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r3 = \u0275\u0275reference(6);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx.criteria);
    \u0275\u0275advance(3);
    \u0275\u0275property("data", ctx.url)("columns", ctx.columns)("contextmenu", ctx.contextMenuProvider)("header", _r3)("loadingDelay", 500)("noResult", ctx.noResult)("page", ctx.page)("pi", ctx.pageIndex)("ps", ctx.pageSize)("req", ctx.request)("res", ctx.response)("total", ctx.total);
  }
}, dependencies: [
  CommonModule,
  NgForOf,
  FormsModule,
  NzButtonModule,
  NzButtonComponent,
  NzButtonGroupComponent,
  NzTransitionPatchDirective,
  NzWaveDirective,
  NzDropDownModule,
  NzMenuDirective,
  NzMenuItemComponent,
  NzDropDownDirective,
  NzDropdownMenuComponent,
  NzDropdownButtonDirective,
  NzIconModule,
  NzIconDirective,
  NzInputModule,
  NzInputDirective,
  NzSelectModule,
  STModule,
  STComponent,
  NzCardModule,
  NzCardComponent
], styles: ["\n\n.header-tools-wrapper[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n.search-criteria-wrapper[_ngcontent-%COMP%] {\n  display: flex;\n  gap: 1rem;\n}\n.header-button[_ngcontent-%COMP%] {\n  width: 64px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidWktY29tcG9uZW50LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIC5oZWFkZXItdG9vbHMtd3JhcHBlciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgIH1cblxuICAgICAgLnNlYXJjaC1jcml0ZXJpYS13cmFwcGVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZ2FwOiAxcmVtO1xuICAgICAgfVxuXG4gICAgICAuaGVhZGVyLWJ1dHRvbiB7XG4gICAgICAgIHdpZHRoOiA2NHB4O1xuICAgICAgfVxuICAgICJdLAogICJtYXBwaW5ncyI6ICI7QUFDTSxDQUFBO0FBQ0UsV0FBQTtBQUNBLGVBQUE7QUFDQSxtQkFBQTs7QUFHRixDQUFBO0FBQ0UsV0FBQTtBQUNBLE9BQUE7O0FBR0YsQ0FBQTtBQUNFLFNBQUE7OyIsCiAgIm5hbWVzIjogW10KfQo= */"] });
var TableComponent = _TableComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(TableComponent, { className: "TableComponent", filePath: "src\\libs\\core\\table\\ui-component.ts", lineNumber: 113 });
})();

// src/libs/core/table/index.ts
var DownloadOption;
(function(DownloadOption2) {
  DownloadOption2[DownloadOption2["CSV"] = 0] = "CSV";
  DownloadOption2[DownloadOption2["JSON"] = 1] = "JSON";
  DownloadOption2[DownloadOption2["PDF"] = 2] = "PDF";
})(DownloadOption || (DownloadOption = {}));
var _Table = class _Table {
  constructor() {
    this.activatedRoute = inject(ActivatedRoute);
    this.message = inject(NzMessageService);
    this.router = inject(Router);
    this.i18n = inject(ALAIN_I18N_TOKEN);
    this.columns = [];
    this.criteria = [];
    this.displayedCriteria = "~";
    this.isLoading = false;
    this.keyword = "";
    this.noResult = " ";
    this.pager = {
      pageSizes: [5, 10, 20, 50, 100],
      position: "bottom"
    };
    this.pageIndex = 1;
    this.pageSize = 10;
    this.selectedCriteria = "";
    this.request = {
      method: "POST",
      body: {
        pn: this.pageIndex,
        ps: this.pageSize,
        criteria: {}
      },
      allInBody: true,
      reName: {
        pi: "pn",
        ps: "ps"
      }
    };
    this.response = {
      process: this.processResponse.bind(this)
    };
    this.url = "";
    this.contextMenuProvider = (options) => {
      if (options.type !== "head") {
        return [
          {
            text: "Edit",
            fn: (item) => {
              this.navigate().relatively([`../edit/${options.data["id"]}`]);
            }
          },
          {
            text: "Delete",
            fn: (item) => {
            }
          }
        ];
      } else {
        return [];
      }
    };
  }
  initialize() {
    this.columns = [
      ...this.getColumns(),
      {
        title: "",
        buttons: [
          {
            icon: "eye",
            click: console.log
          },
          {
            tooltip: this.i18n.fanyi("app.misc.delete"),
            icon: "delete",
            className: "text-error",
            type: "drawer",
            drawer: {
              title: this.i18n.fanyi("app.misc.delete"),
              component: DeleteDrawerComponent
            },
            click: (_record, modal, instance) => {
              this.onDelete(_record, modal).pipe(take(1)).subscribe(() => {
                this.message.success(this.i18n.fanyi("app.misc.deleted"));
                instance?.reload();
              }, (err) => {
                this.message.error(this.i18n.fanyi("app.misc.something_went_wrong"));
              });
            }
          }
          // {
          //   icon: 'ellipsis',
          //   children: [
          //     {
          //       type: 'static',
          //       icon: 'edit',
          //       click: (_record, modal) => {}
          //     }
          //   ]
          // }
        ]
      }
    ];
  }
  download(option) {
    return of();
  }
  onDelete(record, modal) {
    return of({});
  }
  /**
   * Navigate absolutely or relatively
   *
   * @returns {NavigationMapping}
   */
  navigate() {
    return {
      absolutely: (url) => this.router.navigateByUrl(url),
      relatively: (commands) => this.router.navigate(commands, { relativeTo: this.activatedRoute })
    };
  }
  /**
   *  implementation of getColumns().
   * @returns {Tabel Colums}
   */
  getColumns() {
    return [];
  }
  /**
   * Default implementation of response parsing.
   *
   * @param {any[]} data
   * @param {any} rawData
   * @returns {any[]}
   */
  processResponse(data, rawData) {
    return [];
  }
  onAdd() {
    this.navigate().relatively([`../new`]);
  }
  onKeywordChange(k) {
    this.keyword = k;
  }
  onReset(st) {
    this.tableRef = st;
    st.req.body = {
      pn: this.pageIndex,
      ps: this.pageSize,
      criteria: {}
    };
    this.keyword = "";
    this.selectedCriteria = "";
    this.displayedCriteria = "~";
    st.reload();
  }
  onSearch(st) {
    st.req.body = {
      pn: this.pageIndex,
      ps: this.pageSize,
      criteria: {
        [this.selectedCriteria]: this.keyword
      }
    };
    st.reload();
  }
  setCriteria(criteria) {
    this.displayedCriteria = criteria.title;
    this.selectedCriteria = criteria.index;
  }
  setLoading(state2) {
    this.isLoading = state2;
  }
};
_Table.\u0275fac = function Table_Factory(t) {
  return new (t || _Table)();
};
_Table.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _Table, selectors: [["fsi-table"]], decls: 0, vars: 0, template: function Table_Template(rf, ctx) {
}, encapsulation: 2 });
var Table = _Table;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(Table, { className: "Table", filePath: "src\\libs\\core\\table\\index.ts", lineNumber: 34 });
})();

// src/app/routes/dashboard/v1/table.component.ts
var _HomeTable = class _HomeTable extends Table {
  constructor() {
    super();
    this.request.method = "GET";
    this.url = "https://jsonplaceholder.typicode.com/posts";
  }
  ngOnInit() {
    this.initialize();
    this.criteria = [{ index: "id", title: "#" }];
  }
  getColumns() {
    return [
      { index: "id", title: "#" },
      { index: "product", title: "product" }
    ];
  }
  // Override method to process API response data
  processResponse(_data, rawData) {
    this.total = 99;
    return rawData.map((entity) => ({
      id: entity.id,
      product: entity.title
    }));
  }
};
_HomeTable.\u0275fac = function HomeTable_Factory(t) {
  return new (t || _HomeTable)();
};
_HomeTable.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HomeTable, selectors: [["audit-log-table"]], standalone: true, features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275StandaloneFeature], decls: 2, vars: 12, consts: [[3, "columns", "contextMenuProvider", "criteria", "displayedCriteria", "keyword", "noResult", "pageIndex", "pageSize", "request", "response", "url", "total", "addNew", "chooseCriteria", "keywordChange", "search", "reset"], ["st", ""]], template: function HomeTable_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "fsi-ui-table", 0, 1);
    \u0275\u0275listener("addNew", function HomeTable_Template_fsi_ui_table_addNew_0_listener() {
      return ctx.onAdd();
    })("chooseCriteria", function HomeTable_Template_fsi_ui_table_chooseCriteria_0_listener($event) {
      return ctx.setCriteria($event);
    })("keywordChange", function HomeTable_Template_fsi_ui_table_keywordChange_0_listener($event) {
      return ctx.onKeywordChange($event);
    })("search", function HomeTable_Template_fsi_ui_table_search_0_listener($event) {
      return ctx.onSearch($event);
    })("reset", function HomeTable_Template_fsi_ui_table_reset_0_listener($event) {
      return ctx.onReset($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("columns", ctx.columns)("contextMenuProvider", ctx.contextMenuProvider)("criteria", ctx.criteria)("displayedCriteria", ctx.displayedCriteria)("keyword", ctx.keyword)("noResult", ctx.noResult)("pageIndex", ctx.pageIndex)("pageSize", ctx.pageSize)("request", ctx.request)("response", ctx.response)("url", ctx.url)("total", ctx.total);
  }
}, dependencies: [TableComponent], encapsulation: 2 });
var HomeTable = _HomeTable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HomeTable, { className: "HomeTable", filePath: "src\\app\\routes\\dashboard\\v1\\table.component.ts", lineNumber: 35 });
})();

// src/app/routes/dashboard/v1/v1.component.ts
function DashboardV1Component_ng_template_88_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Sales Statistics ");
    \u0275\u0275elementStart(1, "small", 19);
    \u0275\u0275text(2, "Business Expectations & Retail Sales Statistics");
    \u0275\u0275elementEnd();
  }
}
var _DashboardV1Component = class _DashboardV1Component {
  constructor() {
    this.http = inject(_HttpClient);
    this.cdr = inject(ChangeDetectorRef);
    this.obSrv = inject(OnboardingService);
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
    this.pie = {
      series: [44, 55, 13, 43, 22],
      chart: {
        type: "pie"
      },
      labels: ["Starch A", "Starch B", "Starch C", "Starch D", "Starch E"],
      responsive: [
        {
          breakpoint: 480,
          options: {
            chart: {
              width: 200
            }
          }
        }
      ],
      legend: {
        show: false
      }
    };
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  ngOnInit() {
    setTimeout(() => {
    }, 1e3);
  }
};
_DashboardV1Component.\u0275fac = function DashboardV1Component_Factory(t) {
  return new (t || _DashboardV1Component)();
};
_DashboardV1Component.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _DashboardV1Component, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 90, vars: 13, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "12", 1, "mb-md"], ["nz-row", "", "nzType", "flex", "nzAlign", "middle", 1, "rounded-md", 2, "background-color", "#fff", "color", "#1890ff"], ["nz-col", "", "nzSpan", "12", 1, "p-md"], [1, "h2", "mt0"], [1, "text-nowrap", "mb0"], ["nz-col", "", "nzXs", "24", "nzMd", "18"], [2, "height", "500px", 3, "nzBordered", "nzTitle"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "6"], ["nz-col", "", "nzXs", "24", "nzSm", "24", "nzMd", "24"], [3, "nzTitle"], [2, "text-align", "center"], ["nzType", "circle", 3, "nzPercent", "nzStrokeWidth"], ["nz-col", "", "nzXs", "24", "nzMd", "6"], [2, "padding-top", "20%"], [3, "salesPieData"], [3, "nzBordered", "nzTitle"], ["salesTitle", ""], [1, "text-sm", "font-weight-normal"]], template: function DashboardV1Component_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Dashboard ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2)(7, "div", 1)(8, "div", 2)(9, "div", 3)(10, "div", 4)(11, "div", 5);
    \u0275\u0275text(12, "123,45 T");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "h3", 6);
    \u0275\u0275text(14, "Feed 15 %");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(15, "div", 2)(16, "div", 3)(17, "div", 4)(18, "div", 5);
    \u0275\u0275text(19, "234,56 T");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "h3", 6);
    \u0275\u0275text(21, "Feed 65 %");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(22, "div", 2)(23, "div", 3)(24, "div", 4)(25, "div", 5);
    \u0275\u0275text(26, "458,7 L");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(27, "h3", 6);
    \u0275\u0275text(28, "Oil");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(29, "div", 2)(30, "div", 3)(31, "div", 4)(32, "div", 5);
    \u0275\u0275text(33, "456 L");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(34, "h3", 6);
    \u0275\u0275text(35, "Liquid Starch ");
    \u0275\u0275element(36, "nz-demo-modal-basic");
    \u0275\u0275elementEnd()()()()()();
    \u0275\u0275elementStart(37, "div", 2)(38, "div", 1)(39, "div", 2)(40, "div", 3)(41, "div", 4)(42, "div", 5);
    \u0275\u0275text(43, "123,45 T");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(44, "h3", 6);
    \u0275\u0275text(45, "Raw Material 1");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(46, "div", 2)(47, "div", 3)(48, "div", 4)(49, "div", 5);
    \u0275\u0275text(50, "234,56 T");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(51, "h3", 6);
    \u0275\u0275text(52, "Raw Material 2");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(53, "div", 2)(54, "div", 3)(55, "div", 4)(56, "div", 5);
    \u0275\u0275text(57, "458,7 L");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(58, "h3", 6);
    \u0275\u0275text(59, "Raw Material 3");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(60, "div", 2)(61, "div", 3)(62, "div", 4)(63, "div", 5);
    \u0275\u0275text(64, "456 L");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(65, "h3", 6);
    \u0275\u0275text(66, "Raw Material 4");
    \u0275\u0275elementEnd()()()()()()();
    \u0275\u0275elementStart(67, "div", 1)(68, "div", 7)(69, "nz-card", 8);
    \u0275\u0275element(70, "chart-chart-echarts-on");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(71, "div", 9)(72, "div", 1)(73, "div", 10)(74, "nz-card", 11)(75, "div", 12);
    \u0275\u0275element(76, "nz-progress", 13);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(77, "div", 10)(78, "nz-card", 11)(79, "div", 12);
    \u0275\u0275element(80, "nz-progress", 13);
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275elementStart(81, "div", 14)(82, "nz-card", 8)(83, "div", 15);
    \u0275\u0275element(84, "chart-pie-basic", 16);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(85, "div", 7)(86, "nz-card", 17);
    \u0275\u0275element(87, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(88, DashboardV1Component_ng_template_88_Template, 3, 0, "ng-template", null, 18, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    \u0275\u0275advance(69);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Production");
    \u0275\u0275advance(5);
    \u0275\u0275property("nzTitle", "OEE");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzPercent", 75)("nzStrokeWidth", 10);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzTitle", "Up-Time");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzPercent", 25)("nzStrokeWidth", 10);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Corn Components");
    \u0275\u0275advance(2);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Stage Summary");
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzProgressComponent,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule,
  G2TimelineModule,
  LineChartComponent,
  ChartPieBasicComponent,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  OnboardingModule,
  NzDemoTableRowSelectionCustomComponent,
  NzDemoModalBasicComponent
], encapsulation: 2, changeDetection: 0 });
var DashboardV1Component = _DashboardV1Component;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(DashboardV1Component, { className: "DashboardV1Component", filePath: "src\\app\\routes\\dashboard\\v1\\v1.component.ts", lineNumber: 42 });
})();

// src/app/routes/pages/Ai/maintenance.component.ts
var _AiComponent = class _AiComponent {
  constructor() {
  }
};
_AiComponent.\u0275fac = function AiComponent_Factory(t) {
  return new (t || _AiComponent)();
};
_AiComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AiComponent, selectors: [["app-name"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 14, vars: 1, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "6", 1, "mb-md", 2, "width", "auto"], [3, "nzTitle"], ["nzText", "Message-1", "nzColor", "red"], ["nzTitle", "Oil Production Stage", "nzSize", "small"], ["nzText", "Message-2", "nzColor", "green"], ["nzTitle", "Corn Stock", "nzSize", "small"]], template: function AiComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Ai ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2)(7, "nz-card", 3)(8, "nz-ribbon", 4)(9, "nz-card", 5);
    \u0275\u0275text(10, " The oil production stage inside the factory was subjected to several interruptions during the current month as a result of electrical issues in the following motors ( SP1, CP2 ) ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "nz-ribbon", 6)(12, "nz-card", 7);
    \u0275\u0275text(13, " International news shows that there will be an increase in corn prices during the next two months, as the current corn stock inside the factory, along with its current consumption rate, shows that it will run out of the factory within a week, so there must be a direction to increase the stock the next period. ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(7);
    \u0275\u0275property("nzTitle", "Messages");
  }
}, dependencies: [CommonModule, NzBadgeModule, NzRibbonComponent, NzCardModule, NzCardComponent], encapsulation: 2 });
var AiComponent = _AiComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AiComponent, { className: "AiComponent", filePath: "src\\app\\routes\\pages\\Ai\\maintenance.component.ts", lineNumber: 39 });
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-page-header.mjs
function NzPageHeaderComponent_div_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const backIcon_r6 = ctx.$implicit;
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", backIcon_r6 || ctx_r5.getBackIcon());
  }
}
function NzPageHeaderComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275listener("click", function NzPageHeaderComponent_div_3_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.onBack());
    });
    \u0275\u0275elementStart(1, "div", 7);
    \u0275\u0275template(2, NzPageHeaderComponent_div_3_ng_container_2_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.nzBackIcon);
  }
}
function NzPageHeaderComponent_span_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r9.nzTitle);
  }
}
function NzPageHeaderComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 10);
    \u0275\u0275template(1, NzPageHeaderComponent_span_5_ng_container_1_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r1.nzTitle);
  }
}
function NzPageHeaderComponent_ng_content_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0, 6, ["*ngIf", "!nzTitle"]);
  }
}
function NzPageHeaderComponent_span_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r10.nzSubtitle);
  }
}
function NzPageHeaderComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 11);
    \u0275\u0275template(1, NzPageHeaderComponent_span_7_ng_container_1_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.nzSubtitle);
  }
}
function NzPageHeaderComponent_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0, 7, ["*ngIf", "!nzSubtitle"]);
  }
}
var _c043 = [[["nz-breadcrumb", "nz-page-header-breadcrumb", ""]], [["nz-avatar", "nz-page-header-avatar", ""]], [["nz-page-header-tags"], ["", "nz-page-header-tags", ""]], [["nz-page-header-extra"], ["", "nz-page-header-extra", ""]], [["nz-page-header-content"], ["", "nz-page-header-content", ""]], [["nz-page-header-footer"], ["", "nz-page-header-footer", ""]], [["nz-page-header-title"], ["", "nz-page-header-title", ""]], [["nz-page-header-subtitle"], ["", "nz-page-header-subtitle", ""]]];
var _c128 = ["nz-breadcrumb[nz-page-header-breadcrumb]", "nz-avatar[nz-page-header-avatar]", "nz-page-header-tags, [nz-page-header-tags]", "nz-page-header-extra, [nz-page-header-extra]", "nz-page-header-content, [nz-page-header-content]", "nz-page-header-footer, [nz-page-header-footer]", "nz-page-header-title, [nz-page-header-title]", "nz-page-header-subtitle, [nz-page-header-subtitle]"];
var _NzPageHeaderTitleDirective = class _NzPageHeaderTitleDirective {
};
_NzPageHeaderTitleDirective.\u0275fac = function NzPageHeaderTitleDirective_Factory(t) {
  return new (t || _NzPageHeaderTitleDirective)();
};
_NzPageHeaderTitleDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPageHeaderTitleDirective,
  selectors: [["nz-page-header-title"], ["", "nz-page-header-title", ""]],
  hostAttrs: [1, "ant-page-header-heading-title"],
  exportAs: ["nzPageHeaderTitle"],
  standalone: true
});
var NzPageHeaderTitleDirective = _NzPageHeaderTitleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderTitleDirective, [{
    type: Directive,
    args: [{
      selector: "nz-page-header-title, [nz-page-header-title]",
      exportAs: "nzPageHeaderTitle",
      host: {
        class: "ant-page-header-heading-title"
      },
      standalone: true
    }]
  }], null, null);
})();
var _NzPageHeaderSubtitleDirective = class _NzPageHeaderSubtitleDirective {
};
_NzPageHeaderSubtitleDirective.\u0275fac = function NzPageHeaderSubtitleDirective_Factory(t) {
  return new (t || _NzPageHeaderSubtitleDirective)();
};
_NzPageHeaderSubtitleDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPageHeaderSubtitleDirective,
  selectors: [["nz-page-header-subtitle"], ["", "nz-page-header-subtitle", ""]],
  hostAttrs: [1, "ant-page-header-heading-sub-title"],
  exportAs: ["nzPageHeaderSubtitle"],
  standalone: true
});
var NzPageHeaderSubtitleDirective = _NzPageHeaderSubtitleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderSubtitleDirective, [{
    type: Directive,
    args: [{
      selector: "nz-page-header-subtitle, [nz-page-header-subtitle]",
      exportAs: "nzPageHeaderSubtitle",
      host: {
        class: "ant-page-header-heading-sub-title"
      },
      standalone: true
    }]
  }], null, null);
})();
var _NzPageHeaderContentDirective = class _NzPageHeaderContentDirective {
};
_NzPageHeaderContentDirective.\u0275fac = function NzPageHeaderContentDirective_Factory(t) {
  return new (t || _NzPageHeaderContentDirective)();
};
_NzPageHeaderContentDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPageHeaderContentDirective,
  selectors: [["nz-page-header-content"], ["", "nz-page-header-content", ""]],
  hostAttrs: [1, "ant-page-header-content"],
  exportAs: ["nzPageHeaderContent"],
  standalone: true
});
var NzPageHeaderContentDirective = _NzPageHeaderContentDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderContentDirective, [{
    type: Directive,
    args: [{
      selector: "nz-page-header-content, [nz-page-header-content]",
      exportAs: "nzPageHeaderContent",
      host: {
        class: "ant-page-header-content"
      },
      standalone: true
    }]
  }], null, null);
})();
var _NzPageHeaderTagDirective = class _NzPageHeaderTagDirective {
};
_NzPageHeaderTagDirective.\u0275fac = function NzPageHeaderTagDirective_Factory(t) {
  return new (t || _NzPageHeaderTagDirective)();
};
_NzPageHeaderTagDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPageHeaderTagDirective,
  selectors: [["nz-page-header-tags"], ["", "nz-page-header-tags", ""]],
  hostAttrs: [1, "ant-page-header-heading-tags"],
  exportAs: ["nzPageHeaderTags"],
  standalone: true
});
var NzPageHeaderTagDirective = _NzPageHeaderTagDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderTagDirective, [{
    type: Directive,
    args: [{
      selector: "nz-page-header-tags, [nz-page-header-tags]",
      exportAs: "nzPageHeaderTags",
      host: {
        class: "ant-page-header-heading-tags"
      },
      standalone: true
    }]
  }], null, null);
})();
var _NzPageHeaderExtraDirective = class _NzPageHeaderExtraDirective {
};
_NzPageHeaderExtraDirective.\u0275fac = function NzPageHeaderExtraDirective_Factory(t) {
  return new (t || _NzPageHeaderExtraDirective)();
};
_NzPageHeaderExtraDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPageHeaderExtraDirective,
  selectors: [["nz-page-header-extra"], ["", "nz-page-header-extra", ""]],
  hostAttrs: [1, "ant-page-header-heading-extra"],
  exportAs: ["nzPageHeaderExtra"],
  standalone: true
});
var NzPageHeaderExtraDirective = _NzPageHeaderExtraDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderExtraDirective, [{
    type: Directive,
    args: [{
      selector: "nz-page-header-extra, [nz-page-header-extra]",
      exportAs: "nzPageHeaderExtra",
      host: {
        class: "ant-page-header-heading-extra"
      },
      standalone: true
    }]
  }], null, null);
})();
var _NzPageHeaderFooterDirective = class _NzPageHeaderFooterDirective {
};
_NzPageHeaderFooterDirective.\u0275fac = function NzPageHeaderFooterDirective_Factory(t) {
  return new (t || _NzPageHeaderFooterDirective)();
};
_NzPageHeaderFooterDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPageHeaderFooterDirective,
  selectors: [["nz-page-header-footer"], ["", "nz-page-header-footer", ""]],
  hostAttrs: [1, "ant-page-header-footer"],
  exportAs: ["nzPageHeaderFooter"],
  standalone: true
});
var NzPageHeaderFooterDirective = _NzPageHeaderFooterDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderFooterDirective, [{
    type: Directive,
    args: [{
      selector: "nz-page-header-footer, [nz-page-header-footer]",
      exportAs: "nzPageHeaderFooter",
      host: {
        class: "ant-page-header-footer"
      },
      standalone: true
    }]
  }], null, null);
})();
var _NzPageHeaderBreadcrumbDirective = class _NzPageHeaderBreadcrumbDirective {
};
_NzPageHeaderBreadcrumbDirective.\u0275fac = function NzPageHeaderBreadcrumbDirective_Factory(t) {
  return new (t || _NzPageHeaderBreadcrumbDirective)();
};
_NzPageHeaderBreadcrumbDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPageHeaderBreadcrumbDirective,
  selectors: [["nz-breadcrumb", "nz-page-header-breadcrumb", ""]],
  exportAs: ["nzPageHeaderBreadcrumb"],
  standalone: true
});
var NzPageHeaderBreadcrumbDirective = _NzPageHeaderBreadcrumbDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderBreadcrumbDirective, [{
    type: Directive,
    args: [{
      selector: "nz-breadcrumb[nz-page-header-breadcrumb]",
      exportAs: "nzPageHeaderBreadcrumb",
      standalone: true
    }]
  }], null, null);
})();
var _NzPageHeaderAvatarDirective = class _NzPageHeaderAvatarDirective {
};
_NzPageHeaderAvatarDirective.\u0275fac = function NzPageHeaderAvatarDirective_Factory(t) {
  return new (t || _NzPageHeaderAvatarDirective)();
};
_NzPageHeaderAvatarDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzPageHeaderAvatarDirective,
  selectors: [["nz-avatar", "nz-page-header-avatar", ""]],
  exportAs: ["nzPageHeaderAvatar"],
  standalone: true
});
var NzPageHeaderAvatarDirective = _NzPageHeaderAvatarDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderAvatarDirective, [{
    type: Directive,
    args: [{
      selector: "nz-avatar[nz-page-header-avatar]",
      exportAs: "nzPageHeaderAvatar",
      standalone: true
    }]
  }], null, null);
})();
var NZ_CONFIG_MODULE_NAME21 = "pageHeader";
var _NzPageHeaderComponent = class _NzPageHeaderComponent {
  constructor(location2, nzConfigService, elementRef, nzResizeObserver, cdr, directionality) {
    this.location = location2;
    this.nzConfigService = nzConfigService;
    this.elementRef = elementRef;
    this.nzResizeObserver = nzResizeObserver;
    this.cdr = cdr;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME21;
    this.nzBackIcon = null;
    this.nzGhost = true;
    this.nzBack = new EventEmitter();
    this.compact = false;
    this.destroy$ = new Subject();
    this.dir = "ltr";
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngAfterViewInit() {
    this.nzResizeObserver.observe(this.elementRef).pipe(map(([entry]) => entry.contentRect.width), takeUntil(this.destroy$)).subscribe((width) => {
      this.compact = width < 768;
      this.cdr.markForCheck();
    });
  }
  onBack() {
    if (this.nzBack.observers.length) {
      this.nzBack.emit();
    } else {
      if (!this.location) {
        throw new Error(`${PREFIX} you should import 'RouterModule' or register 'Location' if you want to use 'nzBack' default event!`);
      }
      this.location.back();
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  getBackIcon() {
    if (this.dir === "rtl") {
      return "arrow-right";
    }
    return "arrow-left";
  }
};
_NzPageHeaderComponent.\u0275fac = function NzPageHeaderComponent_Factory(t) {
  return new (t || _NzPageHeaderComponent)(\u0275\u0275directiveInject(Location, 8), \u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NzResizeObserver), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzPageHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzPageHeaderComponent,
  selectors: [["nz-page-header"]],
  contentQueries: function NzPageHeaderComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzPageHeaderFooterDirective, 5);
      \u0275\u0275contentQuery(dirIndex, NzPageHeaderBreadcrumbDirective, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzPageHeaderFooter = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nzPageHeaderBreadcrumb = _t.first);
    }
  },
  hostAttrs: [1, "ant-page-header"],
  hostVars: 10,
  hostBindings: function NzPageHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("has-footer", ctx.nzPageHeaderFooter)("ant-page-header-ghost", ctx.nzGhost)("has-breadcrumb", ctx.nzPageHeaderBreadcrumb)("ant-page-header-compact", ctx.compact)("ant-page-header-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzBackIcon: "nzBackIcon",
    nzTitle: "nzTitle",
    nzSubtitle: "nzSubtitle",
    nzGhost: "nzGhost"
  },
  outputs: {
    nzBack: "nzBack"
  },
  exportAs: ["nzPageHeader"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c128,
  decls: 13,
  vars: 5,
  consts: [[1, "ant-page-header-heading"], [1, "ant-page-header-heading-left"], ["class", "ant-page-header-back", 3, "click", 4, "ngIf"], ["class", "ant-page-header-heading-title", 4, "ngIf"], [4, "ngIf"], ["class", "ant-page-header-heading-sub-title", 4, "ngIf"], [1, "ant-page-header-back", 3, "click"], ["role", "button", "tabindex", "0", 1, "ant-page-header-back-button"], [4, "nzStringTemplateOutlet"], ["nz-icon", "", "nzTheme", "outline", 3, "nzType"], [1, "ant-page-header-heading-title"], [1, "ant-page-header-heading-sub-title"]],
  template: function NzPageHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c043);
      \u0275\u0275projection(0);
      \u0275\u0275elementStart(1, "div", 0)(2, "div", 1);
      \u0275\u0275template(3, NzPageHeaderComponent_div_3_Template, 3, 1, "div", 2);
      \u0275\u0275projection(4, 1);
      \u0275\u0275template(5, NzPageHeaderComponent_span_5_Template, 2, 1, "span", 3)(6, NzPageHeaderComponent_ng_content_6_Template, 1, 0, "ng-content", 4)(7, NzPageHeaderComponent_span_7_Template, 2, 1, "span", 5)(8, NzPageHeaderComponent_ng_content_8_Template, 1, 0, "ng-content", 4);
      \u0275\u0275projection(9, 2);
      \u0275\u0275elementEnd();
      \u0275\u0275projection(10, 3);
      \u0275\u0275elementEnd();
      \u0275\u0275projection(11, 4);
      \u0275\u0275projection(12, 5);
    }
    if (rf & 2) {
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", ctx.nzBackIcon !== null);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.nzTitle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.nzTitle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzSubtitle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.nzSubtitle);
    }
  },
  dependencies: [NgIf, NzOutletModule, NzStringTemplateOutletDirective, NzIconModule, NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzPageHeaderComponent = _NzPageHeaderComponent;
__decorate([WithConfig()], NzPageHeaderComponent.prototype, "nzGhost", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nz-page-header",
      exportAs: "nzPageHeader",
      template: `
    <ng-content select="nz-breadcrumb[nz-page-header-breadcrumb]"></ng-content>

    <div class="ant-page-header-heading">
      <div class="ant-page-header-heading-left">
        <!--back-->
        <div *ngIf="nzBackIcon !== null" (click)="onBack()" class="ant-page-header-back">
          <div role="button" tabindex="0" class="ant-page-header-back-button">
            <ng-container *nzStringTemplateOutlet="nzBackIcon; let backIcon">
              <span nz-icon [nzType]="backIcon || getBackIcon()" nzTheme="outline"></span>
            </ng-container>
          </div>
        </div>
        <!--avatar-->
        <ng-content select="nz-avatar[nz-page-header-avatar]"></ng-content>
        <!--title-->
        <span class="ant-page-header-heading-title" *ngIf="nzTitle">
          <ng-container *nzStringTemplateOutlet="nzTitle">{{ nzTitle }}</ng-container>
        </span>
        <ng-content *ngIf="!nzTitle" select="nz-page-header-title, [nz-page-header-title]"></ng-content>
        <!--subtitle-->
        <span class="ant-page-header-heading-sub-title" *ngIf="nzSubtitle">
          <ng-container *nzStringTemplateOutlet="nzSubtitle">{{ nzSubtitle }}</ng-container>
        </span>
        <ng-content *ngIf="!nzSubtitle" select="nz-page-header-subtitle, [nz-page-header-subtitle]"></ng-content>
        <ng-content select="nz-page-header-tags, [nz-page-header-tags]"></ng-content>
      </div>

      <ng-content select="nz-page-header-extra, [nz-page-header-extra]"></ng-content>
    </div>

    <ng-content select="nz-page-header-content, [nz-page-header-content]"></ng-content>
    <ng-content select="nz-page-header-footer, [nz-page-header-footer]"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      host: {
        class: "ant-page-header",
        "[class.has-footer]": "nzPageHeaderFooter",
        "[class.ant-page-header-ghost]": "nzGhost",
        "[class.has-breadcrumb]": "nzPageHeaderBreadcrumb",
        "[class.ant-page-header-compact]": "compact",
        "[class.ant-page-header-rtl]": `dir === 'rtl'`
      },
      imports: [NgIf, NzOutletModule, NzIconModule],
      standalone: true
    }]
  }], () => [{
    type: Location,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzConfigService
  }, {
    type: ElementRef
  }, {
    type: NzResizeObserver
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzBackIcon: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    nzSubtitle: [{
      type: Input
    }],
    nzGhost: [{
      type: Input
    }],
    nzBack: [{
      type: Output
    }],
    nzPageHeaderFooter: [{
      type: ContentChild,
      args: [NzPageHeaderFooterDirective, {
        static: false
      }]
    }],
    nzPageHeaderBreadcrumb: [{
      type: ContentChild,
      args: [NzPageHeaderBreadcrumbDirective, {
        static: false
      }]
    }]
  });
})();
var NzPageHeaderCells = [NzPageHeaderTitleDirective, NzPageHeaderSubtitleDirective, NzPageHeaderContentDirective, NzPageHeaderTagDirective, NzPageHeaderExtraDirective, NzPageHeaderFooterDirective, NzPageHeaderBreadcrumbDirective, NzPageHeaderAvatarDirective];
var _NzPageHeaderModule = class _NzPageHeaderModule {
};
_NzPageHeaderModule.\u0275fac = function NzPageHeaderModule_Factory(t) {
  return new (t || _NzPageHeaderModule)();
};
_NzPageHeaderModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzPageHeaderModule
});
_NzPageHeaderModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzPageHeaderComponent]
});
var NzPageHeaderModule = _NzPageHeaderModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPageHeaderModule, [{
    type: NgModule,
    args: [{
      imports: [NzPageHeaderComponent, NzPageHeaderCells],
      exports: [NzPageHeaderComponent, NzPageHeaderCells]
    }]
  }], null, null);
})();

// node_modules/@delon/chart/fesm2022/card.mjs
function G2CardComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r0.avatar);
  }
}
function G2CardComponent_Conditional_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r5.title);
  }
}
function G2CardComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 13);
    \u0275\u0275template(1, G2CardComponent_Conditional_7_ng_container_1_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r1.title);
  }
}
function G2CardComponent_Conditional_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r6.action);
  }
}
function G2CardComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275template(1, G2CardComponent_Conditional_8_ng_container_1_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2.action);
  }
}
function G2CardComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p", 15);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r3.total, \u0275\u0275sanitizeHtml);
  }
}
function G2CardComponent_Conditional_13_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r7.footer);
  }
}
function G2CardComponent_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275template(1, G2CardComponent_Conditional_13_ng_container_1_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r4.footer);
  }
}
var _c044 = () => ({
  padding: "20px 24px 8px 24px"
});
var _c129 = (a0) => ({
  height: a0
});
var _c219 = (a0) => ({
  "g2-card__fixed": a0
});
var _c314 = ["*"];
var _G2CardComponent = class _G2CardComponent {
  set contentHeight(value) {
    this._orgHeight = value;
    this._height = typeof value === "number" ? this._height = `${value}px` : value;
  }
  constructor(cdr) {
    this.cdr = cdr;
    this.bordered = false;
    this.total = "";
    this._height = "auto";
    this.loading = false;
  }
  ngOnChanges() {
    this.cdr.detectChanges();
  }
};
_G2CardComponent.\u0275fac = function G2CardComponent_Factory(t) {
  return new (t || _G2CardComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_G2CardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _G2CardComponent,
  selectors: [["g2-card"]],
  hostVars: 2,
  hostBindings: function G2CardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("g2-card", true);
    }
  },
  inputs: {
    bordered: "bordered",
    avatar: "avatar",
    title: "title",
    action: "action",
    total: "total",
    contentHeight: "contentHeight",
    footer: "footer",
    loading: "loading"
  },
  exportAs: ["g2Card"],
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c314,
  decls: 14,
  vars: 15,
  consts: [[3, "nzBodyStyle", "nzBordered"], [3, "nzSpinning"], [1, "g2-card__top"], [1, "g2-card__avatar"], [4, "nzStringTemplateOutlet"], [1, "g2-card__meta-wrap"], [1, "g2-card__meta"], ["class", "g2-card__meta-title"], ["class", "g2-card__meta-action"], ["class", "g2-card__total", 3, "innerHTML"], [1, "g2-card__desc", 3, "ngStyle"], [3, "ngClass"], ["class", "g2-card__footer"], [1, "g2-card__meta-title"], [1, "g2-card__meta-action"], [1, "g2-card__total", 3, "innerHTML"], [1, "g2-card__footer"]],
  template: function G2CardComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "nz-card", 0)(1, "nz-spin", 1)(2, "div", 2)(3, "div", 3);
      \u0275\u0275template(4, G2CardComponent_ng_container_4_Template, 2, 1, "ng-container", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "div", 5)(6, "div", 6);
      \u0275\u0275template(7, G2CardComponent_Conditional_7_Template, 2, 1, "span", 7)(8, G2CardComponent_Conditional_8_Template, 2, 1, "span", 8);
      \u0275\u0275elementEnd();
      \u0275\u0275template(9, G2CardComponent_Conditional_9_Template, 1, 1, "p", 9);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(10, "div", 10)(11, "div", 11);
      \u0275\u0275projection(12);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(13, G2CardComponent_Conditional_13_Template, 2, 1, "div", 12);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("nzBodyStyle", \u0275\u0275pureFunction0(10, _c044))("nzBordered", ctx.bordered);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzSpinning", ctx.loading);
      \u0275\u0275advance(3);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.avatar);
      \u0275\u0275advance(3);
      \u0275\u0275conditional(7, ctx.title ? 7 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(8, ctx.action ? 8 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(9, ctx.total ? 9 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(11, _c129, ctx._height));
      \u0275\u0275advance(1);
      \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(13, _c219, !!ctx._orgHeight));
      \u0275\u0275advance(2);
      \u0275\u0275conditional(13, ctx.footer ? 13 : -1);
    }
  },
  dependencies: [NgClass, NgStyle, NzCardComponent, NzSpinComponent, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var G2CardComponent = _G2CardComponent;
__decorate([InputBoolean2()], G2CardComponent.prototype, "bordered", void 0);
__decorate([InputBoolean2()], G2CardComponent.prototype, "loading", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2CardComponent, [{
    type: Component,
    args: [{
      selector: "g2-card",
      exportAs: "g2Card",
      host: {
        "[class.g2-card]": "true"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<nz-card [nzBodyStyle]="{ padding: '20px 24px 8px 24px' }" [nzBordered]="bordered">
  <nz-spin [nzSpinning]="loading">
    <div class="g2-card__top">
      <div class="g2-card__avatar">
        <ng-container *nzStringTemplateOutlet="avatar">{{ avatar }}</ng-container>
      </div>
      <div class="g2-card__meta-wrap">
        <div class="g2-card__meta">
          @if (title) {
            <span class="g2-card__meta-title">
              <ng-container *nzStringTemplateOutlet="title">{{ title }}</ng-container>
            </span>
          }
          @if (action) {
            <span class="g2-card__meta-action">
              <ng-container *nzStringTemplateOutlet="action">{{ action }}</ng-container>
            </span>
          }
        </div>
        @if (total) {
          <p class="g2-card__total" [innerHTML]="total"></p>
        }
      </div>
    </div>
    <div class="g2-card__desc" [ngStyle]="{ height: _height }">
      <div [ngClass]="{ 'g2-card__fixed': !!_orgHeight }">
        <ng-content />
      </div>
    </div>
    @if (footer) {
      <div class="g2-card__footer">
        <ng-container *nzStringTemplateOutlet="footer">{{ footer }}</ng-container>
      </div>
    }
  </nz-spin>
</nz-card>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    bordered: [{
      type: Input
    }],
    avatar: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    action: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    contentHeight: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    loading: [{
      type: Input
    }]
  });
})();
var COMPONENTS14 = [G2CardComponent];
var _G2CardModule = class _G2CardModule {
};
_G2CardModule.\u0275fac = function G2CardModule_Factory(t) {
  return new (t || _G2CardModule)();
};
_G2CardModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _G2CardModule
});
_G2CardModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzCardModule, NzSpinModule, NzOutletModule]
});
var G2CardModule = _G2CardModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2CardModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzCardModule, NzSpinModule, NzOutletModule],
      declarations: COMPONENTS14,
      exports: COMPONENTS14
    }]
  }], null, null);
})();

// node_modules/@delon/chart/fesm2022/trend.mjs
function TrendComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275element(1, "i", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMapInterpolate1("trend__", ctx_r0.flag, "");
    \u0275\u0275advance(1);
    \u0275\u0275propertyInterpolate1("nzType", "caret-", ctx_r0.flag, "");
  }
}
var _c045 = ["*"];
var _TrendComponent = class _TrendComponent {
  constructor() {
    this.colorful = true;
    this.reverseColor = false;
  }
};
_TrendComponent.\u0275fac = function TrendComponent_Factory(t) {
  return new (t || _TrendComponent)();
};
_TrendComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TrendComponent,
  selectors: [["trend"]],
  hostVars: 7,
  hostBindings: function TrendComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("data-flag", ctx.flag);
      \u0275\u0275classProp("trend", true)("trend__grey", !ctx.colorful)("trend__reverse", ctx.colorful && ctx.reverseColor);
    }
  },
  inputs: {
    flag: "flag",
    colorful: "colorful",
    reverseColor: "reverseColor"
  },
  exportAs: ["trend"],
  ngContentSelectors: _c045,
  decls: 2,
  vars: 1,
  consts: [[3, "class"], ["nz-icon", "", 3, "nzType"]],
  template: function TrendComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
      \u0275\u0275template(1, TrendComponent_Conditional_1_Template, 2, 4, "span", 0);
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, ctx.flag ? 1 : -1);
    }
  },
  dependencies: [NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var TrendComponent = _TrendComponent;
__decorate([InputBoolean2()], TrendComponent.prototype, "colorful", void 0);
__decorate([InputBoolean2()], TrendComponent.prototype, "reverseColor", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrendComponent, [{
    type: Component,
    args: [{
      selector: "trend",
      exportAs: "trend",
      template: `
    <ng-content />
    @if (flag) {
      <span class="trend__{{ flag }}"><i nz-icon nzType="caret-{{ flag }}"></i></span>
    }
  `,
      host: {
        "[class.trend]": "true",
        "[class.trend__grey]": "!colorful",
        "[class.trend__reverse]": "colorful && reverseColor",
        "[attr.data-flag]": `flag`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, {
    flag: [{
      type: Input
    }],
    colorful: [{
      type: Input
    }],
    reverseColor: [{
      type: Input
    }]
  });
})();
var COMPONENTS15 = [TrendComponent];
var _TrendModule = class _TrendModule {
};
_TrendModule.\u0275fac = function TrendModule_Factory(t) {
  return new (t || _TrendModule)();
};
_TrendModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TrendModule
});
_TrendModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzIconModule]
});
var TrendModule = _TrendModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TrendModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzIconModule],
      declarations: COMPONENTS15,
      exports: COMPONENTS15
    }]
  }], null, null);
})();

// src/app/routes/pages/inventory/charts/card.ts
function ChartCardStyle1Component_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 3);
  }
}
var _ChartCardStyle1Component = class _ChartCardStyle1Component {
};
_ChartCardStyle1Component.\u0275fac = function ChartCardStyle1Component_Factory(t) {
  return new (t || _ChartCardStyle1Component)();
};
_ChartCardStyle1Component.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartCardStyle1Component, selectors: [["chart-card-style1"]], inputs: { title: "title", total: "total" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 6, vars: 5, consts: [[2, "height", "400px", 3, "title", "bordered", "total", "contentHeight", "action"], ["action", ""], ["flag", "up", "reverseColor", "true", 2, "margin", "0 10px 0 8px", "color", "rgba(0,0,0,.85)"], ["nz-tooltip", "", "nzTooltipTitle", "Value", "nz-icon", "", "nzType", "info-circle"]], template: function ChartCardStyle1Component_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-card", 0);
    \u0275\u0275template(1, ChartCardStyle1Component_ng_template_1_Template, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275text(3, " Change ");
    \u0275\u0275elementStart(4, "trend", 2);
    \u0275\u0275text(5, "12%");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("title", ctx.title)("bordered", true)("total", ctx.total)("contentHeight", 93)("action", _r1);
  }
}, dependencies: [G2CardModule, G2CardComponent, NzToolTipModule, NzTooltipDirective, TrendModule, TrendComponent], encapsulation: 2 });
var ChartCardStyle1Component = _ChartCardStyle1Component;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartCardStyle1Component, { className: "ChartCardStyle1Component", filePath: "src\\app\\routes\\pages\\inventory\\charts\\card.ts", lineNumber: 21 });
})();

// node_modules/@delon/chart/fesm2022/water-wave.mjs
var _c046 = ["container"];
function G2WaterWaveComponent_Conditional_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r2.title);
  }
}
function G2WaterWaveComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 6);
    \u0275\u0275template(1, G2WaterWaveComponent_Conditional_4_ng_container_1_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r1.title);
  }
}
var _c130 = (a0, a1) => ({
  "height.px": a0,
  "width.px": a1,
  overflow: "hidden"
});
var _c220 = (a0) => ({
  "width.px": a0
});
var _G2WaterWaveComponent = class _G2WaterWaveComponent {
  // #endregion
  constructor(el, renderer, ngZone, cdr, platform) {
    this.el = el;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.platform = platform;
    this.resize$ = null;
    this.animate = true;
    this.delay = 0;
    this.color = "#1890FF";
    this.height = 160;
  }
  renderChart(isUpdate) {
    if (!this.resize$)
      return;
    this.updateRadio();
    const {
      percent,
      color,
      node,
      animate: animate2
    } = this;
    const data = Math.min(Math.max(percent / 100, 0), 100);
    const self = this;
    cancelAnimationFrame(this.timer);
    const canvas = node.nativeElement;
    const ctx = canvas.getContext("2d");
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const radius = canvasWidth / 2;
    const lineWidth = 2;
    const cR = radius - lineWidth;
    ctx.beginPath();
    ctx.lineWidth = lineWidth * 2;
    const axisLength = canvasWidth - lineWidth;
    const unit = axisLength / 8;
    const xOffset = lineWidth;
    let sp = 0;
    const range = 0.2;
    let currRange = range;
    let currData = 0;
    const waveupsp = animate2 ? 5e-3 : 0.015;
    let arcStack = [];
    const bR = radius - lineWidth;
    const circleOffset = -(Math.PI / 2);
    let circleLock = true;
    for (let i = circleOffset; i < circleOffset + 2 * Math.PI; i += 1 / (8 * Math.PI)) {
      arcStack.push([radius + bR * Math.cos(i), radius + bR * Math.sin(i)]);
    }
    const cStartPoint = arcStack.shift();
    ctx.strokeStyle = color;
    ctx.moveTo(cStartPoint[0], cStartPoint[1]);
    function drawSin() {
      ctx.beginPath();
      ctx.save();
      const sinStack = [];
      for (let i = xOffset; i <= xOffset + axisLength; i += 20 / axisLength) {
        const x = sp + (xOffset + i) / unit;
        const y = Math.sin(x) * currRange;
        const dx = i;
        const dy = 2 * cR * (1 - currData) + (radius - cR) - unit * y;
        ctx.lineTo(dx, dy);
        sinStack.push([dx, dy]);
      }
      const startPoint = sinStack.shift();
      ctx.lineTo(xOffset + axisLength, canvasHeight);
      ctx.lineTo(xOffset, canvasHeight);
      ctx.lineTo(startPoint[0], startPoint[1]);
      const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
      gradient.addColorStop(0, "#ffffff");
      gradient.addColorStop(1, color);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.restore();
    }
    function render() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      if (circleLock && !isUpdate) {
        if (arcStack.length) {
          if (animate2) {
            const temp = arcStack.shift();
            ctx.lineTo(temp[0], temp[1]);
            ctx.stroke();
          } else {
            for (const temp of arcStack) {
              ctx.lineTo(temp[0], temp[1]);
              ctx.stroke();
            }
            arcStack = [];
          }
        } else {
          circleLock = false;
          ctx.lineTo(cStartPoint[0], cStartPoint[1]);
          ctx.stroke();
          arcStack = null;
          ctx.globalCompositeOperation = "destination-over";
          ctx.beginPath();
          ctx.lineWidth = lineWidth;
          ctx.arc(radius, radius, bR, 0, 2 * Math.PI, true);
          ctx.beginPath();
          ctx.save();
          ctx.arc(radius, radius, radius - 3 * lineWidth, 0, 2 * Math.PI, true);
          ctx.restore();
          ctx.clip();
          ctx.fillStyle = color;
        }
      } else {
        if (data >= 0.85) {
          if (currRange > range / 4) {
            const t = range * 0.01;
            currRange -= t;
          }
        } else if (data <= 0.1) {
          if (currRange < range * 1.5) {
            const t = range * 0.01;
            currRange += t;
          }
        } else {
          if (currRange <= range) {
            const t = range * 0.01;
            currRange += t;
          }
          if (currRange >= range) {
            const t = range * 0.01;
            currRange -= t;
          }
        }
        if (data - currData > 0) {
          currData += waveupsp;
        }
        if (data - currData < 0) {
          currData -= waveupsp;
        }
        sp += 0.07;
        drawSin();
      }
      self.timer = requestAnimationFrame(render);
    }
    render();
  }
  updateRadio() {
    const {
      offsetWidth
    } = this.el.nativeElement.parentNode;
    const radio = offsetWidth < this.height ? offsetWidth / this.height : 1;
    this.renderer.setStyle(this.el.nativeElement, "transform", `scale(${radio})`);
  }
  render() {
    this.renderChart(false);
  }
  installResizeEvent() {
    this.resize$ = fromEvent(window, "resize").pipe(debounceTime(200)).subscribe(() => this.updateRadio());
  }
  ngOnInit() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.installResizeEvent();
    this.ngZone.runOutsideAngular(() => setTimeout(() => this.render(), this.delay));
  }
  ngOnChanges() {
    this.ngZone.runOutsideAngular(() => this.renderChart(true));
    this.cdr.detectChanges();
  }
  ngOnDestroy() {
    if (this.timer) {
      cancelAnimationFrame(this.timer);
    }
    if (this.resize$) {
      this.resize$.unsubscribe();
    }
  }
};
_G2WaterWaveComponent.\u0275fac = function G2WaterWaveComponent_Factory(t) {
  return new (t || _G2WaterWaveComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Platform));
};
_G2WaterWaveComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _G2WaterWaveComponent,
  selectors: [["g2-water-wave"]],
  viewQuery: function G2WaterWaveComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c046, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.node = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function G2WaterWaveComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("g2-water-wave", true);
    }
  },
  inputs: {
    animate: "animate",
    delay: "delay",
    title: "title",
    color: "color",
    height: "height",
    percent: "percent"
  },
  exportAs: ["g2WaterWave"],
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 7,
  vars: 11,
  consts: [[3, "ngStyle"], [1, "g2-water-wave__canvas", 3, "width", "height"], ["container", ""], [1, "g2-water-wave__desc", 3, "ngStyle"], ["class", "g2-water-wave__desc-title"], [1, "g2-water-wave__desc-percent"], [1, "g2-water-wave__desc-title"], [4, "nzStringTemplateOutlet"]],
  template: function G2WaterWaveComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275element(1, "canvas", 1, 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "div", 3);
      \u0275\u0275template(4, G2WaterWaveComponent_Conditional_4_Template, 2, 1, "span", 4);
      \u0275\u0275elementStart(5, "h4", 5);
      \u0275\u0275text(6);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("ngStyle", \u0275\u0275pureFunction2(6, _c130, ctx.height, ctx.height));
      \u0275\u0275advance(1);
      \u0275\u0275propertyInterpolate("width", ctx.height * 2);
      \u0275\u0275propertyInterpolate("height", ctx.height * 2);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(9, _c220, ctx.height));
      \u0275\u0275advance(1);
      \u0275\u0275conditional(4, ctx.title ? 4 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1("", ctx.percent, "%");
    }
  },
  dependencies: [NgStyle, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var G2WaterWaveComponent = _G2WaterWaveComponent;
__decorate([InputBoolean2()], G2WaterWaveComponent.prototype, "animate", void 0);
__decorate([InputNumber2()], G2WaterWaveComponent.prototype, "delay", void 0);
__decorate([InputNumber2()], G2WaterWaveComponent.prototype, "height", void 0);
__decorate([InputNumber2()], G2WaterWaveComponent.prototype, "percent", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2WaterWaveComponent, [{
    type: Component,
    args: [{
      selector: "g2-water-wave",
      exportAs: "g2WaterWave",
      host: {
        "[class.g2-water-wave]": "true"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<div [ngStyle]="{ 'height.px': height, 'width.px': height, overflow: 'hidden' }">
  <canvas #container class="g2-water-wave__canvas" width="{{ height * 2 }}" height="{{ height * 2 }}"></canvas>
</div>
<div class="g2-water-wave__desc" [ngStyle]="{ 'width.px': height }">
  @if (title) {
    <span class="g2-water-wave__desc-title">
      <ng-container *nzStringTemplateOutlet="title">{{ title }}</ng-container>
    </span>
  }
  <h4 class="g2-water-wave__desc-percent">{{ percent }}%</h4>
</div>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: Platform
  }], {
    node: [{
      type: ViewChild,
      args: ["container", {
        static: true
      }]
    }],
    animate: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    percent: [{
      type: Input
    }]
  });
})();
var COMPONENTS16 = [G2WaterWaveComponent];
var _G2WaterWaveModule = class _G2WaterWaveModule {
};
_G2WaterWaveModule.\u0275fac = function G2WaterWaveModule_Factory(t) {
  return new (t || _G2WaterWaveModule)();
};
_G2WaterWaveModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _G2WaterWaveModule
});
_G2WaterWaveModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzOutletModule]
});
var G2WaterWaveModule = _G2WaterWaveModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2WaterWaveModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzOutletModule],
      declarations: COMPONENTS16,
      exports: COMPONENTS16
    }]
  }], null, null);
})();

// src/app/routes/pages/inventory/charts/percent.component.ts
var _ChartWaterWaveBasicComponent = class _ChartWaterWaveBasicComponent {
};
_ChartWaterWaveBasicComponent.\u0275fac = function ChartWaterWaveBasicComponent_Factory(t) {
  return new (t || _ChartWaterWaveBasicComponent)();
};
_ChartWaterWaveBasicComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartWaterWaveBasicComponent, selectors: [["chart-water-wave-basic"]], hostVars: 2, hostBindings: function ChartWaterWaveBasicComponent_HostBindings(rf, ctx) {
  if (rf & 2) {
    \u0275\u0275classProp("d-block", true);
  }
}, inputs: { percent: "percent", title: "title", color: "color" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 5, consts: [[3, "delay", "title", "percent", "height", "color"]], template: function ChartWaterWaveBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "g2-water-wave", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("delay", 10)("title", ctx.title)("percent", ctx.percent)("height", 161)("color", ctx.color);
  }
}, dependencies: [G2WaterWaveModule, G2WaterWaveComponent], encapsulation: 2 });
var ChartWaterWaveBasicComponent = _ChartWaterWaveBasicComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartWaterWaveBasicComponent, { className: "ChartWaterWaveBasicComponent", filePath: "src\\app\\routes\\pages\\inventory\\charts\\percent.component.ts", lineNumber: 14 });
})();

// src/app/routes/pages/inventory/charts/pie.component.ts
var _c047 = ["chart"];
var _ChartPieBasicComponent2 = class _ChartPieBasicComponent2 {
  ngOnInit() {
    this.chartOptions = this.salesPieData;
  }
};
_ChartPieBasicComponent2.\u0275fac = function ChartPieBasicComponent_Factory(t) {
  return new (t || _ChartPieBasicComponent2)();
};
_ChartPieBasicComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartPieBasicComponent2, selectors: [["chart-pie-basic"]], viewQuery: function ChartPieBasicComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c047, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chart = _t.first);
  }
}, inputs: { salesPieData: "salesPieData" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 3, vars: 6, consts: [[3, "series", "chart", "labels", "responsive", "dataLabels", "legend"], [2, "text-align", "center"]], template: function ChartPieBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "apx-chart", 0);
    \u0275\u0275elementStart(1, "h3", 1);
    \u0275\u0275text(2, "Max = 100/T");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("series", ctx.chartOptions == null ? null : ctx.chartOptions.series)("chart", ctx.chartOptions == null ? null : ctx.chartOptions.chart)("labels", ctx.chartOptions == null ? null : ctx.chartOptions.labels)("responsive", ctx.chartOptions == null ? null : ctx.chartOptions.responsive)("dataLabels", ctx.chartOptions == null ? null : ctx.chartOptions.dataLabels)("legend", ctx.chartOptions == null ? null : ctx.chartOptions.legend);
  }
}, dependencies: [CommonModule, NgApexchartsModule, ChartComponent], styles: ["\n\n[_nghost-%COMP%] {\n  width: 50%;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsicGllLmNvbXBvbmVudC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXG4gICAgICA6aG9zdCB7XG4gICAgICAgIHdpZHRoOiA1MCU7XG4gICAgICB9XG4gICAgIl0sCiAgIm1hcHBpbmdzIjogIjtBQUNNO0FBQ0UsU0FBQTs7IiwKICAibmFtZXMiOiBbXQp9Cg== */"] });
var ChartPieBasicComponent2 = _ChartPieBasicComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartPieBasicComponent2, { className: "ChartPieBasicComponent", filePath: "src\\app\\routes\\pages\\inventory\\charts\\pie.component.ts", lineNumber: 35 });
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-steps.mjs
var _c048 = ["processDotTemplate"];
var _c131 = ["itemContainer"];
function NzStepComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 10);
  }
}
function NzStepComponent_ng_template_4_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275element(1, "nz-progress", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzPercent", ctx_r7.nzPercentage)("nzWidth", ctx_r7.nzSize === "small" ? 32 : 40)("nzFormat", ctx_r7.nullProcessFormat)("nzStrokeWidth", 4);
  }
}
function NzStepComponent_ng_template_4_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275element(1, "span", 16);
    \u0275\u0275elementEnd();
  }
}
function NzStepComponent_ng_template_4_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275element(1, "span", 17);
    \u0275\u0275elementEnd();
  }
}
function NzStepComponent_ng_template_4_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r10.index + 1, " ");
  }
}
function NzStepComponent_ng_template_4_span_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "span", 18);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const icon_r13 = ctx.$implicit;
    const ctx_r12 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", !ctx_r12.oldAPIIcon && icon_r13)("ngClass", ctx_r12.oldAPIIcon && icon_r13);
  }
}
function NzStepComponent_ng_template_4_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275template(1, NzStepComponent_ng_template_4_span_4_ng_container_1_Template, 2, 2, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r11 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r11.nzIcon);
  }
}
function NzStepComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzStepComponent_ng_template_4_div_0_Template, 2, 4, "div", 11)(1, NzStepComponent_ng_template_4_span_1_Template, 2, 0, "span", 12)(2, NzStepComponent_ng_template_4_span_2_Template, 2, 0, "span", 12)(3, NzStepComponent_ng_template_4_span_3_Template, 2, 1, "span", 12)(4, NzStepComponent_ng_template_4_span_4_Template, 2, 1, "span", 12);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r2.showProgress);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.nzStatus === "finish" && !ctx_r2.nzIcon);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.nzStatus === "error");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", (ctx_r2.nzStatus === "process" || ctx_r2.nzStatus === "wait") && !ctx_r2.nzIcon);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.nzIcon);
  }
}
function NzStepComponent_ng_template_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 21);
  }
}
function NzStepComponent_ng_template_5_ng_template_3_Template(rf, ctx) {
}
var _c221 = (a0, a1, a2) => ({
  $implicit: a0,
  status: a1,
  index: a2
});
function NzStepComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275template(1, NzStepComponent_ng_template_5_ng_template_1_Template, 1, 0, "ng-template", null, 19, \u0275\u0275templateRefExtractor)(3, NzStepComponent_ng_template_5_ng_template_3_Template, 0, 0, "ng-template", 20);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _r15 = \u0275\u0275reference(2);
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.customProcessTemplate || _r15)("ngTemplateOutletContext", \u0275\u0275pureFunction3(2, _c221, _r15, ctx_r3.nzStatus, ctx_r3.index));
  }
}
function NzStepComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r4.nzTitle);
  }
}
function NzStepComponent_div_9_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r17 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r17.nzSubtitle);
  }
}
function NzStepComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22);
    \u0275\u0275template(1, NzStepComponent_div_9_ng_container_1_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r5.nzSubtitle);
  }
}
function NzStepComponent_ng_container_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r6.nzDescription);
  }
}
var _c315 = ["*"];
var _NzStepComponent = class _NzStepComponent {
  get nzStatus() {
    return this._status;
  }
  set nzStatus(status) {
    this._status = status;
    this.isCustomStatus = true;
  }
  get nzIcon() {
    return this._icon;
  }
  set nzIcon(value) {
    if (!(value instanceof TemplateRef)) {
      this.oldAPIIcon = typeof value === "string" && value.indexOf("anticon") > -1;
    } else {
    }
    this._icon = value;
  }
  get showProgress() {
    return this.nzPercentage !== null && !this.nzIcon && this.nzStatus === "process" && this.nzPercentage >= 0 && this.nzPercentage <= 100;
  }
  get currentIndex() {
    return this._currentIndex;
  }
  set currentIndex(current) {
    this._currentIndex = current;
    if (!this.isCustomStatus) {
      this._status = current > this.index ? "finish" : current === this.index ? this.outStatus || "" : "wait";
    }
  }
  constructor(cdr, ngZone, destroy$) {
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.destroy$ = destroy$;
    this.nzDisabled = false;
    this.nzPercentage = null;
    this.nzSize = "default";
    this.isCustomStatus = false;
    this._status = "wait";
    this.oldAPIIcon = true;
    this.direction = "horizontal";
    this.index = 0;
    this.last = false;
    this.outStatus = "process";
    this.showProcessDot = false;
    this.clickable = false;
    this.clickOutsideAngular$ = new Subject();
    this.nullProcessFormat = () => null;
    this._currentIndex = 0;
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => fromEvent(this.itemContainer.nativeElement, "click").pipe(filter(() => this.clickable && this.currentIndex !== this.index && !this.nzDisabled), takeUntil(this.destroy$)).subscribe(() => {
      this.clickOutsideAngular$.next(this.index);
    }));
  }
  enable() {
    this.nzDisabled = false;
    this.cdr.markForCheck();
  }
  disable() {
    this.nzDisabled = true;
    this.cdr.markForCheck();
  }
  markForCheck() {
    this.cdr.markForCheck();
  }
};
_NzStepComponent.\u0275fac = function NzStepComponent_Factory(t) {
  return new (t || _NzStepComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(NzDestroyService));
};
_NzStepComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzStepComponent,
  selectors: [["nz-step"]],
  viewQuery: function NzStepComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c048, 5);
      \u0275\u0275viewQuery(_c131, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.processDotTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.itemContainer = _t.first);
    }
  },
  hostAttrs: [1, "ant-steps-item"],
  hostVars: 16,
  hostBindings: function NzStepComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-steps-item-wait", ctx.nzStatus === "wait")("ant-steps-item-process", ctx.nzStatus === "process")("ant-steps-item-finish", ctx.nzStatus === "finish")("ant-steps-item-error", ctx.nzStatus === "error")("ant-steps-item-active", ctx.currentIndex === ctx.index)("ant-steps-item-disabled", ctx.nzDisabled)("ant-steps-item-custom", !!ctx.nzIcon)("ant-steps-next-error", ctx.outStatus === "error" && ctx.currentIndex === ctx.index + 1);
    }
  },
  inputs: {
    nzTitle: "nzTitle",
    nzSubtitle: "nzSubtitle",
    nzDescription: "nzDescription",
    nzDisabled: "nzDisabled",
    nzPercentage: "nzPercentage",
    nzSize: "nzSize",
    nzStatus: "nzStatus",
    nzIcon: "nzIcon"
  },
  exportAs: ["nzStep"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService]), \u0275\u0275StandaloneFeature],
  decls: 12,
  vars: 8,
  consts: [[1, "ant-steps-item-container", 3, "tabindex"], ["itemContainer", ""], ["class", "ant-steps-item-tail", 4, "ngIf"], [1, "ant-steps-item-icon"], [3, "ngIf"], [1, "ant-steps-item-content"], [1, "ant-steps-item-title"], [4, "nzStringTemplateOutlet"], ["class", "ant-steps-item-subtitle", 4, "ngIf"], [1, "ant-steps-item-description"], [1, "ant-steps-item-tail"], ["class", "ant-steps-progress-icon", 4, "ngIf"], ["class", "ant-steps-icon", 4, "ngIf"], [1, "ant-steps-progress-icon"], ["nzType", "circle", 3, "nzPercent", "nzWidth", "nzFormat", "nzStrokeWidth"], [1, "ant-steps-icon"], ["nz-icon", "", "nzType", "check"], ["nz-icon", "", "nzType", "close"], ["nz-icon", "", 3, "nzType", "ngClass"], ["processDotTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "ant-steps-icon-dot"], [1, "ant-steps-item-subtitle"]],
  template: function NzStepComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0, 1);
      \u0275\u0275template(2, NzStepComponent_div_2_Template, 1, 0, "div", 2);
      \u0275\u0275elementStart(3, "div", 3);
      \u0275\u0275template(4, NzStepComponent_ng_template_4_Template, 5, 5, "ng-template", 4)(5, NzStepComponent_ng_template_5_Template, 4, 6, "ng-template", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "div", 5)(7, "div", 6);
      \u0275\u0275template(8, NzStepComponent_ng_container_8_Template, 2, 1, "ng-container", 7)(9, NzStepComponent_div_9_Template, 2, 1, "div", 8);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(10, "div", 9);
      \u0275\u0275template(11, NzStepComponent_ng_container_11_Template, 2, 1, "ng-container", 7);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("tabindex", ctx.clickable && !ctx.nzDisabled ? 0 : null);
      \u0275\u0275attribute("role", ctx.clickable && !ctx.nzDisabled ? "button" : null);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.last !== true);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", !ctx.showProcessDot);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.showProcessDot);
      \u0275\u0275advance(3);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzTitle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzSubtitle);
      \u0275\u0275advance(2);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzDescription);
    }
  },
  dependencies: [NgIf, NzProgressModule, NzProgressComponent, NzIconModule, NzIconDirective, NzOutletModule, NzStringTemplateOutletDirective, NgClass, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzStepComponent = _NzStepComponent;
__decorate([InputBoolean()], NzStepComponent.prototype, "nzDisabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzStepComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-step",
      exportAs: "nzStep",
      preserveWhitespaces: false,
      template: `
    <div
      #itemContainer
      class="ant-steps-item-container"
      [attr.role]="clickable && !nzDisabled ? 'button' : null"
      [tabindex]="clickable && !nzDisabled ? 0 : null"
    >
      <div class="ant-steps-item-tail" *ngIf="last !== true"></div>
      <div class="ant-steps-item-icon">
        <ng-template [ngIf]="!showProcessDot">
          <div *ngIf="showProgress" class="ant-steps-progress-icon">
            <nz-progress
              [nzPercent]="nzPercentage"
              nzType="circle"
              [nzWidth]="nzSize === 'small' ? 32 : 40"
              [nzFormat]="nullProcessFormat"
              [nzStrokeWidth]="4"
            ></nz-progress>
          </div>
          <span class="ant-steps-icon" *ngIf="nzStatus === 'finish' && !nzIcon"
            ><span nz-icon nzType="check"></span
          ></span>
          <span class="ant-steps-icon" *ngIf="nzStatus === 'error'"><span nz-icon nzType="close"></span></span>
          <span class="ant-steps-icon" *ngIf="(nzStatus === 'process' || nzStatus === 'wait') && !nzIcon">
            {{ index + 1 }}
          </span>
          <span class="ant-steps-icon" *ngIf="nzIcon">
            <ng-container *nzStringTemplateOutlet="nzIcon; let icon">
              <span nz-icon [nzType]="!oldAPIIcon && icon" [ngClass]="oldAPIIcon && icon"></span>
            </ng-container>
          </span>
        </ng-template>
        <ng-template [ngIf]="showProcessDot">
          <span class="ant-steps-icon">
            <ng-template #processDotTemplate>
              <span class="ant-steps-icon-dot"></span>
            </ng-template>
            <ng-template
              [ngTemplateOutlet]="customProcessTemplate || processDotTemplate"
              [ngTemplateOutletContext]="{
                $implicit: processDotTemplate,
                status: nzStatus,
                index: index
              }"
            ></ng-template>
          </span>
        </ng-template>
      </div>
      <div class="ant-steps-item-content">
        <div class="ant-steps-item-title">
          <ng-container *nzStringTemplateOutlet="nzTitle">{{ nzTitle }}</ng-container>
          <div *ngIf="nzSubtitle" class="ant-steps-item-subtitle">
            <ng-container *nzStringTemplateOutlet="nzSubtitle">{{ nzSubtitle }}</ng-container>
          </div>
        </div>
        <div class="ant-steps-item-description">
          <ng-container *nzStringTemplateOutlet="nzDescription">{{ nzDescription }}</ng-container>
        </div>
      </div>
    </div>
  `,
      host: {
        class: "ant-steps-item",
        "[class.ant-steps-item-wait]": 'nzStatus === "wait"',
        "[class.ant-steps-item-process]": 'nzStatus === "process"',
        "[class.ant-steps-item-finish]": 'nzStatus === "finish"',
        "[class.ant-steps-item-error]": 'nzStatus === "error"',
        "[class.ant-steps-item-active]": "currentIndex === index",
        "[class.ant-steps-item-disabled]": "nzDisabled",
        "[class.ant-steps-item-custom]": "!!nzIcon",
        "[class.ant-steps-next-error]": '(outStatus === "error") && (currentIndex === index + 1)'
      },
      providers: [NzDestroyService],
      imports: [NgIf, NzProgressModule, NzIconModule, NzOutletModule, NgClass, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NzDestroyService
  }], {
    processDotTemplate: [{
      type: ViewChild,
      args: ["processDotTemplate", {
        static: false
      }]
    }],
    itemContainer: [{
      type: ViewChild,
      args: ["itemContainer", {
        static: true
      }]
    }],
    nzTitle: [{
      type: Input
    }],
    nzSubtitle: [{
      type: Input
    }],
    nzDescription: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    nzPercentage: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzIcon: [{
      type: Input
    }]
  });
})();
var _NzStepsComponent = class _NzStepsComponent {
  set nzProgressDot(value) {
    if (value instanceof TemplateRef) {
      this.showProcessDot = true;
      this.customProcessDotTemplate = value;
    } else {
      this.showProcessDot = toBoolean(value);
    }
    this.updateChildrenSteps();
  }
  constructor(ngZone, cdr, directionality, destroy$) {
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.directionality = directionality;
    this.destroy$ = destroy$;
    this.nzCurrent = 0;
    this.nzDirection = "horizontal";
    this.nzLabelPlacement = "horizontal";
    this.nzType = "default";
    this.nzSize = "default";
    this.nzStartIndex = 0;
    this.nzStatus = "process";
    this.nzIndexChange = new EventEmitter();
    this.indexChangeSubscription = Subscription.EMPTY;
    this.showProcessDot = false;
    this.showProgress = false;
    this.dir = "ltr";
  }
  ngOnChanges(changes) {
    if (changes.nzStartIndex || changes.nzDirection || changes.nzStatus || changes.nzCurrent || changes.nzSize) {
      this.updateChildrenSteps();
    }
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
    this.updateChildrenSteps();
  }
  ngAfterContentInit() {
    if (this.steps) {
      this.steps.changes.pipe(startWith(null), takeUntil(this.destroy$)).subscribe(() => {
        this.updateHostProgressClass();
        this.updateChildrenSteps();
      });
    }
  }
  updateHostProgressClass() {
    if (this.steps && !this.showProcessDot) {
      this.showProgress = !!this.steps.toArray().find((step) => step.nzPercentage !== null);
    }
  }
  updateChildrenSteps() {
    if (this.steps) {
      const length = this.steps.length;
      this.steps.toArray().forEach((step, index) => {
        Promise.resolve().then(() => {
          step.nzSize = this.nzSize;
          step.outStatus = this.nzStatus;
          step.showProcessDot = this.showProcessDot;
          if (this.customProcessDotTemplate) {
            step.customProcessTemplate = this.customProcessDotTemplate;
          }
          step.clickable = this.nzIndexChange.observers.length > 0;
          step.direction = this.nzDirection;
          step.index = index + this.nzStartIndex;
          step.currentIndex = this.nzCurrent;
          step.last = length === index + 1;
          step.markForCheck();
        });
      });
      this.indexChangeSubscription.unsubscribe();
      this.indexChangeSubscription = merge(...this.steps.map((step) => step.clickOutsideAngular$)).pipe(takeUntil(this.destroy$)).subscribe((index) => {
        if (this.nzIndexChange.observers.length) {
          this.ngZone.run(() => this.nzIndexChange.emit(index));
        }
      });
    }
  }
};
_NzStepsComponent.\u0275fac = function NzStepsComponent_Factory(t) {
  return new (t || _NzStepsComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzDestroyService));
};
_NzStepsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzStepsComponent,
  selectors: [["nz-steps"]],
  contentQueries: function NzStepsComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzStepComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.steps = _t);
    }
  },
  hostAttrs: [1, "ant-steps"],
  hostVars: 18,
  hostBindings: function NzStepsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-steps-horizontal", ctx.nzDirection === "horizontal")("ant-steps-vertical", ctx.nzDirection === "vertical")("ant-steps-label-horizontal", ctx.nzDirection === "horizontal")("ant-steps-label-vertical", (ctx.showProcessDot || ctx.nzLabelPlacement === "vertical") && ctx.nzDirection === "horizontal")("ant-steps-dot", ctx.showProcessDot)("ant-steps-small", ctx.nzSize === "small")("ant-steps-navigation", ctx.nzType === "navigation")("ant-steps-rtl", ctx.dir === "rtl")("ant-steps-with-progress", ctx.showProgress);
    }
  },
  inputs: {
    nzCurrent: "nzCurrent",
    nzDirection: "nzDirection",
    nzLabelPlacement: "nzLabelPlacement",
    nzType: "nzType",
    nzSize: "nzSize",
    nzStartIndex: "nzStartIndex",
    nzStatus: "nzStatus",
    nzProgressDot: "nzProgressDot"
  },
  outputs: {
    nzIndexChange: "nzIndexChange"
  },
  exportAs: ["nzSteps"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NzDestroyService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c315,
  decls: 1,
  vars: 0,
  template: function NzStepsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzStepsComponent = _NzStepsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzStepsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      preserveWhitespaces: false,
      selector: "nz-steps",
      exportAs: "nzSteps",
      template: `<ng-content></ng-content>`,
      host: {
        class: "ant-steps",
        "[class.ant-steps-horizontal]": `nzDirection === 'horizontal'`,
        "[class.ant-steps-vertical]": `nzDirection === 'vertical'`,
        "[class.ant-steps-label-horizontal]": `nzDirection === 'horizontal'`,
        "[class.ant-steps-label-vertical]": `(showProcessDot || nzLabelPlacement === 'vertical') && nzDirection === 'horizontal'`,
        "[class.ant-steps-dot]": "showProcessDot",
        "[class.ant-steps-small]": `nzSize === 'small'`,
        "[class.ant-steps-navigation]": `nzType === 'navigation'`,
        "[class.ant-steps-rtl]": `dir === 'rtl'`,
        "[class.ant-steps-with-progress]": "showProgress"
      },
      providers: [NzDestroyService],
      standalone: true
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzDestroyService
  }], {
    steps: [{
      type: ContentChildren,
      args: [NzStepComponent]
    }],
    nzCurrent: [{
      type: Input
    }],
    nzDirection: [{
      type: Input
    }],
    nzLabelPlacement: [{
      type: Input
    }],
    nzType: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzStartIndex: [{
      type: Input
    }],
    nzStatus: [{
      type: Input
    }],
    nzProgressDot: [{
      type: Input
    }],
    nzIndexChange: [{
      type: Output
    }]
  });
})();
var _NzStepsModule = class _NzStepsModule {
};
_NzStepsModule.\u0275fac = function NzStepsModule_Factory(t) {
  return new (t || _NzStepsModule)();
};
_NzStepsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzStepsModule
});
_NzStepsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzStepComponent]
});
var NzStepsModule = _NzStepsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzStepsModule, [{
    type: NgModule,
    args: [{
      imports: [NzStepsComponent, NzStepComponent],
      exports: [NzStepsComponent, NzStepComponent]
    }]
  }], null, null);
})();

// src/app/routes/pages/inventory/components/Steps.component.ts
function NzDemoStepsIconComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 5);
  }
}
var _NzDemoStepsIconComponent = class _NzDemoStepsIconComponent {
};
_NzDemoStepsIconComponent.\u0275fac = function NzDemoStepsIconComponent_Factory(t) {
  return new (t || _NzDemoStepsIconComponent)();
};
_NzDemoStepsIconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoStepsIconComponent, selectors: [["nz-demo-steps-icon"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 7, vars: 1, consts: [["nzTitle", "Login", "nzStatus", "finish", "nzIcon", "user"], ["nzTitle", "Verification", "nzStatus", "finish", "nzIcon", "solution"], ["nzTitle", "Pay", "nzStatus", "process", "nzIcon", "loading"], ["nzTitle", "Done", "nzStatus", "wait", 3, "nzIcon"], ["iconTemplate", ""], ["nz-icon", "", "nzType", "check-circle"]], template: function NzDemoStepsIconComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-steps");
    \u0275\u0275element(1, "nz-step", 0)(2, "nz-step", 1)(3, "nz-step", 2)(4, "nz-step", 3);
    \u0275\u0275template(5, NzDemoStepsIconComponent_ng_template_5_Template, 1, 0, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(4);
    \u0275\u0275property("nzIcon", "check-circle");
  }
}, dependencies: [NzStepsModule, NzStepsComponent, NzStepComponent], encapsulation: 2 });
var NzDemoStepsIconComponent = _NzDemoStepsIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoStepsIconComponent, { className: "NzDemoStepsIconComponent", filePath: "src\\app\\routes\\pages\\inventory\\components\\Steps.component.ts", lineNumber: 19 });
})();

// src/app/routes/pages/inventory/components/select.ts
var _NzDemoSelectSearchComponent2 = class _NzDemoSelectSearchComponent2 {
  constructor() {
    this.selectedValue = null;
    this.nzPlaceHolder = "";
  }
};
_NzDemoSelectSearchComponent2.\u0275fac = function NzDemoSelectSearchComponent_Factory(t) {
  return new (t || _NzDemoSelectSearchComponent2)();
};
_NzDemoSelectSearchComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoSelectSearchComponent2, selectors: [["nz-demo-select-search"]], inputs: { nzPlaceHolder: "nzPlaceHolder" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 4, vars: 2, consts: [["nzShowSearch", "", "nzAllowClear", "", 2, "width", "100%", 3, "nzPlaceHolder", "ngModel", "ngModelChange"], ["nzLabel", "test-1", "nzValue", "test-1"], ["nzLabel", "test-2", "nzValue", "test-2"], ["nzLabel", "test-3", "nzValue", "test-3"]], template: function NzDemoSelectSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener($event) {
      return ctx.selectedValue = $event;
    });
    \u0275\u0275element(1, "nz-option", 1)(2, "nz-option", 2)(3, "nz-option", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPlaceHolder", ctx.nzPlaceHolder)("ngModel", ctx.selectedValue);
  }
}, dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, FormsModule, NgControlStatus, NgModel], styles: ["\n\nnz-select[_ngcontent-%COMP%] {\n  width: 200px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2VsZWN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIG56LXNlbGVjdCB7XG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxTQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoSelectSearchComponent2 = _NzDemoSelectSearchComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoSelectSearchComponent2, { className: "NzDemoSelectSearchComponent", filePath: "src\\app\\routes\\pages\\inventory\\components\\select.ts", lineNumber: 25 });
})();

// src/app/routes/pages/inventory/components/table.ts
function NzDemoTableRowSelectionCustomComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Rate of Consumption ");
  }
}
function NzDemoTableRowSelectionCustomComponent_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Rate of Production ");
  }
}
function NzDemoTableRowSelectionCustomComponent_Conditional_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Receiving Date ");
  }
}
function NzDemoTableRowSelectionCustomComponent_Conditional_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Production Date ");
  }
}
function NzDemoTableRowSelectionCustomComponent_tr_26_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr")(1, "td", 4);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_tr_26_Template_td_nzCheckedChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r8);
      const data_r6 = restoredCtx.$implicit;
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.onItemChecked(data_r6.id, $event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "td");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "td");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "td");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "td");
    \u0275\u0275text(9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "td");
    \u0275\u0275text(11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "td");
    \u0275\u0275text(13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "td");
    \u0275\u0275text(15);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "td");
    \u0275\u0275text(17);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "td");
    \u0275\u0275text(19);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r6 = ctx.$implicit;
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzChecked", ctx_r5.setOfCheckedId.has(data_r6.id));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r6.Name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r6.Quantity);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r6.Consumption);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r6.Need);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r6.Order);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r6.Date);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r6.Expected);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r6.Receiving);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r6.Time);
  }
}
var _NzDemoTableRowSelectionCustomComponent2 = class _NzDemoTableRowSelectionCustomComponent2 {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
    this.pageSize = 5;
    this.pageIndex = 1;
    this.row = false;
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = new Array(200).fill(0).map((_, index) => ({
      id: index,
      Name: `Feed  ${index}`,
      Quantity: `20 T `,
      Consumption: "3 T/day",
      Need: "5 T",
      Order: `nbm5040`,
      Date: (/* @__PURE__ */ new Date()).toLocaleString(),
      Expected: "6 Days",
      Receiving: (/* @__PURE__ */ new Date()).toLocaleString(),
      Time: (/* @__PURE__ */ new Date()).toLocaleString()
    }));
  }
};
_NzDemoTableRowSelectionCustomComponent2.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent2)();
};
_NzDemoTableRowSelectionCustomComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent2, selectors: [["nz-demo-table-row-selection-custom"]], inputs: { row: "row" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 27, vars: 9, consts: [["nzShowSizeChanger", "", 3, "nzData", "nzPageSize", "nzPageIndex", "nzCurrentPageDataChange"], ["rowSelectionTable", ""], [3, "nzSelections", "nzChecked", "nzIndeterminate", "nzCheckedChange"], [4, "ngFor", "ngForOf"], [3, "nzChecked", "nzCheckedChange"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1);
    \u0275\u0275listener("nzCurrentPageDataChange", function NzDemoTableRowSelectionCustomComponent_Template_nz_table_nzCurrentPageDataChange_0_listener($event) {
      return ctx.onCurrentPageDataChange($event);
    });
    \u0275\u0275elementStart(2, "thead")(3, "tr")(4, "th", 2);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.checked = $event;
    })("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.onAllChecked($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "th");
    \u0275\u0275text(6, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "th");
    \u0275\u0275text(8, "Current Quantity");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "th");
    \u0275\u0275template(10, NzDemoTableRowSelectionCustomComponent_Conditional_10_Template, 1, 0)(11, NzDemoTableRowSelectionCustomComponent_Conditional_11_Template, 1, 0);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "th");
    \u0275\u0275text(13, "Need");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "th");
    \u0275\u0275text(15, "Order");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "th");
    \u0275\u0275text(17, "Order Date");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "th");
    \u0275\u0275text(19, "Expected run-out time");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "th");
    \u0275\u0275template(21, NzDemoTableRowSelectionCustomComponent_Conditional_21_Template, 1, 0)(22, NzDemoTableRowSelectionCustomComponent_Conditional_22_Template, 1, 0);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "th");
    \u0275\u0275text(24, "Time Stamp");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(25, "tbody");
    \u0275\u0275template(26, NzDemoTableRowSelectionCustomComponent_tr_26_Template, 20, 10, "tr", 3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzPageSize", ctx.pageSize)("nzPageIndex", ctx.pageIndex);
    \u0275\u0275advance(4);
    \u0275\u0275property("nzSelections", ctx.listOfSelection)("nzChecked", ctx.checked)("nzIndeterminate", ctx.indeterminate);
    \u0275\u0275advance(6);
    \u0275\u0275conditional(10, ctx.row ? 10 : 11);
    \u0275\u0275advance(11);
    \u0275\u0275conditional(21, ctx.row ? 21 : 22);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzThSelectionComponent, CommonModule, NgForOf, NzAvatarModule, NzBadgeModule], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent2 = _NzDemoTableRowSelectionCustomComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent2, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\pages\\inventory\\components\\table.ts", lineNumber: 85 });
})();

// src/app/routes/pages/inventory/inventory.component.ts
var _InventoryComponent = class _InventoryComponent {
  constructor() {
    this.http = inject(_HttpClient);
    this.cdr = inject(ChangeDetectorRef);
    this.obSrv = inject(OnboardingService);
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
    this.pie = {};
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  ngOnInit() {
    this.pie = {
      series: [40, 60],
      chart: {
        type: "pie"
      },
      dataLabels: {
        enabled: true
      },
      tooltip: {
        enabled: true
      },
      labels: ["Starch A", "Starch B", "Starch C"],
      responsive: [
        {
          breakpoint: 480,
          options: {
            chart: {
              width: 200
            }
          }
        }
      ],
      legend: {
        show: false
      }
    };
    setTimeout(() => {
    }, 1e3);
  }
};
_InventoryComponent.\u0275fac = function InventoryComponent_Factory(t) {
  return new (t || _InventoryComponent)();
};
_InventoryComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _InventoryComponent, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 47, vars: 31, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "12"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "24"], [3, "nzBordered"], ["nzBackIcon", "", "nzTitle", "Product Inventory", 1, "site-page-header"], [3, "nzBordered", "nzTitle"], [3, "salesPieData"], ["nzBackIcon", "", "nzTitle", "Raw Material", 1, "site-page-header"], [3, "row"]], template: function InventoryComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Inventory ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2)(7, "div", 1)(8, "div", 3)(9, "nz-card", 4);
    \u0275\u0275element(10, "nz-page-header", 5);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 2)(12, "nz-card", 6);
    \u0275\u0275element(13, "chart-pie-basic", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 2)(15, "nz-card", 6);
    \u0275\u0275element(16, "chart-pie-basic", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 2)(18, "nz-card", 6);
    \u0275\u0275element(19, "chart-pie-basic", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(20, "div", 2)(21, "nz-card", 6);
    \u0275\u0275element(22, "chart-pie-basic", 7);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(23, "div", 2)(24, "div", 1)(25, "div", 3)(26, "nz-card", 4);
    \u0275\u0275element(27, "nz-page-header", 8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(28, "div", 2)(29, "nz-card", 6);
    \u0275\u0275element(30, "chart-pie-basic", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(31, "div", 2)(32, "nz-card", 6);
    \u0275\u0275element(33, "chart-pie-basic", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(34, "div", 2)(35, "nz-card", 6);
    \u0275\u0275element(36, "chart-pie-basic", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(37, "div", 2)(38, "nz-card", 6);
    \u0275\u0275element(39, "chart-pie-basic", 7);
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275elementStart(40, "div", 1)(41, "div", 3)(42, "nz-card", 6);
    \u0275\u0275element(43, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(44, "div", 3)(45, "nz-card", 6);
    \u0275\u0275element(46, "nz-demo-table-row-selection-custom", 9);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(9);
    \u0275\u0275property("nzBordered", false);
    \u0275\u0275advance(3);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Feed 15 %");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Feed 65 %");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Liquid Starch");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Oil");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false);
    \u0275\u0275advance(3);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Main Corn");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Material 1");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Material 2");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Material 3");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.pie);
    \u0275\u0275advance(3);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Product Inventory");
    \u0275\u0275advance(3);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Raw Material");
    \u0275\u0275advance(1);
    \u0275\u0275property("row", true);
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule,
  G2TimelineModule,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  OnboardingModule,
  NzDemoTableRowSelectionCustomComponent2,
  ChartPieBasicComponent2,
  NzPageHeaderModule,
  NzPageHeaderComponent
], encapsulation: 2, changeDetection: 0 });
var InventoryComponent = _InventoryComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(InventoryComponent, { className: "InventoryComponent", filePath: "src\\app\\routes\\pages\\inventory\\inventory.component.ts", lineNumber: 42 });
})();

// src/app/routes/pages/live/charts/card.ts
function ChartCardStyle1Component_ng_template_1_Template2(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 4);
  }
}
var _ChartCardStyle1Component2 = class _ChartCardStyle1Component2 {
};
_ChartCardStyle1Component2.\u0275fac = function ChartCardStyle1Component_Factory(t) {
  return new (t || _ChartCardStyle1Component2)();
};
_ChartCardStyle1Component2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartCardStyle1Component2, selectors: [["chart-card-style1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 9, vars: 4, consts: [["footer", " 12,423", 2, "height", "200px", 3, "title", "bordered", "total", "action"], ["action", ""], ["flag", "up", 2, "margin", "0 10px 0 8px", "color", "rgba(0,0,0,.85)"], ["flag", "down", 2, "margin", "0 0 0 8px", "color", "rgba(0,0,0,.85)"], ["nz-tooltip", "", "nzTooltipTitle", "Value", "nz-icon", "", "nzType", "info-circle"]], template: function ChartCardStyle1Component_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-card", 0);
    \u0275\u0275template(1, ChartCardStyle1Component_ng_template_1_Template2, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275text(3, " Active ");
    \u0275\u0275elementStart(4, "trend", 2);
    \u0275\u0275text(5, "12%");
    \u0275\u0275elementEnd();
    \u0275\u0275text(6, " DeActive ");
    \u0275\u0275elementStart(7, "trend", 3);
    \u0275\u0275text(8, "11%");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("title", "Value")("bordered", true)("total", " 126,560.00")("action", _r1);
  }
}, dependencies: [G2CardModule, G2CardComponent, NzToolTipModule, NzTooltipDirective, TrendModule, TrendComponent], encapsulation: 2 });
var ChartCardStyle1Component2 = _ChartCardStyle1Component2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartCardStyle1Component2, { className: "ChartCardStyle1Component", filePath: "src\\app\\routes\\pages\\live\\charts\\card.ts", lineNumber: 23 });
})();

// node_modules/@delon/chart/fesm2022/gauge.mjs
function G2GaugeComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-skeleton");
  }
}
var _G2GaugeComponent = class _G2GaugeComponent extends G2BaseComponent {
  constructor() {
    super(...arguments);
    this.color = "#2f9cff";
    this.padding = [10, 10, 30, 10];
  }
  // #endregion
  install() {
    this.winG2.registerShape("point", "pointer", {
      draw(cfg, container) {
        const group = container.addGroup({});
        const center = this.parsePoint({
          x: 0,
          y: 0
        });
        group.addShape("line", {
          attrs: {
            x1: center.x,
            y1: center.y,
            x2: cfg.x,
            y2: cfg.y,
            stroke: cfg.color,
            lineWidth: 2.5,
            lineCap: "round"
          }
        });
        group.addShape("circle", {
          attrs: {
            x: center.x,
            y: center.y,
            r: 5.75,
            stroke: cfg.color,
            lineWidth: 2,
            fill: "#fff"
          }
        });
        return group;
      }
    });
    const {
      el,
      height,
      padding,
      format: format2,
      theme
    } = this;
    const chart = this._chart = new this.winG2.Chart({
      container: el.nativeElement,
      autoFit: true,
      height,
      padding,
      theme
    });
    chart.legend(false);
    chart.animate(false);
    chart.tooltip(false);
    chart.coordinate("polar", {
      startAngle: -9 / 8 * Math.PI,
      endAngle: 1 / 8 * Math.PI,
      radius: 0.75
    });
    chart.scale("value", {
      min: 0,
      max: 100,
      nice: true,
      tickCount: 6
    });
    chart.axis("1", false);
    chart.axis("value", {
      line: null,
      label: {
        offset: -14,
        formatter: format2
      },
      tickLine: null,
      grid: null
    });
    chart.point().position("value*1").shape("pointer");
    this.ready.next(chart);
    this.changeData();
    chart.render();
  }
  changeData() {
    const {
      _chart,
      percent,
      color,
      bgColor,
      title
    } = this;
    if (!_chart)
      return;
    const data = [{
      name: title,
      value: percent
    }];
    const val = data[0].value;
    _chart.annotation().clear(true);
    _chart.geometries[0].color(color);
    _chart.annotation().arc({
      top: false,
      start: [0, 0.95],
      end: [100, 0.95],
      style: {
        stroke: bgColor,
        lineWidth: 12,
        lineDash: null
      }
    });
    _chart.annotation().arc({
      start: [0, 0.95],
      end: [data[0].value, 0.95],
      style: {
        stroke: color,
        lineWidth: 12,
        lineDash: null
      }
    });
    _chart.annotation().text({
      position: ["50%", "85%"],
      content: title,
      style: {
        fontSize: 12,
        fill: this.theme === "dark" ? "rgba(255, 255, 255, 0.43)" : "rgba(0, 0, 0, 0.43)",
        textAlign: "center"
      }
    });
    _chart.annotation().text({
      position: ["50%", "90%"],
      content: `${val} %`,
      style: {
        fontSize: 20,
        fill: this.theme === "dark" ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)",
        textAlign: "center"
      },
      offsetY: 15
    });
    _chart.changeData(data);
  }
};
_G2GaugeComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275G2GaugeComponent_BaseFactory;
  return function G2GaugeComponent_Factory(t) {
    return (\u0275G2GaugeComponent_BaseFactory || (\u0275G2GaugeComponent_BaseFactory = \u0275\u0275getInheritedFactory(_G2GaugeComponent)))(t || _G2GaugeComponent);
  };
})();
_G2GaugeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _G2GaugeComponent,
  selectors: [["g2-gauge"]],
  hostVars: 2,
  hostBindings: function G2GaugeComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("g2-gauge", true);
    }
  },
  inputs: {
    title: "title",
    height: "height",
    color: "color",
    bgColor: "bgColor",
    format: "format",
    percent: "percent",
    padding: "padding"
  },
  exportAs: ["g2Gauge"],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 1,
  vars: 1,
  template: function G2GaugeComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, G2GaugeComponent_Conditional_0_Template, 1, 0, "nz-skeleton");
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, !ctx.loaded ? 0 : -1);
    }
  },
  dependencies: [NzSkeletonComponent],
  encapsulation: 2,
  changeDetection: 0
});
var G2GaugeComponent = _G2GaugeComponent;
__decorate([InputNumber2()], G2GaugeComponent.prototype, "height", void 0);
__decorate([InputNumber2()], G2GaugeComponent.prototype, "percent", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2GaugeComponent, [{
    type: Component,
    args: [{
      selector: "g2-gauge",
      exportAs: "g2Gauge",
      template: `@if (!loaded) {
    <nz-skeleton />
  }`,
      host: {
        "[class.g2-gauge]": "true"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, {
    title: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    bgColor: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    percent: [{
      type: Input
    }],
    padding: [{
      type: Input
    }]
  });
})();
var COMPONENTS17 = [G2GaugeComponent];
var _G2GaugeModule = class _G2GaugeModule {
};
_G2GaugeModule.\u0275fac = function G2GaugeModule_Factory(t) {
  return new (t || _G2GaugeModule)();
};
_G2GaugeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _G2GaugeModule
});
_G2GaugeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzSkeletonModule]
});
var G2GaugeModule = _G2GaugeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2GaugeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzSkeletonModule],
      declarations: COMPONENTS17,
      exports: COMPONENTS17
    }]
  }], null, null);
})();

// src/app/routes/pages/live/charts/guge.component.ts
var _ChartGaugeBasicComponent = class _ChartGaugeBasicComponent {
  constructor(platform, cdr) {
    this.percent = 36;
    this.color = "#2f9cff";
    if (!platform.isBrowser)
      return;
    this.time$ = setInterval(() => {
      this.percent = parseInt((Math.random() * 100).toString(), 10);
      this.color = this.percent > 50 ? "#f50" : "#2f9cff";
      cdr.detectChanges();
    }, 1e3);
  }
  ngOnDestroy() {
    clearInterval(this.time$);
  }
};
_ChartGaugeBasicComponent.\u0275fac = function ChartGaugeBasicComponent_Factory(t) {
  return new (t || _ChartGaugeBasicComponent)(\u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_ChartGaugeBasicComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartGaugeBasicComponent, selectors: [["chart-gauge-basic"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 4, consts: [["height", "165", 3, "padding", "title", "percent", "color"]], template: function ChartGaugeBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "g2-gauge", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("padding", 10)("title", "Flow")("percent", ctx.percent)("color", ctx.color);
  }
}, dependencies: [G2GaugeModule, G2GaugeComponent, NzCardModule], encapsulation: 2, changeDetection: 0 });
var ChartGaugeBasicComponent = _ChartGaugeBasicComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartGaugeBasicComponent, { className: "ChartGaugeBasicComponent", filePath: "src\\app\\routes\\pages\\live\\charts\\guge.component.ts", lineNumber: 15 });
})();

// src/app/routes/pages/live/charts/percent.component.ts
var _ChartWaterWaveBasicComponent2 = class _ChartWaterWaveBasicComponent2 {
};
_ChartWaterWaveBasicComponent2.\u0275fac = function ChartWaterWaveBasicComponent_Factory(t) {
  return new (t || _ChartWaterWaveBasicComponent2)();
};
_ChartWaterWaveBasicComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartWaterWaveBasicComponent2, selectors: [["chart-water-wave-basic"]], hostVars: 2, hostBindings: function ChartWaterWaveBasicComponent_HostBindings(rf, ctx) {
  if (rf & 2) {
    \u0275\u0275classProp("d-block", true);
  }
}, inputs: { percent: "percent", title: "title", color: "color" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 5, consts: [[3, "delay", "title", "percent", "height", "color"]], template: function ChartWaterWaveBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "g2-water-wave", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("delay", 10)("title", ctx.title)("percent", ctx.percent)("height", 161)("color", ctx.color);
  }
}, dependencies: [G2WaterWaveModule, G2WaterWaveComponent], encapsulation: 2 });
var ChartWaterWaveBasicComponent2 = _ChartWaterWaveBasicComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartWaterWaveBasicComponent2, { className: "ChartWaterWaveBasicComponent", filePath: "src\\app\\routes\\pages\\live\\charts\\percent.component.ts", lineNumber: 14 });
})();

// node_modules/@delon/chart/fesm2022/mini-progress.mjs
var _c049 = (a0) => ({
  "left.%": a0
});
var _c133 = (a0) => ({
  "background-color": a0
});
var _c222 = (a0, a1, a2) => ({
  "background-color": a0,
  "width.%": a1,
  "height.px": a2
});
var _G2MiniProgressComponent = class _G2MiniProgressComponent {
  constructor(i18n, cdr) {
    this.i18n = i18n;
    this.cdr = cdr;
    this.color = "#1890FF";
  }
  fixNum(value) {
    return Math.min(Math.max(toNumber2(value), 0), 100);
  }
  ngOnChanges() {
    this.target = this.fixNum(this.target);
    this.percent = this.fixNum(this.percent);
    this.cdr.detectChanges();
  }
};
_G2MiniProgressComponent.\u0275fac = function G2MiniProgressComponent_Factory(t) {
  return new (t || _G2MiniProgressComponent)(\u0275\u0275directiveInject(DelonLocaleService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_G2MiniProgressComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _G2MiniProgressComponent,
  selectors: [["g2-mini-progress"]],
  hostVars: 2,
  hostBindings: function G2MiniProgressComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("g2-mini-progress", true);
    }
  },
  inputs: {
    color: "color",
    target: "target",
    percent: "percent",
    strokeWidth: "strokeWidth"
  },
  exportAs: ["g2MiniProgress"],
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 5,
  vars: 15,
  consts: [["nz-tooltip", "", 1, "g2-mini-progress__target", 3, "nzTooltipTitle", "ngStyle"], [1, "g2-mini-progress__target-item", 3, "ngStyle"], [1, "g2-mini-progress__wrap"], [1, "g2-mini-progress__value", 3, "ngStyle"]],
  template: function G2MiniProgressComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275element(1, "span", 1)(2, "span", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "div", 2);
      \u0275\u0275element(4, "div", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("nzTooltipTitle", ctx.i18n.getData("miniProgress").target + ctx.target + "%")("ngStyle", \u0275\u0275pureFunction1(5, _c049, ctx.target));
      \u0275\u0275advance(1);
      \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(7, _c133, ctx.color));
      \u0275\u0275advance(1);
      \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(9, _c133, ctx.color));
      \u0275\u0275advance(2);
      \u0275\u0275property("ngStyle", \u0275\u0275pureFunction3(11, _c222, ctx.color, ctx.percent, ctx.strokeWidth));
    }
  },
  dependencies: [NgStyle, NzTooltipDirective],
  encapsulation: 2,
  changeDetection: 0
});
var G2MiniProgressComponent = _G2MiniProgressComponent;
__decorate([InputNumber2()], G2MiniProgressComponent.prototype, "target", void 0);
__decorate([InputNumber2()], G2MiniProgressComponent.prototype, "percent", void 0);
__decorate([InputNumber2()], G2MiniProgressComponent.prototype, "strokeWidth", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2MiniProgressComponent, [{
    type: Component,
    args: [{
      selector: "g2-mini-progress",
      exportAs: "g2MiniProgress",
      host: {
        "[class.g2-mini-progress]": "true"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<div
  nz-tooltip
  [nzTooltipTitle]="i18n.getData('miniProgress').target + target + '%'"
  class="g2-mini-progress__target"
  [ngStyle]="{ 'left.%': target }"
>
  <span class="g2-mini-progress__target-item" [ngStyle]="{ 'background-color': color }"></span>
  <span class="g2-mini-progress__target-item" [ngStyle]="{ 'background-color': color }"></span>
</div>
<div class="g2-mini-progress__wrap">
  <div
    class="g2-mini-progress__value"
    [ngStyle]="{ 'background-color': color, 'width.%': percent, 'height.px': strokeWidth }"
  ></div>
</div>
`
    }]
  }], () => [{
    type: DelonLocaleService
  }, {
    type: ChangeDetectorRef
  }], {
    color: [{
      type: Input
    }],
    target: [{
      type: Input
    }],
    percent: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }]
  });
})();
var COMPONENTS18 = [G2MiniProgressComponent];
var _G2MiniProgressModule = class _G2MiniProgressModule {
};
_G2MiniProgressModule.\u0275fac = function G2MiniProgressModule_Factory(t) {
  return new (t || _G2MiniProgressModule)();
};
_G2MiniProgressModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _G2MiniProgressModule
});
_G2MiniProgressModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, DelonLocaleModule, NzToolTipModule]
});
var G2MiniProgressModule = _G2MiniProgressModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2MiniProgressModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, DelonLocaleModule, NzToolTipModule],
      declarations: COMPONENTS18,
      exports: COMPONENTS18
    }]
  }], null, null);
})();

// src/app/routes/pages/live/charts/temprture.ts
function TemperatureChartComponent__svg_rect_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 6);
  }
  if (rf & 2) {
    const i_r6 = ctx.index;
    \u0275\u0275attribute("x", i_r6 * 50 + 10);
  }
}
function TemperatureChartComponent__svg_rect_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 7);
  }
  if (rf & 2) {
    const temperature_r7 = ctx.$implicit;
    const i_r8 = ctx.index;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("x", i_r8 * 50 + 10)("y", 50 + (150 - ctx_r1.calculateHeight(temperature_r7.value)))("height", ctx_r1.calculateHeight(temperature_r7.value));
  }
}
function TemperatureChartComponent__svg_text_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const temperature_r9 = ctx.$implicit;
    const i_r10 = ctx.index;
    \u0275\u0275attribute("x", i_r10 * 50 + 25);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", temperature_r9.label, " ");
  }
}
function TemperatureChartComponent__svg_text_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const temperature_r11 = ctx.$implicit;
    const i_r12 = ctx.index;
    \u0275\u0275attribute("x", i_r12 * 50 + 25);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", temperature_r11.value, " \xB0C ");
  }
}
function TemperatureChartComponent__svg_text_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 10);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const temperature_r13 = ctx.$implicit;
    const i_r14 = ctx.index;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275attribute("x", i_r14 * 50 + 25)("y", ctx_r4.calculateHeight(temperature_r13.value) + 70);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", temperature_r13.value, "% ");
  }
}
var _TemperatureChartComponent = class _TemperatureChartComponent {
  constructor() {
    this.data = [];
    this.temperatures = [];
  }
  ngOnChanges(changes) {
    if (changes["data"]) {
      this.temperatures = this.data;
    }
  }
  calculateHeight(temperatureValue) {
    return Math.min(temperatureValue / 100 * 150, 150);
  }
};
_TemperatureChartComponent.\u0275fac = function TemperatureChartComponent_Factory(t) {
  return new (t || _TemperatureChartComponent)();
};
_TemperatureChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _TemperatureChartComponent, selectors: [["app-temperature-chart"]], inputs: { data: "data" }, standalone: true, features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature], decls: 6, vars: 5, consts: [["width", "400", "height", "250", 2, "margin", "auto"], ["y", "50", "width", "30", "height", "150", "fill", "#eee", "style", "margin: 20px;", 4, "ngFor", "ngForOf"], ["width", "30", "fill", "#f56a00", 4, "ngFor", "ngForOf"], ["y", "20", "fill", "black", "text-anchor", "middle", 4, "ngFor", "ngForOf"], ["y", "40", "fill", "black", "text-anchor", "middle", 4, "ngFor", "ngForOf"], ["fill", "black", "text-anchor", "middle", 4, "ngFor", "ngForOf"], ["y", "50", "width", "30", "height", "150", "fill", "#eee", 2, "margin", "20px"], ["width", "30", "fill", "#f56a00"], ["y", "20", "fill", "black", "text-anchor", "middle"], ["y", "40", "fill", "black", "text-anchor", "middle"], ["fill", "black", "text-anchor", "middle"]], template: function TemperatureChartComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 0);
    \u0275\u0275template(1, TemperatureChartComponent__svg_rect_1_Template, 1, 1, "rect", 1)(2, TemperatureChartComponent__svg_rect_2_Template, 1, 3, "rect", 2)(3, TemperatureChartComponent__svg_text_3_Template, 2, 2, "text", 3)(4, TemperatureChartComponent__svg_text_4_Template, 2, 2, "text", 4)(5, TemperatureChartComponent__svg_text_5_Template, 2, 3, "text", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx.temperatures);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx.temperatures);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx.temperatures);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx.temperatures);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx.temperatures);
  }
}, dependencies: [CommonModule, NgForOf], encapsulation: 2 });
var TemperatureChartComponent = _TemperatureChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(TemperatureChartComponent, { className: "TemperatureChartComponent", filePath: "src\\app\\routes\\pages\\live\\charts\\temprture.ts", lineNumber: 56 });
})();

// src/app/routes/pages/live/charts/temp.ts
function ChartMiniProgressBasicComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275element(1, "nz-avatar", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const avatar_r2 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("nzText", avatar_r2.text)("nzSize", "large")("nzGap", 4)("ngStyle", avatar_r2.style);
  }
}
function ChartMiniProgressBasicComponent_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275element(1, "nz-avatar", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const avatar_r3 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("nzText", avatar_r3.text)("nzSize", "large")("ngStyle", avatar_r3.style);
  }
}
var _ChartMiniProgressBasicComponent = class _ChartMiniProgressBasicComponent {
  constructor() {
    this.topAvatars = [
      { text: "XV1", size: "large", style: { color: "#f56a00", backgroundColor: "#fde3cf", margin: "5px" } },
      { text: "XV2", size: "large", style: { color: "#f56a00", backgroundColor: "#fde3cf", margin: "5px" } },
      { text: "XV3", size: "large", style: { color: "#f56a00", backgroundColor: "#fde3cf", margin: "5px" } },
      { text: "XV4", size: "large", style: { color: "#f56a00", backgroundColor: "#fde3cf", margin: "5px" } }
    ];
    this.underAvatars = [
      { text: "XV", size: "large", style: { color: "#f56a00", backgroundColor: "#fde3cf", margin: "5px" } },
      { text: "XV", size: "large", style: { color: "#f56a00", backgroundColor: "#fde3cf", margin: "5px" } }
    ];
    this.temperatures = [
      { label: "Water", value: 20 },
      { label: "Material", value: 30 }
      // Add more temperature objects as needed
    ];
  }
};
_ChartMiniProgressBasicComponent.\u0275fac = function ChartMiniProgressBasicComponent_Factory(t) {
  return new (t || _ChartMiniProgressBasicComponent)();
};
_ChartMiniProgressBasicComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartMiniProgressBasicComponent, selectors: [["chart-mini-progress-basic"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 14, vars: 3, consts: [["nzTitle", "Steeping 1"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzMd", "6", 2, "text-align", "center", "padding-bottom", "10px", "display", "flex", "justify-content", "center"], ["class", "avatar-container-top", 4, "ngFor", "ngForOf"], [1, "vertical-line-container"], ["nz-row", "", "nzGutter", "16", 1, "tank-container"], [1, "tank"], [1, "tank-body"], [1, "chart"], ["nz-col", "", "nzXs", "24", "nzMd", "24", 2, "padding-left", "25%"], [3, "data"], ["nz-col", "", "nzXs", "24", "nzMd", "6", 2, "text-align", "center", "display", "flex", "justify-content", "center"], ["class", "avatar-container-under", 4, "ngFor", "ngForOf"], [1, "avatar-container-top"], [3, "nzText", "nzSize", "nzGap", "ngStyle"], [1, "avatar-container-under"], [3, "nzText", "nzSize", "ngStyle"]], template: function ChartMiniProgressBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-card", 0)(1, "div", 1)(2, "div", 2);
    \u0275\u0275template(3, ChartMiniProgressBasicComponent_div_3_Template, 2, 4, "div", 3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "div", 4)(5, "div", 5)(6, "div", 6)(7, "div", 7)(8, "div", 8)(9, "div", 9);
    \u0275\u0275element(10, "app-temperature-chart", 10);
    \u0275\u0275elementEnd()()()()()();
    \u0275\u0275elementStart(11, "div", 1)(12, "div", 11);
    \u0275\u0275template(13, ChartMiniProgressBasicComponent_div_13_Template, 2, 3, "div", 12);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx.topAvatars);
    \u0275\u0275advance(7);
    \u0275\u0275property("data", ctx.temperatures);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx.underAvatars);
  }
}, dependencies: [G2MiniProgressModule, NzAvatarModule, NzAvatarComponent, NzCardModule, NzCardComponent, NzDividerModule, CommonModule, NgForOf, NgStyle, TemperatureChartComponent], styles: ['\n\n.avatar-container-top[_ngcontent-%COMP%], .avatar-container-under[_ngcontent-%COMP%] {\n  position: relative;\n  z-index: 20;\n}\n.avatar-container-top[_ngcontent-%COMP%]::after, .avatar-container-under[_ngcontent-%COMP%]::after {\n  content: "";\n  position: absolute;\n  z-index: -12;\n  left: 50%;\n  transform: translateX(-50%);\n  height: 100%;\n  border-left: 2px solid #000;\n}\n.avatar-container-under[_ngcontent-%COMP%]::after {\n  top: -20%;\n}\n.avatar-container-top[_ngcontent-%COMP%]::after {\n  bottom: -20%;\n}\n.tank-body[_ngcontent-%COMP%] {\n  width: 60%;\n  height: 250px;\n  background-color: #b0c4de;\n  border: 10px solid #808080;\n  border-radius: 10px;\n  margin: auto;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidGVtcC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXG4gICAgICAuYXZhdGFyLWNvbnRhaW5lci10b3AsXG4gICAgICAuYXZhdGFyLWNvbnRhaW5lci11bmRlciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgei1pbmRleDogMjA7XG4gICAgICB9XG5cbiAgICAgIC5hdmF0YXItY29udGFpbmVyLXRvcDo6YWZ0ZXIsXG4gICAgICAuYXZhdGFyLWNvbnRhaW5lci11bmRlcjo6YWZ0ZXIge1xuICAgICAgICBjb250ZW50OiAnJztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB6LWluZGV4OiAtMTI7XG4gICAgICAgIGxlZnQ6IDUwJTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJvcmRlci1sZWZ0OiAycHggc29saWQgIzAwMDtcbiAgICAgIH1cblxuICAgICAgLmF2YXRhci1jb250YWluZXItdW5kZXI6OmFmdGVyIHtcbiAgICAgICAgdG9wOiAtMjAlO1xuICAgICAgfVxuXG4gICAgICAuYXZhdGFyLWNvbnRhaW5lci10b3A6OmFmdGVyIHtcbiAgICAgICAgYm90dG9tOiAtMjAlO1xuICAgICAgfVxuXG4gICAgICAudGFuay1ib2R5IHtcbiAgICAgICAgd2lkdGg6IDYwJTsgLyogQWRqdXN0IHRoZSB3aWR0aCBvZiB0aGUgdGFuayBib2R5ICovXG4gICAgICAgIGhlaWdodDogMjUwcHg7IC8qIEFkanVzdCB0aGUgaGVpZ2h0IG9mIHRoZSB0YW5rIGJvZHkgKi9cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2IwYzRkZTsgLyogUGxhY2Vob2xkZXIgY29sb3IgKi9cbiAgICAgICAgYm9yZGVyOiAxMHB4IHNvbGlkICM4MDgwODA7IC8qIEdyYXkgYm9yZGVyIGZvciB0aGUgdGFuayBib2R5ICovXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7IC8qIEFkanVzdCB0aGUgYm9yZGVyLXJhZGl1cyBmb3Igcm91bmRlZCBjb3JuZXJzICovXG4gICAgICAgIG1hcmdpbjogYXV0bztcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ00sQ0FBQTtBQUFBLENBQUE7QUFFRSxZQUFBO0FBQ0EsV0FBQTs7QUFHRixDQU5BLG9CQU1BO0FBQUEsQ0FOQSxzQkFNQTtBQUVFLFdBQUE7QUFDQSxZQUFBO0FBQ0EsV0FBQTtBQUNBLFFBQUE7QUFDQSxhQUFBLFdBQUE7QUFDQSxVQUFBO0FBQ0EsZUFBQSxJQUFBLE1BQUE7O0FBR0YsQ0FqQkEsc0JBaUJBO0FBQ0UsT0FBQTs7QUFHRixDQXJCQSxvQkFxQkE7QUFDRSxVQUFBOztBQUdGLENBQUE7QUFDRSxTQUFBO0FBQ0EsVUFBQTtBQUNBLG9CQUFBO0FBQ0EsVUFBQSxLQUFBLE1BQUE7QUFDQSxpQkFBQTtBQUNBLFVBQUE7OyIsCiAgIm5hbWVzIjogW10KfQo= */'] });
var ChartMiniProgressBasicComponent = _ChartMiniProgressBasicComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartMiniProgressBasicComponent, { className: "ChartMiniProgressBasicComponent", filePath: "src\\app\\routes\\pages\\live\\charts\\temp.ts", lineNumber: 89 });
})();

// src/app/routes/pages/live/components/p.component.ts
var _NzDemoCardSimpleComponent = class _NzDemoCardSimpleComponent {
};
_NzDemoCardSimpleComponent.\u0275fac = function NzDemoCardSimpleComponent_Factory(t) {
  return new (t || _NzDemoCardSimpleComponent)();
};
_NzDemoCardSimpleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoCardSimpleComponent, selectors: [["nz-demo-card-simple"]], inputs: { Text: "Text", id: "id" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 12, vars: 6, consts: [[2, "margin", "auto", "text-align", "center"], [3, "nzGap", "nzText", "nzSize"], [2, "text-align", "center", "width", "100%"]], template: function NzDemoCardSimpleComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "nz-avatar", 1);
    \u0275\u0275elementStart(2, "nz-card", 2)(3, "p");
    \u0275\u0275text(4, "Temp.");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "p");
    \u0275\u0275text(6, "25\xB0C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(7, "nz-divider");
    \u0275\u0275elementStart(8, "p");
    \u0275\u0275text(9, "Vibration");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "p");
    \u0275\u0275text(11, " 12 IPS");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275styleMapInterpolate1("margin-bottom: 20px; color:#fff; background-color:", ctx.id.toString().includes("1") ? "#ee4035" : "	#7bc043", "; ");
    \u0275\u0275property("nzGap", 2)("nzText", ctx.Text)("nzSize", "large");
  }
}, dependencies: [NzCardComponent, NzAvatarModule, NzAvatarComponent, NzDividerModule, NzDividerComponent], styles: ["\n\np[_ngcontent-%COMP%] {\n  margin: 0;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsicC5jb21wb25lbnQudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIlxuICAgICAgcCB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxVQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoCardSimpleComponent = _NzDemoCardSimpleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoCardSimpleComponent, { className: "NzDemoCardSimpleComponent", filePath: "src\\app\\routes\\pages\\live\\components\\p.component.ts", lineNumber: 36 });
})();

// src/app/routes/pages/live/components/select.ts
var _NzDemoSelectSearchComponent3 = class _NzDemoSelectSearchComponent3 {
  constructor() {
    this.selectedValue = null;
    this.nzPlaceHolder = "";
  }
};
_NzDemoSelectSearchComponent3.\u0275fac = function NzDemoSelectSearchComponent_Factory(t) {
  return new (t || _NzDemoSelectSearchComponent3)();
};
_NzDemoSelectSearchComponent3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoSelectSearchComponent3, selectors: [["nz-demo-select-search"]], inputs: { nzPlaceHolder: "nzPlaceHolder" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 4, vars: 2, consts: [["nzShowSearch", "", "nzAllowClear", "", 2, "width", "100%", 3, "nzPlaceHolder", "ngModel", "ngModelChange"], ["nzLabel", "test-1", "nzValue", "test-1"], ["nzLabel", "test-2", "nzValue", "test-2"], ["nzLabel", "test-3", "nzValue", "test-3"]], template: function NzDemoSelectSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener($event) {
      return ctx.selectedValue = $event;
    });
    \u0275\u0275element(1, "nz-option", 1)(2, "nz-option", 2)(3, "nz-option", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPlaceHolder", ctx.nzPlaceHolder)("ngModel", ctx.selectedValue);
  }
}, dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, FormsModule, NgControlStatus, NgModel], styles: ["\n\nnz-select[_ngcontent-%COMP%] {\n  width: 200px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2VsZWN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIG56LXNlbGVjdCB7XG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxTQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoSelectSearchComponent3 = _NzDemoSelectSearchComponent3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoSelectSearchComponent3, { className: "NzDemoSelectSearchComponent", filePath: "src\\app\\routes\\pages\\live\\components\\select.ts", lineNumber: 25 });
})();

// src/app/routes/pages/live/components/table.ts
function NzDemoTableRowSelectionCustomComponent_tr_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr")(1, "td", 4);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_tr_14_Template_td_nzCheckedChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r4);
      const data_r2 = restoredCtx.$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onItemChecked(data_r2.id, $event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "td");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "td");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "td");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "td");
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzChecked", ctx_r1.setOfCheckedId.has(data_r2.id));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Scale);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Weight);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Flow);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Time);
  }
}
var _NzDemoTableRowSelectionCustomComponent3 = class _NzDemoTableRowSelectionCustomComponent3 {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
    this.pageSize = 5;
    this.pageIndex = 1;
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = new Array(200).fill(0).map((_, index) => ({
      id: index,
      Scale: `Scale ${index}`,
      Weight: "250 Kg",
      Flow: `70 Kg/h`,
      Time: (/* @__PURE__ */ new Date()).toLocaleString()
    }));
  }
};
_NzDemoTableRowSelectionCustomComponent3.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent3)();
};
_NzDemoTableRowSelectionCustomComponent3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent3, selectors: [["nz-demo-table-row-selection-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 15, vars: 7, consts: [["nzShowSizeChanger", "", 3, "nzData", "nzPageSize", "nzPageIndex", "nzCurrentPageDataChange"], ["rowSelectionTable", ""], [3, "nzSelections", "nzChecked", "nzIndeterminate", "nzCheckedChange"], [4, "ngFor", "ngForOf"], [3, "nzChecked", "nzCheckedChange"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1);
    \u0275\u0275listener("nzCurrentPageDataChange", function NzDemoTableRowSelectionCustomComponent_Template_nz_table_nzCurrentPageDataChange_0_listener($event) {
      return ctx.onCurrentPageDataChange($event);
    });
    \u0275\u0275elementStart(2, "thead")(3, "tr")(4, "th", 2);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.checked = $event;
    })("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.onAllChecked($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "th");
    \u0275\u0275text(6, "Scale");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "th");
    \u0275\u0275text(8, "Weight");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "th");
    \u0275\u0275text(10, "Flow");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "th");
    \u0275\u0275text(12, "Time-Stamp");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(13, "tbody");
    \u0275\u0275template(14, NzDemoTableRowSelectionCustomComponent_tr_14_Template, 10, 5, "tr", 3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzPageSize", ctx.pageSize)("nzPageIndex", ctx.pageIndex);
    \u0275\u0275advance(4);
    \u0275\u0275property("nzSelections", ctx.listOfSelection)("nzChecked", ctx.checked)("nzIndeterminate", ctx.indeterminate);
    \u0275\u0275advance(10);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzThSelectionComponent, CommonModule, NgForOf], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent3 = _NzDemoTableRowSelectionCustomComponent3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent3, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\pages\\live\\components\\table.ts", lineNumber: 52 });
})();

// src/app/routes/pages/live/components/tabs.ts
function NzDemoTabsSlideComponent_nz_tab_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-tab", 4);
    \u0275\u0275listener("nzSelect", function NzDemoTabsSlideComponent_nz_tab_6_Template_nz_tab_nzSelect_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const tab_r1 = restoredCtx.$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.log(["select", tab_r1]));
    })("nzClick", function NzDemoTabsSlideComponent_nz_tab_6_Template_nz_tab_nzClick_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const tab_r1 = restoredCtx.$implicit;
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.log(["click", tab_r1]));
    })("nzContextmenu", function NzDemoTabsSlideComponent_nz_tab_6_Template_nz_tab_nzContextmenu_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const tab_r1 = restoredCtx.$implicit;
      const ctx_r5 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r5.log(["contextmenu", tab_r1]));
    })("nzDeselect", function NzDemoTabsSlideComponent_nz_tab_6_Template_nz_tab_nzDeselect_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r3);
      const tab_r1 = restoredCtx.$implicit;
      const ctx_r6 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r6.log(["deselect", tab_r1]));
    });
    \u0275\u0275element(1, "chart-mini-progress-basic");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    \u0275\u0275property("nzTitle", tab_r1.name)("nzDisabled", tab_r1.disabled);
  }
}
var _NzDemoTabsSlideComponent = class _NzDemoTabsSlideComponent {
  constructor() {
    this.tabs = [];
    this.nzTabPosition = "left";
    this.selectedIndex = 27;
  }
  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
  log(args) {
    console.log(args);
  }
  ngOnInit() {
    for (let i = 0; i < 10; i++) {
      this.tabs.push({
        name: `Tank ${i + 1}`,
        disabled: i === 8,
        content: `Content of tab ${i}`
      });
    }
  }
};
_NzDemoTabsSlideComponent.\u0275fac = function NzDemoTabsSlideComponent_Factory(t) {
  return new (t || _NzDemoTabsSlideComponent)();
};
_NzDemoTabsSlideComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTabsSlideComponent, selectors: [["nz-demo-tabs-slide"]], inputs: { content: "content" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 7, vars: 6, consts: [[2, "margin-bottom", "8px", 3, "ngModel", "ngModelChange"], ["nz-radio-button", "", 3, "nzValue"], [2, "height", "auto", 3, "nzTabPosition", "nzSelectedIndex", "nzSelectedIndexChange", "nzSelectChange"], [3, "nzTitle", "nzDisabled", "nzSelect", "nzClick", "nzContextmenu", "nzDeselect", 4, "ngFor", "ngForOf"], [3, "nzTitle", "nzDisabled", "nzSelect", "nzClick", "nzContextmenu", "nzDeselect"]], template: function NzDemoTabsSlideComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-radio-group", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoTabsSlideComponent_Template_nz_radio_group_ngModelChange_0_listener($event) {
      return ctx.nzTabPosition = $event;
    });
    \u0275\u0275elementStart(1, "label", 1);
    \u0275\u0275text(2, "Horizontal");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "label", 1);
    \u0275\u0275text(4, "Vertical");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "nz-tabset", 2);
    \u0275\u0275listener("nzSelectedIndexChange", function NzDemoTabsSlideComponent_Template_nz_tabset_nzSelectedIndexChange_5_listener($event) {
      return ctx.selectedIndex = $event;
    })("nzSelectChange", function NzDemoTabsSlideComponent_Template_nz_tabset_nzSelectChange_5_listener($event) {
      return ctx.log([$event]);
    });
    \u0275\u0275template(6, NzDemoTabsSlideComponent_nz_tab_6_Template, 2, 2, "nz-tab", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("ngModel", ctx.nzTabPosition);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzValue", "top");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzValue", "left");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzTabPosition", ctx.nzTabPosition)("nzSelectedIndex", ctx.selectedIndex);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx.tabs);
  }
}, dependencies: [NzTabsModule, NzTabSetComponent, NzTabComponent, NzRadioModule, NzRadioComponent, NzRadioButtonDirective, NzRadioGroupComponent, ChartMiniProgressBasicComponent, NzInputModule, NzFormModule, CommonModule, NgForOf, FormsModule, NgControlStatus, NgModel], encapsulation: 2 });
var NzDemoTabsSlideComponent = _NzDemoTabsSlideComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTabsSlideComponent, { className: "NzDemoTabsSlideComponent", filePath: "src\\app\\routes\\pages\\live\\components\\tabs.ts", lineNumber: 37 });
})();

// src/app/routes/pages/live/semiCorm.component.ts
function SemiCornComponent_div_38_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18);
    \u0275\u0275element(1, "nz-demo-card-simple", 19);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("Text", item_r1.Text)("id", item_r1.id);
  }
}
var _SemiCornComponent = class _SemiCornComponent {
  constructor() {
    this.http = inject(_HttpClient);
    this.cdr = inject(ChangeDetectorRef);
    this.obSrv = inject(OnboardingService);
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  ngOnInit() {
    setTimeout(() => {
    }, 1e3);
    this.listOfData = new Array(24).fill(0).map((_, index) => ({
      Text: `P${index + 1}`,
      id: index
    }));
  }
};
_SemiCornComponent.\u0275fac = function SemiCornComponent_Factory(t) {
  return new (t || _SemiCornComponent)();
};
_SemiCornComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _SemiCornComponent, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 49, vars: 5, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzMd", "8", 2, "height", "300px"], ["nzTitle", "A150 - Tank 1", 2, "box-shadow", "0 0 10px rgba(0, 0, 0, 0.1)"], [1, "water-tank-container", 2, "text-align", "center", "padding", "20px", "border-radius", "8px"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 200 120", "width", "200", "height", "120"], ["x", "40", "y", "20", "width", "120", "height", "80", "fill", "#3498db"], ["x", "40", "y", "100", "width", "120", "height", "10", "fill", "#87CEEB"], ["x", "30", "y", "10", "width", "140", "height", "10", "fill", "red"], ["x", "50%", "y", "70%", "text-anchor", "middle", "fill", "#fff", "font-size", "14", "font-family", "Arial"], ["x", "50%", "y", "90%", "text-anchor", "middle", "fill", "#fff", "font-size", "12", "font-family", "Arial"], ["nzTitle", "A150 - Tank 2", 2, "box-shadow", "0 0 10px rgba(0, 0, 0, 0.1)"], ["x", "30", "y", "10", "width", "140", "height", "10", "fill", "green"], ["nzTitle", "Main Flow", 2, "box-shadow", "0 0 10px rgba(0, 0, 0, 0.1)"], ["nz-col", "", "nzXs", "24", "nzMd", "24"], [3, "nzBordered", "nzTitle"], ["nz-col", "", "nzXs", "24", "nzMd", "4", 4, "ngFor", "ngForOf"], ["nz-col", "", "nzXs", "24", "nzMd", "12"], ["nz-col", "", "nzXs", "24", "nzMd", "4"], [3, "Text", "id"]], template: function SemiCornComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Semi-Corn ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2)(7, "nz-card", 3)(8, "div", 4);
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(9, "svg", 5);
    \u0275\u0275element(10, "rect", 6)(11, "rect", 7)(12, "rect", 8);
    \u0275\u0275elementStart(13, "text", 9);
    \u0275\u0275text(14, "A150 - Tank 1");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "text", 10);
    \u0275\u0275text(16, "Capacity: 1000L");
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275namespaceHTML();
    \u0275\u0275elementStart(17, "div", 2)(18, "nz-card", 11)(19, "div", 4);
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(20, "svg", 5);
    \u0275\u0275element(21, "rect", 6)(22, "rect", 7)(23, "rect", 12);
    \u0275\u0275elementStart(24, "text", 9);
    \u0275\u0275text(25, "A150 - Tank 2");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "text", 10);
    \u0275\u0275text(27, "Capacity: 1000L");
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275namespaceHTML();
    \u0275\u0275elementStart(28, "div", 2)(29, "nz-card", 13);
    \u0275\u0275element(30, "chart-gauge-basic");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(31, "div", 1)(32, "div", 14)(33, "nz-card", 15);
    \u0275\u0275element(34, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(35, "div", 14)(36, "nz-card", 15)(37, "div", 1);
    \u0275\u0275template(38, SemiCornComponent_div_38_Template, 2, 2, "div", 16);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(39, "div", 14)(40, "div", 1)(41, "div", 17)(42, "nz-card")(43, "nz-demo-tabs-slide");
    \u0275\u0275element(44, "chart-mini-progress-basic");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(45, "div", 17)(46, "nz-card")(47, "nz-demo-tabs-slide");
    \u0275\u0275element(48, "chart-mini-progress-basic");
    \u0275\u0275elementEnd()()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(33);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Scale Log");
    \u0275\u0275advance(3);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Pump State");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.listOfData);
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule,
  G2TimelineModule,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  OnboardingModule,
  NzDemoTableRowSelectionCustomComponent3,
  NzDemoCardSimpleComponent,
  CommonModule,
  NgForOf,
  ChartMiniProgressBasicComponent,
  ChartGaugeBasicComponent,
  NzDemoTabsSlideComponent
], encapsulation: 2, changeDetection: 0 });
var SemiCornComponent = _SemiCornComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(SemiCornComponent, { className: "SemiCornComponent", filePath: "src\\app\\routes\\pages\\live\\semiCorm.component.ts", lineNumber: 45 });
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-descriptions.mjs
function NzDescriptionsItemComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c050 = ["*"];
function NzDescriptionsComponent_div_0_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r5.nzTitle);
  }
}
function NzDescriptionsComponent_div_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275template(1, NzDescriptionsComponent_div_0_div_1_ng_container_1_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r3.nzTitle);
  }
}
function NzDescriptionsComponent_div_0_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r6.nzExtra);
  }
}
function NzDescriptionsComponent_div_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275template(1, NzDescriptionsComponent_div_0_div_2_ng_container_1_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r4.nzExtra);
  }
}
function NzDescriptionsComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275template(1, NzDescriptionsComponent_div_0_div_1_Template, 2, 1, "div", 4)(2, NzDescriptionsComponent_div_0_div_2_Template, 2, 1, "div", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzTitle);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzExtra);
  }
}
function NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r11 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", item_r11.title, " ");
  }
}
function NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_1_ng_template_6_Template(rf, ctx) {
}
function NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "td", 12)(2, "div", 13)(3, "span", 14);
    \u0275\u0275template(4, NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_1_ng_container_4_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "span", 15);
    \u0275\u0275template(6, NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_1_ng_template_6_Template, 0, 0, "ng-template", 16);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r11 = \u0275\u0275nextContext().$implicit;
    const ctx_r13 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("colSpan", item_r11.span);
    \u0275\u0275advance(2);
    \u0275\u0275classProp("ant-descriptions-item-no-colon", !ctx_r13.nzColon);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", item_r11.title);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", item_r11.content);
  }
}
function NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r11 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", item_r11.title, " ");
  }
}
function NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_2_ng_template_4_Template(rf, ctx) {
}
function NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "td", 14);
    \u0275\u0275template(2, NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_2_ng_container_2_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td", 17);
    \u0275\u0275template(4, NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_2_ng_template_4_Template, 0, 0, "ng-template", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r11 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", item_r11.title);
    \u0275\u0275advance(1);
    \u0275\u0275property("colSpan", item_r11.span * 2 - 1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", item_r11.content);
  }
}
function NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_1_Template, 7, 5, "ng-container", 2)(2, NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_ng_container_2_Template, 5, 3, "ng-container", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r10 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r10.nzBordered);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r10.nzBordered);
  }
}
function NzDescriptionsComponent_ng_container_4_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 10);
    \u0275\u0275template(1, NzDescriptionsComponent_ng_container_4_tr_1_ng_container_1_Template, 3, 2, "ng-container", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r8 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", row_r8);
  }
}
function NzDescriptionsComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzDescriptionsComponent_ng_container_4_tr_1_Template, 2, 1, "tr", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r1.itemMatrix);
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_ng_container_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r30 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", item_r30.title, " ");
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "td", 12)(2, "div", 13)(3, "span", 14);
    \u0275\u0275template(4, NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_ng_container_2_ng_container_4_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r30 = ctx.$implicit;
    const ctx_r28 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(1);
    \u0275\u0275property("colSpan", item_r30.span);
    \u0275\u0275advance(2);
    \u0275\u0275classProp("ant-descriptions-item-no-colon", !ctx_r28.nzColon);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", item_r30.title);
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_ng_container_4_ng_template_4_Template(rf, ctx) {
}
function NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "td", 12)(2, "div", 13)(3, "span", 15);
    \u0275\u0275template(4, NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_ng_container_4_ng_template_4_Template, 0, 0, "ng-template", 16);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r34 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("colSpan", item_r34.span);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", item_r34.content);
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "tr", 10);
    \u0275\u0275template(2, NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_ng_container_2_Template, 5, 4, "ng-container", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "tr", 10);
    \u0275\u0275template(4, NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_ng_container_4_Template, 5, 2, "ng-container", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const row_r26 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", row_r26);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", row_r26);
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzDescriptionsComponent_ng_container_5_ng_container_1_ng_container_1_Template, 5, 2, "ng-container", 11);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r23 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r23.itemMatrix);
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r42 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", item_r42.title, " ");
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "td", 18);
    \u0275\u0275template(2, NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_ng_container_2_ng_container_2_Template, 2, 1, "ng-container", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r42 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("colSpan", item_r42.span);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", item_r42.title);
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_ng_container_4_ng_template_2_Template(rf, ctx) {
}
function NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "td", 17);
    \u0275\u0275template(2, NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_ng_container_4_ng_template_2_Template, 0, 0, "ng-template", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r46 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("colSpan", item_r46.span);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", item_r46.content);
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "tr", 10);
    \u0275\u0275template(2, NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_ng_container_2_Template, 3, 2, "ng-container", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "tr", 10);
    \u0275\u0275template(4, NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_ng_container_4_Template, 3, 2, "ng-container", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const row_r38 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", row_r38);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", row_r38);
  }
}
function NzDescriptionsComponent_ng_container_5_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzDescriptionsComponent_ng_container_5_ng_container_2_ng_container_1_Template, 5, 2, "ng-container", 11);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r24 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx_r24.itemMatrix);
  }
}
function NzDescriptionsComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzDescriptionsComponent_ng_container_5_ng_container_1_Template, 2, 1, "ng-container", 2)(2, NzDescriptionsComponent_ng_container_5_ng_container_2_Template, 2, 1, "ng-container", 2);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r2.nzBordered);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r2.nzBordered);
  }
}
var _NzDescriptionsItemComponent = class _NzDescriptionsItemComponent {
  constructor() {
    this.nzSpan = 1;
    this.nzTitle = "";
    this.inputChange$ = new Subject();
  }
  ngOnChanges() {
    this.inputChange$.next();
  }
  ngOnDestroy() {
    this.inputChange$.complete();
  }
};
_NzDescriptionsItemComponent.\u0275fac = function NzDescriptionsItemComponent_Factory(t) {
  return new (t || _NzDescriptionsItemComponent)();
};
_NzDescriptionsItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzDescriptionsItemComponent,
  selectors: [["nz-descriptions-item"]],
  viewQuery: function NzDescriptionsItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.content = _t.first);
    }
  },
  inputs: {
    nzSpan: "nzSpan",
    nzTitle: "nzTitle"
  },
  exportAs: ["nzDescriptionsItem"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c050,
  decls: 1,
  vars: 0,
  template: function NzDescriptionsItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzDescriptionsItemComponent_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzDescriptionsItemComponent = _NzDescriptionsItemComponent;
__decorate([InputNumber()], NzDescriptionsItemComponent.prototype, "nzSpan", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDescriptionsItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-descriptions-item",
      template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `,
      exportAs: "nzDescriptionsItem",
      preserveWhitespaces: false,
      standalone: true
    }]
  }], null, {
    content: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    nzSpan: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }]
  });
})();
var NZ_CONFIG_MODULE_NAME22 = "descriptions";
var defaultColumnMap = {
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
var _NzDescriptionsComponent = class _NzDescriptionsComponent {
  constructor(nzConfigService, cdr, breakpointService, directionality) {
    this.nzConfigService = nzConfigService;
    this.cdr = cdr;
    this.breakpointService = breakpointService;
    this.directionality = directionality;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME22;
    this.nzBordered = false;
    this.nzLayout = "horizontal";
    this.nzColumn = defaultColumnMap;
    this.nzSize = "default";
    this.nzTitle = "";
    this.nzColon = true;
    this.itemMatrix = [];
    this.realColumn = 3;
    this.dir = "ltr";
    this.breakpoint = NzBreakpointEnum.md;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
    });
  }
  ngOnChanges(changes) {
    if (changes.nzColumn) {
      this.prepareMatrix();
    }
  }
  ngAfterContentInit() {
    const contentChange$ = this.items.changes.pipe(startWith(this.items), takeUntil(this.destroy$));
    merge(contentChange$, contentChange$.pipe(switchMap(() => merge(...this.items.map((i) => i.inputChange$)).pipe(auditTime(16)))), this.breakpointService.subscribe(gridResponsiveMap).pipe(tap((bp) => this.breakpoint = bp))).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.prepareMatrix();
      this.cdr.markForCheck();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Prepare the render matrix according to description items' spans.
   */
  prepareMatrix() {
    if (!this.items) {
      return;
    }
    let currentRow = [];
    let width = 0;
    const column = this.realColumn = this.getColumn();
    const items = this.items.toArray();
    const length = items.length;
    const matrix = [];
    const flushRow = () => {
      matrix.push(currentRow);
      currentRow = [];
      width = 0;
    };
    for (let i = 0; i < length; i++) {
      const item = items[i];
      const {
        nzTitle: title,
        content,
        nzSpan: span
      } = item;
      width += span;
      if (width >= column) {
        if (width > column) {
          warn2(`"nzColumn" is ${column} but we have row length ${width}`);
        }
        currentRow.push({
          title,
          content,
          span: column - (width - span)
        });
        flushRow();
      } else if (i === length - 1) {
        currentRow.push({
          title,
          content,
          span: column - (width - span)
        });
        flushRow();
      } else {
        currentRow.push({
          title,
          content,
          span
        });
      }
    }
    this.itemMatrix = matrix;
  }
  getColumn() {
    if (typeof this.nzColumn !== "number") {
      return this.nzColumn[this.breakpoint];
    }
    return this.nzColumn;
  }
};
_NzDescriptionsComponent.\u0275fac = function NzDescriptionsComponent_Factory(t) {
  return new (t || _NzDescriptionsComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzBreakpointService), \u0275\u0275directiveInject(Directionality, 8));
};
_NzDescriptionsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzDescriptionsComponent,
  selectors: [["nz-descriptions"]],
  contentQueries: function NzDescriptionsComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzDescriptionsItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.items = _t);
    }
  },
  hostAttrs: [1, "ant-descriptions"],
  hostVars: 8,
  hostBindings: function NzDescriptionsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-descriptions-bordered", ctx.nzBordered)("ant-descriptions-middle", ctx.nzSize === "middle")("ant-descriptions-small", ctx.nzSize === "small")("ant-descriptions-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzBordered: "nzBordered",
    nzLayout: "nzLayout",
    nzColumn: "nzColumn",
    nzSize: "nzSize",
    nzTitle: "nzTitle",
    nzExtra: "nzExtra",
    nzColon: "nzColon"
  },
  exportAs: ["nzDescriptions"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 6,
  vars: 3,
  consts: [["class", "ant-descriptions-header", 4, "ngIf"], [1, "ant-descriptions-view"], [4, "ngIf"], [1, "ant-descriptions-header"], ["class", "ant-descriptions-title", 4, "ngIf"], ["class", "ant-descriptions-extra", 4, "ngIf"], [1, "ant-descriptions-title"], [4, "nzStringTemplateOutlet"], [1, "ant-descriptions-extra"], ["class", "ant-descriptions-row", 4, "ngFor", "ngForOf"], [1, "ant-descriptions-row"], [4, "ngFor", "ngForOf"], [1, "ant-descriptions-item", 3, "colSpan"], [1, "ant-descriptions-item-container"], [1, "ant-descriptions-item-label"], [1, "ant-descriptions-item-content"], [3, "ngTemplateOutlet"], [1, "ant-descriptions-item-content", 3, "colSpan"], [1, "ant-descriptions-item-label", 3, "colSpan"]],
  template: function NzDescriptionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, NzDescriptionsComponent_div_0_Template, 3, 2, "div", 0);
      \u0275\u0275elementStart(1, "div", 1)(2, "table")(3, "tbody");
      \u0275\u0275template(4, NzDescriptionsComponent_ng_container_4_Template, 2, 1, "ng-container", 2)(5, NzDescriptionsComponent_ng_container_5_Template, 3, 2, "ng-container", 2);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.nzTitle || ctx.nzExtra);
      \u0275\u0275advance(4);
      \u0275\u0275property("ngIf", ctx.nzLayout === "horizontal");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzLayout === "vertical");
    }
  },
  dependencies: [NgIf, NzOutletModule, NzStringTemplateOutletDirective, NgForOf, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzDescriptionsComponent = _NzDescriptionsComponent;
__decorate([InputBoolean(), WithConfig()], NzDescriptionsComponent.prototype, "nzBordered", void 0);
__decorate([WithConfig()], NzDescriptionsComponent.prototype, "nzColumn", void 0);
__decorate([WithConfig()], NzDescriptionsComponent.prototype, "nzSize", void 0);
__decorate([WithConfig(), InputBoolean()], NzDescriptionsComponent.prototype, "nzColon", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDescriptionsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-descriptions",
      exportAs: "nzDescriptions",
      preserveWhitespaces: false,
      template: `
    <div *ngIf="nzTitle || nzExtra" class="ant-descriptions-header">
      <div *ngIf="nzTitle" class="ant-descriptions-title">
        <ng-container *nzStringTemplateOutlet="nzTitle">{{ nzTitle }}</ng-container>
      </div>
      <div *ngIf="nzExtra" class="ant-descriptions-extra">
        <ng-container *nzStringTemplateOutlet="nzExtra">{{ nzExtra }}</ng-container>
      </div>
    </div>
    <div class="ant-descriptions-view">
      <table>
        <tbody>
          <ng-container *ngIf="nzLayout === 'horizontal'">
            <tr class="ant-descriptions-row" *ngFor="let row of itemMatrix; let i = index">
              <ng-container *ngFor="let item of row; let isLast = last">
                <!-- Horizontal & NOT Bordered -->
                <ng-container *ngIf="!nzBordered">
                  <td class="ant-descriptions-item" [colSpan]="item.span">
                    <div class="ant-descriptions-item-container">
                      <span class="ant-descriptions-item-label" [class.ant-descriptions-item-no-colon]="!nzColon">
                        <ng-container *nzStringTemplateOutlet="item.title">
                          {{ item.title }}
                        </ng-container>
                      </span>
                      <span class="ant-descriptions-item-content">
                        <ng-template [ngTemplateOutlet]="item.content"></ng-template>
                      </span>
                    </div>
                  </td>
                </ng-container>
                <!-- Horizontal & Bordered -->
                <ng-container *ngIf="nzBordered">
                  <td class="ant-descriptions-item-label">
                    <ng-container *nzStringTemplateOutlet="item.title">
                      {{ item.title }}
                    </ng-container>
                  </td>
                  <td class="ant-descriptions-item-content" [colSpan]="item.span * 2 - 1">
                    <ng-template [ngTemplateOutlet]="item.content"></ng-template>
                  </td>
                </ng-container>
              </ng-container>
            </tr>
          </ng-container>

          <ng-container *ngIf="nzLayout === 'vertical'">
            <!-- Vertical & NOT Bordered -->
            <ng-container *ngIf="!nzBordered">
              <ng-container *ngFor="let row of itemMatrix; let i = index">
                <tr class="ant-descriptions-row">
                  <ng-container *ngFor="let item of row; let isLast = last">
                    <td class="ant-descriptions-item" [colSpan]="item.span">
                      <div class="ant-descriptions-item-container">
                        <span class="ant-descriptions-item-label" [class.ant-descriptions-item-no-colon]="!nzColon">
                          <ng-container *nzStringTemplateOutlet="item.title">
                            {{ item.title }}
                          </ng-container>
                        </span>
                      </div>
                    </td>
                  </ng-container>
                </tr>
                <tr class="ant-descriptions-row">
                  <ng-container *ngFor="let item of row; let isLast = last">
                    <td class="ant-descriptions-item" [colSpan]="item.span">
                      <div class="ant-descriptions-item-container">
                        <span class="ant-descriptions-item-content">
                          <ng-template [ngTemplateOutlet]="item.content"></ng-template>
                        </span>
                      </div>
                    </td>
                  </ng-container>
                </tr>
              </ng-container>
            </ng-container>
            <!-- Vertical & Bordered -->
            <ng-container *ngIf="nzBordered">
              <ng-container *ngFor="let row of itemMatrix; let i = index">
                <tr class="ant-descriptions-row">
                  <ng-container *ngFor="let item of row; let isLast = last">
                    <td class="ant-descriptions-item-label" [colSpan]="item.span">
                      <ng-container *nzStringTemplateOutlet="item.title">
                        {{ item.title }}
                      </ng-container>
                    </td>
                  </ng-container>
                </tr>
                <tr class="ant-descriptions-row">
                  <ng-container *ngFor="let item of row; let isLast = last">
                    <td class="ant-descriptions-item-content" [colSpan]="item.span">
                      <ng-template [ngTemplateOutlet]="item.content"></ng-template>
                    </td>
                  </ng-container>
                </tr>
              </ng-container>
            </ng-container>
          </ng-container>
        </tbody>
      </table>
    </div>
  `,
      host: {
        class: "ant-descriptions",
        "[class.ant-descriptions-bordered]": "nzBordered",
        "[class.ant-descriptions-middle]": 'nzSize === "middle"',
        "[class.ant-descriptions-small]": 'nzSize === "small"',
        "[class.ant-descriptions-rtl]": 'dir === "rtl"'
      },
      imports: [NgIf, NzOutletModule, NgForOf, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NzBreakpointService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    items: [{
      type: ContentChildren,
      args: [NzDescriptionsItemComponent]
    }],
    nzBordered: [{
      type: Input
    }],
    nzLayout: [{
      type: Input
    }],
    nzColumn: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    nzExtra: [{
      type: Input
    }],
    nzColon: [{
      type: Input
    }]
  });
})();
var _NzDescriptionsModule = class _NzDescriptionsModule {
};
_NzDescriptionsModule.\u0275fac = function NzDescriptionsModule_Factory(t) {
  return new (t || _NzDescriptionsModule)();
};
_NzDescriptionsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzDescriptionsModule
});
_NzDescriptionsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzDescriptionsComponent]
});
var NzDescriptionsModule = _NzDescriptionsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzDescriptionsModule, [{
    type: NgModule,
    args: [{
      imports: [NzDescriptionsComponent, NzDescriptionsItemComponent],
      exports: [NzDescriptionsComponent, NzDescriptionsItemComponent]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-core-pipe.mjs
var _NzTimeRangePipe = class _NzTimeRangePipe {
  transform(value, format2 = "HH:mm:ss") {
    let duration = Number(value || 0);
    return timeUnits.reduce((current, [name, unit]) => {
      if (current.indexOf(name) !== -1) {
        const v = Math.floor(duration / unit);
        duration -= v * unit;
        return current.replace(new RegExp(`${name}+`, "g"), (match3) => padStart(v.toString(), match3.length, "0"));
      }
      return current;
    }, format2);
  }
};
_NzTimeRangePipe.\u0275fac = function NzTimeRangePipe_Factory(t) {
  return new (t || _NzTimeRangePipe)();
};
_NzTimeRangePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "nzTimeRange",
  type: _NzTimeRangePipe,
  pure: true,
  standalone: true
});
var NzTimeRangePipe = _NzTimeRangePipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTimeRangePipe, [{
    type: Pipe,
    args: [{
      name: "nzTimeRange",
      pure: true,
      standalone: true
    }]
  }], null, null);
})();
var _NzPipesModule = class _NzPipesModule {
};
_NzPipesModule.\u0275fac = function NzPipesModule_Factory(t) {
  return new (t || _NzPipesModule)();
};
_NzPipesModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzPipesModule
});
_NzPipesModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzPipesModule = _NzPipesModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzPipesModule, [{
    type: NgModule,
    args: [{
      imports: [NzTimeRangePipe],
      exports: [NzTimeRangePipe]
    }]
  }], null, null);
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-statistic.mjs
var _c051 = (a0) => ({
  $implicit: a0
});
function NzStatisticNumberComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 3);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.nzValueTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c051, ctx_r0.nzValue));
  }
}
function NzStatisticNumberComponent_ng_container_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 6);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r2.displayInt);
  }
}
function NzStatisticNumberComponent_ng_container_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r3.displayDecimal);
  }
}
function NzStatisticNumberComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzStatisticNumberComponent_ng_container_2_span_1_Template, 2, 1, "span", 4)(2, NzStatisticNumberComponent_ng_container_2_span_2_Template, 2, 1, "span", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r1.displayInt);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r1.displayDecimal);
  }
}
function NzStatisticComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r0.nzTitle);
  }
}
function NzStatisticComponent_span_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r3.nzPrefix);
  }
}
function NzStatisticComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 6);
    \u0275\u0275template(1, NzStatisticComponent_span_3_ng_container_1_Template, 2, 1, "ng-container", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r1.nzPrefix);
  }
}
function NzStatisticComponent_span_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r4.nzSuffix);
  }
}
function NzStatisticComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 7);
    \u0275\u0275template(1, NzStatisticComponent_span_5_ng_container_1_Template, 2, 1, "ng-container", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2.nzSuffix);
  }
}
function NzCountdownComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275pipe(1, "nzTimeRange");
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(1, 1, ctx_r0.diff, ctx_r0.nzFormat));
  }
}
var _NzStatisticNumberComponent = class _NzStatisticNumberComponent {
  constructor(locale_id) {
    this.locale_id = locale_id;
    this.displayInt = "";
    this.displayDecimal = "";
  }
  ngOnChanges() {
    this.formatNumber();
  }
  formatNumber() {
    const decimalSeparator = typeof this.nzValue === "number" ? "." : getLocaleNumberSymbol(this.locale_id, NumberSymbol.Decimal);
    const value = String(this.nzValue);
    const [int, decimal] = value.split(decimalSeparator);
    this.displayInt = int;
    this.displayDecimal = decimal ? `${decimalSeparator}${decimal}` : "";
  }
};
_NzStatisticNumberComponent.\u0275fac = function NzStatisticNumberComponent_Factory(t) {
  return new (t || _NzStatisticNumberComponent)(\u0275\u0275directiveInject(LOCALE_ID));
};
_NzStatisticNumberComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzStatisticNumberComponent,
  selectors: [["nz-statistic-number"]],
  inputs: {
    nzValue: "nzValue",
    nzValueTemplate: "nzValueTemplate"
  },
  exportAs: ["nzStatisticNumber"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 3,
  vars: 2,
  consts: [[1, "ant-statistic-content-value"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "ant-statistic-content-value-int", 4, "ngIf"], ["class", "ant-statistic-content-value-decimal", 4, "ngIf"], [1, "ant-statistic-content-value-int"], [1, "ant-statistic-content-value-decimal"]],
  template: function NzStatisticNumberComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275template(1, NzStatisticNumberComponent_ng_container_1_Template, 1, 4, "ng-container", 1)(2, NzStatisticNumberComponent_ng_container_2_Template, 3, 2, "ng-container", 2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzValueTemplate);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.nzValueTemplate);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var NzStatisticNumberComponent = _NzStatisticNumberComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzStatisticNumberComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      preserveWhitespaces: false,
      selector: "nz-statistic-number",
      exportAs: "nzStatisticNumber",
      template: `
    <span class="ant-statistic-content-value">
      <ng-container
        *ngIf="nzValueTemplate"
        [ngTemplateOutlet]="nzValueTemplate"
        [ngTemplateOutletContext]="{ $implicit: nzValue }"
      ></ng-container>
      <ng-container *ngIf="!nzValueTemplate">
        <span *ngIf="displayInt" class="ant-statistic-content-value-int">{{ displayInt }}</span>
        <span *ngIf="displayDecimal" class="ant-statistic-content-value-decimal">{{ displayDecimal }}</span>
      </ng-container>
    </span>
  `,
      imports: [NgIf, NgTemplateOutlet],
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], {
    nzValue: [{
      type: Input
    }],
    nzValueTemplate: [{
      type: Input
    }]
  });
})();
var _NzStatisticComponent = class _NzStatisticComponent {
  constructor(cdr, directionality) {
    this.cdr = cdr;
    this.directionality = directionality;
    this.nzValueStyle = {};
    this.dir = "ltr";
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NzStatisticComponent.\u0275fac = function NzStatisticComponent_Factory(t) {
  return new (t || _NzStatisticComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(Directionality, 8));
};
_NzStatisticComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzStatisticComponent,
  selectors: [["nz-statistic"]],
  hostAttrs: [1, "ant-statistic"],
  hostVars: 2,
  hostBindings: function NzStatisticComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("ant-statistic-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    nzPrefix: "nzPrefix",
    nzSuffix: "nzSuffix",
    nzTitle: "nzTitle",
    nzValue: "nzValue",
    nzValueStyle: "nzValueStyle",
    nzValueTemplate: "nzValueTemplate"
  },
  exportAs: ["nzStatistic"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 6,
  vars: 6,
  consts: [[1, "ant-statistic-title"], [4, "nzStringTemplateOutlet"], [1, "ant-statistic-content", 3, "ngStyle"], ["class", "ant-statistic-content-prefix", 4, "ngIf"], [3, "nzValue", "nzValueTemplate"], ["class", "ant-statistic-content-suffix", 4, "ngIf"], [1, "ant-statistic-content-prefix"], [1, "ant-statistic-content-suffix"]],
  template: function NzStatisticComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, NzStatisticComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "div", 2);
      \u0275\u0275template(3, NzStatisticComponent_span_3_Template, 2, 1, "span", 3);
      \u0275\u0275element(4, "nz-statistic-number", 4);
      \u0275\u0275template(5, NzStatisticComponent_span_5_Template, 2, 1, "span", 5);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzTitle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngStyle", ctx.nzValueStyle);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzPrefix);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzValue", ctx.nzValue)("nzValueTemplate", ctx.nzValueTemplate);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzSuffix);
    }
  },
  dependencies: [NzStatisticNumberComponent, NgIf, NzOutletModule, NzStringTemplateOutletDirective, NgStyle],
  encapsulation: 2,
  changeDetection: 0
});
var NzStatisticComponent = _NzStatisticComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzStatisticComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-statistic",
      exportAs: "nzStatistic",
      template: `
    <div class="ant-statistic-title">
      <ng-container *nzStringTemplateOutlet="nzTitle">{{ nzTitle }}</ng-container>
    </div>
    <div class="ant-statistic-content" [ngStyle]="nzValueStyle">
      <span *ngIf="nzPrefix" class="ant-statistic-content-prefix">
        <ng-container *nzStringTemplateOutlet="nzPrefix">{{ nzPrefix }}</ng-container>
      </span>
      <nz-statistic-number [nzValue]="nzValue" [nzValueTemplate]="nzValueTemplate"></nz-statistic-number>
      <span *ngIf="nzSuffix" class="ant-statistic-content-suffix">
        <ng-container *nzStringTemplateOutlet="nzSuffix">{{ nzSuffix }}</ng-container>
      </span>
    </div>
  `,
      host: {
        class: "ant-statistic",
        "[class.ant-statistic-rtl]": `dir === 'rtl'`
      },
      imports: [NzStatisticNumberComponent, NgIf, NzOutletModule, NgStyle],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzPrefix: [{
      type: Input
    }],
    nzSuffix: [{
      type: Input
    }],
    nzTitle: [{
      type: Input
    }],
    nzValue: [{
      type: Input
    }],
    nzValueStyle: [{
      type: Input
    }],
    nzValueTemplate: [{
      type: Input
    }]
  });
})();
var REFRESH_INTERVAL2 = 1e3 / 30;
var _NzCountdownComponent = class _NzCountdownComponent extends NzStatisticComponent {
  constructor(cdr, ngZone, platform, directionality) {
    super(cdr, directionality);
    this.ngZone = ngZone;
    this.platform = platform;
    this.nzFormat = "HH:mm:ss";
    this.nzCountdownFinish = new EventEmitter();
    this.target = 0;
  }
  ngOnChanges(changes) {
    if (changes.nzValue) {
      this.target = Number(changes.nzValue.currentValue);
      if (!changes.nzValue.isFirstChange()) {
        this.syncTimer();
      }
    }
  }
  ngOnInit() {
    super.ngOnInit();
    this.syncTimer();
  }
  ngOnDestroy() {
    this.stopTimer();
  }
  syncTimer() {
    if (this.target >= Date.now()) {
      this.startTimer();
    } else {
      this.stopTimer();
    }
  }
  startTimer() {
    if (this.platform.isBrowser) {
      this.ngZone.runOutsideAngular(() => {
        this.stopTimer();
        this.updater_ = interval(REFRESH_INTERVAL2).subscribe(() => {
          this.updateValue();
          this.cdr.detectChanges();
        });
      });
    }
  }
  stopTimer() {
    if (this.updater_) {
      this.updater_.unsubscribe();
      this.updater_ = null;
    }
  }
  /**
   * Update time that should be displayed on the screen.
   */
  updateValue() {
    this.diff = Math.max(this.target - Date.now(), 0);
    if (this.diff === 0) {
      this.stopTimer();
      if (this.nzCountdownFinish.observers.length) {
        this.ngZone.run(() => this.nzCountdownFinish.emit());
      }
    }
  }
};
_NzCountdownComponent.\u0275fac = function NzCountdownComponent_Factory(t) {
  return new (t || _NzCountdownComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(Directionality, 8));
};
_NzCountdownComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzCountdownComponent,
  selectors: [["nz-countdown"]],
  inputs: {
    nzFormat: "nzFormat"
  },
  outputs: {
    nzCountdownFinish: "nzCountdownFinish"
  },
  exportAs: ["nzCountdown"],
  standalone: true,
  features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  decls: 3,
  vars: 6,
  consts: [[3, "nzValue", "nzValueStyle", "nzValueTemplate", "nzTitle", "nzPrefix", "nzSuffix"], ["countDownTpl", ""]],
  template: function NzCountdownComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "nz-statistic", 0);
      \u0275\u0275template(1, NzCountdownComponent_ng_template_1_Template, 2, 4, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      const _r1 = \u0275\u0275reference(2);
      \u0275\u0275property("nzValue", ctx.diff)("nzValueStyle", ctx.nzValueStyle)("nzValueTemplate", ctx.nzValueTemplate || _r1)("nzTitle", ctx.nzTitle)("nzPrefix", ctx.nzPrefix)("nzSuffix", ctx.nzSuffix);
    }
  },
  dependencies: [NzStatisticComponent, NzPipesModule, NzTimeRangePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NzCountdownComponent = _NzCountdownComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzCountdownComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      selector: "nz-countdown",
      exportAs: "nzCountdown",
      template: `
    <nz-statistic
      [nzValue]="diff"
      [nzValueStyle]="nzValueStyle"
      [nzValueTemplate]="nzValueTemplate || countDownTpl"
      [nzTitle]="nzTitle"
      [nzPrefix]="nzPrefix"
      [nzSuffix]="nzSuffix"
    ></nz-statistic>

    <ng-template #countDownTpl>{{ diff | nzTimeRange: nzFormat }}</ng-template>
  `,
      imports: [NzStatisticComponent, NzPipesModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: Platform
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    nzFormat: [{
      type: Input
    }],
    nzCountdownFinish: [{
      type: Output
    }]
  });
})();
var _NzStatisticModule = class _NzStatisticModule {
};
_NzStatisticModule.\u0275fac = function NzStatisticModule_Factory(t) {
  return new (t || _NzStatisticModule)();
};
_NzStatisticModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzStatisticModule
});
_NzStatisticModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzStatisticComponent, NzCountdownComponent]
});
var NzStatisticModule = _NzStatisticModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzStatisticModule, [{
    type: NgModule,
    args: [{
      imports: [NzStatisticComponent, NzCountdownComponent, NzStatisticNumberComponent],
      exports: [NzStatisticComponent, NzCountdownComponent, NzStatisticNumberComponent]
    }]
  }], null, null);
})();

// node_modules/@delon/chart/fesm2022/pie.mjs
function G2PieComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-skeleton");
  }
}
function G2PieComponent_Conditional_4_Conditional_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r6.subTitle, \u0275\u0275sanitizeHtml);
  }
}
function G2PieComponent_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "h4", 7);
    \u0275\u0275template(1, G2PieComponent_Conditional_4_Conditional_1_ng_container_1_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r4.subTitle);
  }
}
function G2PieComponent_Conditional_4_Conditional_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "div", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r7.total, \u0275\u0275sanitizeHtml);
  }
}
function G2PieComponent_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275template(1, G2PieComponent_Conditional_4_Conditional_2_ng_container_1_Template, 2, 1, "ng-container", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r5.total);
  }
}
function G2PieComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275template(1, G2PieComponent_Conditional_4_Conditional_1_Template, 2, 1, "h4", 5)(2, G2PieComponent_Conditional_4_Conditional_2_Template, 2, 1, "div", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r2.subTitle ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, ctx_r2.total ? 2 : -1);
  }
}
var _c052 = (a0) => ({
  "background-color": a0
});
function G2PieComponent_Conditional_5_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 12);
    \u0275\u0275listener("click", function G2PieComponent_Conditional_5_For_2_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r15);
      const $index_r10 = restoredCtx.$index;
      const ctx_r14 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r14._click($index_r10));
    });
    \u0275\u0275element(1, "span", 13);
    \u0275\u0275elementStart(2, "span", 14);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "nz-divider", 15);
    \u0275\u0275elementStart(5, "span", 16);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275element(7, "span", 17);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    const ctx_r8 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(4, _c052, !item_r9.checked ? "#aaa" : item_r9.color));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r9.x);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1("", item_r9.percent, "%");
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", ctx_r8.valueFormat ? ctx_r8.valueFormat(item_r9.y) : item_r9.y, \u0275\u0275sanitizeHtml);
  }
}
function G2PieComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 11);
    \u0275\u0275repeaterCreate(1, G2PieComponent_Conditional_5_For_2_Template, 8, 6, "li", 18, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r3.legendData);
  }
}
var _G2PieComponent = class _G2PieComponent extends G2BaseComponent {
  constructor() {
    super(...arguments);
    this.legendData = [];
    this.isPercent = false;
    this.animate = true;
    this.color = "rgba(24, 144, 255, 0.85)";
    this.height = 0;
    this.hasLegend = false;
    this.inner = 0.75;
    this.padding = [12, 0, 12, 0];
    this.tooltip = true;
    this.lineWidth = 0;
    this.blockMaxWidth = 380;
    this.select = true;
    this.data = [];
    this.interaction = "none";
    this.ratio = {
      text: "\u5360\u6BD4",
      inverse: "\u53CD\u6BD4",
      color: "",
      inverseColor: "#F0F2F5"
    };
    this.clickItem = new EventEmitter();
    this.block = false;
  }
  fixData() {
    const {
      percent,
      color
    } = this;
    this.isPercent = percent != null;
    if (!this.isPercent) {
      return;
    }
    this.select = false;
    this.tooltip = false;
    const {
      text,
      inverse,
      color: textColor,
      inverseColor
    } = this.ratio;
    this.percentColor = (value) => value === text ? textColor || color : inverseColor;
    this.data = [{
      x: text,
      y: percent
    }, {
      x: inverse,
      y: 100 - percent
    }];
  }
  updateBlock() {
    this.block = this._chart && this.hasLegend && this.el.nativeElement.clientWidth <= this.blockMaxWidth;
    this.cdr.detectChanges();
  }
  install() {
    const {
      node,
      height,
      padding,
      tooltip,
      inner,
      hasLegend,
      interaction,
      theme,
      animate: animate2,
      lineWidth,
      isPercent,
      percentColor,
      colors
    } = this;
    const chart = this._chart = new this.winG2.Chart({
      container: node.nativeElement,
      autoFit: true,
      height,
      padding,
      theme
    });
    chart.animate(animate2);
    if (!tooltip) {
      chart.tooltip(false);
    } else {
      chart.tooltip({
        showTitle: false,
        showMarkers: false
      });
    }
    if (interaction !== "none") {
      chart.interaction(interaction);
    }
    chart.axis(false).legend(false).coordinate("theta", {
      innerRadius: inner
    });
    chart.filter("x", (_val, item) => item.checked !== false);
    chart.interval().adjust("stack").position("y").style({
      lineWidth,
      stroke: "#fff"
    }).color("x", isPercent ? percentColor : colors).tooltip("x*percent", (name, p) => ({
      name,
      value: `${hasLegend ? p : (p * 100).toFixed(2)} %`
    })).state({});
    chart.scale({
      x: {
        type: "cat",
        range: [0, 1]
      }
    });
    chart.on(`interval:click`, (ev) => {
      this.ngZone.run(() => this.clickItem.emit({
        item: ev.data?.data,
        ev
      }));
    }).on("afterrender", () => {
      this.ngZone.run(() => this.updateBlock());
    });
    this.ready.next(chart);
    this.changeData();
    chart.render();
  }
  changeData() {
    const {
      _chart,
      data
    } = this;
    if (!_chart || !Array.isArray(data) || data.length <= 0)
      return;
    const totalSum = data.reduce((cur, item) => cur + item.y, 0);
    for (const item of data) {
      item.percent = totalSum === 0 ? 0 : item.y / totalSum;
    }
    _chart.changeData(data);
    this.ngZone.run(() => this.genLegend());
  }
  genLegend() {
    const {
      hasLegend,
      isPercent,
      cdr,
      _chart
    } = this;
    if (!hasLegend || isPercent)
      return;
    this.legendData = _chart.geometries[0].dataArray.map((item) => {
      const origin = item[0]._origin;
      origin.color = item[0].color;
      origin.checked = true;
      origin.percent = (origin.percent * 100).toFixed(2);
      return origin;
    });
    cdr.detectChanges();
  }
  _click(i) {
    const {
      legendData,
      _chart
    } = this;
    legendData[i].checked = !legendData[i].checked;
    _chart.render(true);
  }
  onChanges() {
    this.fixData();
  }
};
_G2PieComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275G2PieComponent_BaseFactory;
  return function G2PieComponent_Factory(t) {
    return (\u0275G2PieComponent_BaseFactory || (\u0275G2PieComponent_BaseFactory = \u0275\u0275getInheritedFactory(_G2PieComponent)))(t || _G2PieComponent);
  };
})();
_G2PieComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _G2PieComponent,
  selectors: [["g2-pie"]],
  hostVars: 8,
  hostBindings: function G2PieComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("g2-pie", true)("g2-pie__legend-has", ctx.hasLegend)("g2-pie__legend-block", ctx.block)("g2-pie__mini", ctx.isPercent);
    }
  },
  inputs: {
    animate: "animate",
    color: "color",
    subTitle: "subTitle",
    total: "total",
    height: "height",
    hasLegend: "hasLegend",
    inner: "inner",
    padding: "padding",
    percent: "percent",
    tooltip: "tooltip",
    lineWidth: "lineWidth",
    blockMaxWidth: "blockMaxWidth",
    select: "select",
    valueFormat: "valueFormat",
    data: "data",
    colors: "colors",
    interaction: "interaction",
    ratio: "ratio"
  },
  outputs: {
    clickItem: "clickItem"
  },
  exportAs: ["g2Pie"],
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 6,
  vars: 3,
  consts: [[1, "g2-pie__chart"], ["container", ""], ["class", "g2-pie__total"], ["class", "g2-pie__legend"], [1, "g2-pie__total"], ["class", "g2-pie__total-title"], ["class", "g2-pie__total-stat"], [1, "g2-pie__total-title"], [4, "nzStringTemplateOutlet"], [3, "innerHTML"], [1, "g2-pie__total-stat"], [1, "g2-pie__legend"], [1, "g2-pie__legend-item", 3, "click"], [1, "g2-pie__legend-dot", 3, "ngStyle"], [1, "g2-pie__legend-title"], ["nzType", "vertical"], [1, "g2-pie__legend-percent"], [1, "g2-pie__legend-value", 3, "innerHTML"], ["class", "g2-pie__legend-item"]],
  template: function G2PieComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, G2PieComponent_Conditional_0_Template, 1, 0, "nz-skeleton");
      \u0275\u0275elementStart(1, "div", 0);
      \u0275\u0275element(2, "div", null, 1);
      \u0275\u0275template(4, G2PieComponent_Conditional_4_Template, 3, 2, "div", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275template(5, G2PieComponent_Conditional_5_Template, 3, 0, "ul", 3);
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, !ctx.loaded ? 0 : -1);
      \u0275\u0275advance(4);
      \u0275\u0275conditional(4, ctx.subTitle || ctx.total ? 4 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(5, ctx.hasLegend && ctx.legendData.length > 0 ? 5 : -1);
    }
  },
  dependencies: [NgStyle, NzDividerComponent, NzStringTemplateOutletDirective, NzSkeletonComponent],
  encapsulation: 2,
  changeDetection: 0
});
var G2PieComponent = _G2PieComponent;
__decorate([InputBoolean2()], G2PieComponent.prototype, "animate", void 0);
__decorate([InputNumber2()], G2PieComponent.prototype, "height", void 0);
__decorate([InputBoolean2()], G2PieComponent.prototype, "hasLegend", void 0);
__decorate([InputNumber2()], G2PieComponent.prototype, "percent", void 0);
__decorate([InputBoolean2()], G2PieComponent.prototype, "tooltip", void 0);
__decorate([InputNumber2()], G2PieComponent.prototype, "lineWidth", void 0);
__decorate([InputNumber2()], G2PieComponent.prototype, "blockMaxWidth", void 0);
__decorate([InputBoolean2()], G2PieComponent.prototype, "select", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2PieComponent, [{
    type: Component,
    args: [{
      selector: "g2-pie",
      exportAs: "g2Pie",
      host: {
        "[class.g2-pie]": "true",
        "[class.g2-pie__legend-has]": "hasLegend",
        "[class.g2-pie__legend-block]": "block",
        "[class.g2-pie__mini]": "isPercent"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `@if (!loaded) {
  <nz-skeleton />
}
<div class="g2-pie__chart">
  <div #container></div>
  @if (subTitle || total) {
    <div class="g2-pie__total">
      @if (subTitle) {
        <h4 class="g2-pie__total-title">
          <ng-container *nzStringTemplateOutlet="subTitle">
            <div [innerHTML]="subTitle"></div>
          </ng-container>
        </h4>
      }
      @if (total) {
        <div class="g2-pie__total-stat">
          <ng-container *nzStringTemplateOutlet="total">
            <div [innerHTML]="total"></div>
          </ng-container>
        </div>
      }
    </div>
  }
</div>
@if (hasLegend && legendData.length > 0) {
  <ul class="g2-pie__legend">
    @for (item of legendData; track $index) {
      <li (click)="_click($index)" class="g2-pie__legend-item">
        <span class="g2-pie__legend-dot" [ngStyle]="{ 'background-color': !item.checked ? '#aaa' : item.color }"></span>
        <span class="g2-pie__legend-title">{{ item.x }}</span>
        <nz-divider nzType="vertical" />
        <span class="g2-pie__legend-percent">{{ item.percent }}%</span>
        <span class="g2-pie__legend-value" [innerHTML]="valueFormat ? valueFormat(item.y) : item.y"></span>
      </li>
    }
  </ul>
}
`
    }]
  }], null, {
    animate: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    subTitle: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    hasLegend: [{
      type: Input
    }],
    inner: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    percent: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }],
    lineWidth: [{
      type: Input
    }],
    blockMaxWidth: [{
      type: Input
    }],
    select: [{
      type: Input
    }],
    valueFormat: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    interaction: [{
      type: Input
    }],
    ratio: [{
      type: Input
    }],
    clickItem: [{
      type: Output
    }]
  });
})();
var COMPONENTS19 = [G2PieComponent];
var _G2PieModule = class _G2PieModule {
};
_G2PieModule.\u0275fac = function G2PieModule_Factory(t) {
  return new (t || _G2PieModule)();
};
_G2PieModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _G2PieModule
});
_G2PieModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzDividerModule, NzOutletModule, NzSkeletonModule]
});
var G2PieModule = _G2PieModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(G2PieModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzDividerModule, NzOutletModule, NzSkeletonModule],
      declarations: COMPONENTS19,
      exports: COMPONENTS19
    }]
  }], null, null);
})();

// src/app/routes/pages/machines/charts/pie.component.ts
var _c053 = ["pie"];
var _ChartPieBasicComponent3 = class _ChartPieBasicComponent3 {
  constructor(msg) {
    this.msg = msg;
    this.salesPieData = [];
    this.total = "";
    this.refresh();
  }
  refresh() {
    const rv = (min = 0, max = 5e3) => Math.floor(Math.random() * (max - min + 1) + min);
    this.salesPieData = [
      {
        x: "on",
        y: 70
      },
      {
        x: "of",
        y: 30
      }
    ];
    this.total = `70 %`;
    if (this.pie) {
      setTimeout(() => this.pie.changeData());
    }
  }
  format(val) {
    return `&yen ${val.toFixed(2)}`;
  }
  handleClick(data) {
    this.msg.info(`${data.item.x} - ${data.item.y}`);
  }
};
_ChartPieBasicComponent3.\u0275fac = function ChartPieBasicComponent_Factory(t) {
  return new (t || _ChartPieBasicComponent3)(\u0275\u0275directiveInject(NzMessageService));
};
_ChartPieBasicComponent3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartPieBasicComponent3, selectors: [["chart-pie-basic"]], viewQuery: function ChartPieBasicComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c053, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.pie = _t.first);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 3, consts: [["title", "ON/OFF", "subTitle", "ON/OFF", "height", "200", "repaint", "false", 3, "total", "valueFormat", "data", "clickItem"], ["pie", ""]], template: function ChartPieBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-pie", 0, 1);
    \u0275\u0275listener("clickItem", function ChartPieBasicComponent_Template_g2_pie_clickItem_0_listener($event) {
      return ctx.handleClick($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("total", ctx.total)("valueFormat", ctx.format)("data", ctx.salesPieData);
  }
}, dependencies: [NzButtonModule, G2PieModule, G2PieComponent], encapsulation: 2 });
var ChartPieBasicComponent3 = _ChartPieBasicComponent3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartPieBasicComponent3, { className: "ChartPieBasicComponent", filePath: "src\\app\\routes\\pages\\machines\\charts\\pie.component.ts", lineNumber: 25 });
})();

// src/app/routes/pages/machines/charts/rate.component.ts
function ChartCardStyle1Component_ng_template_1_Template3(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 4);
  }
}
var _ChartCardStyle1Component3 = class _ChartCardStyle1Component3 {
};
_ChartCardStyle1Component3.\u0275fac = function ChartCardStyle1Component_Factory(t) {
  return new (t || _ChartCardStyle1Component3)();
};
_ChartCardStyle1Component3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartCardStyle1Component3, selectors: [["chart-card-style1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 9, vars: 4, consts: [["footer", "\u65E5\u8BBF\u95EE\u91CF 12,423", "contentHeight", "46", 3, "title", "bordered", "total", "action"], ["action", ""], ["flag", "up", 2, "margin", "0 16px 0 8px", "color", "rgba(0,0,0,.85)"], ["flag", "down", 2, "margin", "0 0 0 8px", "color", "rgba(0,0,0,.85)"], ["nz-tooltip", "", "nzTooltipTitle", "\u6307\u6807\u8BF4\u660E", "nz-icon", "", "nzType", "info-circle"]], template: function ChartCardStyle1Component_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-card", 0);
    \u0275\u0275template(1, ChartCardStyle1Component_ng_template_1_Template3, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275text(3, " \u5468\u540C\u6BD4 ");
    \u0275\u0275elementStart(4, "trend", 2);
    \u0275\u0275text(5, "12%");
    \u0275\u0275elementEnd();
    \u0275\u0275text(6, " \u65E5\u73AF\u6BD4 ");
    \u0275\u0275elementStart(7, "trend", 3);
    \u0275\u0275text(8, "11%");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("title", "\u9500\u552E\u989D")("bordered", true)("total", "\xA5 126,560.00")("action", _r1);
  }
}, dependencies: [G2CardModule, G2CardComponent, NzToolTipModule, NzTooltipDirective, TrendModule, TrendComponent], encapsulation: 2 });
var ChartCardStyle1Component3 = _ChartCardStyle1Component3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartCardStyle1Component3, { className: "ChartCardStyle1Component", filePath: "src\\app\\routes\\pages\\machines\\charts\\rate.component.ts", lineNumber: 23 });
})();

// src/app/routes/pages/machines/components/info.ts
var _NzDemoDescriptionsVerticalBorderComponent = class _NzDemoDescriptionsVerticalBorderComponent {
};
_NzDemoDescriptionsVerticalBorderComponent.\u0275fac = function NzDemoDescriptionsVerticalBorderComponent_Factory(t) {
  return new (t || _NzDemoDescriptionsVerticalBorderComponent)();
};
_NzDemoDescriptionsVerticalBorderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoDescriptionsVerticalBorderComponent, selectors: [["nz-demo-descriptions-vertical-border"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 19, vars: 2, consts: [["nzTitle", "User Info", "nzBordered", ""], ["nzTitle", "Last Maintenance"], ["nzTitle", "Next Maintenance"], ["nzTitle", "Working Hours"], ["nzTitle", "Working Hours Since the last Maintenance"], ["nzTitle", "Performance", 3, "nzSpan"], ["nzTitle", "Stops Count", 3, "nzSpan"], ["nzStatus", "processing", "nzText", "Running"], ["nzTitle", "Expected Downtime"], ["nzTitle", "Temperature"], ["nzTitle", "Pressure "]], template: function NzDemoDescriptionsVerticalBorderComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-descriptions", 0)(1, "nz-descriptions-item", 1);
    \u0275\u0275text(2, "Cloud Database");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-descriptions-item", 2);
    \u0275\u0275text(4, "Prepaid");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "nz-descriptions-item", 3);
    \u0275\u0275text(6, "YES");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "nz-descriptions-item", 4);
    \u0275\u0275text(8, "2018-04-24 18:00:00");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "nz-descriptions-item", 5);
    \u0275\u0275text(10, " 2018-04-24 18:00:00 To 2019-04-24 18:00:00 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "nz-descriptions-item", 6);
    \u0275\u0275element(12, "nz-badge", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "nz-descriptions-item", 8);
    \u0275\u0275text(14, "$80.00");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "nz-descriptions-item", 9);
    \u0275\u0275text(16, "$20.00");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "nz-descriptions-item", 10);
    \u0275\u0275text(18, "$60.00");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(9);
    \u0275\u0275property("nzSpan", 2);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzSpan", 3);
  }
}, dependencies: [NzDescriptionsModule, NzDescriptionsComponent, NzDescriptionsItemComponent, NzBadgeModule, NzBadgeComponent], encapsulation: 2 });
var NzDemoDescriptionsVerticalBorderComponent = _NzDemoDescriptionsVerticalBorderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoDescriptionsVerticalBorderComponent, { className: "NzDemoDescriptionsVerticalBorderComponent", filePath: "src\\app\\routes\\pages\\machines\\components\\info.ts", lineNumber: 26 });
})();

// src/app/routes/pages/machines/components/table.ts
function NzDemoTableRowSelectionCustomComponent_tr_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.value, " ");
  }
}
var _NzDemoTableRowSelectionCustomComponent4 = class _NzDemoTableRowSelectionCustomComponent4 {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = [
      { name: "Stage", value: "Stage 1" },
      { name: "Machine", value: "Machine 1" },
      { name: "Last Maintenance", value: (/* @__PURE__ */ new Date()).toLocaleString() },
      { name: "Next Maintenance", value: (/* @__PURE__ */ new Date()).toLocaleString() },
      { name: "Energy Consumption", value: "250 kWh" },
      { name: "Gas Consumption", value: "50 kg" },
      { name: "Water Consumption", value: "25 m3" },
      { name: "Max Temperature", value: "45 'C" },
      { name: "Max Vibration", value: "Ips" },
      { name: "Time Stamp", value: (/* @__PURE__ */ new Date()).toLocaleString() }
    ];
  }
};
_NzDemoTableRowSelectionCustomComponent4.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent4)();
};
_NzDemoTableRowSelectionCustomComponent4.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent4, selectors: [["nz-demo-table-row-selection-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 10, vars: 3, consts: [[3, "nzData", "nzShowPagination"], ["rowSelectionTable", ""], [4, "ngFor", "ngForOf"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1)(2, "thead")(3, "tr")(4, "th");
    \u0275\u0275text(5, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "th");
    \u0275\u0275text(7, "Value");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(8, "tbody");
    \u0275\u0275template(9, NzDemoTableRowSelectionCustomComponent_tr_9_Template, 5, 2, "tr", 2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzShowPagination", false);
    \u0275\u0275advance(9);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTheadComponent, NzTbodyComponent, NzTrDirective, CommonModule, NgForOf, NzAvatarModule, NzBadgeModule], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent4 = _NzDemoTableRowSelectionCustomComponent4;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent4, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\pages\\machines\\components\\table.ts", lineNumber: 51 });
})();

// src/app/routes/pages/machines/components/model.ts
function NzDemoModalBasicComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementContainerEnd();
  }
}
var _c054 = ["*"];
var _NzDemoModalBasicComponent2 = class _NzDemoModalBasicComponent2 {
  constructor() {
    this.isVisible = false;
  }
  showModal() {
    this.isVisible = true;
  }
  handleOk() {
    console.log("Button ok clicked!");
    this.isVisible = false;
  }
  handleCancel() {
    console.log("Button cancel clicked!");
    this.isVisible = false;
  }
};
_NzDemoModalBasicComponent2.\u0275fac = function NzDemoModalBasicComponent_Factory(t) {
  return new (t || _NzDemoModalBasicComponent2)();
};
_NzDemoModalBasicComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoModalBasicComponent2, selectors: [["nz-demo-modal-basic"]], standalone: true, features: [\u0275\u0275StandaloneFeature], ngContentSelectors: _c054, decls: 4, vars: 1, consts: [[2, "cursor", "pointer", 3, "click"], ["nzTitle", "Vehicle Details", 3, "nzVisible", "nzVisibleChange", "nzOnCancel", "nzOnOk"], [4, "nzModalContent"]], template: function NzDemoModalBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projectionDef();
    \u0275\u0275elementStart(0, "span", 0);
    \u0275\u0275listener("click", function NzDemoModalBasicComponent_Template_span_click_0_listener() {
      return ctx.showModal();
    });
    \u0275\u0275projection(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "nz-modal", 1);
    \u0275\u0275listener("nzVisibleChange", function NzDemoModalBasicComponent_Template_nz_modal_nzVisibleChange_2_listener($event) {
      return ctx.isVisible = $event;
    })("nzOnCancel", function NzDemoModalBasicComponent_Template_nz_modal_nzOnCancel_2_listener() {
      return ctx.handleCancel();
    })("nzOnOk", function NzDemoModalBasicComponent_Template_nz_modal_nzOnOk_2_listener() {
      return ctx.handleOk();
    });
    \u0275\u0275template(3, NzDemoModalBasicComponent_ng_container_3_Template, 2, 0, "ng-container", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275property("nzVisible", ctx.isVisible);
  }
}, dependencies: [NzModalModule, NzModalComponent, NzModalContentDirective, CommonModule, NzIconModule, NzDemoTableRowSelectionCustomComponent4], encapsulation: 2 });
var NzDemoModalBasicComponent2 = _NzDemoModalBasicComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoModalBasicComponent2, { className: "NzDemoModalBasicComponent", filePath: "src\\app\\routes\\pages\\machines\\components\\model.ts", lineNumber: 24 });
})();

// src/app/routes/pages/machines/components/p.component.ts
var _NzDemoCardSimpleComponent2 = class _NzDemoCardSimpleComponent2 {
};
_NzDemoCardSimpleComponent2.\u0275fac = function NzDemoCardSimpleComponent_Factory(t) {
  return new (t || _NzDemoCardSimpleComponent2)();
};
_NzDemoCardSimpleComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoCardSimpleComponent2, selectors: [["nz-demo-card-simple"]], inputs: { Text: "Text", id: "id", load: "load" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 13, vars: 6, consts: [[2, "margin", "auto", "text-align", "center"], [3, "nzGap", "nzText", "nzSize"], [2, "text-align", "center", "width", "100%"]], template: function NzDemoCardSimpleComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "nz-demo-modal-basic");
    \u0275\u0275element(2, "nz-avatar", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-card", 2)(4, "p");
    \u0275\u0275text(5, "Temp.");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "p");
    \u0275\u0275text(7, "25\xB0C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(8, "nz-divider");
    \u0275\u0275elementStart(9, "p");
    \u0275\u0275text(10, "Vibration");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "p");
    \u0275\u0275text(12, " 12 IPS");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275styleMapInterpolate1("margin-bottom: 20px; color:#fff; background-color:", ctx.id.toString().includes("1") ? "#ee4035" : "	#7bc043", "; ");
    \u0275\u0275property("nzGap", 2)("nzText", ctx.Text)("nzSize", "large");
  }
}, dependencies: [NzCardComponent, NzAvatarModule, NzAvatarComponent, NzDividerModule, NzDividerComponent, NzDemoModalBasicComponent2], styles: ["\n\np[_ngcontent-%COMP%] {\n  margin: 0;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsicC5jb21wb25lbnQudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIlxuICAgICAgcCB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxVQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoCardSimpleComponent2 = _NzDemoCardSimpleComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoCardSimpleComponent2, { className: "NzDemoCardSimpleComponent", filePath: "src\\app\\routes\\pages\\machines\\components\\p.component.ts", lineNumber: 41 });
})();

// src/app/routes/pages/machines/components/select.ts
function NzDemoSelectSearchComponent_nz_option_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-option", 2);
  }
  if (rf & 2) {
    const option_r1 = ctx.$implicit;
    \u0275\u0275property("nzLabel", option_r1.label)("nzValue", option_r1.value);
  }
}
var _NzDemoSelectSearchComponent4 = class _NzDemoSelectSearchComponent4 {
  constructor() {
    this.nzPlaceHolder = "";
    this.selectedValueT = new EventEmitter();
    this.selectedValue = null;
    this.options = [
      { label: "test-1", value: "test-1" },
      { label: "test-2", value: "test-2" },
      { label: "test-3", value: "test-3" }
    ];
  }
  onSelectedValueChange() {
    this.selectedValueT.emit(this.selectedValue);
  }
};
_NzDemoSelectSearchComponent4.\u0275fac = function NzDemoSelectSearchComponent_Factory(t) {
  return new (t || _NzDemoSelectSearchComponent4)();
};
_NzDemoSelectSearchComponent4.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoSelectSearchComponent4, selectors: [["nz-demo-select-search"]], inputs: { nzPlaceHolder: "nzPlaceHolder" }, outputs: { selectedValueT: "selectedValueT" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 3, consts: [["nzShowSearch", "", "nzAllowClear", "", 2, "width", "100%", 3, "nzPlaceHolder", "ngModel", "ngModelChange"], [3, "nzLabel", "nzValue", 4, "ngFor", "ngForOf"], [3, "nzLabel", "nzValue"]], template: function NzDemoSelectSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener($event) {
      return ctx.selectedValue = $event;
    })("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener() {
      return ctx.onSelectedValueChange();
    });
    \u0275\u0275template(1, NzDemoSelectSearchComponent_nz_option_1_Template, 1, 2, "nz-option", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPlaceHolder", ctx.nzPlaceHolder)("ngModel", ctx.selectedValue);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngForOf", ctx.options);
  }
}, dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, FormsModule, NgControlStatus, NgModel, CommonModule, NgForOf], styles: ["\n\nnz-select[_ngcontent-%COMP%] {\n  width: 200px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2VsZWN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIG56LXNlbGVjdCB7XG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxTQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoSelectSearchComponent4 = _NzDemoSelectSearchComponent4;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoSelectSearchComponent4, { className: "NzDemoSelectSearchComponent", filePath: "src\\app\\routes\\pages\\machines\\components\\select.ts", lineNumber: 31 });
})();

// src/app/routes/pages/machines/machine.component.ts
function MachineComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 16);
    \u0275\u0275element(1, "span", 17);
    \u0275\u0275elementEnd();
  }
}
function MachineComponent_Conditional_24_Conditional_3_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275element(1, "nz-demo-card-simple", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r8 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("Text", item_r8.Text)("id", item_r8.id);
  }
}
function MachineComponent_Conditional_24_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, MachineComponent_Conditional_24_Conditional_3_div_0_Template, 2, 2, "div", 20);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngForOf", ctx_r5.listOfData);
  }
}
function MachineComponent_Conditional_24_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22);
    \u0275\u0275element(1, "nz-spin", 23);
    \u0275\u0275elementEnd();
  }
}
function MachineComponent_Conditional_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14)(1, "nz-card", 18)(2, "div", 1);
    \u0275\u0275template(3, MachineComponent_Conditional_24_Conditional_3_Template, 1, 1, "div", 19);
    \u0275\u0275pipe(4, "async");
    \u0275\u0275template(5, MachineComponent_Conditional_24_Conditional_5_Template, 2, 0);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Machines State");
    \u0275\u0275advance(2);
    \u0275\u0275conditional(3, \u0275\u0275pipeBind1(4, 3, ctx_r2.load) ? 3 : 5);
  }
}
function MachineComponent_ng_template_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Sales Statistics ");
    \u0275\u0275elementStart(1, "small", 24);
    \u0275\u0275text(2, "Business Expectations & Retail Sales Statistics");
    \u0275\u0275elementEnd();
  }
}
var _MachineComponent = class _MachineComponent {
  constructor() {
    this.http = inject(_HttpClient);
    this.cdr = inject(ChangeDetectorRef);
    this.obSrv = inject(OnboardingService);
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  GetValue(e) {
    if (e) {
      this.e = e;
      this.load = of(true).pipe(delay(2e3));
    } else {
      this.load = of(false);
      this.e = null;
    }
  }
  ngOnInit() {
    this.listOfData = new Array(15).fill(0).map((_, index) => ({
      Text: `M${index + 1}`,
      id: index
    }));
    setTimeout(() => {
    }, 1e3);
  }
};
_MachineComponent.\u0275fac = function MachineComponent_Factory(t) {
  return new (t || _MachineComponent)();
};
_MachineComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _MachineComponent, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 27, vars: 5, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "6", 1, "mb-md", 2, "width", "auto"], [3, "nzPlaceHolder", "selectedValueT"], [3, "nzPlaceHolder"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "12", 1, "mb-md"], ["nzSearch", "", 2, "width", "100%", 3, "nzAddOnAfter"], ["type", "text", "nz-input", "", "placeholder", "input search text"], ["suffixIconButton", ""], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "24", 1, "mb-md"], [3, "nzTitle"], ["nzText", "Message-1", "nzColor", "red"], ["nzTitle", "Pushes open the window", "nzSize", "small"], ["nzText", "Message-2", "nzColor", "green"], ["nz-col", "", "nzXs", "24", "nzMd", "24"], ["salesTitle", ""], ["nz-button", "", "nzType", "primary", "nzSearch", ""], ["nz-icon", "", "nzType", "search"], [3, "nzBordered", "nzTitle"], ["nz-col", "", "nzXs", "24", "nzMd", "4"], ["nz-col", "", "nzXs", "24", "nzMd", "4", 4, "ngFor", "ngForOf"], [3, "Text", "id"], [1, "example"], ["nzSimple", ""], [1, "text-sm", "font-weight-normal"]], template: function MachineComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Machines ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2)(7, "nz-demo-select-search", 3);
    \u0275\u0275listener("selectedValueT", function MachineComponent_Template_nz_demo_select_search_selectedValueT_7_listener($event) {
      return ctx.GetValue($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "div", 2);
    \u0275\u0275element(9, "nz-demo-select-search", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 5)(11, "nz-input-group", 6);
    \u0275\u0275element(12, "input", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275template(13, MachineComponent_ng_template_13_Template, 2, 0, "ng-template", null, 8, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(15, "div", 1)(16, "div", 9)(17, "nz-card", 10)(18, "nz-ribbon", 11)(19, "nz-card", 12);
    \u0275\u0275text(20, " And raises the spyglass. ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(21, "nz-ribbon", 13)(22, "nz-card", 12);
    \u0275\u0275text(23, " And raises the spyglass. ");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275template(24, MachineComponent_Conditional_24_Template, 6, 5, "div", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275template(25, MachineComponent_ng_template_25_Template, 3, 0, "ng-template", null, 15, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(14);
    \u0275\u0275advance(7);
    \u0275\u0275property("nzPlaceHolder", "Stage");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzPlaceHolder", "Machine");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzAddOnAfter", _r1);
    \u0275\u0275advance(6);
    \u0275\u0275property("nzTitle", "Messages");
    \u0275\u0275advance(7);
    \u0275\u0275conditional(24, ctx.e ? 24 : -1);
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzButtonComponent,
  NzTransitionPatchDirective,
  NzWaveDirective,
  NzInputModule,
  NzInputDirective,
  NzInputGroupComponent,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzIconDirective,
  NzCheckboxModule,
  NzSpinModule,
  NzSpinComponent,
  G2TimelineModule,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  OnboardingModule,
  NzDemoSelectSearchComponent4,
  NzStatisticModule,
  CommonModule,
  NgForOf,
  AsyncPipe,
  NzDescriptionsModule,
  NzBadgeModule,
  NzRibbonComponent,
  NzDemoCardSimpleComponent2
], styles: ["\n\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzb3VyY2VzQ29udGVudCI6IFtdLAogICJtYXBwaW5ncyI6ICIiLAogICJuYW1lcyI6IFtdCn0K */"], changeDetection: 0 });
var MachineComponent = _MachineComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(MachineComponent, { className: "MachineComponent", filePath: "src\\app\\routes\\pages\\machines\\machine.component.ts", lineNumber: 53 });
})();

// src/app/routes/pages/maintenance/charts/bar.component.ts
var _ChartBarBasicComponent = class _ChartBarBasicComponent {
  constructor() {
    this.msg = inject(NzMessageService);
    this.salesData = this.genData();
  }
  genData() {
    return [
      {
        x: `Power`,
        y: 100
      },
      {
        x: `Gas `,
        y: 80
      },
      {
        x: `Water `,
        y: 90
      },
      {
        x: `Max Temp`,
        y: 70
      },
      {
        x: `Max Vibration`,
        y: 95
      }
    ];
  }
  refresh() {
    this.salesData = this.genData();
  }
  handleClick(data) {
    this.msg.info(`${data.item.x} - ${data.item.y}`);
  }
};
_ChartBarBasicComponent.\u0275fac = function ChartBarBasicComponent_Factory(t) {
  return new (t || _ChartBarBasicComponent)();
};
_ChartBarBasicComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartBarBasicComponent, selectors: [["chart-bar-basic"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 2, consts: [["height", "200", 3, "title", "data", "clickItem"]], template: function ChartBarBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-bar", 0);
    \u0275\u0275listener("clickItem", function ChartBarBasicComponent_Template_g2_bar_clickItem_0_listener($event) {
      return ctx.handleClick($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("title", "bar")("data", ctx.salesData);
  }
}, dependencies: [NzButtonModule, G2BarModule, G2BarComponent], encapsulation: 2 });
var ChartBarBasicComponent = _ChartBarBasicComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartBarBasicComponent, { className: "ChartBarBasicComponent", filePath: "src\\app\\routes\\pages\\maintenance\\charts\\bar.component.ts", lineNumber: 16 });
})();

// src/app/routes/pages/maintenance/charts/chart.component.ts
var _c055 = ["chart"];
var _LineChartComponent2 = class _LineChartComponent2 {
  ngOnInit() {
    this.chartOptions = this.salesPieData;
  }
};
_LineChartComponent2.\u0275fac = function LineChartComponent_Factory(t) {
  return new (t || _LineChartComponent2)();
};
_LineChartComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LineChartComponent2, selectors: [["chart-chart-echarts-on"]], viewQuery: function LineChartComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c055, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chart = _t.first);
  }
}, inputs: { salesPieData: "salesPieData" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 7, consts: [["id", "chart"], [3, "series", "chart", "xaxis", "dataLabels", "grid", "stroke", "title"]], template: function LineChartComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "apx-chart", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275property("series", ctx.chartOptions == null ? null : ctx.chartOptions.series)("chart", ctx.chartOptions == null ? null : ctx.chartOptions.chart)("xaxis", ctx.chartOptions == null ? null : ctx.chartOptions.xaxis)("dataLabels", ctx.chartOptions == null ? null : ctx.chartOptions.dataLabels)("grid", ctx.chartOptions == null ? null : ctx.chartOptions.grid)("stroke", ctx.chartOptions == null ? null : ctx.chartOptions.stroke)("title", ctx.chartOptions == null ? null : ctx.chartOptions.title);
  }
}, dependencies: [CommonModule, NgApexchartsModule, ChartComponent], encapsulation: 2 });
var LineChartComponent2 = _LineChartComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LineChartComponent2, { className: "LineChartComponent", filePath: "src\\app\\routes\\pages\\maintenance\\charts\\chart.component.ts", lineNumber: 42 });
})();

// src/app/routes/pages/maintenance/charts/guge.component.ts
var _ChartGaugeBasicComponent2 = class _ChartGaugeBasicComponent2 {
  constructor(platform, cdr) {
    this.percent = 36;
    this.color = "#2f9cff";
    this.title = "";
    if (!platform.isBrowser)
      return;
    this.time$ = setInterval(() => {
      this.percent = parseInt((Math.random() * 100).toString(), 10);
      this.color = this.percent > 50 ? "#f50" : "#2f9cff";
      cdr.detectChanges();
    }, 1e3);
  }
  ngOnDestroy() {
    clearInterval(this.time$);
  }
};
_ChartGaugeBasicComponent2.\u0275fac = function ChartGaugeBasicComponent_Factory(t) {
  return new (t || _ChartGaugeBasicComponent2)(\u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_ChartGaugeBasicComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartGaugeBasicComponent2, selectors: [["chart-gauge-basic"]], inputs: { title: "title" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 3, consts: [["height", "200", 3, "title", "percent", "color"]], template: function ChartGaugeBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "g2-gauge", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("title", ctx.title)("percent", ctx.percent)("color", ctx.color);
  }
}, dependencies: [G2GaugeModule, G2GaugeComponent], encapsulation: 2, changeDetection: 0 });
var ChartGaugeBasicComponent2 = _ChartGaugeBasicComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartGaugeBasicComponent2, { className: "ChartGaugeBasicComponent", filePath: "src\\app\\routes\\pages\\maintenance\\charts\\guge.component.ts", lineNumber: 14 });
})();

// src/app/routes/pages/maintenance/charts/pie.component.ts
var _c056 = ["pie"];
var _ChartPieBasicComponent4 = class _ChartPieBasicComponent4 {
  constructor(msg) {
    this.msg = msg;
    this.salesPieData = [];
    this.total = "";
    this.refresh();
  }
  refresh() {
    const rv = (min = 0, max = 5e3) => Math.floor(Math.random() * (max - min + 1) + min);
    this.salesPieData = [
      {
        x: "data1",
        y: rv()
      },
      {
        x: "data2",
        y: rv()
      },
      {
        x: "data3",
        y: rv()
      },
      {
        x: "data4",
        y: rv()
      },
      {
        x: "data5",
        y: rv()
      }
    ];
    if (Math.random() > 0.5) {
      this.salesPieData.push({
        x: "data",
        y: rv()
      });
    }
    this.total = `&yen ${this.salesPieData.reduce((pre, now) => now.y + pre, 0).toFixed(2)}`;
    if (this.pie) {
      setTimeout(() => this.pie.changeData());
    }
  }
  format(val) {
    return `&yen ${val.toFixed(2)}`;
  }
  handleClick(data) {
    this.msg.info(`${data.item.x} - ${data.item.y}`);
  }
};
_ChartPieBasicComponent4.\u0275fac = function ChartPieBasicComponent_Factory(t) {
  return new (t || _ChartPieBasicComponent4)(\u0275\u0275directiveInject(NzMessageService));
};
_ChartPieBasicComponent4.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartPieBasicComponent4, selectors: [["chart-pie-basic"]], viewQuery: function ChartPieBasicComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c056, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.pie = _t.first);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 3, consts: [["title", "pie", "subTitle", "pie", "height", "400", "repaint", "false", 3, "total", "valueFormat", "data", "clickItem"], ["pie", ""]], template: function ChartPieBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-pie", 0, 1);
    \u0275\u0275listener("clickItem", function ChartPieBasicComponent_Template_g2_pie_clickItem_0_listener($event) {
      return ctx.handleClick($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("total", ctx.total)("valueFormat", ctx.format)("data", ctx.salesPieData);
  }
}, dependencies: [NzButtonModule, G2PieModule, G2PieComponent], encapsulation: 2 });
var ChartPieBasicComponent4 = _ChartPieBasicComponent4;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartPieBasicComponent4, { className: "ChartPieBasicComponent", filePath: "src\\app\\routes\\pages\\maintenance\\charts\\pie.component.ts", lineNumber: 25 });
})();

// src/app/routes/pages/maintenance/components/date.component.ts
var _NzDemoDatePickerPresettedRangesComponent2 = class _NzDemoDatePickerPresettedRangesComponent2 {
  constructor() {
    this.ranges = { Today: [/* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()], "This Month": [/* @__PURE__ */ new Date(), endOfMonth(/* @__PURE__ */ new Date())] };
  }
  onChange(result) {
    console.log("From: ", result[0], ", to: ", result[1]);
  }
};
_NzDemoDatePickerPresettedRangesComponent2.\u0275fac = function NzDemoDatePickerPresettedRangesComponent_Factory(t) {
  return new (t || _NzDemoDatePickerPresettedRangesComponent2)();
};
_NzDemoDatePickerPresettedRangesComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoDatePickerPresettedRangesComponent2, selectors: [["nz-demo-date-picker-presetted-ranges"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 1, consts: [["nzShowTime", "", "nzFormat", "yyyy/MM/dd HH:mm:ss", "ngModel", "", 3, "nzRanges"]], template: function NzDemoDatePickerPresettedRangesComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-range-picker", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("nzRanges", ctx.ranges);
  }
}, dependencies: [NzDatePickerModule, NzDatePickerComponent, NzRangePickerComponent], styles: ["\n\nnz-date-picker[_ngcontent-%COMP%], nz-range-picker[_ngcontent-%COMP%] {\n  margin: 0 8px 12px 0;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiZGF0ZS5jb21wb25lbnQudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIlxuICAgICAgbnotZGF0ZS1waWNrZXIsXG4gICAgICBuei1yYW5nZS1waWNrZXIge1xuICAgICAgICBtYXJnaW46IDAgOHB4IDEycHggMDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFBQTtBQUVFLFVBQUEsRUFBQSxJQUFBLEtBQUE7OyIsCiAgIm5hbWVzIjogW10KfQo= */"] });
var NzDemoDatePickerPresettedRangesComponent2 = _NzDemoDatePickerPresettedRangesComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoDatePickerPresettedRangesComponent2, { className: "NzDemoDatePickerPresettedRangesComponent", filePath: "src\\app\\routes\\pages\\maintenance\\components\\date.component.ts", lineNumber: 20 });
})();

// src/app/routes/pages/maintenance/components/select.ts
var _NzDemoSelectSearchComponent5 = class _NzDemoSelectSearchComponent5 {
  constructor() {
    this.selectedValue = null;
    this.nzPlaceHolder = "";
  }
};
_NzDemoSelectSearchComponent5.\u0275fac = function NzDemoSelectSearchComponent_Factory(t) {
  return new (t || _NzDemoSelectSearchComponent5)();
};
_NzDemoSelectSearchComponent5.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoSelectSearchComponent5, selectors: [["nz-demo-select-search"]], inputs: { nzPlaceHolder: "nzPlaceHolder" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 4, vars: 2, consts: [["nzShowSearch", "", "nzAllowClear", "", 2, "width", "100%", 3, "nzPlaceHolder", "ngModel", "ngModelChange"], ["nzLabel", "test-1", "nzValue", "test-1"], ["nzLabel", "test-2", "nzValue", "test-2"], ["nzLabel", "test-3", "nzValue", "test-3"]], template: function NzDemoSelectSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener($event) {
      return ctx.selectedValue = $event;
    });
    \u0275\u0275element(1, "nz-option", 1)(2, "nz-option", 2)(3, "nz-option", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPlaceHolder", ctx.nzPlaceHolder)("ngModel", ctx.selectedValue);
  }
}, dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, FormsModule, NgControlStatus, NgModel], styles: ["\n\nnz-select[_ngcontent-%COMP%] {\n  width: 200px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2VsZWN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIG56LXNlbGVjdCB7XG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxTQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoSelectSearchComponent5 = _NzDemoSelectSearchComponent5;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoSelectSearchComponent5, { className: "NzDemoSelectSearchComponent", filePath: "src\\app\\routes\\pages\\maintenance\\components\\select.ts", lineNumber: 25 });
})();

// src/app/routes/pages/maintenance/components/tab.ts
var _NzDemoTabsBasicComponent = class _NzDemoTabsBasicComponent {
  constructor() {
    this.Gas = {
      series: [
        {
          name: "Desktops",
          data: [10, 41, 35, 51, 49, 62, 69, 91, 148],
          color: "#ff91b2"
        }
      ],
      chart: {
        height: 350,
        type: "area",
        zoom: {
          enabled: false
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        curve: "straight"
      },
      title: {
        text: "Gas Trends by Month",
        align: "left"
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"],
          opacity: 0.5
        }
      },
      xaxis: {
        categories: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"]
      }
    };
    this.Water = {
      series: [
        {
          name: "Desktops",
          data: [10, 41, 35, 51, 49, 62, 69, 91, 148]
        }
      ],
      chart: {
        height: 350,
        type: "area",
        zoom: {
          enabled: false
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        curve: "straight"
      },
      title: {
        text: "Water Trends by Month",
        align: "left"
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"],
          opacity: 0.5
        }
      },
      xaxis: {
        categories: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"]
      }
    };
    this.Vibration = {
      series: [
        {
          name: "Desktops",
          data: [10, 41, 35, 51, 49, 62, 69, 91, 148],
          color: "#91e5d6"
        }
      ],
      chart: {
        height: 350,
        type: "area",
        zoom: {
          enabled: false
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        curve: "straight"
      },
      title: {
        text: "Vibration Trends by Month",
        align: "left"
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"],
          opacity: 0.5
        }
      },
      xaxis: {
        categories: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"]
      }
    };
    this.energy = {
      series: [
        {
          name: "Desktops",
          data: [10, 41, 35, 51, 49, 62, 69, 91, 148],
          color: "#fb5e5e"
        }
      ],
      chart: {
        height: 350,
        type: "area",
        zoom: {
          enabled: false
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        curve: "straight"
      },
      title: {
        text: "energy Trends by Month",
        align: "left"
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"],
          opacity: 0.5
        }
      },
      xaxis: {
        categories: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"]
      }
    };
    this.Temperature = {
      series: [
        {
          name: "Desktops",
          data: [10, 41, 35, 51, 49, 62, 69, 91, 148],
          color: "#ffc125"
        }
      ],
      chart: {
        height: 350,
        type: "area",
        zoom: {
          enabled: false
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        curve: "straight"
      },
      title: {
        text: "Temperature Trends by Month",
        align: "left"
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"],
          opacity: 0.5
        }
      },
      xaxis: {
        categories: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"]
      }
    };
  }
};
_NzDemoTabsBasicComponent.\u0275fac = function NzDemoTabsBasicComponent_Factory(t) {
  return new (t || _NzDemoTabsBasicComponent)();
};
_NzDemoTabsBasicComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTabsBasicComponent, selectors: [["nz-demo-tabs-basic"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 11, vars: 10, consts: [["nzTitle", "Gas", 3, "nzForceRender"], [3, "salesPieData"], ["nzTitle", "Water", 3, "nzForceRender"], ["nzTitle", "Vibration", 3, "nzForceRender"], ["nzTitle", "Energy", 3, "nzForceRender"], ["nzTitle", "Temperature", 3, "nzForceRender"]], template: function NzDemoTabsBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-tabset")(1, "nz-tab", 0);
    \u0275\u0275element(2, "chart-chart-echarts-on", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-tab", 2);
    \u0275\u0275element(4, "chart-chart-echarts-on", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "nz-tab", 3);
    \u0275\u0275element(6, "chart-chart-echarts-on", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "nz-tab", 4);
    \u0275\u0275element(8, "chart-chart-echarts-on", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "nz-tab", 5);
    \u0275\u0275element(10, "chart-chart-echarts-on", 1);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275property("nzForceRender", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.Gas);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzForceRender", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.Water);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzForceRender", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.Vibration);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzForceRender", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.energy);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzForceRender", true);
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.Temperature);
  }
}, dependencies: [CommonModule, NzTabsModule, NzTabSetComponent, NzTabComponent, LineChartComponent2], encapsulation: 2 });
var NzDemoTabsBasicComponent = _NzDemoTabsBasicComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTabsBasicComponent, { className: "NzDemoTabsBasicComponent", filePath: "src\\app\\routes\\pages\\maintenance\\components\\tab.ts", lineNumber: 23 });
})();

// src/app/routes/pages/maintenance/components/table.ts
function NzDemoTableRowSelectionCustomComponent_tr_20_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr")(1, "td", 4);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_tr_20_Template_td_nzCheckedChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r4);
      const data_r2 = restoredCtx.$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onItemChecked(data_r2.id, $event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "td");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "td");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "td");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "td");
    \u0275\u0275text(9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "td");
    \u0275\u0275text(11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "td");
    \u0275\u0275text(13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "td");
    \u0275\u0275element(15, "nz-badge", 5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzChecked", ctx_r1.setOfCheckedId.has(data_r2.id));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.Stage, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Machine);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Last);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Next);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Performance);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Grade);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzSize", "small")("nzColor", data_r2.id > 1 ? "green" : "red")("nzText", data_r2.recommendation);
  }
}
var _NzDemoTableRowSelectionCustomComponent5 = class _NzDemoTableRowSelectionCustomComponent5 {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
    this.pageSize = 5;
    this.pageIndex = 1;
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = new Array(200).fill(0).map((_, index) => ({
      id: index,
      Stage: `Stage  ${index + 1}`,
      Machine: `Machine ${index + 1}`,
      Last: (/* @__PURE__ */ new Date()).toLocaleString(),
      Next: (/* @__PURE__ */ new Date()).toLocaleString(),
      Performance: `${(Math.random() * 100).toFixed(0)}%`,
      Grade: "A",
      recommendation: index > 1 ? "No replacement needed" : "To be Replaced"
    }));
  }
};
_NzDemoTableRowSelectionCustomComponent5.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent5)();
};
_NzDemoTableRowSelectionCustomComponent5.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent5, selectors: [["nz-demo-table-row-selection-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 21, vars: 7, consts: [["nzShowSizeChanger", "", 3, "nzData", "nzPageSize", "nzPageIndex", "nzCurrentPageDataChange"], ["rowSelectionTable", ""], [3, "nzSelections", "nzChecked", "nzIndeterminate", "nzCheckedChange"], [4, "ngFor", "ngForOf"], [3, "nzChecked", "nzCheckedChange"], [3, "nzSize", "nzColor", "nzText"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1);
    \u0275\u0275listener("nzCurrentPageDataChange", function NzDemoTableRowSelectionCustomComponent_Template_nz_table_nzCurrentPageDataChange_0_listener($event) {
      return ctx.onCurrentPageDataChange($event);
    });
    \u0275\u0275elementStart(2, "thead")(3, "tr")(4, "th", 2);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.checked = $event;
    })("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.onAllChecked($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "th");
    \u0275\u0275text(6, "Stage");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "th");
    \u0275\u0275text(8, "Machine");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "th");
    \u0275\u0275text(10, "Last Maintenance");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "th");
    \u0275\u0275text(12, "Next Maintenance");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "th");
    \u0275\u0275text(14, "Performance");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "th");
    \u0275\u0275text(16, "Grade");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "th");
    \u0275\u0275text(18, "Recommendation");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(19, "tbody");
    \u0275\u0275template(20, NzDemoTableRowSelectionCustomComponent_tr_20_Template, 16, 10, "tr", 3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzPageSize", ctx.pageSize)("nzPageIndex", ctx.pageIndex);
    \u0275\u0275advance(4);
    \u0275\u0275property("nzSelections", ctx.listOfSelection)("nzChecked", ctx.checked)("nzIndeterminate", ctx.indeterminate);
    \u0275\u0275advance(16);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzThSelectionComponent, CommonModule, NgForOf, NzAvatarModule, NzBadgeModule, NzBadgeComponent], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent5 = _NzDemoTableRowSelectionCustomComponent5;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent5, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\pages\\maintenance\\components\\table.ts", lineNumber: 71 });
})();

// src/app/routes/pages/maintenance/maintenance.component.ts
var _MaintenanceComponent = class _MaintenanceComponent {
  constructor() {
    this.http = inject(_HttpClient);
    this.cdr = inject(ChangeDetectorRef);
    this.obSrv = inject(OnboardingService);
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
    this.line1 = {
      series: [
        {
          name: "Production ",
          data: [10, 41, 35, 51, 49, 62, 69, 91, 148]
        },
        {
          name: "Cost",
          data: [5, 30, 20, 45, 55, 77, 89, 99, 148]
        }
      ],
      chart: {
        height: 350,
        type: "area",
        zoom: {
          enabled: false
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        curve: "straight"
      },
      title: {
        text: "Product Trends by Month",
        align: "left"
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"],
          opacity: 0.5
        }
      },
      xaxis: {
        categories: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep"]
      }
    };
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  ngOnInit() {
    setTimeout(() => {
    }, 1e3);
  }
};
_MaintenanceComponent.\u0275fac = function MaintenanceComponent_Factory(t) {
  return new (t || _MaintenanceComponent)();
};
_MaintenanceComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _MaintenanceComponent, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 23, vars: 9, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "6", 1, "mb-md", 2, "width", "auto"], [3, "nzPlaceHolder"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "6", 1, "mb-md"], ["nz-col", "", "nzXs", "24", "nzMd", "24"], [3, "nzBordered", "nzTitle"], [3, "salesPieData"]], template: function MaintenanceComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Maintenance ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2);
    \u0275\u0275element(7, "nz-demo-select-search", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 4);
    \u0275\u0275element(9, "nz-demo-select-search", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 4);
    \u0275\u0275element(11, "nz-demo-date-picker-presetted-ranges");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(12, "div", 1)(13, "div", 5)(14, "nz-card", 6);
    \u0275\u0275element(15, "chart-chart-echarts-on", 7);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(16, "div", 1)(17, "div", 5)(18, "nz-card", 6);
    \u0275\u0275element(19, "nz-demo-tabs-basic");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(20, "div", 5)(21, "nz-card", 6);
    \u0275\u0275element(22, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(7);
    \u0275\u0275property("nzPlaceHolder", "Stage");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzPlaceHolder", "Machine");
    \u0275\u0275advance(5);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Production - Cost");
    \u0275\u0275advance(1);
    \u0275\u0275property("salesPieData", ctx.line1);
    \u0275\u0275advance(3);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Consumption");
    \u0275\u0275advance(3);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Machine Details");
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule,
  G2TimelineModule,
  LineChartComponent2,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  OnboardingModule,
  NzDemoTableRowSelectionCustomComponent5,
  NzDemoSelectSearchComponent5,
  NzDemoDatePickerPresettedRangesComponent2,
  NzDemoTabsBasicComponent
], encapsulation: 2, changeDetection: 0 });
var MaintenanceComponent = _MaintenanceComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(MaintenanceComponent, { className: "MaintenanceComponent", filePath: "src\\app\\routes\\pages\\maintenance\\maintenance.component.ts", lineNumber: 44 });
})();

// src/app/routes/pages/orders/components/Steps.component.ts
function NzDemoStepsIconComponent_ng_template_5_Template2(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 5);
  }
}
var _NzDemoStepsIconComponent2 = class _NzDemoStepsIconComponent2 {
};
_NzDemoStepsIconComponent2.\u0275fac = function NzDemoStepsIconComponent_Factory(t) {
  return new (t || _NzDemoStepsIconComponent2)();
};
_NzDemoStepsIconComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoStepsIconComponent2, selectors: [["nz-demo-steps-icon"]], inputs: { nzStatus: "nzStatus", icons: "icons" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 7, vars: 8, consts: [["nzTitle", "Order", 3, "nzStatus", "nzIcon"], ["nzTitle", "Preparation", 3, "nzStatus", "nzIcon"], ["nzTitle", "Shipping", 3, "nzStatus", "nzIcon"], ["nzTitle", "Done", 3, "nzStatus", "nzIcon"], ["iconTemplate", ""], ["nz-icon", "", "nzType", "check-circle"]], template: function NzDemoStepsIconComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-steps");
    \u0275\u0275element(1, "nz-step", 0)(2, "nz-step", 1)(3, "nz-step", 2)(4, "nz-step", 3);
    \u0275\u0275template(5, NzDemoStepsIconComponent_ng_template_5_Template2, 1, 0, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStatus", ctx.nzStatus == null ? null : ctx.nzStatus.step1)("nzIcon", ctx.icons.icon1);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStatus", ctx.nzStatus == null ? null : ctx.nzStatus.step2)("nzIcon", ctx.icons.icon2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStatus", ctx.nzStatus == null ? null : ctx.nzStatus.step3)("nzIcon", ctx.icons.icon3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStatus", ctx.nzStatus == null ? null : ctx.nzStatus.step4)("nzIcon", ctx.icons.icon4);
  }
}, dependencies: [NzStepsModule, NzStepsComponent, NzStepComponent], encapsulation: 2 });
var NzDemoStepsIconComponent2 = _NzDemoStepsIconComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoStepsIconComponent2, { className: "NzDemoStepsIconComponent", filePath: "src\\app\\routes\\pages\\orders\\components\\Steps.component.ts", lineNumber: 19 });
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-space.mjs
function NzSpaceComponent_ng_template_1_span_2_ng_template_1_Template(rf, ctx) {
}
var _c057 = (a0) => ({
  $implicit: a0
});
function NzSpaceComponent_ng_template_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 4);
    \u0275\u0275template(1, NzSpaceComponent_ng_template_1_span_2_ng_template_1_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext();
    const last_r2 = ctx_r6.last;
    const index_r3 = ctx_r6.index;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("margin-bottom", ctx_r4.nzDirection === "vertical" ? last_r2 ? null : ctx_r4.spaceSize : null, "px")("margin-right", ctx_r4.nzDirection === "horizontal" ? last_r2 ? null : ctx_r4.spaceSize : null, "px");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r4.nzSplit)("ngTemplateOutletContext", \u0275\u0275pureFunction1(6, _c057, index_r3));
  }
}
function NzSpaceComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275elementContainer(1, 2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, NzSpaceComponent_ng_template_1_span_2_Template, 2, 8, "span", 3);
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const last_r2 = ctx.last;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("margin-bottom", ctx_r0.nzDirection === "vertical" ? last_r2 ? null : ctx_r0.spaceSize : null, "px")("margin-right", ctx_r0.nzDirection === "horizontal" ? last_r2 ? null : ctx_r0.spaceSize : null, "px");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", item_r1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzSplit && !last_r2);
  }
}
var _c134 = ["*"];
var _NzSpaceItemDirective = class _NzSpaceItemDirective {
  constructor() {
  }
};
_NzSpaceItemDirective.\u0275fac = function NzSpaceItemDirective_Factory(t) {
  return new (t || _NzSpaceItemDirective)();
};
_NzSpaceItemDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzSpaceItemDirective,
  selectors: [["", "nzSpaceItem", ""]],
  standalone: true
});
var NzSpaceItemDirective = _NzSpaceItemDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSpaceItemDirective, [{
    type: Directive,
    args: [{
      selector: "[nzSpaceItem]",
      standalone: true
    }]
  }], () => [], null);
})();
var NZ_CONFIG_MODULE_NAME23 = "space";
var SPACE_SIZE = {
  small: 8,
  middle: 16,
  large: 24
};
var _NzSpaceComponent = class _NzSpaceComponent {
  constructor(nzConfigService, cdr) {
    this.nzConfigService = nzConfigService;
    this.cdr = cdr;
    this._nzModuleName = NZ_CONFIG_MODULE_NAME23;
    this.nzDirection = "horizontal";
    this.nzSplit = null;
    this.nzWrap = false;
    this.nzSize = "small";
    this.spaceSize = SPACE_SIZE.small;
    this.destroy$ = new Subject();
  }
  updateSpaceItems() {
    const numberSize = typeof this.nzSize === "string" ? SPACE_SIZE[this.nzSize] : this.nzSize;
    this.spaceSize = numberSize / (this.nzSplit ? 2 : 1);
    this.cdr.markForCheck();
  }
  ngOnChanges() {
    this.updateSpaceItems();
    this.mergedAlign = this.nzAlign === void 0 && this.nzDirection === "horizontal" ? "center" : this.nzAlign;
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  ngAfterContentInit() {
    this.updateSpaceItems();
    this.items.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.cdr.markForCheck();
    });
  }
};
_NzSpaceComponent.\u0275fac = function NzSpaceComponent_Factory(t) {
  return new (t || _NzSpaceComponent)(\u0275\u0275directiveInject(NzConfigService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_NzSpaceComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzSpaceComponent,
  selectors: [["nz-space"], ["", "nz-space", ""]],
  contentQueries: function NzSpaceComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzSpaceItemDirective, 4, TemplateRef);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.items = _t);
    }
  },
  hostAttrs: [1, "ant-space"],
  hostVars: 14,
  hostBindings: function NzSpaceComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275styleProp("flex-wrap", ctx.nzWrap ? "wrap" : null);
      \u0275\u0275classProp("ant-space-horizontal", ctx.nzDirection === "horizontal")("ant-space-vertical", ctx.nzDirection === "vertical")("ant-space-align-start", ctx.mergedAlign === "start")("ant-space-align-end", ctx.mergedAlign === "end")("ant-space-align-center", ctx.mergedAlign === "center")("ant-space-align-baseline", ctx.mergedAlign === "baseline");
    }
  },
  inputs: {
    nzDirection: "nzDirection",
    nzAlign: "nzAlign",
    nzSplit: "nzSplit",
    nzWrap: "nzWrap",
    nzSize: "nzSize"
  },
  exportAs: ["NzSpace"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c134,
  decls: 2,
  vars: 1,
  consts: [["ngFor", "", 3, "ngForOf"], [1, "ant-space-item"], [3, "ngTemplateOutlet"], ["class", "ant-space-split", 3, "margin-bottom", "margin-right", 4, "ngIf"], [1, "ant-space-split"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function NzSpaceComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
      \u0275\u0275template(1, NzSpaceComponent_ng_template_1_Template, 3, 6, "ng-template", 0);
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.items);
    }
  },
  dependencies: [NgTemplateOutlet, NgIf, NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var NzSpaceComponent = _NzSpaceComponent;
__decorate([InputBoolean()], NzSpaceComponent.prototype, "nzWrap", void 0);
__decorate([WithConfig()], NzSpaceComponent.prototype, "nzSize", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSpaceComponent, [{
    type: Component,
    args: [{
      selector: "nz-space, [nz-space]",
      exportAs: "NzSpace",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <ng-content></ng-content>
    <ng-template ngFor let-item let-last="last" let-index="index" [ngForOf]="items">
      <div
        class="ant-space-item"
        [style.margin-bottom.px]="nzDirection === 'vertical' ? (last ? null : spaceSize) : null"
        [style.margin-right.px]="nzDirection === 'horizontal' ? (last ? null : spaceSize) : null"
      >
        <ng-container [ngTemplateOutlet]="item"></ng-container>
      </div>
      <span
        *ngIf="nzSplit && !last"
        class="ant-space-split"
        [style.margin-bottom.px]="nzDirection === 'vertical' ? (last ? null : spaceSize) : null"
        [style.margin-right.px]="nzDirection === 'horizontal' ? (last ? null : spaceSize) : null"
      >
        <ng-template [ngTemplateOutlet]="nzSplit" [ngTemplateOutletContext]="{ $implicit: index }"></ng-template>
      </span>
    </ng-template>
  `,
      host: {
        class: "ant-space",
        "[class.ant-space-horizontal]": 'nzDirection === "horizontal"',
        "[class.ant-space-vertical]": 'nzDirection === "vertical"',
        "[class.ant-space-align-start]": 'mergedAlign === "start"',
        "[class.ant-space-align-end]": 'mergedAlign === "end"',
        "[class.ant-space-align-center]": 'mergedAlign === "center"',
        "[class.ant-space-align-baseline]": 'mergedAlign === "baseline"',
        "[style.flex-wrap]": 'nzWrap ? "wrap" : null'
      },
      imports: [NgTemplateOutlet, NgIf, NgForOf],
      standalone: true
    }]
  }], () => [{
    type: NzConfigService
  }, {
    type: ChangeDetectorRef
  }], {
    nzDirection: [{
      type: Input
    }],
    nzAlign: [{
      type: Input
    }],
    nzSplit: [{
      type: Input
    }],
    nzWrap: [{
      type: Input
    }],
    nzSize: [{
      type: Input
    }],
    items: [{
      type: ContentChildren,
      args: [NzSpaceItemDirective, {
        read: TemplateRef
      }]
    }]
  });
})();
var _NzSpaceModule = class _NzSpaceModule {
};
_NzSpaceModule.\u0275fac = function NzSpaceModule_Factory(t) {
  return new (t || _NzSpaceModule)();
};
_NzSpaceModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzSpaceModule
});
_NzSpaceModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NzSpaceModule = _NzSpaceModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzSpaceModule, [{
    type: NgModule,
    args: [{
      imports: [NzSpaceComponent, NzSpaceItemDirective],
      exports: [NzSpaceComponent, NzSpaceItemDirective]
    }]
  }], null, null);
})();

// src/app/routes/pages/orders/components/header.ts
function NzDemoPageHeaderGhostComponent_button_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 7);
    \u0275\u0275text(1, "All Orders");
    \u0275\u0275elementEnd();
  }
}
function NzDemoPageHeaderGhostComponent_button_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 8);
    \u0275\u0275text(1, "Active Orders");
    \u0275\u0275elementEnd();
  }
}
function NzDemoPageHeaderGhostComponent_button_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 8);
    \u0275\u0275text(1, "Closed Orders");
    \u0275\u0275elementEnd();
  }
}
var _NzDemoPageHeaderGhostComponent = class _NzDemoPageHeaderGhostComponent {
};
_NzDemoPageHeaderGhostComponent.\u0275fac = function NzDemoPageHeaderGhostComponent_Factory(t) {
  return new (t || _NzDemoPageHeaderGhostComponent)();
};
_NzDemoPageHeaderGhostComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoPageHeaderGhostComponent, selectors: [["nz-demo-page-header-ghost"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 13, vars: 3, consts: [["nzBackIcon", ""], ["nz-button", "", "nzType", "primary", 4, "nzSpaceItem"], ["nz-button", "", 4, "nzSpaceItem"], ["nzType", "flex"], ["nzTitle", "All Orders", 3, "nzValue"], ["nzTitle", "Active Orders", 2, "margin", "0 32px", 3, "nzValue"], ["nzTitle", "Closed Orders", 3, "nzValue"], ["nz-button", "", "nzType", "primary"], ["nz-button", ""]], template: function NzDemoPageHeaderGhostComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-page-header", 0)(1, "nz-page-header-title");
    \u0275\u0275text(2, "Orders Summary");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-page-header-extra")(4, "nz-space");
    \u0275\u0275template(5, NzDemoPageHeaderGhostComponent_button_5_Template, 2, 0, "button", 1)(6, NzDemoPageHeaderGhostComponent_button_6_Template, 2, 0, "button", 2)(7, NzDemoPageHeaderGhostComponent_button_7_Template, 2, 0, "button", 2);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "nz-page-header-content")(9, "nz-row", 3);
    \u0275\u0275element(10, "nz-statistic", 4)(11, "nz-statistic", 5)(12, "nz-statistic", 6);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(10);
    \u0275\u0275property("nzValue", 20);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzValue", 15);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzValue", 5);
  }
}, dependencies: [NzPageHeaderModule, NzPageHeaderComponent, NzPageHeaderTitleDirective, NzPageHeaderContentDirective, NzPageHeaderExtraDirective, NzButtonModule, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, NzSpaceModule, NzSpaceComponent, NzSpaceItemDirective, NzDescriptionsModule, NzTagModule, NzGridModule, NzRowDirective, NzStatisticModule, NzStatisticComponent], encapsulation: 2 });
var NzDemoPageHeaderGhostComponent = _NzDemoPageHeaderGhostComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoPageHeaderGhostComponent, { className: "NzDemoPageHeaderGhostComponent", filePath: "src\\app\\routes\\pages\\orders\\components\\header.ts", lineNumber: 59 });
})();

// src/app/routes/pages/orders/components/info.ts
var _NzDemoDescriptionsVerticalBorderComponent2 = class _NzDemoDescriptionsVerticalBorderComponent2 {
};
_NzDemoDescriptionsVerticalBorderComponent2.\u0275fac = function NzDemoDescriptionsVerticalBorderComponent_Factory(t) {
  return new (t || _NzDemoDescriptionsVerticalBorderComponent2)();
};
_NzDemoDescriptionsVerticalBorderComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoDescriptionsVerticalBorderComponent2, selectors: [["nz-demo-descriptions-vertical-border"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 19, vars: 2, consts: [["nzTitle", "Order Info", "nzBordered", "", "nzLayout", "vertical", "nzSize", "small", 2, "padding-top", "20px"], ["nzTitle", "Product"], ["nzTitle", "Billing Mode"], ["nzTitle", "Automatic Renewal"], ["nzTitle", "Order Time"], ["nzTitle", "Usage Time", 3, "nzSpan"], ["nzTitle", "Status", 3, "nzSpan"], ["nzStatus", "processing", "nzText", "Running"], ["nzTitle", "Negotiated Amount"], ["nzTitle", "Discount"], ["nzTitle", "Official Receipts"]], template: function NzDemoDescriptionsVerticalBorderComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-descriptions", 0)(1, "nz-descriptions-item", 1);
    \u0275\u0275text(2, "Cloud Database");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-descriptions-item", 2);
    \u0275\u0275text(4, "Prepaid");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "nz-descriptions-item", 3);
    \u0275\u0275text(6, "YES");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "nz-descriptions-item", 4);
    \u0275\u0275text(8, "2018-04-24 18:00:00");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "nz-descriptions-item", 5);
    \u0275\u0275text(10, " 2018-04-24 18:00:00 To 2019-04-24 18:00:00 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "nz-descriptions-item", 6);
    \u0275\u0275element(12, "nz-badge", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "nz-descriptions-item", 8);
    \u0275\u0275text(14, "$80.00");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "nz-descriptions-item", 9);
    \u0275\u0275text(16, "$20.00");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "nz-descriptions-item", 10);
    \u0275\u0275text(18, "$60.00");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(9);
    \u0275\u0275property("nzSpan", 2);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzSpan", 3);
  }
}, dependencies: [NzDescriptionsModule, NzDescriptionsComponent, NzDescriptionsItemComponent, NzBadgeModule, NzBadgeComponent], encapsulation: 2 });
var NzDemoDescriptionsVerticalBorderComponent2 = _NzDemoDescriptionsVerticalBorderComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoDescriptionsVerticalBorderComponent2, { className: "NzDemoDescriptionsVerticalBorderComponent", filePath: "src\\app\\routes\\pages\\orders\\components\\info.ts", lineNumber: 40 });
})();

// src/app/routes/pages/orders/components/table.ts
function NzDemoTableRowSelectionCustomComponent_tr_9_Template2(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.value, " ");
  }
}
var _NzDemoTableRowSelectionCustomComponent6 = class _NzDemoTableRowSelectionCustomComponent6 {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = [
      { name: "Customer", value: "Customer 1" },
      { name: "Material Name", value: "Starch" },
      { name: "Material Code", value: "ST3" },
      { name: "Quantity", value: "250 kWh" },
      { name: "Order Time", value: (/* @__PURE__ */ new Date()).toLocaleString() },
      { name: "Delivery Date", value: (/* @__PURE__ */ new Date()).toLocaleString() }
    ];
  }
};
_NzDemoTableRowSelectionCustomComponent6.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent6)();
};
_NzDemoTableRowSelectionCustomComponent6.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent6, selectors: [["nz-demo-table-row-selection-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 10, vars: 3, consts: [[3, "nzData", "nzShowPagination"], ["rowSelectionTable", ""], [4, "ngFor", "ngForOf"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1)(2, "thead")(3, "tr")(4, "th");
    \u0275\u0275text(5, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "th");
    \u0275\u0275text(7, "Value");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(8, "tbody");
    \u0275\u0275template(9, NzDemoTableRowSelectionCustomComponent_tr_9_Template2, 5, 2, "tr", 2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzShowPagination", false);
    \u0275\u0275advance(9);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTheadComponent, NzTbodyComponent, NzTrDirective, CommonModule, NgForOf, NzAvatarModule, NzBadgeModule], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent6 = _NzDemoTableRowSelectionCustomComponent6;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent6, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\pages\\orders\\components\\table.ts", lineNumber: 51 });
})();

// src/app/routes/pages/orders/orders.component.ts
function OrdersComponent_ng_template_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Order Details ");
  }
}
var _c058 = () => ({ step1: "finish", step2: "finish", step3: "finish", step4: "wait" });
var _c135 = () => ({ icon1: "shopping-cart", icon2: "solution", icon3: "check-circle", icon4: "loading" });
var _c223 = () => ({ step1: "finish", step2: "finish", step3: "process", step4: "wait" });
var _c316 = () => ({ icon1: "shopping-cart", icon2: "solution", icon3: "loading", icon4: "check-circle" });
var _OrdersComponent = class _OrdersComponent {
  constructor() {
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  ngOnInit() {
    setTimeout(() => {
    }, 1e3);
  }
};
_OrdersComponent.\u0275fac = function OrdersComponent_Factory(t) {
  return new (t || _OrdersComponent)();
};
_OrdersComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _OrdersComponent, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 22, vars: 13, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzMd", "24"], [3, "nzBordered"], ["nzText", "Order-4554", "nzOrientation", "left"], [3, "nzBordered", "nzTitle"], [3, "nzStatus", "icons"], ["nzText", "Order-4555", "nzOrientation", "left"], ["salesTitle", ""]], template: function OrdersComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Orders ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2)(7, "nz-card", 3);
    \u0275\u0275element(8, "nz-demo-page-header-ghost");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(9, "div", 1);
    \u0275\u0275element(10, "nz-divider", 4);
    \u0275\u0275elementStart(11, "div", 2)(12, "nz-card", 5);
    \u0275\u0275element(13, "nz-demo-steps-icon", 6)(14, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(15, "nz-divider", 7);
    \u0275\u0275elementStart(16, "div", 2)(17, "nz-card", 5);
    \u0275\u0275element(18, "nz-demo-steps-icon", 6)(19, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(20, OrdersComponent_ng_template_20_Template, 1, 0, "ng-template", null, 8, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(21);
    \u0275\u0275advance(7);
    \u0275\u0275property("nzBordered", true);
    \u0275\u0275advance(5);
    \u0275\u0275property("nzBordered", false)("nzTitle", _r1);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStatus", \u0275\u0275pureFunction0(9, _c058))("icons", \u0275\u0275pureFunction0(10, _c135));
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", _r1);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStatus", \u0275\u0275pureFunction0(11, _c223))("icons", \u0275\u0275pureFunction0(12, _c316));
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule,
  NzDemoStepsIconComponent2,
  G2TimelineModule,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  NzDividerModule,
  NzDividerComponent,
  NzDemoPageHeaderGhostComponent,
  NzDemoTableRowSelectionCustomComponent6
], encapsulation: 2, changeDetection: 0 });
var OrdersComponent = _OrdersComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(OrdersComponent, { className: "OrdersComponent", filePath: "src\\app\\routes\\pages\\orders\\orders.component.ts", lineNumber: 36 });
})();

// src/app/routes/pages/power/charts/card.ts
function ChartCardStyle1Component_ng_template_1_Template4(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 2);
  }
}
var _ChartCardStyle1Component4 = class _ChartCardStyle1Component4 {
};
_ChartCardStyle1Component4.\u0275fac = function ChartCardStyle1Component_Factory(t) {
  return new (t || _ChartCardStyle1Component4)();
};
_ChartCardStyle1Component4.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartCardStyle1Component4, selectors: [["chart-card-style1"]], inputs: { title: "title", total: "total" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 3, vars: 5, consts: [[3, "title", "bordered", "total", "contentHeight", "action"], ["action", ""], ["nz-tooltip", "", "nzTooltipTitle", "Value", "nz-icon", "", "nzType", "info-circle"]], template: function ChartCardStyle1Component_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-card", 0);
    \u0275\u0275template(1, ChartCardStyle1Component_ng_template_1_Template4, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("title", ctx.title)("bordered", true)("total", ctx.total)("contentHeight", 93)("action", _r1);
  }
}, dependencies: [G2CardModule, G2CardComponent, NzToolTipModule, NzTooltipDirective, TrendModule], encapsulation: 2 });
var ChartCardStyle1Component4 = _ChartCardStyle1Component4;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartCardStyle1Component4, { className: "ChartCardStyle1Component", filePath: "src\\app\\routes\\pages\\power\\charts\\card.ts", lineNumber: 19 });
})();

// src/app/routes/pages/power/charts/chart.component.ts
var _c059 = ["chart"];
var _LineChartComponent3 = class _LineChartComponent3 {
  constructor() {
  }
  ngOnChanges(changes) {
    this.chartOptions = {
      series: this.series,
      chart: {
        height: 200,
        type: "area",
        zoom: {
          enabled: false
        }
      },
      dataLabels: {
        enabled: false
      },
      stroke: {
        curve: "straight"
      },
      title: {
        align: "left"
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"],
          opacity: 0.5
        }
      },
      xaxis: {
        categories: [""]
      }
    };
  }
};
_LineChartComponent3.\u0275fac = function LineChartComponent_Factory(t) {
  return new (t || _LineChartComponent3)();
};
_LineChartComponent3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LineChartComponent3, selectors: [["chart-chart-echarts-on"]], viewQuery: function LineChartComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c059, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chart = _t.first);
  }
}, inputs: { series: "series" }, standalone: true, features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature], decls: 2, vars: 7, consts: [["id", "chart"], [3, "series", "chart", "xaxis", "dataLabels", "grid", "stroke", "title"]], template: function LineChartComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "apx-chart", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275property("series", ctx.chartOptions == null ? null : ctx.chartOptions.series)("chart", ctx.chartOptions == null ? null : ctx.chartOptions.chart)("xaxis", ctx.chartOptions == null ? null : ctx.chartOptions.xaxis)("dataLabels", ctx.chartOptions == null ? null : ctx.chartOptions.dataLabels)("grid", ctx.chartOptions == null ? null : ctx.chartOptions.grid)("stroke", ctx.chartOptions == null ? null : ctx.chartOptions.stroke)("title", ctx.chartOptions == null ? null : ctx.chartOptions.title);
  }
}, dependencies: [CommonModule, NgApexchartsModule, ChartComponent], encapsulation: 2 });
var LineChartComponent3 = _LineChartComponent3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LineChartComponent3, { className: "LineChartComponent", filePath: "src\\app\\routes\\pages\\power\\charts\\chart.component.ts", lineNumber: 42 });
})();

// src/app/routes/pages/power/charts/guge.component.ts
var _ChartGaugeBasicComponent3 = class _ChartGaugeBasicComponent3 {
  constructor(platform, cdr) {
    this.percent = 36;
    this.color = "#2f9cff";
    this.title = "";
    if (!platform.isBrowser)
      return;
    this.time$ = setInterval(() => {
      this.percent = parseInt((Math.random() * 100).toString(), 10);
      this.color = this.percent > 50 ? "#f50" : "#2f9cff";
      cdr.detectChanges();
    }, 1e3);
  }
  ngOnDestroy() {
    clearInterval(this.time$);
  }
};
_ChartGaugeBasicComponent3.\u0275fac = function ChartGaugeBasicComponent_Factory(t) {
  return new (t || _ChartGaugeBasicComponent3)(\u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_ChartGaugeBasicComponent3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartGaugeBasicComponent3, selectors: [["chart-gauge-basic"]], inputs: { title: "title" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 3, consts: [["height", "380", 3, "title", "percent", "color"]], template: function ChartGaugeBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "g2-gauge", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("title", ctx.title)("percent", ctx.percent)("color", ctx.color);
  }
}, dependencies: [G2GaugeModule, G2GaugeComponent], encapsulation: 2, changeDetection: 0 });
var ChartGaugeBasicComponent3 = _ChartGaugeBasicComponent3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartGaugeBasicComponent3, { className: "ChartGaugeBasicComponent", filePath: "src\\app\\routes\\pages\\power\\charts\\guge.component.ts", lineNumber: 14 });
})();

// src/app/routes/pages/power/charts/pie.component.ts
var _c060 = ["pie"];
var _ChartPieBasicComponent5 = class _ChartPieBasicComponent5 {
  constructor(msg) {
    this.msg = msg;
    this.salesPieData = [];
    this.total = "";
    this.refresh();
  }
  refresh() {
    const rv = (min = 0, max = 5e3) => Math.floor(Math.random() * (max - min + 1) + min);
    this.salesPieData = [
      {
        x: "data1",
        y: rv()
      },
      {
        x: "data2",
        y: rv()
      }
    ];
    if (Math.random() > 0.5) {
      this.salesPieData.push({
        x: "data",
        y: rv()
      });
    }
    this.total = `&yen ${this.salesPieData.reduce((pre, now) => now.y + pre, 0).toFixed(2)}`;
    if (this.pie) {
      setTimeout(() => this.pie.changeData());
    }
  }
  format(val) {
    return `&yen ${val.toFixed(2)}`;
  }
  handleClick(data) {
    this.msg.info(`${data.item.x} - ${data.item.y}`);
  }
};
_ChartPieBasicComponent5.\u0275fac = function ChartPieBasicComponent_Factory(t) {
  return new (t || _ChartPieBasicComponent5)(\u0275\u0275directiveInject(NzMessageService));
};
_ChartPieBasicComponent5.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartPieBasicComponent5, selectors: [["chart-pie-basic"]], viewQuery: function ChartPieBasicComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c060, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.pie = _t.first);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 3, consts: [["title", "pie", "subTitle", "pie", "height", "200", "repaint", "false", 3, "total", "valueFormat", "data", "clickItem"], ["pie", ""]], template: function ChartPieBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-pie", 0, 1);
    \u0275\u0275listener("clickItem", function ChartPieBasicComponent_Template_g2_pie_clickItem_0_listener($event) {
      return ctx.handleClick($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("total", ctx.total)("valueFormat", ctx.format)("data", ctx.salesPieData);
  }
}, dependencies: [NzButtonModule, G2PieModule, G2PieComponent], encapsulation: 2 });
var ChartPieBasicComponent5 = _ChartPieBasicComponent5;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartPieBasicComponent5, { className: "ChartPieBasicComponent", filePath: "src\\app\\routes\\pages\\power\\charts\\pie.component.ts", lineNumber: 25 });
})();

// src/app/routes/pages/power/components/Steps.component.ts
function NzDemoStepsIconComponent_ng_template_5_Template3(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 5);
  }
}
var _NzDemoStepsIconComponent3 = class _NzDemoStepsIconComponent3 {
};
_NzDemoStepsIconComponent3.\u0275fac = function NzDemoStepsIconComponent_Factory(t) {
  return new (t || _NzDemoStepsIconComponent3)();
};
_NzDemoStepsIconComponent3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoStepsIconComponent3, selectors: [["nz-demo-steps-icon"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 7, vars: 1, consts: [["nzTitle", "Login", "nzStatus", "finish", "nzIcon", "user"], ["nzTitle", "Verification", "nzStatus", "finish", "nzIcon", "solution"], ["nzTitle", "Pay", "nzStatus", "process", "nzIcon", "loading"], ["nzTitle", "Done", "nzStatus", "wait", 3, "nzIcon"], ["iconTemplate", ""], ["nz-icon", "", "nzType", "check-circle"]], template: function NzDemoStepsIconComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-steps");
    \u0275\u0275element(1, "nz-step", 0)(2, "nz-step", 1)(3, "nz-step", 2)(4, "nz-step", 3);
    \u0275\u0275template(5, NzDemoStepsIconComponent_ng_template_5_Template3, 1, 0, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(4);
    \u0275\u0275property("nzIcon", "check-circle");
  }
}, dependencies: [NzStepsModule, NzStepsComponent, NzStepComponent], encapsulation: 2 });
var NzDemoStepsIconComponent3 = _NzDemoStepsIconComponent3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoStepsIconComponent3, { className: "NzDemoStepsIconComponent", filePath: "src\\app\\routes\\pages\\power\\components\\Steps.component.ts", lineNumber: 19 });
})();

// src/app/routes/pages/power/components/select.ts
var _NzDemoSelectSearchComponent6 = class _NzDemoSelectSearchComponent6 {
  constructor() {
    this.selectedValue = null;
  }
};
_NzDemoSelectSearchComponent6.\u0275fac = function NzDemoSelectSearchComponent_Factory(t) {
  return new (t || _NzDemoSelectSearchComponent6)();
};
_NzDemoSelectSearchComponent6.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoSelectSearchComponent6, selectors: [["nz-demo-select-search"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 4, vars: 1, consts: [["nzShowSearch", "", "nzAllowClear", "", "nzPlaceHolder", "Select a person", 2, "width", "100%", 3, "ngModel", "ngModelChange"], ["nzLabel", "Jack", "nzValue", "jack"], ["nzLabel", "Lucy", "nzValue", "lucy"], ["nzLabel", "Tom", "nzValue", "tom"]], template: function NzDemoSelectSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener($event) {
      return ctx.selectedValue = $event;
    });
    \u0275\u0275element(1, "nz-option", 1)(2, "nz-option", 2)(3, "nz-option", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("ngModel", ctx.selectedValue);
  }
}, dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, FormsModule, NgControlStatus, NgModel], styles: ["\n\nnz-select[_ngcontent-%COMP%] {\n  width: 200px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2VsZWN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIG56LXNlbGVjdCB7XG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxTQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoSelectSearchComponent6 = _NzDemoSelectSearchComponent6;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoSelectSearchComponent6, { className: "NzDemoSelectSearchComponent", filePath: "src\\app\\routes\\pages\\power\\components\\select.ts", lineNumber: 25 });
})();

// src/app/routes/pages/power/components/table.ts
function NzDemoTableRowSelectionCustomComponent_tr_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr")(1, "td", 4);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_tr_12_Template_td_nzCheckedChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r4);
      const data_r2 = restoredCtx.$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onItemChecked(data_r2.id, $event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "td");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "td");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "td");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzChecked", ctx_r1.setOfCheckedId.has(data_r2.id));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.name);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.age);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.address);
  }
}
var _NzDemoTableRowSelectionCustomComponent7 = class _NzDemoTableRowSelectionCustomComponent7 {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
    this.pageSize = 5;
    this.pageIndex = 1;
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = new Array(200).fill(0).map((_, index) => ({
      id: index,
      name: `Edward King ${index}`,
      age: 32,
      address: `London, Park Lane no. ${index}`
    }));
  }
};
_NzDemoTableRowSelectionCustomComponent7.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent7)();
};
_NzDemoTableRowSelectionCustomComponent7.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent7, selectors: [["nz-demo-table-row-selection-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 13, vars: 7, consts: [["nzShowSizeChanger", "", 3, "nzData", "nzPageSize", "nzPageIndex", "nzCurrentPageDataChange"], ["rowSelectionTable", ""], [3, "nzSelections", "nzChecked", "nzIndeterminate", "nzCheckedChange"], [4, "ngFor", "ngForOf"], [3, "nzChecked", "nzCheckedChange"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1);
    \u0275\u0275listener("nzCurrentPageDataChange", function NzDemoTableRowSelectionCustomComponent_Template_nz_table_nzCurrentPageDataChange_0_listener($event) {
      return ctx.onCurrentPageDataChange($event);
    });
    \u0275\u0275elementStart(2, "thead")(3, "tr")(4, "th", 2);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.checked = $event;
    })("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.onAllChecked($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "th");
    \u0275\u0275text(6, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "th");
    \u0275\u0275text(8, "Age");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "th");
    \u0275\u0275text(10, "Address");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(11, "tbody");
    \u0275\u0275template(12, NzDemoTableRowSelectionCustomComponent_tr_12_Template, 8, 4, "tr", 3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzPageSize", ctx.pageSize)("nzPageIndex", ctx.pageIndex);
    \u0275\u0275advance(4);
    \u0275\u0275property("nzSelections", ctx.listOfSelection)("nzChecked", ctx.checked)("nzIndeterminate", ctx.indeterminate);
    \u0275\u0275advance(8);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzThSelectionComponent, CommonModule, NgForOf], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent7 = _NzDemoTableRowSelectionCustomComponent7;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent7, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\pages\\power\\components\\table.ts", lineNumber: 50 });
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-timeline.mjs
var _c061 = ["template"];
function NzTimelineItemComponent_ng_template_0_div_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r4.nzLabel);
  }
}
function NzTimelineItemComponent_ng_template_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275template(1, NzTimelineItemComponent_ng_template_0_div_1_ng_container_1_Template, 2, 1, "ng-container", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r2.nzLabel);
  }
}
function NzTimelineItemComponent_ng_template_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r3.nzDot);
  }
}
function NzTimelineItemComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 1);
    \u0275\u0275template(1, NzTimelineItemComponent_ng_template_0_div_1_Template, 2, 1, "div", 2);
    \u0275\u0275element(2, "div", 3);
    \u0275\u0275elementStart(3, "div", 4);
    \u0275\u0275template(4, NzTimelineItemComponent_ng_template_0_ng_container_4_Template, 2, 1, "ng-container", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 6);
    \u0275\u0275projection(6);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-timeline-item-right", (ctx_r0.nzPosition || ctx_r0.position) === "right")("ant-timeline-item-left", (ctx_r0.nzPosition || ctx_r0.position) === "left")("ant-timeline-item-last", ctx_r0.isLast);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", ctx_r0.nzLabel);
    \u0275\u0275advance(2);
    \u0275\u0275styleProp("border-color", ctx_r0.borderColor);
    \u0275\u0275classProp("ant-timeline-item-head-red", ctx_r0.nzColor === "red")("ant-timeline-item-head-blue", ctx_r0.nzColor === "blue")("ant-timeline-item-head-green", ctx_r0.nzColor === "green")("ant-timeline-item-head-gray", ctx_r0.nzColor === "gray")("ant-timeline-item-head-custom", !!ctx_r0.nzDot);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r0.nzDot);
  }
}
var _c136 = ["*"];
function NzTimelineComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 4);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r4 = \u0275\u0275reference(5);
    \u0275\u0275property("ngTemplateOutlet", _r4);
  }
}
function NzTimelineComponent_ng_container_2_ng_template_1_Template(rf, ctx) {
}
function NzTimelineComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NzTimelineComponent_ng_container_2_ng_template_1_Template, 0, 0, "ng-template", 4);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", item_r5.template);
  }
}
function NzTimelineComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 4);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r4 = \u0275\u0275reference(5);
    \u0275\u0275property("ngTemplateOutlet", _r4);
  }
}
function NzTimelineComponent_ng_template_4_li_0_ng_container_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 12);
  }
}
function NzTimelineComponent_ng_template_4_li_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275template(2, NzTimelineComponent_ng_template_4_li_0_ng_container_3_span_2_Template, 1, 0, "span", 11);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r8.nzPendingDot, " ");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngIf", !ctx_r8.nzPendingDot);
  }
}
function NzTimelineComponent_ng_template_4_li_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx_r9.isPendingBoolean ? "" : ctx_r9.nzPending, " ");
  }
}
function NzTimelineComponent_ng_template_4_li_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 6);
    \u0275\u0275element(1, "div", 7);
    \u0275\u0275elementStart(2, "div", 8);
    \u0275\u0275template(3, NzTimelineComponent_ng_template_4_li_0_ng_container_3_Template, 3, 2, "ng-container", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 10);
    \u0275\u0275template(5, NzTimelineComponent_ng_template_4_li_0_ng_container_5_Template, 2, 1, "ng-container", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r7.nzPendingDot);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzStringTemplateOutlet", ctx_r7.nzPending);
  }
}
function NzTimelineComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzTimelineComponent_ng_template_4_li_0_Template, 6, 2, "li", 5);
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r3.nzPending);
  }
}
var TimelineTimeDefaultColors = ["red", "blue", "green", "grey", "gray"];
var _TimelineService = class _TimelineService {
  constructor() {
    this.check$ = new ReplaySubject(1);
  }
  markForCheck() {
    this.check$.next();
  }
};
_TimelineService.\u0275fac = function TimelineService_Factory(t) {
  return new (t || _TimelineService)();
};
_TimelineService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _TimelineService,
  factory: _TimelineService.\u0275fac
});
var TimelineService = _TimelineService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineService, [{
    type: Injectable
  }], null, null);
})();
function isDefaultColor(color) {
  return TimelineTimeDefaultColors.findIndex((i) => i === color) !== -1;
}
var _NzTimelineItemComponent = class _NzTimelineItemComponent {
  constructor(cdr, timelineService) {
    this.cdr = cdr;
    this.timelineService = timelineService;
    this.nzColor = "blue";
    this.isLast = false;
    this.borderColor = null;
  }
  ngOnChanges(changes) {
    this.timelineService.markForCheck();
    if (changes.nzColor) {
      this.updateCustomColor();
    }
  }
  detectChanges() {
    this.cdr.detectChanges();
  }
  updateCustomColor() {
    this.borderColor = isDefaultColor(this.nzColor) ? null : this.nzColor;
  }
};
_NzTimelineItemComponent.\u0275fac = function NzTimelineItemComponent_Factory(t) {
  return new (t || _NzTimelineItemComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(TimelineService));
};
_NzTimelineItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTimelineItemComponent,
  selectors: [["nz-timeline-item"], ["", "nz-timeline-item", ""]],
  viewQuery: function NzTimelineItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c061, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.template = _t.first);
    }
  },
  inputs: {
    nzPosition: "nzPosition",
    nzColor: "nzColor",
    nzDot: "nzDot",
    nzLabel: "nzLabel"
  },
  exportAs: ["nzTimelineItem"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c136,
  decls: 2,
  vars: 0,
  consts: [["template", ""], [1, "ant-timeline-item"], ["class", "ant-timeline-item-label", 4, "ngIf"], [1, "ant-timeline-item-tail"], [1, "ant-timeline-item-head"], [4, "nzStringTemplateOutlet"], [1, "ant-timeline-item-content"], [1, "ant-timeline-item-label"]],
  template: function NzTimelineItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzTimelineItemComponent_ng_template_0_Template, 7, 20, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
  },
  dependencies: [NgIf, NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzTimelineItemComponent = _NzTimelineItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTimelineItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      preserveWhitespaces: false,
      selector: "nz-timeline-item, [nz-timeline-item]",
      exportAs: "nzTimelineItem",
      template: `
    <ng-template #template>
      <li
        class="ant-timeline-item"
        [class.ant-timeline-item-right]="(nzPosition || position) === 'right'"
        [class.ant-timeline-item-left]="(nzPosition || position) === 'left'"
        [class.ant-timeline-item-last]="isLast"
      >
        <div *ngIf="nzLabel" class="ant-timeline-item-label">
          <ng-container *nzStringTemplateOutlet="nzLabel">{{ nzLabel }}</ng-container>
        </div>
        <div class="ant-timeline-item-tail"></div>
        <div
          class="ant-timeline-item-head"
          [class.ant-timeline-item-head-red]="nzColor === 'red'"
          [class.ant-timeline-item-head-blue]="nzColor === 'blue'"
          [class.ant-timeline-item-head-green]="nzColor === 'green'"
          [class.ant-timeline-item-head-gray]="nzColor === 'gray'"
          [class.ant-timeline-item-head-custom]="!!nzDot"
          [style.border-color]="borderColor"
        >
          <ng-container *nzStringTemplateOutlet="nzDot">{{ nzDot }}</ng-container>
        </div>
        <div class="ant-timeline-item-content">
          <ng-content></ng-content>
        </div>
      </li>
    </ng-template>
  `,
      imports: [NgIf, NzOutletModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: TimelineService
  }], {
    template: [{
      type: ViewChild,
      args: ["template", {
        static: false
      }]
    }],
    nzPosition: [{
      type: Input
    }],
    nzColor: [{
      type: Input
    }],
    nzDot: [{
      type: Input
    }],
    nzLabel: [{
      type: Input
    }]
  });
})();
var _NzTimelineComponent = class _NzTimelineComponent {
  constructor(cdr, timelineService, directionality) {
    this.cdr = cdr;
    this.timelineService = timelineService;
    this.directionality = directionality;
    this.nzMode = "left";
    this.nzReverse = false;
    this.isPendingBoolean = false;
    this.timelineItems = [];
    this.dir = "ltr";
    this.hasLabelItem = false;
    this.destroy$ = new Subject();
  }
  ngOnChanges(changes) {
    const {
      nzMode,
      nzReverse,
      nzPending
    } = changes;
    if (simpleChangeActivated(nzMode) || simpleChangeActivated(nzReverse)) {
      this.updateChildren();
    }
    if (nzPending) {
      this.isPendingBoolean = nzPending.currentValue === true;
    }
  }
  ngOnInit() {
    this.timelineService.check$.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.cdr.markForCheck();
    });
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngAfterContentInit() {
    this.updateChildren();
    this.listOfItems.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.updateChildren();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  updateChildren() {
    if (this.listOfItems && this.listOfItems.length) {
      const length = this.listOfItems.length;
      let hasLabelItem = false;
      this.listOfItems.forEach((item, index) => {
        item.isLast = !this.nzReverse ? index === length - 1 : index === 0;
        item.position = getInferredTimelineItemPosition(index, this.nzMode);
        if (!hasLabelItem && item.nzLabel) {
          hasLabelItem = true;
        }
        item.detectChanges();
      });
      this.timelineItems = this.nzReverse ? this.listOfItems.toArray().reverse() : this.listOfItems.toArray();
      this.hasLabelItem = hasLabelItem;
    } else {
      this.timelineItems = [];
      this.hasLabelItem = false;
    }
    this.cdr.markForCheck();
  }
};
_NzTimelineComponent.\u0275fac = function NzTimelineComponent_Factory(t) {
  return new (t || _NzTimelineComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(TimelineService), \u0275\u0275directiveInject(Directionality, 8));
};
_NzTimelineComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzTimelineComponent,
  selectors: [["nz-timeline"]],
  contentQueries: function NzTimelineComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzTimelineItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listOfItems = _t);
    }
  },
  inputs: {
    nzMode: "nzMode",
    nzPending: "nzPending",
    nzPendingDot: "nzPendingDot",
    nzReverse: "nzReverse"
  },
  exportAs: ["nzTimeline"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([TimelineService]), \u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c136,
  decls: 7,
  vars: 15,
  consts: [[1, "ant-timeline"], [3, "ngTemplateOutlet", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["pendingTemplate", ""], [3, "ngTemplateOutlet"], ["class", "ant-timeline-item ant-timeline-item-pending", 4, "ngIf"], [1, "ant-timeline-item", "ant-timeline-item-pending"], [1, "ant-timeline-item-tail"], [1, "ant-timeline-item-head", "ant-timeline-item-head-custom", "ant-timeline-item-head-blue"], [4, "nzStringTemplateOutlet"], [1, "ant-timeline-item-content"], ["nz-icon", "", "nzType", "loading", 4, "ngIf"], ["nz-icon", "", "nzType", "loading"]],
  template: function NzTimelineComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "ul", 0);
      \u0275\u0275template(1, NzTimelineComponent_ng_container_1_Template, 1, 1, "ng-container", 1)(2, NzTimelineComponent_ng_container_2_Template, 2, 1, "ng-container", 2)(3, NzTimelineComponent_ng_container_3_Template, 1, 1, "ng-container", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, NzTimelineComponent_ng_template_4_Template, 1, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
      \u0275\u0275projection(6);
    }
    if (rf & 2) {
      \u0275\u0275classProp("ant-timeline-label", ctx.hasLabelItem)("ant-timeline-right", !ctx.hasLabelItem && ctx.nzMode === "right")("ant-timeline-alternate", ctx.nzMode === "alternate" || ctx.nzMode === "custom")("ant-timeline-pending", !!ctx.nzPending)("ant-timeline-reverse", ctx.nzReverse)("ant-timeline-rtl", ctx.dir === "rtl");
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", ctx.nzReverse);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngForOf", ctx.timelineItems);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngIf", !ctx.nzReverse);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgForOf, NzOutletModule, NzStringTemplateOutletDirective, NzIconModule, NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzTimelineComponent = _NzTimelineComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTimelineComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      preserveWhitespaces: false,
      selector: "nz-timeline",
      providers: [TimelineService],
      exportAs: "nzTimeline",
      template: `
    <ul
      class="ant-timeline"
      [class.ant-timeline-label]="hasLabelItem"
      [class.ant-timeline-right]="!hasLabelItem && nzMode === 'right'"
      [class.ant-timeline-alternate]="nzMode === 'alternate' || nzMode === 'custom'"
      [class.ant-timeline-pending]="!!nzPending"
      [class.ant-timeline-reverse]="nzReverse"
      [class.ant-timeline-rtl]="dir === 'rtl'"
    >
      <!-- pending dot (reversed) -->
      <ng-container *ngIf="nzReverse" [ngTemplateOutlet]="pendingTemplate"></ng-container>
      <!-- timeline items -->
      <ng-container *ngFor="let item of timelineItems">
        <ng-template [ngTemplateOutlet]="item.template"></ng-template>
      </ng-container>
      <ng-container *ngIf="!nzReverse" [ngTemplateOutlet]="pendingTemplate"></ng-container>
      <!-- pending dot -->
    </ul>
    <ng-template #pendingTemplate>
      <li *ngIf="nzPending" class="ant-timeline-item ant-timeline-item-pending">
        <div class="ant-timeline-item-tail"></div>
        <div class="ant-timeline-item-head ant-timeline-item-head-custom ant-timeline-item-head-blue">
          <ng-container *nzStringTemplateOutlet="nzPendingDot">
            {{ nzPendingDot }}
            <span *ngIf="!nzPendingDot" nz-icon nzType="loading"></span>
          </ng-container>
        </div>
        <div class="ant-timeline-item-content">
          <ng-container *nzStringTemplateOutlet="nzPending">
            {{ isPendingBoolean ? '' : nzPending }}
          </ng-container>
        </div>
      </li>
    </ng-template>
    <!-- Grasp items -->
    <ng-content></ng-content>
  `,
      imports: [NgIf, NgTemplateOutlet, NgForOf, NzOutletModule, NzIconModule],
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: TimelineService
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    listOfItems: [{
      type: ContentChildren,
      args: [NzTimelineItemComponent]
    }],
    nzMode: [{
      type: Input
    }],
    nzPending: [{
      type: Input
    }],
    nzPendingDot: [{
      type: Input
    }],
    nzReverse: [{
      type: Input
    }]
  });
})();
function simpleChangeActivated(simpleChange) {
  return !!(simpleChange && (simpleChange.previousValue !== simpleChange.currentValue || simpleChange.isFirstChange()));
}
function getInferredTimelineItemPosition(index, mode) {
  return mode === "custom" ? void 0 : mode === "left" ? "left" : mode === "right" ? "right" : mode === "alternate" && index % 2 === 0 ? "left" : "right";
}
var _NzTimelineModule = class _NzTimelineModule {
};
_NzTimelineModule.\u0275fac = function NzTimelineModule_Factory(t) {
  return new (t || _NzTimelineModule)();
};
_NzTimelineModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzTimelineModule
});
_NzTimelineModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzTimelineItemComponent, NzTimelineComponent]
});
var NzTimelineModule = _NzTimelineModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTimelineModule, [{
    type: NgModule,
    args: [{
      imports: [NzTimelineItemComponent, NzTimelineComponent],
      exports: [NzTimelineItemComponent, NzTimelineComponent]
    }]
  }], null, null);
})();

// src/app/routes/pages/power/components/time.component.ts
var _NzDemoTimelineCustomComponent = class _NzDemoTimelineCustomComponent {
  constructor() {
    this.reverse = false;
  }
  toggleReverse() {
    this.reverse = !this.reverse;
  }
};
_NzDemoTimelineCustomComponent.\u0275fac = function NzDemoTimelineCustomComponent_Factory(t) {
  return new (t || _NzDemoTimelineCustomComponent)();
};
_NzDemoTimelineCustomComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTimelineCustomComponent, selectors: [["nz-demo-timeline-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 7, vars: 2, consts: [["height", "200", 3, "nzPending", "nzReverse"]], template: function NzDemoTimelineCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-timeline", 0)(1, "nz-timeline-item");
    \u0275\u0275text(2, "Create a services site 2015-09-01");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-timeline-item");
    \u0275\u0275text(4, "Solve initial network problems 2015-09-01");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "nz-timeline-item");
    \u0275\u0275text(6, "Technical testing 2015-09-01");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPending", "Recording...")("nzReverse", ctx.reverse);
  }
}, dependencies: [NzTimelineModule, NzTimelineItemComponent, NzTimelineComponent], encapsulation: 2 });
var NzDemoTimelineCustomComponent = _NzDemoTimelineCustomComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTimelineCustomComponent, { className: "NzDemoTimelineCustomComponent", filePath: "src\\app\\routes\\pages\\power\\components\\time.component.ts", lineNumber: 17 });
})();

// src/app/routes/pages/power/power.component.ts
function PowerComponent_ng_template_63_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Sales Statistics ");
    \u0275\u0275elementStart(1, "small", 9);
    \u0275\u0275text(2, "Business Expectations & Retail Sales Statistics");
    \u0275\u0275elementEnd();
  }
}
var _c062 = (a1) => ({ name: "Active Power", data: a1 });
var _c137 = (a1) => ({ name: "Reactive  Power", data: a1 });
var _c224 = (a1) => ({ name: "Apparent  Power", data: a1 });
var _c317 = (a0, a1, a2) => [a0, a1, a2];
var _c412 = (a1) => ({ name: "Frequency", data: a1 });
var _c58 = (a0) => [a0];
var _c66 = (a1) => ({ name: "Voltage 1", data: a1 });
var _c75 = (a1) => ({ name: "Voltage 2", data: a1 });
var _c85 = (a1) => ({ name: "Voltage 3", data: a1 });
var _c95 = (a1) => ({ name: "Current 1", data: a1 });
var _c104 = (a1) => ({ name: "Current 2", data: a1 });
var _c1110 = (a1) => ({ name: "Current 3", data: a1 });
var _c1210 = (a1) => ({ name: "Harmonic 1", data: a1 });
var _c138 = (a1) => ({ name: "Harmonic 2", data: a1 });
var _c142 = (a1) => ({ name: "Harmonic 3", data: a1 });
var _PowerComponent = class _PowerComponent {
  constructor() {
    this.http = inject(_HttpClient);
    this.cdr = inject(ChangeDetectorRef);
    this.obSrv = inject(OnboardingService);
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  ngOnInit() {
    setTimeout(() => {
    }, 1e3);
  }
  // private genOnboarding(): void {
  //   const KEY = 'on-boarding';
  //   if (!this.platform.isBrowser || localStorage.getItem(KEY) === '1') {
  //     return;
  //   }
  //   this.http.get(`./assets/tmp/on-boarding.json`).subscribe(res => {
  //     this.obSrv.start(res);
  //     localStorage.setItem(KEY, '1');
  //   });
  // }
  r(num) {
    return new Array(100).fill(0).map((_, index) => (Math.random() * num).toFixed(0));
  }
  rv(num) {
    return new Array(100).fill(55).map((_, index) => {
      return 59;
    });
  }
};
_PowerComponent.\u0275fac = function PowerComponent_Factory(t) {
  return new (t || _PowerComponent)();
};
_PowerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PowerComponent, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 65, vars: 79, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzMd", "12"], ["nz-col", "", "nzXs", "24", "nzMd", "8"], [2, "height", "150px", 3, "nzBordered", "nzTitle"], [3, "nzBordered", "nzTitle"], ["nz-col", "", "nzXs", "24", "nzMd", "24"], [3, "series"], ["salesTitle", ""], [1, "text-sm", "font-weight-normal"]], template: function PowerComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Power ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2)(7, "div", 1)(8, "div", 3)(9, "nz-card", 4)(10, "h3");
    \u0275\u0275text(11, "223 V");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(12, "div", 3)(13, "nz-card", 4)(14, "h3");
    \u0275\u0275text(15, "223 V");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(16, "div", 3)(17, "nz-card", 4)(18, "h3");
    \u0275\u0275text(19, "223 V");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(20, "div", 3)(21, "nz-card", 4)(22, "h3");
    \u0275\u0275text(23, "8.5875 A");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(24, "div", 3)(25, "nz-card", 4)(26, "h3");
    \u0275\u0275text(27, "8.5875 A");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(28, "div", 3)(29, "nz-card", 4)(30, "h3");
    \u0275\u0275text(31, "9.5875 A");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(32, "div", 3)(33, "nz-card", 4)(34, "h3");
    \u0275\u0275text(35, "1.7 KW");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(36, "div", 3)(37, "nz-card", 4)(38, "h3");
    \u0275\u0275text(39, "1.7 KW");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(40, "div", 3)(41, "nz-card", 4)(42, "h3");
    \u0275\u0275text(43, "1.7 KW");
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275elementStart(44, "div", 2)(45, "nz-card", 5);
    \u0275\u0275element(46, "chart-gauge-basic");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(47, "div", 1)(48, "div", 6)(49, "nz-card", 5);
    \u0275\u0275element(50, "chart-chart-echarts-on", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(51, "div", 6)(52, "nz-card", 5);
    \u0275\u0275element(53, "chart-chart-echarts-on", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(54, "div", 6)(55, "nz-card", 5);
    \u0275\u0275element(56, "chart-chart-echarts-on", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(57, "div", 6)(58, "nz-card", 5);
    \u0275\u0275element(59, "chart-chart-echarts-on", 7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(60, "div", 6)(61, "nz-card", 5);
    \u0275\u0275element(62, "chart-chart-echarts-on", 7);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(63, PowerComponent_ng_template_63_Template, 3, 0, "ng-template", null, 8, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    \u0275\u0275advance(9);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Current Voltage 1");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Current Voltage 2");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Current Voltage 3");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "CT1 Current");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "CT2 Current");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "CT3 Current");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Current Power 1");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Current Power 2");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Current Power 3");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Power Factor");
    \u0275\u0275advance(4);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Power");
    \u0275\u0275advance(1);
    \u0275\u0275property("series", \u0275\u0275pureFunction3(41, _c317, \u0275\u0275pureFunction1(35, _c062, ctx.r(100)), \u0275\u0275pureFunction1(37, _c137, ctx.r(100)), \u0275\u0275pureFunction1(39, _c224, ctx.r(100))));
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Average Frequency");
    \u0275\u0275advance(1);
    \u0275\u0275property("series", \u0275\u0275pureFunction1(47, _c58, \u0275\u0275pureFunction1(45, _c412, ctx.rv(62))));
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Voltage");
    \u0275\u0275advance(1);
    \u0275\u0275property("series", \u0275\u0275pureFunction3(55, _c317, \u0275\u0275pureFunction1(49, _c66, ctx.r(100)), \u0275\u0275pureFunction1(51, _c75, ctx.r(100)), \u0275\u0275pureFunction1(53, _c85, ctx.r(100))));
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Current");
    \u0275\u0275advance(1);
    \u0275\u0275property("series", \u0275\u0275pureFunction3(65, _c317, \u0275\u0275pureFunction1(59, _c95, ctx.r(100)), \u0275\u0275pureFunction1(61, _c104, ctx.r(100)), \u0275\u0275pureFunction1(63, _c1110, ctx.r(100))));
    \u0275\u0275advance(2);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Harmonic");
    \u0275\u0275advance(1);
    \u0275\u0275property("series", \u0275\u0275pureFunction3(75, _c317, \u0275\u0275pureFunction1(69, _c1210, ctx.r(100)), \u0275\u0275pureFunction1(71, _c138, ctx.r(100)), \u0275\u0275pureFunction1(73, _c142, ctx.r(100))));
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule,
  G2TimelineModule,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  OnboardingModule,
  ChartGaugeBasicComponent3,
  LineChartComponent3
], encapsulation: 2, changeDetection: 0 });
var PowerComponent = _PowerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PowerComponent, { className: "PowerComponent", filePath: "src\\app\\routes\\pages\\power\\power.component.ts", lineNumber: 44 });
})();

// src/app/routes/pages/supplyChain/charts/pie.component.ts
var _c063 = ["pie"];
var _ChartPieBasicComponent6 = class _ChartPieBasicComponent6 {
  constructor(msg) {
    this.msg = msg;
    this.salesPieData = [];
    this.total = "";
    this.refresh();
  }
  refresh() {
    const rv = (min = 0, max = 5e3) => Math.floor(Math.random() * (max - min + 1) + min);
    this.salesPieData = [
      {
        x: "Material 1",
        y: rv()
      },
      {
        x: "Material 2",
        y: rv()
      }
    ];
    if (Math.random() > 0.5) {
      this.salesPieData.push({
        x: "Material 3",
        y: rv()
      });
    }
    this.total = ` ${this.salesPieData.reduce((pre, now) => now.y + pre, 0).toFixed(2)}`;
    if (this.pie) {
      setTimeout(() => this.pie.changeData());
    }
  }
  format(val) {
    return `&yen ${val.toFixed(2)}`;
  }
  handleClick(data) {
    this.msg.info(`${data.item.x} - ${data.item.y}`);
  }
};
_ChartPieBasicComponent6.\u0275fac = function ChartPieBasicComponent_Factory(t) {
  return new (t || _ChartPieBasicComponent6)(\u0275\u0275directiveInject(NzMessageService));
};
_ChartPieBasicComponent6.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartPieBasicComponent6, selectors: [["chart-pie-basic"]], viewQuery: function ChartPieBasicComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c063, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.pie = _t.first);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 3, consts: [["title", "pie", "subTitle", "Total", "height", "200", "repaint", "false", 3, "total", "valueFormat", "data", "clickItem"], ["pie", ""]], template: function ChartPieBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-pie", 0, 1);
    \u0275\u0275listener("clickItem", function ChartPieBasicComponent_Template_g2_pie_clickItem_0_listener($event) {
      return ctx.handleClick($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("total", ctx.total)("valueFormat", ctx.format)("data", ctx.salesPieData);
  }
}, dependencies: [NzButtonModule, G2PieModule, G2PieComponent], encapsulation: 2 });
var ChartPieBasicComponent6 = _ChartPieBasicComponent6;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartPieBasicComponent6, { className: "ChartPieBasicComponent", filePath: "src\\app\\routes\\pages\\supplyChain\\charts\\pie.component.ts", lineNumber: 25 });
})();

// src/app/routes/pages/supplyChain/charts/rate.component.ts
function ChartCardStyle1Component_ng_template_1_Template5(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 4);
  }
}
var _ChartCardStyle1Component5 = class _ChartCardStyle1Component5 {
};
_ChartCardStyle1Component5.\u0275fac = function ChartCardStyle1Component_Factory(t) {
  return new (t || _ChartCardStyle1Component5)();
};
_ChartCardStyle1Component5.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartCardStyle1Component5, selectors: [["chart-card-style1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 9, vars: 4, consts: [["footer", "\u65E5\u8BBF\u95EE\u91CF 12,423", "contentHeight", "46", 3, "title", "bordered", "total", "action"], ["action", ""], ["flag", "up", 2, "margin", "0 16px 0 8px", "color", "rgba(0,0,0,.85)"], ["flag", "down", 2, "margin", "0 0 0 8px", "color", "rgba(0,0,0,.85)"], ["nz-tooltip", "", "nzTooltipTitle", "\u6307\u6807\u8BF4\u660E", "nz-icon", "", "nzType", "info-circle"]], template: function ChartCardStyle1Component_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-card", 0);
    \u0275\u0275template(1, ChartCardStyle1Component_ng_template_1_Template5, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275text(3, " \u5468\u540C\u6BD4 ");
    \u0275\u0275elementStart(4, "trend", 2);
    \u0275\u0275text(5, "12%");
    \u0275\u0275elementEnd();
    \u0275\u0275text(6, " \u65E5\u73AF\u6BD4 ");
    \u0275\u0275elementStart(7, "trend", 3);
    \u0275\u0275text(8, "11%");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("title", "\u9500\u552E\u989D")("bordered", true)("total", "\xA5 126,560.00")("action", _r1);
  }
}, dependencies: [G2CardModule, G2CardComponent, NzToolTipModule, NzTooltipDirective, TrendModule, TrendComponent], encapsulation: 2 });
var ChartCardStyle1Component5 = _ChartCardStyle1Component5;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartCardStyle1Component5, { className: "ChartCardStyle1Component", filePath: "src\\app\\routes\\pages\\supplyChain\\charts\\rate.component.ts", lineNumber: 23 });
})();

// src/app/routes/pages/supplyChain/components/Steps.component.ts
function NzDemoStepsIconComponent_ng_template_5_Template4(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 5);
  }
}
var _NzDemoStepsIconComponent4 = class _NzDemoStepsIconComponent4 {
};
_NzDemoStepsIconComponent4.\u0275fac = function NzDemoStepsIconComponent_Factory(t) {
  return new (t || _NzDemoStepsIconComponent4)();
};
_NzDemoStepsIconComponent4.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoStepsIconComponent4, selectors: [["nz-demo-steps-icon"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 7, vars: 1, consts: [["nzTitle", "Login", "nzStatus", "finish", "nzIcon", "user"], ["nzTitle", "Verification", "nzStatus", "finish", "nzIcon", "solution"], ["nzTitle", "Pay", "nzStatus", "process", "nzIcon", "loading"], ["nzTitle", "Done", "nzStatus", "wait", 3, "nzIcon"], ["iconTemplate", ""], ["nz-icon", "", "nzType", "check-circle"]], template: function NzDemoStepsIconComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-steps");
    \u0275\u0275element(1, "nz-step", 0)(2, "nz-step", 1)(3, "nz-step", 2)(4, "nz-step", 3);
    \u0275\u0275template(5, NzDemoStepsIconComponent_ng_template_5_Template4, 1, 0, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(4);
    \u0275\u0275property("nzIcon", "check-circle");
  }
}, dependencies: [NzStepsModule, NzStepsComponent, NzStepComponent], encapsulation: 2 });
var NzDemoStepsIconComponent4 = _NzDemoStepsIconComponent4;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoStepsIconComponent4, { className: "NzDemoStepsIconComponent", filePath: "src\\app\\routes\\pages\\supplyChain\\components\\Steps.component.ts", lineNumber: 19 });
})();

// src/app/routes/pages/supplyChain/components/select.ts
var _NzDemoSelectSearchComponent7 = class _NzDemoSelectSearchComponent7 {
  constructor() {
    this.selectedValue = null;
    this.nzPlaceHolder = "";
  }
};
_NzDemoSelectSearchComponent7.\u0275fac = function NzDemoSelectSearchComponent_Factory(t) {
  return new (t || _NzDemoSelectSearchComponent7)();
};
_NzDemoSelectSearchComponent7.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoSelectSearchComponent7, selectors: [["nz-demo-select-search"]], inputs: { nzPlaceHolder: "nzPlaceHolder" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 4, vars: 2, consts: [["nzShowSearch", "", "nzAllowClear", "", 2, "width", "100%", 3, "nzPlaceHolder", "ngModel", "ngModelChange"], ["nzLabel", "test-1", "nzValue", "test-1"], ["nzLabel", "test-2", "nzValue", "test-2"], ["nzLabel", "test-3", "nzValue", "test-3"]], template: function NzDemoSelectSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener($event) {
      return ctx.selectedValue = $event;
    });
    \u0275\u0275element(1, "nz-option", 1)(2, "nz-option", 2)(3, "nz-option", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPlaceHolder", ctx.nzPlaceHolder)("ngModel", ctx.selectedValue);
  }
}, dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, FormsModule, NgControlStatus, NgModel], styles: ["\n\nnz-select[_ngcontent-%COMP%] {\n  width: 200px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2VsZWN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIG56LXNlbGVjdCB7XG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxTQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoSelectSearchComponent7 = _NzDemoSelectSearchComponent7;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoSelectSearchComponent7, { className: "NzDemoSelectSearchComponent", filePath: "src\\app\\routes\\pages\\supplyChain\\components\\select.ts", lineNumber: 25 });
})();

// src/app/routes/pages/supplyChain/components/table.ts
function NzDemoTableRowSelectionCustomComponent_tr_24_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr")(1, "td", 4);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_tr_24_Template_td_nzCheckedChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r4);
      const data_r2 = restoredCtx.$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onItemChecked(data_r2.id, $event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "td");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "td");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "td");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "td");
    \u0275\u0275text(9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "td");
    \u0275\u0275text(11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "td");
    \u0275\u0275text(13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "td");
    \u0275\u0275text(15);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "td");
    \u0275\u0275text(17);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "td");
    \u0275\u0275text(19);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzChecked", ctx_r1.setOfCheckedId.has(data_r2.id));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.Name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.id);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Rate);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Last);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.New);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Quantity);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.date);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.RsDate);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Grade);
  }
}
var _NzDemoTableRowSelectionCustomComponent8 = class _NzDemoTableRowSelectionCustomComponent8 {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
    this.pageSize = 5;
    this.pageIndex = 1;
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = new Array(200).fill(0).map((_, index) => ({
      id: ((index + 2) * Math.random() * 55).toFixed(0),
      Name: `Starch`,
      Rate: `10 T/M`,
      Last: "Order-4554",
      New: "Order-4555",
      Quantity: `3 T`,
      date: (/* @__PURE__ */ new Date()).toLocaleString(),
      RsDate: (/* @__PURE__ */ new Date()).toLocaleString(),
      Grade: "A"
    }));
  }
};
_NzDemoTableRowSelectionCustomComponent8.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent8)();
};
_NzDemoTableRowSelectionCustomComponent8.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent8, selectors: [["nz-demo-table-row-selection-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 25, vars: 7, consts: [["nzShowSizeChanger", "", 3, "nzData", "nzPageSize", "nzPageIndex", "nzCurrentPageDataChange"], ["rowSelectionTable", ""], [3, "nzSelections", "nzChecked", "nzIndeterminate", "nzCheckedChange"], [4, "ngFor", "ngForOf"], [3, "nzChecked", "nzCheckedChange"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1);
    \u0275\u0275listener("nzCurrentPageDataChange", function NzDemoTableRowSelectionCustomComponent_Template_nz_table_nzCurrentPageDataChange_0_listener($event) {
      return ctx.onCurrentPageDataChange($event);
    });
    \u0275\u0275elementStart(2, "thead")(3, "tr")(4, "th", 2);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.checked = $event;
    })("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.onAllChecked($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "th");
    \u0275\u0275text(6, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "th");
    \u0275\u0275text(8, "ID");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "th");
    \u0275\u0275text(10, "Rate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "th");
    \u0275\u0275text(12, "Last Order");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "th");
    \u0275\u0275text(14, "New Order");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "th");
    \u0275\u0275text(16, "Quantity");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "th");
    \u0275\u0275text(18, "Order Date");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "th");
    \u0275\u0275text(20, "Receiving Date");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "th");
    \u0275\u0275text(22, "Grade");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(23, "tbody");
    \u0275\u0275template(24, NzDemoTableRowSelectionCustomComponent_tr_24_Template, 20, 10, "tr", 3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzPageSize", ctx.pageSize)("nzPageIndex", ctx.pageIndex);
    \u0275\u0275advance(4);
    \u0275\u0275property("nzSelections", ctx.listOfSelection)("nzChecked", ctx.checked)("nzIndeterminate", ctx.indeterminate);
    \u0275\u0275advance(20);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzThSelectionComponent, CommonModule, NgForOf, NzAvatarModule, NzBadgeModule], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent8 = _NzDemoTableRowSelectionCustomComponent8;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent8, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\pages\\supplyChain\\components\\table.ts", lineNumber: 73 });
})();

// src/app/routes/pages/supplyChain/components/time.component.ts
var _NzDemoTimelineCustomComponent2 = class _NzDemoTimelineCustomComponent2 {
  constructor() {
    this.reverse = false;
  }
  toggleReverse() {
    this.reverse = !this.reverse;
  }
};
_NzDemoTimelineCustomComponent2.\u0275fac = function NzDemoTimelineCustomComponent_Factory(t) {
  return new (t || _NzDemoTimelineCustomComponent2)();
};
_NzDemoTimelineCustomComponent2.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTimelineCustomComponent2, selectors: [["nz-demo-timeline-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 7, vars: 2, consts: [["height", "200", 3, "nzPending", "nzReverse"]], template: function NzDemoTimelineCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-timeline", 0)(1, "nz-timeline-item");
    \u0275\u0275text(2, "Create a services site 2015-09-01");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-timeline-item");
    \u0275\u0275text(4, "Solve initial network problems 2015-09-01");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "nz-timeline-item");
    \u0275\u0275text(6, "Technical testing 2015-09-01");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPending", "Recording...")("nzReverse", ctx.reverse);
  }
}, dependencies: [NzTimelineModule, NzTimelineItemComponent, NzTimelineComponent], encapsulation: 2 });
var NzDemoTimelineCustomComponent2 = _NzDemoTimelineCustomComponent2;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTimelineCustomComponent2, { className: "NzDemoTimelineCustomComponent", filePath: "src\\app\\routes\\pages\\supplyChain\\components\\time.component.ts", lineNumber: 17 });
})();

// src/app/routes/pages/supplyChain/supplyChain.component.ts
function SupplyChainComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 16);
    \u0275\u0275element(1, "span", 17);
    \u0275\u0275elementEnd();
  }
}
function SupplyChainComponent_ng_template_28_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Sales Statistics ");
    \u0275\u0275elementStart(1, "small", 18);
    \u0275\u0275text(2, "Business Expectations & Retail Sales Statistics");
    \u0275\u0275elementEnd();
  }
}
var _SupplyChainComponent = class _SupplyChainComponent {
  constructor() {
    this.http = inject(_HttpClient);
    this.cdr = inject(ChangeDetectorRef);
    this.obSrv = inject(OnboardingService);
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  ngOnInit() {
    setTimeout(() => {
    }, 1e3);
  }
};
_SupplyChainComponent.\u0275fac = function SupplyChainComponent_Factory(t) {
  return new (t || _SupplyChainComponent)();
};
_SupplyChainComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _SupplyChainComponent, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 30, vars: 7, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "6", 1, "mb-md", 2, "width", "auto"], [3, "nzPlaceHolder"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "12", 1, "mb-md"], ["nzSearch", "", 2, "width", "100%", 3, "nzAddOnAfter"], ["type", "text", "nz-input", "", "placeholder", "input search text"], ["suffixIconButton", ""], ["nz-col", "", "nzXs", "24", "nzMd", "24"], [3, "nzBordered", "nzTitle"], ["nz-col", "", "nzXs", "24", "nzMd", "12"], [3, "nzTitle"], ["nzText", "Message-1", "nzColor", "red"], ["nzTitle", "Pushes open the window", "nzSize", "small"], ["nzText", "Message-2", "nzColor", "green"], ["salesTitle", ""], ["nz-button", "", "nzType", "primary", "nzSearch", ""], ["nz-icon", "", "nzType", "search"], [1, "text-sm", "font-weight-normal"]], template: function SupplyChainComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Supply-chain ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2);
    \u0275\u0275element(7, "nz-demo-select-search", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 4)(9, "nz-input-group", 5);
    \u0275\u0275element(10, "input", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275template(11, SupplyChainComponent_ng_template_11_Template, 2, 0, "ng-template", null, 7, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "div", 1)(14, "div", 8)(15, "nz-card", 9);
    \u0275\u0275element(16, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 10)(18, "nz-card", 11)(19, "nz-ribbon", 12)(20, "nz-card", 13);
    \u0275\u0275text(21, " And raises the spyglass. ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "nz-ribbon", 14)(23, "nz-card", 13);
    \u0275\u0275text(24, " And raises the spyglass. ");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(25, "div", 10)(26, "nz-card", 9);
    \u0275\u0275element(27, "chart-pie-basic");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(28, SupplyChainComponent_ng_template_28_Template, 3, 0, "ng-template", null, 15, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(12);
    \u0275\u0275advance(7);
    \u0275\u0275property("nzPlaceHolder", "Item");
    \u0275\u0275advance(2);
    \u0275\u0275property("nzAddOnAfter", _r1);
    \u0275\u0275advance(6);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Material Stock");
    \u0275\u0275advance(3);
    \u0275\u0275property("nzTitle", "Messages");
    \u0275\u0275advance(8);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Material Consumption");
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzButtonComponent,
  NzTransitionPatchDirective,
  NzWaveDirective,
  NzInputModule,
  NzInputDirective,
  NzInputGroupComponent,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzIconDirective,
  NzCheckboxModule,
  NzSpinModule,
  G2TimelineModule,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  OnboardingModule,
  NzDemoTableRowSelectionCustomComponent8,
  NzDemoSelectSearchComponent7,
  ChartPieBasicComponent6,
  NzBadgeModule,
  NzRibbonComponent
], encapsulation: 2, changeDetection: 0 });
var SupplyChainComponent = _SupplyChainComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(SupplyChainComponent, { className: "SupplyChainComponent", filePath: "src\\app\\routes\\pages\\supplyChain\\supplyChain.component.ts", lineNumber: 42 });
})();

// src/app/routes/pages/vehicles/charts/pie.component.ts
var _c064 = ["pie"];
var _ChartPieBasicComponent7 = class _ChartPieBasicComponent7 {
  constructor(msg) {
    this.msg = msg;
    this.salesPieData = [];
    this.total = "";
    this.refresh();
  }
  refresh() {
    const rv = (min = 0, max = 5e3) => Math.floor(Math.random() * (max - min + 1) + min);
    this.salesPieData = [
      {
        x: "data1",
        y: rv()
      },
      {
        x: "data2",
        y: rv()
      }
    ];
    if (Math.random() > 0.5) {
      this.salesPieData.push({
        x: "data",
        y: rv()
      });
    }
    this.total = `&yen ${this.salesPieData.reduce((pre, now) => now.y + pre, 0).toFixed(2)}`;
    if (this.pie) {
      setTimeout(() => this.pie.changeData());
    }
  }
  format(val) {
    return `&yen ${val.toFixed(2)}`;
  }
  handleClick(data) {
    this.msg.info(`${data.item.x} - ${data.item.y}`);
  }
};
_ChartPieBasicComponent7.\u0275fac = function ChartPieBasicComponent_Factory(t) {
  return new (t || _ChartPieBasicComponent7)(\u0275\u0275directiveInject(NzMessageService));
};
_ChartPieBasicComponent7.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartPieBasicComponent7, selectors: [["chart-pie-basic"]], viewQuery: function ChartPieBasicComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c064, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.pie = _t.first);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 2, vars: 3, consts: [["title", "pie", "subTitle", "pie", "height", "200", "repaint", "false", 3, "total", "valueFormat", "data", "clickItem"], ["pie", ""]], template: function ChartPieBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-pie", 0, 1);
    \u0275\u0275listener("clickItem", function ChartPieBasicComponent_Template_g2_pie_clickItem_0_listener($event) {
      return ctx.handleClick($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("total", ctx.total)("valueFormat", ctx.format)("data", ctx.salesPieData);
  }
}, dependencies: [NzButtonModule, G2PieModule, G2PieComponent], encapsulation: 2 });
var ChartPieBasicComponent7 = _ChartPieBasicComponent7;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartPieBasicComponent7, { className: "ChartPieBasicComponent", filePath: "src\\app\\routes\\pages\\vehicles\\charts\\pie.component.ts", lineNumber: 25 });
})();

// src/app/routes/pages/vehicles/charts/rate.component.ts
function ChartCardStyle1Component_ng_template_1_Template6(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 4);
  }
}
var _ChartCardStyle1Component6 = class _ChartCardStyle1Component6 {
};
_ChartCardStyle1Component6.\u0275fac = function ChartCardStyle1Component_Factory(t) {
  return new (t || _ChartCardStyle1Component6)();
};
_ChartCardStyle1Component6.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ChartCardStyle1Component6, selectors: [["chart-card-style1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 9, vars: 4, consts: [["footer", "\u65E5\u8BBF\u95EE\u91CF 12,423", "contentHeight", "46", 3, "title", "bordered", "total", "action"], ["action", ""], ["flag", "up", 2, "margin", "0 16px 0 8px", "color", "rgba(0,0,0,.85)"], ["flag", "down", 2, "margin", "0 0 0 8px", "color", "rgba(0,0,0,.85)"], ["nz-tooltip", "", "nzTooltipTitle", "\u6307\u6807\u8BF4\u660E", "nz-icon", "", "nzType", "info-circle"]], template: function ChartCardStyle1Component_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "g2-card", 0);
    \u0275\u0275template(1, ChartCardStyle1Component_ng_template_1_Template6, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275text(3, " \u5468\u540C\u6BD4 ");
    \u0275\u0275elementStart(4, "trend", 2);
    \u0275\u0275text(5, "12%");
    \u0275\u0275elementEnd();
    \u0275\u0275text(6, " \u65E5\u73AF\u6BD4 ");
    \u0275\u0275elementStart(7, "trend", 3);
    \u0275\u0275text(8, "11%");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(2);
    \u0275\u0275property("title", "\u9500\u552E\u989D")("bordered", true)("total", "\xA5 126,560.00")("action", _r1);
  }
}, dependencies: [G2CardModule, G2CardComponent, NzToolTipModule, NzTooltipDirective, TrendModule, TrendComponent], encapsulation: 2 });
var ChartCardStyle1Component6 = _ChartCardStyle1Component6;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ChartCardStyle1Component6, { className: "ChartCardStyle1Component", filePath: "src\\app\\routes\\pages\\vehicles\\charts\\rate.component.ts", lineNumber: 23 });
})();

// src/app/routes/pages/vehicles/components/date.component.ts
var _NzDemoDatePickerPresettedRangesComponent3 = class _NzDemoDatePickerPresettedRangesComponent3 {
  constructor() {
    this.ranges = { Today: [/* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()], "This Month": [/* @__PURE__ */ new Date(), endOfMonth(/* @__PURE__ */ new Date())] };
  }
  onChange(result) {
    console.log("From: ", result[0], ", to: ", result[1]);
  }
};
_NzDemoDatePickerPresettedRangesComponent3.\u0275fac = function NzDemoDatePickerPresettedRangesComponent_Factory(t) {
  return new (t || _NzDemoDatePickerPresettedRangesComponent3)();
};
_NzDemoDatePickerPresettedRangesComponent3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoDatePickerPresettedRangesComponent3, selectors: [["nz-demo-date-picker-presetted-ranges"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 1, consts: [["nzShowTime", "", "nzFormat", "yyyy/MM/dd HH:mm:ss", "ngModel", "", 3, "nzRanges"]], template: function NzDemoDatePickerPresettedRangesComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-range-picker", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("nzRanges", ctx.ranges);
  }
}, dependencies: [NzDatePickerModule, NzDatePickerComponent, NzRangePickerComponent], styles: ["\n\nnz-date-picker[_ngcontent-%COMP%], nz-range-picker[_ngcontent-%COMP%] {\n  margin: 0 8px 12px 0;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiZGF0ZS5jb21wb25lbnQudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIlxuICAgICAgbnotZGF0ZS1waWNrZXIsXG4gICAgICBuei1yYW5nZS1waWNrZXIge1xuICAgICAgICBtYXJnaW46IDAgOHB4IDEycHggMDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFBQTtBQUVFLFVBQUEsRUFBQSxJQUFBLEtBQUE7OyIsCiAgIm5hbWVzIjogW10KfQo= */"] });
var NzDemoDatePickerPresettedRangesComponent3 = _NzDemoDatePickerPresettedRangesComponent3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoDatePickerPresettedRangesComponent3, { className: "NzDemoDatePickerPresettedRangesComponent", filePath: "src\\app\\routes\\pages\\vehicles\\components\\date.component.ts", lineNumber: 20 });
})();

// src/app/routes/pages/vehicles/components/select.ts
var _NzDemoSelectSearchComponent8 = class _NzDemoSelectSearchComponent8 {
  constructor() {
    this.selectedValue = null;
    this.nzPlaceHolder = "";
  }
};
_NzDemoSelectSearchComponent8.\u0275fac = function NzDemoSelectSearchComponent_Factory(t) {
  return new (t || _NzDemoSelectSearchComponent8)();
};
_NzDemoSelectSearchComponent8.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoSelectSearchComponent8, selectors: [["nz-demo-select-search"]], inputs: { nzPlaceHolder: "nzPlaceHolder" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 4, vars: 2, consts: [["nzShowSearch", "", "nzAllowClear", "", 2, "width", "100%", 3, "nzPlaceHolder", "ngModel", "ngModelChange"], ["nzLabel", "test-1", "nzValue", "test-1"], ["nzLabel", "test-2", "nzValue", "test-2"], ["nzLabel", "test-3", "nzValue", "test-3"]], template: function NzDemoSelectSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-select", 0);
    \u0275\u0275listener("ngModelChange", function NzDemoSelectSearchComponent_Template_nz_select_ngModelChange_0_listener($event) {
      return ctx.selectedValue = $event;
    });
    \u0275\u0275element(1, "nz-option", 1)(2, "nz-option", 2)(3, "nz-option", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("nzPlaceHolder", ctx.nzPlaceHolder)("ngModel", ctx.selectedValue);
  }
}, dependencies: [NzSelectModule, NzOptionComponent, NzSelectComponent, FormsModule, NgControlStatus, NgModel], styles: ["\n\nnz-select[_ngcontent-%COMP%] {\n  width: 200px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic2VsZWN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcbiAgICAgIG56LXNlbGVjdCB7XG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIH1cbiAgICAiXSwKICAibWFwcGluZ3MiOiAiO0FBQ007QUFDRSxTQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */"] });
var NzDemoSelectSearchComponent8 = _NzDemoSelectSearchComponent8;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoSelectSearchComponent8, { className: "NzDemoSelectSearchComponent", filePath: "src\\app\\routes\\pages\\vehicles\\components\\select.ts", lineNumber: 25 });
})();

// src/app/routes/pages/vehicles/components/modelTable.ts
function NzDemoTComponent_tr_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", data_r2.value, " ");
  }
}
var _NzDemoTComponent = class _NzDemoTComponent {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = [
      { name: "Car license", value: "1972 : \u0641 \u064A \u0646" },
      { name: "Expression Date", value: (/* @__PURE__ */ new Date()).toLocaleString() },
      { name: "Average Cost Per Month", value: "40$" },
      { name: "Current Trip From", value: "Cairo" },
      { name: "Current Trip to", value: "Giza" }
    ];
  }
};
_NzDemoTComponent.\u0275fac = function NzDemoTComponent_Factory(t) {
  return new (t || _NzDemoTComponent)();
};
_NzDemoTComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTComponent, selectors: [["nz-demo-model-table"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 10, vars: 3, consts: [[3, "nzData", "nzShowPagination"], ["rowSelectionTable", ""], [4, "ngFor", "ngForOf"]], template: function NzDemoTComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1)(2, "thead")(3, "tr")(4, "th");
    \u0275\u0275text(5, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "th");
    \u0275\u0275text(7, "Value");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(8, "tbody");
    \u0275\u0275template(9, NzDemoTComponent_tr_9_Template, 5, 2, "tr", 2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzShowPagination", false);
    \u0275\u0275advance(9);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTheadComponent, NzTbodyComponent, NzTrDirective, CommonModule, NgForOf, NzAvatarModule, NzBadgeModule], encapsulation: 2 });
var NzDemoTComponent = _NzDemoTComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTComponent, { className: "NzDemoTComponent", filePath: "src\\app\\routes\\pages\\vehicles\\components\\modelTable.ts", lineNumber: 51 });
})();

// src/app/routes/pages/vehicles/components/model.ts
function NzDemoModalBasicComponent_ng_container_3_Template2(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275element(1, "nz-demo-model-table");
    \u0275\u0275elementContainerEnd();
  }
}
var _c065 = ["*"];
var _NzDemoModalBasicComponent3 = class _NzDemoModalBasicComponent3 {
  constructor() {
    this.isVisible = false;
  }
  showModal() {
    this.isVisible = true;
  }
  handleOk() {
    console.log("Button ok clicked!");
    this.isVisible = false;
  }
  handleCancel() {
    console.log("Button cancel clicked!");
    this.isVisible = false;
  }
};
_NzDemoModalBasicComponent3.\u0275fac = function NzDemoModalBasicComponent_Factory(t) {
  return new (t || _NzDemoModalBasicComponent3)();
};
_NzDemoModalBasicComponent3.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoModalBasicComponent3, selectors: [["nz-demo-modal-basic"]], standalone: true, features: [\u0275\u0275StandaloneFeature], ngContentSelectors: _c065, decls: 4, vars: 1, consts: [[2, "cursor", "pointer", 3, "click"], ["nzTitle", "Vehicle Details", 3, "nzVisible", "nzVisibleChange", "nzOnCancel", "nzOnOk"], [4, "nzModalContent"]], template: function NzDemoModalBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projectionDef();
    \u0275\u0275elementStart(0, "span", 0);
    \u0275\u0275listener("click", function NzDemoModalBasicComponent_Template_span_click_0_listener() {
      return ctx.showModal();
    });
    \u0275\u0275projection(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "nz-modal", 1);
    \u0275\u0275listener("nzVisibleChange", function NzDemoModalBasicComponent_Template_nz_modal_nzVisibleChange_2_listener($event) {
      return ctx.isVisible = $event;
    })("nzOnCancel", function NzDemoModalBasicComponent_Template_nz_modal_nzOnCancel_2_listener() {
      return ctx.handleCancel();
    })("nzOnOk", function NzDemoModalBasicComponent_Template_nz_modal_nzOnOk_2_listener() {
      return ctx.handleOk();
    });
    \u0275\u0275template(3, NzDemoModalBasicComponent_ng_container_3_Template2, 2, 0, "ng-container", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275property("nzVisible", ctx.isVisible);
  }
}, dependencies: [NzModalModule, NzModalComponent, NzModalContentDirective, CommonModule, NzIconModule, NzDemoTComponent], encapsulation: 2 });
var NzDemoModalBasicComponent3 = _NzDemoModalBasicComponent3;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoModalBasicComponent3, { className: "NzDemoModalBasicComponent", filePath: "src\\app\\routes\\pages\\vehicles\\components\\model.ts", lineNumber: 24 });
})();

// src/app/routes/pages/vehicles/components/table.ts
function NzDemoTableRowSelectionCustomComponent_tr_28_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr")(1, "td", 4);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_tr_28_Template_td_nzCheckedChange_1_listener($event) {
      const restoredCtx = \u0275\u0275restoreView(_r4);
      const data_r2 = restoredCtx.$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onItemChecked(data_r2.id, $event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "td")(3, "a", 5)(4, "nz-demo-modal-basic");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(6, "td");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "td");
    \u0275\u0275text(9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "td");
    \u0275\u0275text(11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "td");
    \u0275\u0275text(13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "td");
    \u0275\u0275text(15);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "td");
    \u0275\u0275text(17);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "td");
    \u0275\u0275text(19);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "td");
    \u0275\u0275text(21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "td");
    \u0275\u0275text(23);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(24, "td");
    \u0275\u0275text(25);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("nzChecked", ctx_r1.setOfCheckedId.has(data_r2.id));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", data_r2.Vehicle, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.LastTrip);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.From);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.To);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.TimeStamp);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Performance);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Plate);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Driver);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.Distance);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.LastMaintenance);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(data_r2.NextMaintenance);
  }
}
var _NzDemoTableRowSelectionCustomComponent9 = class _NzDemoTableRowSelectionCustomComponent9 {
  constructor() {
    this.listOfSelection = [
      {
        text: "Select All Row",
        onSelect: () => {
          this.onAllChecked(true);
        }
      },
      {
        text: "Select Odd Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 !== 0));
          this.refreshCheckedStatus();
        }
      },
      {
        text: "Select Even Row",
        onSelect: () => {
          this.listOfCurrentPageData.forEach((data, index) => this.updateCheckedSet(data.id, index % 2 === 0));
          this.refreshCheckedStatus();
        }
      }
    ];
    this.checked = false;
    this.indeterminate = false;
    this.listOfCurrentPageData = [];
    this.listOfData = [];
    this.setOfCheckedId = /* @__PURE__ */ new Set();
    this.pageSize = 5;
    this.pageIndex = 1;
  }
  updateCheckedSet(id, checked) {
    if (checked) {
      this.setOfCheckedId.add(id);
    } else {
      this.setOfCheckedId.delete(id);
    }
  }
  onItemChecked(id, checked) {
    this.updateCheckedSet(id, checked);
    this.refreshCheckedStatus();
  }
  onAllChecked(value) {
    this.listOfCurrentPageData.forEach((item) => this.updateCheckedSet(item.id, value));
    this.refreshCheckedStatus();
  }
  onCurrentPageDataChange($event) {
    this.listOfCurrentPageData = $event;
    this.refreshCheckedStatus();
  }
  refreshCheckedStatus() {
    this.checked = this.listOfCurrentPageData.every((item) => this.setOfCheckedId.has(item.id));
    this.indeterminate = this.listOfCurrentPageData.some((item) => this.setOfCheckedId.has(item.id)) && !this.checked;
  }
  ngOnInit() {
    this.listOfData = new Array(200).fill(0).map((_, index) => ({
      id: index,
      Vehicle: `Vehicle ${index + 1}`,
      LastTrip: (Math.random() * 250).toFixed(2),
      From: `Cairo`,
      To: "Giza",
      TimeStamp: (/* @__PURE__ */ new Date()).toLocaleString(),
      Performance: `70 %`,
      Plate: "123ABC",
      Driver: "Hassan",
      Distance: (Math.random() * 1e3).toFixed(2),
      LastMaintenance: (/* @__PURE__ */ new Date()).toLocaleString(),
      NextMaintenance: (/* @__PURE__ */ new Date()).toLocaleString()
    }));
  }
};
_NzDemoTableRowSelectionCustomComponent9.\u0275fac = function NzDemoTableRowSelectionCustomComponent_Factory(t) {
  return new (t || _NzDemoTableRowSelectionCustomComponent9)();
};
_NzDemoTableRowSelectionCustomComponent9.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NzDemoTableRowSelectionCustomComponent9, selectors: [["nz-demo-table-row-selection-custom"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 29, vars: 7, consts: [["nzShowSizeChanger", "", 3, "nzData", "nzPageSize", "nzPageIndex", "nzCurrentPageDataChange"], ["rowSelectionTable", ""], [3, "nzSelections", "nzChecked", "nzIndeterminate", "nzCheckedChange"], [4, "ngFor", "ngForOf"], [3, "nzChecked", "nzCheckedChange"], [2, "text-decoration", "underline"]], template: function NzDemoTableRowSelectionCustomComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-table", 0, 1);
    \u0275\u0275listener("nzCurrentPageDataChange", function NzDemoTableRowSelectionCustomComponent_Template_nz_table_nzCurrentPageDataChange_0_listener($event) {
      return ctx.onCurrentPageDataChange($event);
    });
    \u0275\u0275elementStart(2, "thead")(3, "tr")(4, "th", 2);
    \u0275\u0275listener("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.checked = $event;
    })("nzCheckedChange", function NzDemoTableRowSelectionCustomComponent_Template_th_nzCheckedChange_4_listener($event) {
      return ctx.onAllChecked($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "th");
    \u0275\u0275text(6, "Vehicle ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "th");
    \u0275\u0275text(8, "Last Trip");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "th");
    \u0275\u0275text(10, "From ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "th");
    \u0275\u0275text(12, "To");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "th");
    \u0275\u0275text(14, "Time Stamp");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "th");
    \u0275\u0275text(16, "Performance");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "th");
    \u0275\u0275text(18, "Plate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "th");
    \u0275\u0275text(20, "Driver");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "th");
    \u0275\u0275text(22, "Distance");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "th");
    \u0275\u0275text(24, "Last Maintenance");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(25, "th");
    \u0275\u0275text(26, "Next Maintenance");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(27, "tbody");
    \u0275\u0275template(28, NzDemoTableRowSelectionCustomComponent_tr_28_Template, 26, 12, "tr", 3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(1);
    \u0275\u0275property("nzData", ctx.listOfData)("nzPageSize", ctx.pageSize)("nzPageIndex", ctx.pageIndex);
    \u0275\u0275advance(4);
    \u0275\u0275property("nzSelections", ctx.listOfSelection)("nzChecked", ctx.checked)("nzIndeterminate", ctx.indeterminate);
    \u0275\u0275advance(24);
    \u0275\u0275property("ngForOf", _r0.data);
  }
}, dependencies: [NzTableModule, NzTableComponent, NzTableCellDirective, NzThMeasureDirective, NzTdAddOnComponent, NzTheadComponent, NzTbodyComponent, NzTrDirective, NzThSelectionComponent, CommonModule, NgForOf, NzAvatarModule, NzBadgeModule, NzDemoModalBasicComponent3], encapsulation: 2 });
var NzDemoTableRowSelectionCustomComponent9 = _NzDemoTableRowSelectionCustomComponent9;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NzDemoTableRowSelectionCustomComponent9, { className: "NzDemoTableRowSelectionCustomComponent", filePath: "src\\app\\routes\\pages\\vehicles\\components\\table.ts", lineNumber: 77 });
})();

// src/app/routes/pages/vehicles/vehicles.component.ts
function VehiclesComponent_ng_template_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Sales Statistics ");
    \u0275\u0275elementStart(1, "small", 10);
    \u0275\u0275text(2, "Business Expectations & Retail Sales Statistics");
    \u0275\u0275elementEnd();
  }
}
var _VehiclesComponent = class _VehiclesComponent {
  constructor() {
    this.http = inject(_HttpClient);
    this.cdr = inject(ChangeDetectorRef);
    this.obSrv = inject(OnboardingService);
    this.platform = inject(Platform);
    this.doc = inject(DOCUMENT);
  }
  fixDark(chart) {
    if (!this.platform.isBrowser || this.doc.body.getAttribute("data-theme") !== "dark")
      return;
    chart.theme({
      styleSheet: {
        backgroundColor: "transparent"
      }
    });
  }
  ngOnInit() {
    setTimeout(() => {
    }, 1e3);
  }
};
_VehiclesComponent.\u0275fac = function VehiclesComponent_Factory(t) {
  return new (t || _VehiclesComponent)();
};
_VehiclesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _VehiclesComponent, selectors: [["app-dashboard-v1"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 21, vars: 5, consts: [[1, "alain-default__content-title"], ["nz-row", "", "nzGutter", "16"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "6", 1, "mb-md", 2, "width", "auto"], [3, "nzPlaceHolder"], ["nz-col", "", "nzXs", "24", "nzSm", "12", "nzMd", "12", 1, "mb-md"], ["nz-col", "", "nzXs", "24", "nzMd", "24"], [3, "nzBordered", "nzTitle"], [2, "padding", "0"], ["src", "https://www.google.com/maps/embed?pb=!1m14!1m12!1m3!1d110502.6118504635!2d31.176062206799557!3d30.05961134332401!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!5e0!3m2!1sen!2seg!4v1703774704130!5m2!1sen!2seg", "width", "100%", "height", "450", "allowfullscreen", "", "loading", "lazy", "referrerpolicy", "no-referrer-when-downgrade", 2, "border", "0"], ["salesTitle", ""], [1, "text-sm", "font-weight-normal"]], template: function VehiclesComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h1");
    \u0275\u0275text(2, " Vehicles ");
    \u0275\u0275elementStart(3, "small");
    \u0275\u0275text(4, "Welcome !");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(5, "div", 1)(6, "div", 2);
    \u0275\u0275element(7, "nz-demo-select-search", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 4);
    \u0275\u0275element(9, "nz-demo-date-picker-presetted-ranges");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "div", 1)(11, "div", 5)(12, "nz-card", 6)(13, "div", 7);
    \u0275\u0275element(14, "iframe", 8);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(15, "div", 1)(16, "div", 5)(17, "nz-card", 6);
    \u0275\u0275element(18, "nz-demo-table-row-selection-custom");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(19, VehiclesComponent_ng_template_19_Template, 3, 0, "ng-template", null, 9, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    \u0275\u0275advance(7);
    \u0275\u0275property("nzPlaceHolder", "Vehicle");
    \u0275\u0275advance(5);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Map");
    \u0275\u0275advance(5);
    \u0275\u0275property("nzBordered", false)("nzTitle", "Vehicles Details");
  }
}, dependencies: [
  FormsModule,
  ReactiveFormsModule,
  PageHeaderModule,
  STModule,
  SEModule,
  SVModule,
  ResultModule,
  DelonFormModule,
  NzFormModule,
  NzColDirective,
  NzRowDirective,
  NzGridModule,
  NzButtonModule,
  NzInputModule,
  NzInputNumberModule,
  NzAlertModule,
  NzProgressModule,
  NzSelectModule,
  NzAvatarModule,
  NzCardModule,
  NzCardComponent,
  NzDropDownModule,
  NzPopconfirmModule,
  NzTableModule,
  NzPopoverModule,
  NzDrawerModule,
  NzModalModule,
  NzTabsModule,
  NzToolTipModule,
  NzIconModule,
  NzCheckboxModule,
  NzSpinModule,
  G2TimelineModule,
  G2BarModule,
  G2MiniBarModule,
  QuickMenuModule,
  OnboardingModule,
  NzDemoTableRowSelectionCustomComponent9,
  NzDemoSelectSearchComponent8,
  NzDemoDatePickerPresettedRangesComponent3
], encapsulation: 2, changeDetection: 0 });
var VehiclesComponent = _VehiclesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(VehiclesComponent, { className: "VehiclesComponent", filePath: "src\\app\\routes\\pages\\vehicles\\vehicles.component.ts", lineNumber: 38 });
})();

// node_modules/@delon/theme/fesm2022/layout-default.mjs
var _c066 = ["host"];
function LayoutDefaultHeaderItemComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c139 = ["*"];
function LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 3);
  }
  if (rf & 2) {
    const i_r5 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("nzType", i_r5.value)("nzTheme", i_r5.theme)("nzSpin", i_r5.spin)("nzTwotoneColor", i_r5.twoToneColor)("nzIconfont", i_r5.iconfont)("nzRotate", i_r5.rotate);
  }
}
function LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 4);
  }
  if (rf & 2) {
    const i_r5 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("nzIconfont", i_r5.iconfont);
  }
}
function LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 5);
  }
  if (rf & 2) {
    const i_r5 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("src", i_r5.value, \u0275\u0275sanitizeUrl);
  }
}
function LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 6);
  }
  if (rf & 2) {
    const i_r5 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("innerHTML", i_r5.value, \u0275\u0275sanitizeHtml);
  }
}
function LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i");
  }
  if (rf & 2) {
    const i_r5 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275classMapInterpolate1("sidebar-nav__item-icon ", i_r5.value, "");
  }
}
function LayoutDefaultNavComponent_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_0_Template, 1, 6)(1, LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_1_Template, 1, 1)(2, LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_2_Template, 1, 1)(3, LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_3_Template, 1, 1)(4, LayoutDefaultNavComponent_ng_template_0_Conditional_0_Case_4_Template, 1, 3);
  }
  if (rf & 2) {
    const i_r5 = \u0275\u0275nextContext().$implicit;
    let LayoutDefaultNavComponent_ng_template_0_Conditional_0_contFlowTmp;
    \u0275\u0275conditional(0, (LayoutDefaultNavComponent_ng_template_0_Conditional_0_contFlowTmp = i_r5.type) === "icon" ? 0 : LayoutDefaultNavComponent_ng_template_0_Conditional_0_contFlowTmp === "iconfont" ? 1 : LayoutDefaultNavComponent_ng_template_0_Conditional_0_contFlowTmp === "img" ? 2 : LayoutDefaultNavComponent_ng_template_0_Conditional_0_contFlowTmp === "svg" ? 3 : 4);
  }
}
function LayoutDefaultNavComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LayoutDefaultNavComponent_ng_template_0_Conditional_0_Template, 5, 1);
  }
  if (rf & 2) {
    const i_r5 = ctx.$implicit;
    \u0275\u0275conditional(0, i_r5 ? 0 : -1);
  }
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Conditional_0_ng_template_1_Template(rf, ctx) {
}
var _c225 = (a0) => ({
  $implicit: a0
});
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275template(1, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r20 = \u0275\u0275nextContext(4).$implicit;
    \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("nzTooltipTitle", i_r20.text);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(3, _c225, i_r20.icon));
  }
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    const i_r20 = \u0275\u0275nextContext(4).$implicit;
    \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c225, i_r20.icon));
  }
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Conditional_0_Template, 2, 5, "span", 15)(1, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Conditional_1_Template, 1, 4);
  }
  if (rf & 2) {
    const ctx_r30 = \u0275\u0275nextContext(5);
    \u0275\u0275conditional(0, ctx_r30.collapsed ? 0 : 1);
  }
}
var _c318 = (a0) => ({
  "sidebar-nav__item-disabled": a0
});
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r39 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 13);
    \u0275\u0275listener("click", function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r39);
      const i_r20 = \u0275\u0275nextContext(2).$implicit;
      const ctx_r37 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r37.to(i_r20));
    })("mouseenter", function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Template_a_mouseenter_0_listener() {
      \u0275\u0275restoreView(_r39);
      const ctx_r40 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r40.closeSubMenu());
    });
    \u0275\u0275template(1, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Conditional_1_Template, 2, 1);
    \u0275\u0275element(2, "span", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r20 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(5, _c318, i_r20.disabled));
    \u0275\u0275attribute("data-id", i_r20._id);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, i_r20._needIcon ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", i_r20._text, \u0275\u0275sanitizeHtml);
    \u0275\u0275attribute("title", i_r20.text);
  }
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_2_ng_template_1_Template(rf, ctx) {
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r45 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 17);
    \u0275\u0275listener("click", function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_2_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r45);
      const i_r20 = \u0275\u0275nextContext(2).$implicit;
      const ctx_r43 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r43.toggleOpen(i_r20));
    })("mouseenter", function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_2_Template_a_mouseenter_0_listener($event) {
      \u0275\u0275restoreView(_r45);
      const i_r20 = \u0275\u0275nextContext(2).$implicit;
      const ctx_r46 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r46.showSubMenu($event, i_r20));
    });
    \u0275\u0275template(1, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_2_ng_template_1_Template, 0, 0, "ng-template", 16);
    \u0275\u0275element(2, "span", 14)(3, "i", 18);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r20 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275nextContext(2);
    const _r1 = \u0275\u0275reference(1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c225, i_r20.icon));
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", i_r20._text, \u0275\u0275sanitizeHtml);
    \u0275\u0275attribute("title", i_r20.text);
  }
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "nz-badge", 11);
  }
  if (rf & 2) {
    const i_r20 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("nzCount", i_r20.badge)("nzDot", i_r20.badgeDot)("nzOverflowCount", 9);
  }
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_4_ng_template_1_Template(rf, ctx) {
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul");
    \u0275\u0275template(1, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_4_ng_template_1_Template, 0, 0, "ng-template", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r20 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275nextContext(2);
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275classMapInterpolate1("sidebar-nav sidebar-nav__sub sidebar-nav__depth", i_r20._depth, "");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r3)("ngTemplateOutletContext", \u0275\u0275pureFunction1(5, _c225, i_r20.children));
  }
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 8);
    \u0275\u0275template(1, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_1_Template, 3, 7, "a", 9)(2, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_2_Template, 4, 6, "a", 10)(3, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_3_Template, 1, 3, "nz-badge", 11)(4, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Conditional_4_Template, 2, 7, "ul", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r20 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275classProp("sidebar-nav__selected", i_r20._selected)("sidebar-nav__open", i_r20.open);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, i_r20.children.length === 0 ? 1 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(2, i_r20.children.length > 0 ? 2 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(3, i_r20.badge ? 3 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(4, i_r20.children.length > 0 ? 4 : -1);
  }
}
function LayoutDefaultNavComponent_ng_template_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LayoutDefaultNavComponent_ng_template_2_For_1_Conditional_0_Template, 5, 8, "li", 7);
  }
  if (rf & 2) {
    const i_r20 = ctx.$implicit;
    \u0275\u0275conditional(0, i_r20._hidden !== true ? 0 : -1);
  }
}
function LayoutDefaultNavComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, LayoutDefaultNavComponent_ng_template_2_For_1_Template, 1, 1, null, null, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ls_r18 = ctx.$implicit;
    \u0275\u0275repeater(ls_r18);
  }
}
function LayoutDefaultNavComponent_For_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 20);
    \u0275\u0275element(1, "span", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const group_r53 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("innerHTML", group_r53._text, \u0275\u0275sanitizeHtml);
  }
}
function LayoutDefaultNavComponent_For_6_ng_template_1_Template(rf, ctx) {
}
function LayoutDefaultNavComponent_For_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LayoutDefaultNavComponent_For_6_Conditional_0_Template, 2, 1, "li", 19)(1, LayoutDefaultNavComponent_For_6_ng_template_1_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    const group_r53 = ctx.$implicit;
    \u0275\u0275nextContext();
    const _r3 = \u0275\u0275reference(3);
    \u0275\u0275conditional(0, group_r53.group ? 0 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", _r3)("ngTemplateOutletContext", \u0275\u0275pureFunction1(3, _c225, group_r53.children));
  }
}
function LayoutDefaultHeaderComponent_ng_template_0_For_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function LayoutDefaultHeaderComponent_ng_template_0_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li");
    \u0275\u0275template(1, LayoutDefaultHeaderComponent_ng_template_0_For_1_ng_container_1_Template, 1, 0, "ng-container", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r10 = ctx.$implicit;
    \u0275\u0275classProp("hidden-mobile", i_r10.hidden === "mobile")("hidden-pc", i_r10.hidden === "pc");
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", i_r10.host);
  }
}
function LayoutDefaultHeaderComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, LayoutDefaultHeaderComponent_ng_template_0_For_1_Template, 2, 5, "li", 7, \u0275\u0275repeaterTrackByIndex);
  }
  if (rf & 2) {
    const ls_r8 = ctx.$implicit;
    \u0275\u0275repeater(ls_r8);
  }
}
function LayoutDefaultHeaderComponent_Conditional_3_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function LayoutDefaultHeaderComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LayoutDefaultHeaderComponent_Conditional_3_ng_container_0_Template, 1, 0, "ng-container", 6);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.opt.logo);
  }
}
function LayoutDefaultHeaderComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 8);
    \u0275\u0275element(1, "img", 9)(2, "img", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("routerLink", ctx_r3.opt.logoLink);
    \u0275\u0275advance(1);
    \u0275\u0275attribute("src", ctx_r3.opt.logoExpanded, \u0275\u0275sanitizeUrl)("alt", ctx_r3.app.name);
    \u0275\u0275advance(1);
    \u0275\u0275attribute("src", ctx_r3.opt.logoCollapsed, \u0275\u0275sanitizeUrl)("alt", ctx_r3.app.name);
  }
}
function LayoutDefaultHeaderComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li")(1, "div", 11);
    \u0275\u0275listener("click", function LayoutDefaultHeaderComponent_Conditional_7_Template_div_click_1_listener() {
      \u0275\u0275restoreView(_r18);
      const ctx_r17 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r17.toggleCollapsed());
    });
    \u0275\u0275element(2, "span", 12);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("nzType", ctx_r4.collapsedIcon);
  }
}
function LayoutDefaultHeaderComponent_ng_template_8_Template(rf, ctx) {
}
function LayoutDefaultHeaderComponent_Conditional_9_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function LayoutDefaultHeaderComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275template(1, LayoutDefaultHeaderComponent_Conditional_9_ng_container_1_Template, 1, 0, "ng-container", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r6.middle[0].host);
  }
}
function LayoutDefaultHeaderComponent_ng_template_11_Template(rf, ctx) {
}
function LayoutDefaultComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 5);
  }
}
function LayoutDefaultComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "layout-default-header", 1);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("items", ctx_r1.headerItems);
  }
}
function LayoutDefaultComponent_Conditional_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function LayoutDefaultComponent_Conditional_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function LayoutDefaultComponent_Conditional_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "layout-default-nav");
  }
}
function LayoutDefaultComponent_Conditional_2_Conditional_6_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function LayoutDefaultComponent_Conditional_2_Conditional_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LayoutDefaultComponent_Conditional_2_Conditional_6_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 4);
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r8.asideBottom);
  }
}
function LayoutDefaultComponent_Conditional_2_Conditional_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275listener("click", function LayoutDefaultComponent_Conditional_2_Conditional_6_Conditional_2_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r11 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r11.toggleCollapsed());
    });
    \u0275\u0275element(1, "span", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzType", ctx_r9.collapsedIcon);
  }
}
function LayoutDefaultComponent_Conditional_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275template(1, LayoutDefaultComponent_Conditional_2_Conditional_6_Conditional_1_Template, 1, 1, "ng-container")(2, LayoutDefaultComponent_Conditional_2_Conditional_6_Conditional_2_Template, 2, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r7.asideBottom ? 1 : 2);
  }
}
function LayoutDefaultComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6)(1, "div", 7)(2, "div", 8);
    \u0275\u0275template(3, LayoutDefaultComponent_Conditional_2_ng_container_3_Template, 1, 0, "ng-container", 4)(4, LayoutDefaultComponent_Conditional_2_ng_container_4_Template, 1, 0, "ng-container", 4)(5, LayoutDefaultComponent_Conditional_2_Conditional_5_Template, 1, 0, "layout-default-nav");
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, LayoutDefaultComponent_Conditional_2_Conditional_6_Template, 3, 1, "div", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.asideUser);
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.nav);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(5, !ctx_r2.nav ? 5 : -1);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(6, ctx_r2.opt.showSiderCollapse ? 6 : -1);
  }
}
function LayoutDefaultComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
var _LayoutDefaultHeaderItemComponent = class _LayoutDefaultHeaderItemComponent {
  constructor() {
    this.hidden = "none";
    this.direction = "right";
  }
};
_LayoutDefaultHeaderItemComponent.\u0275fac = function LayoutDefaultHeaderItemComponent_Factory(t) {
  return new (t || _LayoutDefaultHeaderItemComponent)();
};
_LayoutDefaultHeaderItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LayoutDefaultHeaderItemComponent,
  selectors: [["layout-default-header-item"]],
  viewQuery: function LayoutDefaultHeaderItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c066, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.host = _t.first);
    }
  },
  inputs: {
    hidden: "hidden",
    direction: "direction"
  },
  ngContentSelectors: _c139,
  decls: 2,
  vars: 0,
  consts: [["host", ""]],
  template: function LayoutDefaultHeaderItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, LayoutDefaultHeaderItemComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
  },
  encapsulation: 2
});
var LayoutDefaultHeaderItemComponent = _LayoutDefaultHeaderItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutDefaultHeaderItemComponent, [{
    type: Component,
    args: [{
      selector: "layout-default-header-item",
      template: `
    <ng-template #host>
      <ng-content />
    </ng-template>
  `
    }]
  }], null, {
    host: [{
      type: ViewChild,
      args: ["host", {
        static: true
      }]
    }],
    hidden: [{
      type: Input
    }],
    direction: [{
      type: Input
    }]
  });
})();
var DEFAULT2 = {
  logoExpanded: `./assets/logo-full.svg`,
  logoCollapsed: `./assets/logo.svg`,
  logoLink: `/`,
  showHeaderCollapse: true,
  showSiderCollapse: false,
  hideAside: false,
  hideHeader: false
};
var _LayoutDefaultService = class _LayoutDefaultService {
  get options() {
    return this._options;
  }
  get options$() {
    return this._options$.asObservable();
  }
  get collapsedIcon() {
    const collapsed = this.settings.layout.collapsed;
    let type = collapsed ? "unfold" : "fold";
    if (this.settings.layout.direction === "rtl") {
      type = collapsed ? "fold" : "unfold";
    }
    return `menu-${type}`;
  }
  constructor(settings) {
    this.settings = settings;
    this._options$ = new BehaviorSubject(DEFAULT2);
    this._options = DEFAULT2;
  }
  notify() {
    this._options$.next(this._options);
  }
  /**
   * Set layout configuration
   *
   * 设置布局配置
   */
  setOptions(options) {
    this._options = __spreadValues(__spreadValues({}, DEFAULT2), options);
    this.notify();
  }
  /**
   * Toggle the collapsed state of the sidebar menu bar
   *
   * 切换侧边栏菜单栏折叠状态
   */
  toggleCollapsed(status) {
    this.settings.setLayout("collapsed", status != null ? status : !this.settings.layout.collapsed);
    this.notify();
  }
};
_LayoutDefaultService.\u0275fac = function LayoutDefaultService_Factory(t) {
  return new (t || _LayoutDefaultService)(\u0275\u0275inject(SettingsService));
};
_LayoutDefaultService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _LayoutDefaultService,
  factory: _LayoutDefaultService.\u0275fac,
  providedIn: "root"
});
var LayoutDefaultService = _LayoutDefaultService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutDefaultService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: SettingsService
  }], null);
})();
var SHOWCLS = "sidebar-nav__floating-show";
var FLOATINGCLS = "sidebar-nav__floating";
var _LayoutDefaultNavComponent = class _LayoutDefaultNavComponent {
  set openStrictly(value) {
    this.menuSrv.openStrictly = value;
  }
  get collapsed() {
    return this.settings.layout.collapsed;
  }
  constructor(menuSrv, settings, router, render, cdr, ngZone, sanitizer, doc, win, directionality) {
    this.menuSrv = menuSrv;
    this.settings = settings;
    this.router = router;
    this.render = render;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.sanitizer = sanitizer;
    this.doc = doc;
    this.win = win;
    this.directionality = directionality;
    this.destroy$ = inject(DestroyRef);
    this.dir = "ltr";
    this.list = [];
    this.disabledAcl = false;
    this.autoCloseUnderPad = true;
    this.recursivePath = true;
    this.maxLevelIcon = 3;
    this.select = new EventEmitter();
  }
  getLinkNode(node) {
    node = node.nodeName === "A" ? node : node.parentNode;
    return node.nodeName !== "A" ? null : node;
  }
  floatingClickHandle(e) {
    e.stopPropagation();
    const linkNode = this.getLinkNode(e.target);
    if (linkNode == null) {
      return false;
    }
    const id = +linkNode.dataset.id;
    if (isNaN(id)) {
      return false;
    }
    let item;
    this.menuSrv.visit(this.list, (i) => {
      if (!item && i._id === id) {
        item = i;
      }
    });
    this.to(item);
    this.hideAll();
    e.preventDefault();
    return false;
  }
  clearFloating() {
    if (!this.floatingEl)
      return;
    this.floatingEl.removeEventListener("click", this.floatingClickHandle.bind(this));
    if (this.floatingEl.hasOwnProperty("remove")) {
      this.floatingEl.remove();
    } else if (this.floatingEl.parentNode) {
      this.floatingEl.parentNode.removeChild(this.floatingEl);
    }
  }
  genFloating() {
    this.clearFloating();
    this.floatingEl = this.render.createElement("div");
    this.floatingEl.classList.add(`${FLOATINGCLS}-container`);
    this.floatingEl.addEventListener("click", this.floatingClickHandle.bind(this), false);
    this.bodyEl.appendChild(this.floatingEl);
  }
  genSubNode(linkNode, item) {
    const id = `_sidebar-nav-${item._id}`;
    const childNode = item.badge ? linkNode.nextElementSibling.nextElementSibling : linkNode.nextElementSibling;
    const node = childNode.cloneNode(true);
    node.id = id;
    node.classList.add(FLOATINGCLS);
    node.addEventListener("mouseleave", () => {
      node.classList.remove(SHOWCLS);
    }, false);
    this.floatingEl.appendChild(node);
    return node;
  }
  hideAll() {
    const allNode = this.floatingEl.querySelectorAll(`.${FLOATINGCLS}`);
    for (let i = 0; i < allNode.length; i++) {
      allNode[i].classList.remove(SHOWCLS);
    }
  }
  // calculate the node position values.
  calPos(linkNode, node) {
    const rect = linkNode.getBoundingClientRect();
    const scrollTop = Math.max(this.doc.documentElement.scrollTop, this.bodyEl.scrollTop);
    const docHeight = Math.max(this.doc.documentElement.clientHeight, this.bodyEl.clientHeight);
    const spacing = 5;
    let offsetHeight = -spacing;
    if (docHeight < rect.top + node.clientHeight) {
      offsetHeight = rect.top + node.clientHeight - docHeight + spacing;
    }
    node.style.top = `${rect.top + scrollTop - offsetHeight}px`;
    if (this.dir === "rtl") {
      node.style.right = `${rect.width + spacing}px`;
    } else {
      node.style.left = `${rect.right + spacing}px`;
    }
  }
  showSubMenu(e, item) {
    if (this.collapsed !== true) {
      return;
    }
    e.preventDefault();
    const linkNode = e.target;
    this.genFloating();
    const subNode = this.genSubNode(linkNode, item);
    this.hideAll();
    subNode.classList.add(SHOWCLS);
    this.calPos(linkNode, subNode);
  }
  to(item) {
    this.select.emit(item);
    if (item.disabled)
      return;
    if (item.externalLink) {
      if (item.target === "_blank") {
        this.win.open(item.externalLink);
      } else {
        this.win.location.href = item.externalLink;
      }
      return;
    }
    this.ngZone.run(() => this.router.navigateByUrl(item.link));
  }
  toggleOpen(item) {
    this.menuSrv.toggleOpen(item);
  }
  _click() {
    if (this.isPad && this.collapsed) {
      this.openAside(false);
      this.hideAll();
    }
  }
  closeSubMenu() {
    if (this.collapsed) {
      this.hideAll();
    }
  }
  openByUrl(url) {
    const {
      menuSrv,
      recursivePath
    } = this;
    this.menuSrv.open(menuSrv.find({
      url,
      recursive: recursivePath
    }));
  }
  ngOnInit() {
    const {
      doc,
      router,
      menuSrv,
      settings,
      cdr
    } = this;
    this.bodyEl = doc.querySelector("body");
    menuSrv.change.pipe(takeUntilDestroyed(this.destroy$)).subscribe((data) => {
      menuSrv.visit(data, (i, _p, depth) => {
        i._text = this.sanitizer.bypassSecurityTrustHtml(i.text);
        i._needIcon = depth <= this.maxLevelIcon && !!i.icon;
        if (!i._aclResult) {
          if (this.disabledAcl) {
            i.disabled = true;
          } else {
            i._hidden = true;
          }
        }
        const icon = i.icon;
        if (icon && icon.type === "svg" && typeof icon.value === "string") {
          icon.value = this.sanitizer.bypassSecurityTrustHtml(icon.value);
        }
      });
      this.fixHide(data);
      this.list = data.filter((w) => w._hidden !== true);
      cdr.detectChanges();
    });
    router.events.pipe(takeUntilDestroyed(this.destroy$)).subscribe((e) => {
      if (e instanceof NavigationEnd) {
        this.openByUrl(e.urlAfterRedirects);
        this.underPad();
        this.cdr.detectChanges();
      }
    });
    settings.notify.pipe(takeUntilDestroyed(this.destroy$), filter((t) => t.type === "layout" && t.name === "collapsed")).subscribe(() => this.clearFloating());
    this.underPad();
    this.dir = this.directionality.value;
    this.directionality.change?.pipe(takeUntilDestroyed(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.openByUrl(router.url);
    this.ngZone.runOutsideAngular(() => this.genFloating());
  }
  fixHide(ls) {
    const inFn = (list2) => {
      for (const item of list2) {
        if (item.children && item.children.length > 0) {
          inFn(item.children);
          if (!item._hidden) {
            item._hidden = item.children.every((v) => v._hidden);
          }
        }
      }
    };
    inFn(ls);
  }
  ngOnDestroy() {
    this.clearFloating();
  }
  // #region Under pad
  get isPad() {
    return this.doc.defaultView.innerWidth < 768;
  }
  underPad() {
    if (this.autoCloseUnderPad && this.isPad && !this.collapsed) {
      setTimeout(() => this.openAside(true));
    }
  }
  openAside(status) {
    this.settings.setLayout("collapsed", status);
  }
};
_LayoutDefaultNavComponent.\u0275fac = function LayoutDefaultNavComponent_Factory(t) {
  return new (t || _LayoutDefaultNavComponent)(\u0275\u0275directiveInject(MenuService), \u0275\u0275directiveInject(SettingsService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(DomSanitizer), \u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(WINDOW), \u0275\u0275directiveInject(Directionality, 8));
};
_LayoutDefaultNavComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LayoutDefaultNavComponent,
  selectors: [["layout-default-nav"]],
  hostVars: 2,
  hostBindings: function LayoutDefaultNavComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function LayoutDefaultNavComponent_click_HostBindingHandler() {
        return ctx._click();
      })("click", function LayoutDefaultNavComponent_click_HostBindingHandler() {
        return ctx.closeSubMenu();
      }, false, \u0275\u0275resolveDocument);
    }
    if (rf & 2) {
      \u0275\u0275classProp("d-block", true);
    }
  },
  inputs: {
    disabledAcl: "disabledAcl",
    autoCloseUnderPad: "autoCloseUnderPad",
    recursivePath: "recursivePath",
    openStrictly: "openStrictly",
    maxLevelIcon: "maxLevelIcon"
  },
  outputs: {
    select: "select"
  },
  decls: 7,
  vars: 0,
  consts: [["icon", ""], ["tree", ""], [1, "sidebar-nav"], ["nz-icon", "", 1, "sidebar-nav__item-icon", 3, "nzType", "nzTheme", "nzSpin", "nzTwotoneColor", "nzIconfont", "nzRotate"], ["nz-icon", "", 1, "sidebar-nav__item-icon", 3, "nzIconfont"], [1, "sidebar-nav__item-icon", "sidebar-nav__item-img", 3, "src"], [1, "sidebar-nav__item-icon", "sidebar-nav__item-svg", 3, "innerHTML"], ["class", "sidebar-nav__item", 3, "sidebar-nav__selected", "sidebar-nav__open"], [1, "sidebar-nav__item"], ["class", "sidebar-nav__item-link", 3, "ngClass"], ["class", "sidebar-nav__item-link"], ["nzStandalone", "", 3, "nzCount", "nzDot", "nzOverflowCount"], [3, "class"], [1, "sidebar-nav__item-link", 3, "ngClass", "click", "mouseenter"], [1, "sidebar-nav__item-text", 3, "innerHTML"], ["nz-tooltip", "", "nzTooltipPlacement", "right", 3, "nzTooltipTitle"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "sidebar-nav__item-link", 3, "click", "mouseenter"], [1, "sidebar-nav__sub-arrow"], ["class", "sidebar-nav__item sidebar-nav__group-title"], [1, "sidebar-nav__item", "sidebar-nav__group-title"], [3, "innerHTML"]],
  template: function LayoutDefaultNavComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, LayoutDefaultNavComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, LayoutDefaultNavComponent_ng_template_2_Template, 2, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(4, "ul", 2);
      \u0275\u0275repeaterCreate(5, LayoutDefaultNavComponent_For_6_Template, 2, 5, null, 16, \u0275\u0275repeaterTrackByIndex);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(5);
      \u0275\u0275repeater(ctx.list);
    }
  },
  dependencies: [NgClass, NgTemplateOutlet, NzTooltipDirective, NzIconDirective, NzBadgeComponent],
  encapsulation: 2,
  changeDetection: 0
});
var LayoutDefaultNavComponent = _LayoutDefaultNavComponent;
__decorate([InputBoolean2()], LayoutDefaultNavComponent.prototype, "disabledAcl", void 0);
__decorate([InputBoolean2()], LayoutDefaultNavComponent.prototype, "autoCloseUnderPad", void 0);
__decorate([InputBoolean2()], LayoutDefaultNavComponent.prototype, "recursivePath", void 0);
__decorate([InputBoolean2()], LayoutDefaultNavComponent.prototype, "openStrictly", null);
__decorate([InputNumber2()], LayoutDefaultNavComponent.prototype, "maxLevelIcon", void 0);
__decorate([ZoneOutside()], LayoutDefaultNavComponent.prototype, "showSubMenu", null);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutDefaultNavComponent, [{
    type: Component,
    args: [{
      selector: "layout-default-nav",
      host: {
        "(click)": "_click()",
        "(document:click)": "closeSubMenu()",
        "[class.d-block]": `true`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<ng-template #icon let-i>
  @if (i) {
    @switch (i.type) {
      @case ('icon') {
        <i
          class="sidebar-nav__item-icon"
          nz-icon
          [nzType]="i.value"
          [nzTheme]="i.theme"
          [nzSpin]="i.spin"
          [nzTwotoneColor]="i.twoToneColor"
          [nzIconfont]="i.iconfont"
          [nzRotate]="i.rotate"
        ></i>
      }
      @case ('iconfont') {
        <i class="sidebar-nav__item-icon" nz-icon [nzIconfont]="i.iconfont"></i>
      }
      @case ('img') {
        <img [src]="i.value" class="sidebar-nav__item-icon sidebar-nav__item-img" />
      }
      @case ('svg') {
        <span class="sidebar-nav__item-icon sidebar-nav__item-svg" [innerHTML]="i.value"></span>
      }
      @default {
        <i class="sidebar-nav__item-icon {{ i.value }}"></i>
      }
    }
  }
</ng-template>
<ng-template #tree let-ls>
  @for (i of ls; track $index) {
    @if (i._hidden !== true) {
      <li class="sidebar-nav__item" [class.sidebar-nav__selected]="i._selected" [class.sidebar-nav__open]="i.open">
        <!-- link -->
        @if (i.children.length === 0) {
          <a
            (click)="to(i)"
            [attr.data-id]="i._id"
            class="sidebar-nav__item-link"
            [ngClass]="{ 'sidebar-nav__item-disabled': i.disabled }"
            (mouseenter)="closeSubMenu()"
          >
            @if (i._needIcon) {
              @if (collapsed) {
                <span nz-tooltip nzTooltipPlacement="right" [nzTooltipTitle]="i.text">
                  <ng-template [ngTemplateOutlet]="icon" [ngTemplateOutletContext]="{ $implicit: i.icon }" />
                </span>
              } @else {
                <ng-template [ngTemplateOutlet]="icon" [ngTemplateOutletContext]="{ $implicit: i.icon }" />
              }
            }
            <span class="sidebar-nav__item-text" [innerHTML]="i._text" [attr.title]="i.text"></span>
          </a>
        }
        <!-- has children link -->
        @if (i.children.length > 0) {
          <a (click)="toggleOpen(i)" (mouseenter)="showSubMenu($event, i)" class="sidebar-nav__item-link">
            <ng-template [ngTemplateOutlet]="icon" [ngTemplateOutletContext]="{ $implicit: i.icon }" />
            <span class="sidebar-nav__item-text" [innerHTML]="i._text" [attr.title]="i.text"></span>
            <i class="sidebar-nav__sub-arrow"></i>
          </a>
        }
        <!-- badge -->
        @if (i.badge) {
          <nz-badge [nzCount]="i.badge" [nzDot]="i.badgeDot" nzStandalone [nzOverflowCount]="9" />
        }
        @if (i.children.length > 0) {
          <ul class="sidebar-nav sidebar-nav__sub sidebar-nav__depth{{ i._depth }}">
            <ng-template [ngTemplateOutlet]="tree" [ngTemplateOutletContext]="{ $implicit: i.children }" />
          </ul>
        }
      </li>
    }
  }
</ng-template>
<ul class="sidebar-nav">
  @for (group of list; track $index) {
    @if (group.group) {
      <li class="sidebar-nav__item sidebar-nav__group-title">
        <span [innerHTML]="group._text"></span>
      </li>
    }
    <ng-template [ngTemplateOutlet]="tree" [ngTemplateOutletContext]="{ $implicit: group.children }" />
  }
</ul>
`
    }]
  }], () => [{
    type: MenuService
  }, {
    type: SettingsService
  }, {
    type: Router
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: DomSanitizer
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [WINDOW]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    disabledAcl: [{
      type: Input
    }],
    autoCloseUnderPad: [{
      type: Input
    }],
    recursivePath: [{
      type: Input
    }],
    openStrictly: [{
      type: Input
    }],
    maxLevelIcon: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    showSubMenu: []
  });
})();
var _LayoutDefaultHeaderComponent = class _LayoutDefaultHeaderComponent {
  get opt() {
    return this.srv.options;
  }
  get app() {
    return this.settings.app;
  }
  get collapsed() {
    return this.settings.layout.collapsed;
  }
  get collapsedIcon() {
    return this.srv.collapsedIcon;
  }
  constructor(srv, settings, cdr) {
    this.srv = srv;
    this.settings = settings;
    this.cdr = cdr;
    this.destroy$ = inject(DestroyRef);
    this.left = [];
    this.middle = [];
    this.right = [];
  }
  refresh() {
    const arr = this.items.toArray();
    this.left = arr.filter((i) => i.direction === "left");
    this.middle = arr.filter((i) => i.direction === "middle");
    this.right = arr.filter((i) => i.direction === "right");
    this.cdr.detectChanges();
  }
  ngAfterViewInit() {
    this.items.changes.pipe(takeUntilDestroyed(this.destroy$)).subscribe(() => this.refresh());
    this.srv.options$.pipe(takeUntilDestroyed(this.destroy$)).subscribe(() => this.cdr.detectChanges());
    this.refresh();
  }
  toggleCollapsed() {
    this.srv.toggleCollapsed();
  }
};
_LayoutDefaultHeaderComponent.\u0275fac = function LayoutDefaultHeaderComponent_Factory(t) {
  return new (t || _LayoutDefaultHeaderComponent)(\u0275\u0275directiveInject(LayoutDefaultService), \u0275\u0275directiveInject(SettingsService), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_LayoutDefaultHeaderComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LayoutDefaultHeaderComponent,
  selectors: [["layout-default-header"]],
  hostVars: 2,
  hostBindings: function LayoutDefaultHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("alain-default__header", true);
    }
  },
  inputs: {
    items: "items"
  },
  decls: 12,
  vars: 13,
  consts: [["render", ""], [1, "alain-default__header-logo"], [1, "alain-default__nav-wrap"], [1, "alain-default__nav"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "alain-default__nav alain-default__nav-middle"], [4, "ngTemplateOutlet"], [3, "hidden-mobile", "hidden-pc"], [1, "alain-default__header-logo-link", 3, "routerLink"], [1, "alain-default__header-logo-expanded"], [1, "alain-default__header-logo-collapsed"], [1, "alain-default__nav-item", "alain-default__nav-item--collapse", 3, "click"], ["nz-icon", "", 3, "nzType"], [1, "alain-default__nav", "alain-default__nav-middle"]],
  template: function LayoutDefaultHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, LayoutDefaultHeaderComponent_ng_template_0_Template, 2, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275elementStart(2, "div", 1);
      \u0275\u0275template(3, LayoutDefaultHeaderComponent_Conditional_3_Template, 1, 1, "ng-container")(4, LayoutDefaultHeaderComponent_Conditional_4_Template, 3, 5);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "div", 2)(6, "ul", 3);
      \u0275\u0275template(7, LayoutDefaultHeaderComponent_Conditional_7_Template, 3, 1, "li")(8, LayoutDefaultHeaderComponent_ng_template_8_Template, 0, 0, "ng-template", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275template(9, LayoutDefaultHeaderComponent_Conditional_9_Template, 2, 1, "div", 5);
      \u0275\u0275elementStart(10, "ul", 3);
      \u0275\u0275template(11, LayoutDefaultHeaderComponent_ng_template_11_Template, 0, 0, "ng-template", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      const _r1 = \u0275\u0275reference(1);
      \u0275\u0275advance(2);
      \u0275\u0275styleProp("width", ctx.opt.logoFixWidth, "px");
      \u0275\u0275advance(1);
      \u0275\u0275conditional(3, ctx.opt.logo ? 3 : 4);
      \u0275\u0275advance(4);
      \u0275\u0275conditional(7, !ctx.opt.hideAside && ctx.opt.showHeaderCollapse ? 7 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(9, _c225, ctx.left));
      \u0275\u0275advance(1);
      \u0275\u0275conditional(9, ctx.middle.length > 0 ? 9 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngTemplateOutlet", _r1)("ngTemplateOutletContext", \u0275\u0275pureFunction1(11, _c225, ctx.right));
    }
  },
  dependencies: [NgTemplateOutlet, RouterLink, NzIconDirective],
  encapsulation: 2,
  changeDetection: 0
});
var LayoutDefaultHeaderComponent = _LayoutDefaultHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutDefaultHeaderComponent, [{
    type: Component,
    args: [{
      selector: "layout-default-header",
      template: `
    <ng-template #render let-ls>
      @for (i of ls; track $index) {
        <li [class.hidden-mobile]="i.hidden === 'mobile'" [class.hidden-pc]="i.hidden === 'pc'">
          <ng-container *ngTemplateOutlet="i.host" />
        </li>
      }
    </ng-template>
    <div class="alain-default__header-logo" [style.width.px]="opt.logoFixWidth">
      @if (opt.logo) {
        <ng-container *ngTemplateOutlet="opt.logo" />
      } @else {
        <a [routerLink]="opt.logoLink" class="alain-default__header-logo-link">
          <img class="alain-default__header-logo-expanded" [attr.src]="opt.logoExpanded" [attr.alt]="app.name" />
          <img class="alain-default__header-logo-collapsed" [attr.src]="opt.logoCollapsed" [attr.alt]="app.name" />
        </a>
      }
    </div>
    <div class="alain-default__nav-wrap">
      <ul class="alain-default__nav">
        @if (!opt.hideAside && opt.showHeaderCollapse) {
          <li>
            <div class="alain-default__nav-item alain-default__nav-item--collapse" (click)="toggleCollapsed()">
              <span nz-icon [nzType]="collapsedIcon"></span>
            </div>
          </li>
        }
        <ng-template [ngTemplateOutlet]="render" [ngTemplateOutletContext]="{ $implicit: left }" />
      </ul>
      @if (middle.length > 0) {
        <div class="alain-default__nav alain-default__nav-middle">
          <ng-container *ngTemplateOutlet="middle[0].host" />
        </div>
      }
      <ul class="alain-default__nav">
        <ng-template [ngTemplateOutlet]="render" [ngTemplateOutletContext]="{ $implicit: right }" />
      </ul>
    </div>
  `,
      host: {
        "[class.alain-default__header]": `true`
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: LayoutDefaultService
  }, {
    type: SettingsService
  }, {
    type: ChangeDetectorRef
  }], {
    items: [{
      type: Input
    }]
  });
})();
var _LayoutDefaultComponent = class _LayoutDefaultComponent {
  get opt() {
    return this.srv.options;
  }
  set options(value) {
    this.srv.setOptions(value);
  }
  get showFetching() {
    if (this.fetchingStrictly)
      return this.fetching;
    return this.isFetching;
  }
  get collapsed() {
    return this.settings.layout.collapsed;
  }
  get collapsedIcon() {
    return this.srv.collapsedIcon;
  }
  toggleCollapsed() {
    this.srv.toggleCollapsed();
  }
  constructor(router, msgSrv, settings, el, renderer, doc, srv) {
    this.msgSrv = msgSrv;
    this.settings = settings;
    this.el = el;
    this.renderer = renderer;
    this.doc = doc;
    this.srv = srv;
    this.asideUser = null;
    this.asideBottom = null;
    this.nav = null;
    this.content = null;
    this.fetchingStrictly = false;
    this.fetching = false;
    this.isFetching = false;
    router.events.pipe(takeUntilDestroyed(), filter(() => !this.fetchingStrictly)).subscribe((ev) => this.processEv(ev));
    this.srv.options$.pipe(takeUntilDestroyed()).subscribe(() => this.setClass());
    this.settings.notify.pipe(takeUntilDestroyed()).subscribe(() => this.setClass());
  }
  processEv(ev) {
    if (!this.isFetching && ev instanceof RouteConfigLoadStart) {
      this.isFetching = true;
    }
    if (ev instanceof NavigationError || ev instanceof NavigationCancel) {
      this.isFetching = false;
      const err = this.customError === null ? null : this.customError ?? `Could not load ${ev.url} route`;
      if (err && ev instanceof NavigationError) {
        this.msgSrv.error(err, {
          nzDuration: 1e3 * 3
        });
      }
      return;
    }
    if (!(ev instanceof NavigationEnd || ev instanceof RouteConfigLoadEnd)) {
      return;
    }
    if (this.isFetching) {
      setTimeout(() => {
        this.isFetching = false;
      }, 100);
    }
  }
  setClass() {
    const {
      el,
      doc,
      renderer,
      settings
    } = this;
    const layout = settings.layout;
    updateHostClass(el.nativeElement, renderer, {
      ["alain-default"]: true,
      [`alain-default__fixed`]: layout.fixed,
      [`alain-default__collapsed`]: layout.collapsed,
      [`alain-default__hide-aside`]: this.opt.hideAside,
      [`alain-default__hide-header`]: this.opt.hideHeader
    });
    doc.body.classList[layout.colorWeak ? "add" : "remove"]("color-weak");
  }
};
_LayoutDefaultComponent.\u0275fac = function LayoutDefaultComponent_Factory(t) {
  return new (t || _LayoutDefaultComponent)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(NzMessageService), \u0275\u0275directiveInject(SettingsService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(LayoutDefaultService));
};
_LayoutDefaultComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LayoutDefaultComponent,
  selectors: [["layout-default"]],
  contentQueries: function LayoutDefaultComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, LayoutDefaultHeaderItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerItems = _t);
    }
  },
  inputs: {
    options: "options",
    asideUser: "asideUser",
    asideBottom: "asideBottom",
    nav: "nav",
    content: "content",
    customError: "customError",
    fetchingStrictly: "fetchingStrictly",
    fetching: "fetching"
  },
  exportAs: ["layoutDefault"],
  ngContentSelectors: _c139,
  decls: 6,
  vars: 4,
  consts: [["class", "alain-default__progress-bar"], [3, "items"], ["class", "alain-default__aside"], [1, "alain-default__content"], [4, "ngTemplateOutlet"], [1, "alain-default__progress-bar"], [1, "alain-default__aside"], [1, "alain-default__aside-wrap"], [1, "alain-default__aside-inner"], ["class", "alain-default__aside-link"], [1, "alain-default__aside-link"], [1, "alain-default__aside-link-collapsed", 3, "click"], ["nz-icon", "", 3, "nzType"]],
  template: function LayoutDefaultComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, LayoutDefaultComponent_Conditional_0_Template, 1, 0, "div", 0)(1, LayoutDefaultComponent_Conditional_1_Template, 1, 1, "layout-default-header", 1)(2, LayoutDefaultComponent_Conditional_2_Template, 7, 4, "div", 2);
      \u0275\u0275elementStart(3, "section", 3);
      \u0275\u0275template(4, LayoutDefaultComponent_ng_container_4_Template, 1, 0, "ng-container", 4);
      \u0275\u0275projection(5);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, ctx.showFetching ? 0 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(1, !ctx.opt.hideHeader ? 1 : -1);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(2, !ctx.opt.hideAside ? 2 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngTemplateOutlet", ctx.content);
    }
  },
  dependencies: [NgTemplateOutlet, NzIconDirective, LayoutDefaultNavComponent, LayoutDefaultHeaderComponent],
  encapsulation: 2
});
var LayoutDefaultComponent = _LayoutDefaultComponent;
__decorate([InputBoolean2()], LayoutDefaultComponent.prototype, "fetchingStrictly", void 0);
__decorate([InputBoolean2()], LayoutDefaultComponent.prototype, "fetching", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutDefaultComponent, [{
    type: Component,
    args: [{
      selector: "layout-default",
      exportAs: "layoutDefault",
      template: `
    @if (showFetching) {
      <div class="alain-default__progress-bar"></div>
    }
    @if (!opt.hideHeader) {
      <layout-default-header [items]="headerItems" />
    }
    @if (!opt.hideAside) {
      <div class="alain-default__aside">
        <div class="alain-default__aside-wrap">
          <div class="alain-default__aside-inner">
            <ng-container *ngTemplateOutlet="asideUser" />
            <ng-container *ngTemplateOutlet="nav" />
            @if (!nav) {
              <layout-default-nav />
            }
          </div>
          @if (opt.showSiderCollapse) {
            <div class="alain-default__aside-link">
              @if (asideBottom) {
                <ng-container *ngTemplateOutlet="asideBottom" />
              } @else {
                <div class="alain-default__aside-link-collapsed" (click)="toggleCollapsed()">
                  <span nz-icon [nzType]="collapsedIcon"></span>
                </div>
              }
            </div>
          }
        </div>
      </div>
    }
    <section class="alain-default__content">
      <ng-container *ngTemplateOutlet="content" />
      <ng-content />
    </section>
  `
    }]
  }], () => [{
    type: Router
  }, {
    type: NzMessageService
  }, {
    type: SettingsService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: LayoutDefaultService
  }], {
    headerItems: [{
      type: ContentChildren,
      args: [LayoutDefaultHeaderItemComponent, {
        descendants: false
      }]
    }],
    options: [{
      type: Input
    }],
    asideUser: [{
      type: Input
    }],
    asideBottom: [{
      type: Input
    }],
    nav: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    customError: [{
      type: Input
    }],
    fetchingStrictly: [{
      type: Input
    }],
    fetching: [{
      type: Input
    }]
  });
})();
var _LayoutDefaultHeaderItemTriggerDirective = class _LayoutDefaultHeaderItemTriggerDirective {
};
_LayoutDefaultHeaderItemTriggerDirective.\u0275fac = function LayoutDefaultHeaderItemTriggerDirective_Factory(t) {
  return new (t || _LayoutDefaultHeaderItemTriggerDirective)();
};
_LayoutDefaultHeaderItemTriggerDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _LayoutDefaultHeaderItemTriggerDirective,
  selectors: [["", "layout-default-header-item-trigger", ""]],
  hostVars: 2,
  hostBindings: function LayoutDefaultHeaderItemTriggerDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("alain-default__nav-item", true);
    }
  }
});
var LayoutDefaultHeaderItemTriggerDirective = _LayoutDefaultHeaderItemTriggerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutDefaultHeaderItemTriggerDirective, [{
    type: Directive,
    args: [{
      selector: "[layout-default-header-item-trigger]",
      host: {
        "[class.alain-default__nav-item]": `true`
      }
    }]
  }], null, null);
})();
var _LayoutDefaultTopMenuItemComponent = class _LayoutDefaultTopMenuItemComponent {
  constructor() {
    this.selected = false;
    this.disabled = false;
  }
};
_LayoutDefaultTopMenuItemComponent.\u0275fac = function LayoutDefaultTopMenuItemComponent_Factory(t) {
  return new (t || _LayoutDefaultTopMenuItemComponent)();
};
_LayoutDefaultTopMenuItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LayoutDefaultTopMenuItemComponent,
  selectors: [["layout-default-top-menu-item"]],
  hostVars: 8,
  hostBindings: function LayoutDefaultTopMenuItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("alain-default__nav-item", true)("alain-default__top-menu-item", true)("alain-default__top-menu-item-selected", ctx.selected)("alain-default__top-menu-item-disabled", ctx.disabled);
    }
  },
  inputs: {
    selected: "selected",
    disabled: "disabled"
  },
  ngContentSelectors: _c139,
  decls: 1,
  vars: 0,
  template: function LayoutDefaultTopMenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var LayoutDefaultTopMenuItemComponent = _LayoutDefaultTopMenuItemComponent;
__decorate([InputBoolean2()], LayoutDefaultTopMenuItemComponent.prototype, "selected", void 0);
__decorate([InputBoolean2()], LayoutDefaultTopMenuItemComponent.prototype, "disabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutDefaultTopMenuItemComponent, [{
    type: Component,
    args: [{
      selector: "layout-default-top-menu-item",
      template: `<ng-content />`,
      host: {
        "[class.alain-default__nav-item]": `true`,
        "[class.alain-default__top-menu-item]": `true`,
        "[class.alain-default__top-menu-item-selected]": `selected`,
        "[class.alain-default__top-menu-item-disabled]": `disabled`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, {
    selected: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var COMPONENTS20 = [LayoutDefaultComponent, LayoutDefaultNavComponent, LayoutDefaultHeaderComponent, LayoutDefaultHeaderItemComponent, LayoutDefaultHeaderItemTriggerDirective, LayoutDefaultTopMenuItemComponent];
var _LayoutDefaultModule = class _LayoutDefaultModule {
};
_LayoutDefaultModule.\u0275fac = function LayoutDefaultModule_Factory(t) {
  return new (t || _LayoutDefaultModule)();
};
_LayoutDefaultModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LayoutDefaultModule
});
_LayoutDefaultModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule, NzToolTipModule, NzIconModule, NzAvatarModule, NzDropDownModule, NzMessageModule, NzBadgeModule]
});
var LayoutDefaultModule = _LayoutDefaultModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutDefaultModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, NzToolTipModule, NzIconModule, NzAvatarModule, NzDropDownModule, NzMessageModule, NzBadgeModule],
      declarations: COMPONENTS20,
      exports: COMPONENTS20
    }]
  }], null, null);
})();

// node_modules/@delon/theme/fesm2022/setting-drawer.mjs
var _c067 = () => ({
  standalone: true
});
function SettingDrawerItemComponent_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 1);
    \u0275\u0275listener("ngModelChange", function SettingDrawerItemComponent_Case_4_Template_input_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r5 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r5.i.value = $event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngModel", ctx_r0.i.value)("ngModelOptions", \u0275\u0275pureFunction0(2, _c067));
  }
}
function SettingDrawerItemComponent_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 2);
    \u0275\u0275listener("ngModelChange", function SettingDrawerItemComponent_Case_5_Template_input_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.i.value = $event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngModel", ctx_r1.i.value)("ngModelOptions", \u0275\u0275pureFunction0(2, _c067));
  }
}
function SettingDrawerItemComponent_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-input-number", 3);
    \u0275\u0275listener("ngModelChange", function SettingDrawerItemComponent_Case_6_Template_nz_input_number_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.pxVal = $event);
    })("ngModelChange", function SettingDrawerItemComponent_Case_6_Template_nz_input_number_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r11 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r11.pxChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngModel", ctx_r2.pxVal)("nzMin", ctx_r2.i.min)("nzMax", ctx_r2.i.max)("nzStep", ctx_r2.i.step || 2)("nzFormatter", ctx_r2.format);
  }
}
function SettingDrawerItemComponent_Case_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nz-switch", 4);
    \u0275\u0275listener("ngModelChange", function SettingDrawerItemComponent_Case_7_Template_nz_switch_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r13);
      const ctx_r12 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r12.i.value = $event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("ngModel", ctx_r3.i.value)("ngModelOptions", \u0275\u0275pureFunction0(2, _c067));
  }
}
function SettingDrawerItemComponent_Case_8_ng_template_0_Template(rf, ctx) {
}
function SettingDrawerItemComponent_Case_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SettingDrawerItemComponent_Case_8_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
}
function SettingDrawerComponent_div_1_For_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 19);
  }
}
var _c140 = (a0) => ({
  "background-color": a0
});
function SettingDrawerComponent_div_1_For_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275listener("click", function SettingDrawerComponent_div_1_For_5_Template_span_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r9);
      const c_r2 = restoredCtx.$implicit;
      const ctx_r8 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r8.changeColor(c_r2.color));
    });
    \u0275\u0275template(1, SettingDrawerComponent_div_1_For_5_Conditional_1_Template, 1, 0, "i", 19);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r2 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275styleMap(\u0275\u0275pureFunction1(4, _c140, c_r2.color));
    \u0275\u0275property("nzTooltipTitle", c_r2.key);
    \u0275\u0275advance(1);
    \u0275\u0275conditional(1, ctx_r1.color === c_r2.color ? 1 : -1);
  }
}
function SettingDrawerComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5)(2, "h3", 6);
    \u0275\u0275text(3, "\u4E3B\u9898\u8272");
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(4, SettingDrawerComponent_div_1_For_5_Template, 2, 6, "span", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "nz-divider");
    \u0275\u0275elementStart(7, "div", 7)(8, "h3", 6);
    \u0275\u0275text(9, "\u8BBE\u7F6E");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "nz-tabset")(11, "nz-tab", 8)(12, "div", 7);
    \u0275\u0275element(13, "setting-drawer-item", 9)(14, "setting-drawer-item", 9)(15, "setting-drawer-item", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "nz-tab", 10);
    \u0275\u0275element(17, "setting-drawer-item", 9)(18, "setting-drawer-item", 9)(19, "setting-drawer-item", 9)(20, "setting-drawer-item", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "nz-tab", 11);
    \u0275\u0275element(22, "setting-drawer-item", 9)(23, "setting-drawer-item", 9)(24, "setting-drawer-item", 9)(25, "setting-drawer-item", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "nz-tab", 12);
    \u0275\u0275element(27, "setting-drawer-item", 9)(28, "setting-drawer-item", 9)(29, "setting-drawer-item", 9)(30, "setting-drawer-item", 9)(31, "setting-drawer-item", 9)(32, "setting-drawer-item", 9);
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(33, "nz-divider");
    \u0275\u0275elementStart(34, "div", 7)(35, "div", 13);
    \u0275\u0275text(36, " \u56FA\u5B9A\u5934\u548C\u4FA7\u8FB9\u680F ");
    \u0275\u0275elementStart(37, "nz-switch", 14);
    \u0275\u0275listener("ngModelChange", function SettingDrawerComponent_div_1_Template_nz_switch_ngModelChange_37_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r10 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r10.layout.fixed = $event);
    })("ngModelChange", function SettingDrawerComponent_div_1_Template_nz_switch_ngModelChange_37_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r12 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r12.setLayout("fixed", ctx_r12.layout.fixed));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(38, "div", 13);
    \u0275\u0275text(39, " \u8272\u5F31\u6A21\u5F0F ");
    \u0275\u0275elementStart(40, "nz-switch", 14);
    \u0275\u0275listener("ngModelChange", function SettingDrawerComponent_div_1_Template_nz_switch_ngModelChange_40_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r13 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r13.layout.colorWeak = $event);
    })("ngModelChange", function SettingDrawerComponent_div_1_Template_nz_switch_ngModelChange_40_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r14 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r14.setLayout("colorWeak", ctx_r14.layout.colorWeak));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(41, "nz-divider");
    \u0275\u0275elementStart(42, "button", 15);
    \u0275\u0275listener("click", function SettingDrawerComponent_div_1_Template_button_click_42_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r15 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r15.apply());
    });
    \u0275\u0275text(43, "\u9884\u89C8");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(44, "button", 16);
    \u0275\u0275listener("click", function SettingDrawerComponent_div_1_Template_button_click_44_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r16 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r16.reset());
    });
    \u0275\u0275text(45, "\u91CD\u7F6E");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(46, "button", 16);
    \u0275\u0275listener("click", function SettingDrawerComponent_div_1_Template_button_click_46_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r17 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r17.copyVar());
    });
    \u0275\u0275text(47, "\u62F7\u8D1D");
    \u0275\u0275elementEnd();
    \u0275\u0275element(48, "nz-alert", 17);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275repeater(ctx_r0.colors);
    \u0275\u0275advance(9);
    \u0275\u0275property("data", ctx_r0.data["alain-default-header-hg"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["alain-default-header-bg"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["alain-default-header-padding"]);
    \u0275\u0275advance(2);
    \u0275\u0275property("data", ctx_r0.data["alain-default-aside-wd"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["alain-default-aside-bg"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["alain-default-aside-collapsed-wd"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["alain-default-aside-nav-padding-top-bottom"]);
    \u0275\u0275advance(2);
    \u0275\u0275property("data", ctx_r0.data["alain-default-content-bg"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["alain-default-content-heading-bg"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["alain-default-content-heading-border"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["alain-default-content-padding"]);
    \u0275\u0275advance(2);
    \u0275\u0275property("data", ctx_r0.data["form-state-visual-feedback-enabled"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["preserve-white-spaces-enabled"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["nz-table-img-radius"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["nz-table-img-margin-right"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["nz-table-img-max-width"]);
    \u0275\u0275advance(1);
    \u0275\u0275property("data", ctx_r0.data["nz-table-img-max-height"]);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngModel", ctx_r0.layout.fixed);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngModel", ctx_r0.layout.colorWeak);
  }
}
var _c226 = (a0) => ({
  "setting-drawer__handle-opened": a0
});
var _SettingDrawerItemComponent = class _SettingDrawerItemComponent {
  constructor() {
    this.i = {};
    this.pxVal = 0;
    this.format = (value) => `${value} px`;
  }
  set data(val) {
    this.i = val;
    if (val.type === "px") {
      this.pxVal = +val.value.replace("px", "");
    }
  }
  pxChange(val) {
    this.i.value = `${val}px`;
  }
};
_SettingDrawerItemComponent.\u0275fac = function SettingDrawerItemComponent_Factory(t) {
  return new (t || _SettingDrawerItemComponent)();
};
_SettingDrawerItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SettingDrawerItemComponent,
  selectors: [["setting-drawer-item"]],
  hostVars: 2,
  hostBindings: function SettingDrawerItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("setting-drawer__body-item", true);
    }
  },
  inputs: {
    data: "data"
  },
  decls: 9,
  vars: 3,
  consts: [[1, "pl-sm", "text-grey"], ["nz-input", "", "type", "color", 2, "min-width", "88px", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["nz-input", "", 2, "min-width", "88px", 3, "ngModel", "ngModelOptions", "ngModelChange"], [3, "ngModel", "nzMin", "nzMax", "nzStep", "nzFormatter", "ngModelChange"], ["nzSize", "small", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["nzDrawerContent", ""]],
  template: function SettingDrawerItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "span");
      \u0275\u0275text(1);
      \u0275\u0275elementStart(2, "span", 0);
      \u0275\u0275text(3);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(4, SettingDrawerItemComponent_Case_4_Template, 1, 3)(5, SettingDrawerItemComponent_Case_5_Template, 1, 3)(6, SettingDrawerItemComponent_Case_6_Template, 1, 5)(7, SettingDrawerItemComponent_Case_7_Template, 1, 3)(8, SettingDrawerItemComponent_Case_8_Template, 1, 0);
    }
    if (rf & 2) {
      let SettingDrawerItemComponent_contFlowTmp;
      \u0275\u0275advance(1);
      \u0275\u0275textInterpolate1(" ", ctx.i.label, " ");
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.i.tip);
      \u0275\u0275advance(1);
      \u0275\u0275conditional(4, (SettingDrawerItemComponent_contFlowTmp = ctx.i.type) === "color" ? 4 : SettingDrawerItemComponent_contFlowTmp === "input" ? 5 : SettingDrawerItemComponent_contFlowTmp === "px" ? 6 : SettingDrawerItemComponent_contFlowTmp === "switch" ? 7 : 8);
    }
  },
  dependencies: [DefaultValueAccessor, NgControlStatus, NgModel, NzDrawerContentDirective, NzSwitchComponent, NzInputDirective, NzInputNumberComponent],
  encapsulation: 2
});
var SettingDrawerItemComponent = _SettingDrawerItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SettingDrawerItemComponent, [{
    type: Component,
    args: [{
      selector: "setting-drawer-item",
      host: {
        "[class.setting-drawer__body-item]": "true"
      },
      template: `<span>
  {{ i.label }}
  <span class="pl-sm text-grey">{{ i.tip }}</span>
</span>
@switch (i.type) {
  @case ('color') {
    <input
      nz-input
      type="color"
      style="min-width: 88px"
      [(ngModel)]="i.value"
      [ngModelOptions]="{ standalone: true }"
    />
  }
  @case ('input') {
    <input nz-input style="min-width: 88px" [(ngModel)]="i.value" [ngModelOptions]="{ standalone: true }" />
  }
  @case ('px') {
    <nz-input-number
      [(ngModel)]="pxVal"
      (ngModelChange)="pxChange($event)"
      [nzMin]="i.min"
      [nzMax]="i.max"
      [nzStep]="i.step || 2"
      [nzFormatter]="format"
    />
  }
  @case ('switch') {
    <nz-switch nzSize="small" [(ngModel)]="i.value" [ngModelOptions]="{ standalone: true }" />
  }
  @default {
    <ng-template nzDrawerContent />
  }
}
`
    }]
  }], null, {
    data: [{
      type: Input
    }]
  });
})();
var ALAINDEFAULTVAR = "alain-default-vars";
var DEFAULT_COLORS = [{
  key: "dust",
  color: "#F5222D"
}, {
  key: "volcano",
  color: "#FA541C"
}, {
  key: "sunset",
  color: "#FAAD14"
}, {
  key: "cyan",
  color: "#13C2C2"
}, {
  key: "green",
  color: "#52C41A"
}, {
  key: "daybreak",
  color: "#1890ff"
}, {
  key: "geekblue",
  color: "#2F54EB"
}, {
  key: "purple",
  color: "#722ED1"
}, {
  key: "black",
  color: "#001529"
}];
var DEFAULT_VARS = {
  "primary-color": {
    label: "\u4E3B\u989C\u8272",
    type: "color",
    default: "#1890ff"
  },
  "alain-default-header-hg": {
    label: "\u9AD8",
    type: "px",
    default: "64px",
    max: 300,
    min: 24
  },
  "alain-default-header-bg": {
    label: "\u80CC\u666F\u8272",
    type: "color",
    default: "@primary-color",
    tip: "\u9ED8\u8BA4\u540C\u4E3B\u8272\u7CFB"
  },
  "alain-default-header-padding": {
    label: "\u9876\u90E8\u5DE6\u53F3\u5185\u8FB9\u8DDD",
    type: "px",
    default: "16px"
  },
  // 侧边栏
  "alain-default-aside-wd": {
    label: "\u5BBD\u5EA6",
    type: "px",
    default: "200px"
  },
  "alain-default-aside-bg": {
    label: "\u80CC\u666F",
    type: "color",
    default: "#ffffff"
  },
  "alain-default-aside-collapsed-wd": {
    label: "\u6536\u7F29\u5BBD\u5EA6",
    type: "px",
    default: "64px"
  },
  "alain-default-aside-nav-padding-top-bottom": {
    label: "\u9879\u4E0A\u4E0B\u5185\u8FB9\u8DDD",
    type: "px",
    default: "8px",
    step: 8
  },
  // 主菜单
  "alain-default-aside-nav-fs": {
    label: "\u83DC\u5355\u5B57\u53F7",
    type: "px",
    default: "14px",
    min: 14,
    max: 30
  },
  "alain-default-aside-collapsed-nav-fs": {
    label: "\u6536\u7F29\u83DC\u5355\u5B57\u53F7",
    type: "px",
    default: "24px",
    min: 24,
    max: 32
  },
  "alain-default-aside-nav-item-height": {
    label: "\u83DC\u5355\u9879\u9AD8\u5EA6",
    type: "px",
    default: "38px",
    min: 24,
    max: 64
  },
  "alain-default-aside-nav-text-color": {
    label: "\u83DC\u5355\u6587\u672C\u989C\u8272",
    type: "color",
    default: "rgba(0, 0, 0, 0.65)",
    rgba: true
  },
  "alain-default-aside-nav-text-hover-color": {
    label: "\u83DC\u5355\u6587\u672C\u60AC\u505C\u989C\u8272",
    type: "color",
    default: "@primary-color",
    tip: "\u9ED8\u8BA4\u540C\u4E3B\u8272\u7CFB"
  },
  "alain-default-aside-nav-group-text-color": {
    label: "\u83DC\u5355\u5206\u7EC4\u6587\u672C\u989C\u8272",
    type: "color",
    default: "rgba(0, 0, 0, 0.43)",
    rgba: true
  },
  "alain-default-aside-nav-selected-text-color": {
    label: "\u83DC\u5355\u6FC0\u6D3B\u65F6\u6587\u672C\u989C\u8272",
    type: "color",
    default: "@primary-color",
    tip: "\u9ED8\u8BA4\u540C\u4E3B\u8272\u7CFB"
  },
  "alain-default-aside-nav-selected-bg": {
    label: "\u83DC\u5355\u6FC0\u6D3B\u65F6\u80CC\u666F\u989C\u8272",
    type: "color",
    default: "#fcfcfc"
  },
  // 内容
  "alain-default-content-bg": {
    label: "\u80CC\u666F\u8272",
    type: "color",
    default: "#f5f7fa"
  },
  "alain-default-content-heading-bg": {
    label: "\u6807\u9898\u80CC\u666F\u8272",
    type: "color",
    default: "#fafbfc"
  },
  "alain-default-content-heading-border": {
    label: "\u6807\u9898\u5E95\u90E8\u8FB9\u6846\u8272",
    type: "color",
    default: "#efe3e5"
  },
  "alain-default-content-padding": {
    label: "\u5185\u8FB9\u8DDD",
    type: "px",
    default: "24px",
    min: 0,
    max: 128,
    step: 8
  },
  // zorro组件修正
  "form-state-visual-feedback-enabled": {
    label: "\u5F00\u542F\u8868\u5355\u5143\u7D20\u7684\u89C6\u89C9\u53CD\u9988",
    type: "switch",
    default: true
  },
  "preserve-white-spaces-enabled": {
    label: "\u5F00\u542F preserveWhitespaces",
    type: "switch",
    default: true
  },
  "nz-table-img-radius": {
    label: "\u8868\u683C\u4E2D\uFF1A\u56FE\u7247\u5706\u89D2",
    type: "px",
    default: "4px",
    min: 0,
    max: 128
  },
  "nz-table-img-margin-right": {
    label: "\u8868\u683C\u4E2D\uFF1A\u56FE\u7247\u53F3\u5916\u8FB9\u8DDD",
    type: "px",
    default: "4px",
    min: 0,
    max: 128
  },
  "nz-table-img-max-width": {
    label: "\u8868\u683C\u4E2D\uFF1A\u56FE\u7247\u6700\u5927\u5BBD\u5EA6",
    type: "px",
    default: "32px",
    min: 8,
    max: 128
  },
  "nz-table-img-max-height": {
    label: "\u8868\u683C\u4E2D\uFF1A\u56FE\u7247\u6700\u5927\u9AD8\u5EA6",
    type: "px",
    default: "32px",
    min: 8,
    max: 128
  }
};
var _SettingDrawerComponent = class _SettingDrawerComponent {
  get layout() {
    return this.settingSrv.layout;
  }
  constructor(cdr, msg, settingSrv, lazy, ngZone, doc, directionality) {
    this.cdr = cdr;
    this.msg = msg;
    this.settingSrv = settingSrv;
    this.lazy = lazy;
    this.ngZone = ngZone;
    this.doc = doc;
    this.directionality = directionality;
    this.autoApplyColor = true;
    this.compilingText = "Compiling...";
    this.devTips = `When the color can't be switched, you need to run it once: npm run color-less`;
    this.lessJs = "https://cdn.jsdelivr.net/npm/less";
    this.loadedLess = false;
    this.dir$ = this.directionality.change?.pipe(takeUntilDestroyed());
    this.dir = "ltr";
    this.isDev = isDevMode();
    this.collapse = false;
    this.data = {};
    this.colors = DEFAULT_COLORS;
    this.color = this.cachedData["@primary-color"] || this.DEFAULT_PRIMARY;
    this.resetData(this.cachedData, false);
  }
  get cachedData() {
    return this.settingSrv.layout[ALAINDEFAULTVAR] || {};
  }
  get DEFAULT_PRIMARY() {
    return DEFAULT_VARS["primary-color"].default;
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.dir$.subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    if (this.autoApplyColor && this.color !== this.DEFAULT_PRIMARY) {
      this.changeColor(this.color);
      this.runLess();
    }
  }
  loadLess() {
    return __async(this, null, function* () {
      if (this.loadedLess) {
        return Promise.resolve();
      }
      return this.lazy.loadStyle("./assets/color.less", {
        rel: "stylesheet/less"
      }).then(() => {
        const lessConfigNode = this.doc.createElement("script");
        lessConfigNode.innerHTML = `
          window.less = {
            async: true,
            env: 'production',
            javascriptEnabled: true
          };
        `;
        this.doc.body.appendChild(lessConfigNode);
      }).then(() => this.lazy.loadScript(this.lessJs)).then(() => {
        this.loadedLess = true;
      });
    });
  }
  genVars() {
    const {
      data,
      color,
      validKeys
    } = this;
    const vars = {
      [`@primary-color`]: color
    };
    validKeys.filter((key) => key !== "primary-color").forEach((key) => vars[`@${key}`] = data[key].value);
    this.setLayout(ALAINDEFAULTVAR, vars);
    return vars;
  }
  runLess() {
    const {
      ngZone,
      msg,
      cdr
    } = this;
    const msgId = msg.loading(this.compilingText, {
      nzDuration: 0
    }).messageId;
    setTimeout(() => {
      this.loadLess().then(() => {
        window.less.modifyVars(this.genVars()).then(() => {
          msg.success("\u6210\u529F");
          msg.remove(msgId);
          ngZone.run(() => cdr.detectChanges());
        });
      });
    }, 200);
  }
  toggle() {
    this.collapse = !this.collapse;
  }
  changeColor(color) {
    this.color = color;
    Object.keys(DEFAULT_VARS).filter((key) => DEFAULT_VARS[key].default === "@primary-color").forEach((key) => delete this.cachedData[`@${key}`]);
    this.resetData(this.cachedData, false);
  }
  setLayout(name, value) {
    this.settingSrv.setLayout(name, value);
  }
  resetData(nowData, run = true) {
    nowData = nowData || {};
    const data = deepCopy(DEFAULT_VARS);
    Object.keys(data).forEach((key) => {
      const value = nowData[`@${key}`] || data[key].default || "";
      data[key].value = value === `@primary-color` ? this.color : value;
    });
    this.data = data;
    if (run) {
      this.cdr.detectChanges();
      this.runLess();
    }
  }
  get validKeys() {
    return Object.keys(this.data).filter((key) => this.data[key].value !== this.data[key].default);
  }
  apply() {
    this.runLess();
  }
  reset() {
    this.color = this.DEFAULT_PRIMARY;
    this.settingSrv.setLayout(ALAINDEFAULTVAR, {});
    this.resetData({});
  }
  copyVar() {
    const vars = this.genVars();
    const copyContent = Object.keys(vars).map((key) => `${key}: ${vars[key]};`).join("\n");
    copy(copyContent);
    this.msg.success("Copy success");
  }
};
_SettingDrawerComponent.\u0275fac = function SettingDrawerComponent_Factory(t) {
  return new (t || _SettingDrawerComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NzMessageService), \u0275\u0275directiveInject(SettingsService), \u0275\u0275directiveInject(LazyService), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(Directionality, 8));
};
_SettingDrawerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SettingDrawerComponent,
  selectors: [["setting-drawer"]],
  hostVars: 4,
  hostBindings: function SettingDrawerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("setting-drawer", true)("setting-drawer-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    autoApplyColor: "autoApplyColor",
    compilingText: "compilingText",
    devTips: "devTips",
    lessJs: "lessJs"
  },
  decls: 4,
  vars: 8,
  consts: [[3, "nzVisible", "nzPlacement", "nzWidth", "nzOnClose"], ["class", "setting-drawer__content", 4, "nzDrawerContent"], ["nz-tooltip", "", 1, "setting-drawer__handle", 3, "ngClass", "nzTooltipTitle", "click"], ["nz-icon", "", 1, "setting-drawer__handle-icon", 3, "nzType"], [1, "setting-drawer__content"], [1, "setting-drawer__body", "setting-drawer__theme"], [1, "setting-drawer__title"], [1, "setting-drawer__body"], ["nzTitle", "\u9876\u90E8"], [3, "data"], ["nzTitle", "\u4FA7\u8FB9\u680F"], ["nzTitle", "\u5185\u5BB9"], ["nzTitle", "\u5176\u5B83"], [1, "setting-drawer__body-item"], ["nzSize", "small", 3, "ngModel", "ngModelChange"], ["type", "button", "nz-button", "", "nzType", "primary", 3, "click"], ["type", "button", "nz-button", "", 3, "click"], ["nzType", "warning", "nzMessage", "\u914D\u7F6E\u680F\u53EA\u5728\u5F00\u53D1\u73AF\u5883\u7528\u4E8E\u9884\u89C8\uFF0C\u751F\u4EA7\u73AF\u5883\u4E0D\u4F1A\u5C55\u73B0\uFF0C\u8BF7\u62F7\u8D1D\u540E\u624B\u52A8\u4FEE\u6539\u53C2\u6570\u914D\u7F6E\u6587\u4EF6 src/styles/theme.less", 1, "mt-md"], ["nz-tooltip", "", 1, "setting-drawer__theme-tag", 3, "nzTooltipTitle", "click"], ["nz-icon", "", "nzType", "check"], ["nz-tooltip", "", "class", "setting-drawer__theme-tag", 3, "style", "nzTooltipTitle"]],
  template: function SettingDrawerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "nz-drawer", 0);
      \u0275\u0275listener("nzOnClose", function SettingDrawerComponent_Template_nz_drawer_nzOnClose_0_listener() {
        return ctx.toggle();
      });
      \u0275\u0275template(1, SettingDrawerComponent_div_1_Template, 49, 19, "div", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "div", 2);
      \u0275\u0275listener("click", function SettingDrawerComponent_Template_div_click_2_listener() {
        return ctx.toggle();
      });
      \u0275\u0275element(3, "i", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("nzVisible", ctx.collapse)("nzPlacement", ctx.dir === "rtl" ? "left" : "right")("nzWidth", 500);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(6, _c226, ctx.collapse))("nzTooltipTitle", ctx.isDev ? ctx.devTips : null);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzType", !ctx.collapse ? "setting" : "close");
    }
  },
  dependencies: [NgClass, NgControlStatus, NgModel, NzDrawerComponent, NzDrawerContentDirective, NzTooltipDirective, NzDividerComponent, NzTabSetComponent, NzTabComponent, NzSwitchComponent, NzAlertComponent, NzIconDirective, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, SettingDrawerItemComponent],
  encapsulation: 2,
  changeDetection: 0
});
var SettingDrawerComponent = _SettingDrawerComponent;
__decorate([InputBoolean2()], SettingDrawerComponent.prototype, "autoApplyColor", void 0);
__decorate([ZoneOutside()], SettingDrawerComponent.prototype, "loadLess", null);
__decorate([ZoneOutside()], SettingDrawerComponent.prototype, "runLess", null);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SettingDrawerComponent, [{
    type: Component,
    args: [{
      selector: "setting-drawer",
      host: {
        "[class.setting-drawer]": "true",
        "[class.setting-drawer-rtl]": `dir === 'rtl'`
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<nz-drawer
  [nzVisible]="collapse"
  [nzPlacement]="dir === 'rtl' ? 'left' : 'right'"
  [nzWidth]="500"
  (nzOnClose)="toggle()"
>
  <div *nzDrawerContent class="setting-drawer__content">
    <div class="setting-drawer__body setting-drawer__theme">
      <h3 class="setting-drawer__title">\u4E3B\u9898\u8272</h3>
      @for (c of colors; track $index) {
        <span
          [style]="{ 'background-color': c.color }"
          (click)="changeColor(c.color)"
          nz-tooltip
          [nzTooltipTitle]="c.key"
          class="setting-drawer__theme-tag"
        >
          @if (color === c.color) {
            <i nz-icon nzType="check"></i>
          }
        </span>
      }
    </div>
    <nz-divider />
    <div class="setting-drawer__body">
      <h3 class="setting-drawer__title">\u8BBE\u7F6E</h3>
      <nz-tabset>
        <nz-tab nzTitle="\u9876\u90E8">
          <div class="setting-drawer__body">
            <setting-drawer-item [data]="data['alain-default-header-hg']" />
            <setting-drawer-item [data]="data['alain-default-header-bg']" />
            <setting-drawer-item [data]="data['alain-default-header-padding']" />
          </div>
        </nz-tab>
        <nz-tab nzTitle="\u4FA7\u8FB9\u680F">
          <setting-drawer-item [data]="data['alain-default-aside-wd']" />
          <setting-drawer-item [data]="data['alain-default-aside-bg']" />
          <setting-drawer-item [data]="data['alain-default-aside-collapsed-wd']" />
          <setting-drawer-item [data]="data['alain-default-aside-nav-padding-top-bottom']" />
        </nz-tab>
        <nz-tab nzTitle="\u5185\u5BB9">
          <setting-drawer-item [data]="data['alain-default-content-bg']" />
          <setting-drawer-item [data]="data['alain-default-content-heading-bg']" />
          <setting-drawer-item [data]="data['alain-default-content-heading-border']" />
          <setting-drawer-item [data]="data['alain-default-content-padding']" />
        </nz-tab>
        <nz-tab nzTitle="\u5176\u5B83">
          <setting-drawer-item [data]="data['form-state-visual-feedback-enabled']" />
          <setting-drawer-item [data]="data['preserve-white-spaces-enabled']" />
          <setting-drawer-item [data]="data['nz-table-img-radius']" />
          <setting-drawer-item [data]="data['nz-table-img-margin-right']" />
          <setting-drawer-item [data]="data['nz-table-img-max-width']" />
          <setting-drawer-item [data]="data['nz-table-img-max-height']" />
        </nz-tab>
      </nz-tabset>
    </div>
    <nz-divider />
    <div class="setting-drawer__body">
      <div class="setting-drawer__body-item">
        \u56FA\u5B9A\u5934\u548C\u4FA7\u8FB9\u680F
        <nz-switch nzSize="small" [(ngModel)]="layout.fixed" (ngModelChange)="setLayout('fixed', layout.fixed)" />
      </div>
      <div class="setting-drawer__body-item">
        \u8272\u5F31\u6A21\u5F0F
        <nz-switch
          nzSize="small"
          [(ngModel)]="layout.colorWeak"
          (ngModelChange)="setLayout('colorWeak', layout.colorWeak)"
        />
      </div>
    </div>
    <nz-divider />
    <button (click)="apply()" type="button" nz-button nzType="primary">\u9884\u89C8</button>
    <button (click)="reset()" type="button" nz-button>\u91CD\u7F6E</button>
    <button (click)="copyVar()" type="button" nz-button>\u62F7\u8D1D</button>
    <nz-alert
      class="mt-md"
      nzType="warning"
      nzMessage="\u914D\u7F6E\u680F\u53EA\u5728\u5F00\u53D1\u73AF\u5883\u7528\u4E8E\u9884\u89C8\uFF0C\u751F\u4EA7\u73AF\u5883\u4E0D\u4F1A\u5C55\u73B0\uFF0C\u8BF7\u62F7\u8D1D\u540E\u624B\u52A8\u4FEE\u6539\u53C2\u6570\u914D\u7F6E\u6587\u4EF6 src/styles/theme.less"
    />
  </div>
</nz-drawer>
<div
  class="setting-drawer__handle"
  [ngClass]="{ 'setting-drawer__handle-opened': collapse }"
  (click)="toggle()"
  nz-tooltip
  [nzTooltipTitle]="isDev ? devTips : null"
>
  <i nz-icon [nzType]="!collapse ? 'setting' : 'close'" class="setting-drawer__handle-icon"></i>
</div>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NzMessageService
  }, {
    type: SettingsService
  }, {
    type: LazyService
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    autoApplyColor: [{
      type: Input
    }],
    compilingText: [{
      type: Input
    }],
    devTips: [{
      type: Input
    }],
    lessJs: [{
      type: Input
    }],
    loadLess: [],
    runLess: []
  });
})();
var COMPONENTS21 = [SettingDrawerItemComponent, SettingDrawerComponent];
var _SettingDrawerModule = class _SettingDrawerModule {
};
_SettingDrawerModule.\u0275fac = function SettingDrawerModule_Factory(t) {
  return new (t || _SettingDrawerModule)();
};
_SettingDrawerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SettingDrawerModule
});
_SettingDrawerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, FormsModule, NzDrawerModule, NzToolTipModule, NzDividerModule, NzTabsModule, NzSwitchModule, NzAlertModule, NzIconModule, NzInputModule, NzInputNumberModule, NzButtonModule]
});
var SettingDrawerModule = _SettingDrawerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SettingDrawerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, NzDrawerModule, NzToolTipModule, NzDividerModule, NzTabsModule, NzSwitchModule, NzAlertModule, NzIconModule, NzInputModule, NzInputNumberModule, NzButtonModule],
      declarations: COMPONENTS21,
      exports: COMPONENTS21
    }]
  }], null, null);
})();

// node_modules/@delon/theme/fesm2022/theme-btn.mjs
function ThemeBtnComponent_For_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 7);
    \u0275\u0275listener("click", function ThemeBtnComponent_For_9_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r8);
      const i_r2 = restoredCtx.$implicit;
      const ctx_r7 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r7.onThemeChange(i_r2.key));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r2 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(i_r2.text);
  }
}
var ALAIN_THEME_BTN_KEYS = new InjectionToken("ALAIN_THEME_BTN_KEYS");
var _ThemeBtnComponent = class _ThemeBtnComponent {
  constructor(renderer, configSrv, platform, doc, directionality, KEYS, cdr) {
    this.renderer = renderer;
    this.configSrv = configSrv;
    this.platform = platform;
    this.doc = doc;
    this.directionality = directionality;
    this.cdr = cdr;
    this.theme = "default";
    this.isDev = isDevMode();
    this.types = [{
      key: "default",
      text: "Default Theme"
    }, {
      key: "dark",
      text: "Dark Theme"
    }, {
      key: "compact",
      text: "Compact Theme"
    }];
    this.devTips = `When the dark.css file can't be found, you need to run it once: npm run theme`;
    this.deployUrl = "";
    this.themeChange = new EventEmitter();
    this.dir$ = this.directionality.change?.pipe(takeUntilDestroyed());
    this.dir = "ltr";
    this.key = "";
    this.key = KEYS ?? "site-theme";
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.dir$.subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
    this.initTheme();
  }
  initTheme() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.theme = localStorage.getItem(this.key) || "default";
    this.updateChartTheme();
    this.onThemeChange(this.theme);
  }
  updateChartTheme() {
    this.configSrv.set("chart", {
      theme: this.theme === "dark" ? "dark" : ""
    });
  }
  onThemeChange(theme) {
    if (!this.platform.isBrowser) {
      return;
    }
    this.theme = theme;
    this.themeChange.emit(theme);
    this.renderer.setAttribute(this.doc.body, "data-theme", theme);
    const dom = this.doc.getElementById(this.key);
    if (dom) {
      dom.remove();
    }
    localStorage.removeItem(this.key);
    if (theme !== "default") {
      const el = this.doc.createElement("link");
      el.type = "text/css";
      el.rel = "stylesheet";
      el.id = this.key;
      el.href = `${this.deployUrl}assets/style.${theme}.css`;
      localStorage.setItem(this.key, theme);
      this.doc.body.append(el);
    }
    this.updateChartTheme();
  }
  ngOnDestroy() {
    const el = this.doc.getElementById(this.key);
    if (el != null) {
      this.doc.body.removeChild(el);
    }
  }
};
_ThemeBtnComponent.\u0275fac = function ThemeBtnComponent_Factory(t) {
  return new (t || _ThemeBtnComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(AlainConfigService), \u0275\u0275directiveInject(Platform), \u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(ALAIN_THEME_BTN_KEYS, 8), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_ThemeBtnComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ThemeBtnComponent,
  selectors: [["theme-btn"]],
  hostVars: 4,
  hostBindings: function ThemeBtnComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("theme-btn", true)("theme-btn-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    types: "types",
    devTips: "devTips",
    deployUrl: "deployUrl"
  },
  outputs: {
    themeChange: "themeChange"
  },
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  decls: 10,
  vars: 2,
  consts: [["nz-dropdown", "", "nzPlacement", "topCenter", 1, "ant-avatar", "ant-avatar-circle", "ant-avatar-icon", 3, "nzDropdownMenu"], ["nz-tooltip", "", "role", "img", "width", "21", "height", "21", "viewBox", "0 0 21 21", "fill", "currentColor", 1, "anticon", 3, "nzTooltipTitle"], ["fill-rule", "evenodd"], ["fill-rule", "nonzero"], ["d", "M7.02 3.635l12.518 12.518a1.863 1.863 0 010 2.635l-1.317 1.318a1.863 1.863 0 01-2.635 0L3.068 7.588A2.795 2.795 0 117.02 3.635zm2.09 14.428a.932.932 0 110 1.864.932.932 0 010-1.864zm-.043-9.747L7.75 9.635l9.154 9.153 1.318-1.317-9.154-9.155zM3.52 12.473c.514 0 .931.417.931.931v.932h.932a.932.932 0 110 1.864h-.932v.931a.932.932 0 01-1.863 0l-.001-.931h-.93a.932.932 0 010-1.864h.93v-.932c0-.514.418-.931.933-.931zm15.374-3.727a1.398 1.398 0 110 2.795 1.398 1.398 0 010-2.795zM4.385 4.953a.932.932 0 000 1.317l2.046 2.047L7.75 7 5.703 4.953a.932.932 0 00-1.318 0zM14.701.36a.932.932 0 01.931.932v.931h.932a.932.932 0 010 1.864h-.933l.001.932a.932.932 0 11-1.863 0l-.001-.932h-.93a.932.932 0 110-1.864h.93v-.931a.932.932 0 01.933-.932z"], ["menu", "nzDropdownMenu"], ["nz-menu", "", "nzSelectable", ""], ["nz-menu-item", "", 3, "click"], ["nz-menu-item", ""]],
  template: function ThemeBtnComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "svg", 1)(2, "g", 2)(3, "g", 3);
      \u0275\u0275element(4, "path", 4);
      \u0275\u0275elementEnd()()();
      \u0275\u0275namespaceHTML();
      \u0275\u0275elementStart(5, "nz-dropdown-menu", null, 5)(7, "ul", 6);
      \u0275\u0275repeaterCreate(8, ThemeBtnComponent_For_9_Template, 2, 1, "li", 8, \u0275\u0275repeaterTrackByIndex);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      const _r0 = \u0275\u0275reference(6);
      \u0275\u0275property("nzDropdownMenu", ctx.types.length > 0 ? _r0 : null);
      \u0275\u0275advance(1);
      \u0275\u0275property("nzTooltipTitle", ctx.isDev ? ctx.devTips : null);
      \u0275\u0275advance(7);
      \u0275\u0275repeater(ctx.types);
    }
  },
  dependencies: [NzDropDownModule, NzMenuDirective, NzMenuItemComponent, NzDropDownDirective, NzDropdownMenuComponent, NzToolTipModule, NzTooltipDirective],
  encapsulation: 2,
  changeDetection: 0
});
var ThemeBtnComponent = _ThemeBtnComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThemeBtnComponent, [{
    type: Component,
    args: [{
      selector: "theme-btn",
      host: {
        "[class.theme-btn]": `true`,
        "[class.theme-btn-rtl]": `dir === 'rtl'`
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [NzDropDownModule, NzToolTipModule],
      template: '<div\n  class="ant-avatar ant-avatar-circle ant-avatar-icon"\n  nz-dropdown\n  nzPlacement="topCenter"\n  [nzDropdownMenu]="types.length > 0 ? menu : null"\n>\n  <svg\n    nz-tooltip\n    [nzTooltipTitle]="isDev ? devTips : null"\n    class="anticon"\n    role="img"\n    width="21"\n    height="21"\n    viewBox="0 0 21 21"\n    fill="currentColor"\n  >\n    <g fill-rule="evenodd">\n      <g fill-rule="nonzero">\n        <path\n          d="M7.02 3.635l12.518 12.518a1.863 1.863 0 010 2.635l-1.317 1.318a1.863 1.863 0 01-2.635 0L3.068 7.588A2.795 2.795 0 117.02 3.635zm2.09 14.428a.932.932 0 110 1.864.932.932 0 010-1.864zm-.043-9.747L7.75 9.635l9.154 9.153 1.318-1.317-9.154-9.155zM3.52 12.473c.514 0 .931.417.931.931v.932h.932a.932.932 0 110 1.864h-.932v.931a.932.932 0 01-1.863 0l-.001-.931h-.93a.932.932 0 010-1.864h.93v-.932c0-.514.418-.931.933-.931zm15.374-3.727a1.398 1.398 0 110 2.795 1.398 1.398 0 010-2.795zM4.385 4.953a.932.932 0 000 1.317l2.046 2.047L7.75 7 5.703 4.953a.932.932 0 00-1.318 0zM14.701.36a.932.932 0 01.931.932v.931h.932a.932.932 0 010 1.864h-.933l.001.932a.932.932 0 11-1.863 0l-.001-.932h-.93a.932.932 0 110-1.864h.93v-.931a.932.932 0 01.933-.932z"\n        />\n      </g>\n    </g>\n  </svg>\n  <nz-dropdown-menu #menu="nzDropdownMenu">\n    <ul nz-menu nzSelectable>\n      @for (i of types; track $index) {\n        <li nz-menu-item (click)="onThemeChange(i.key)">{{ i.text }}</li>\n      }\n    </ul>\n  </nz-dropdown-menu>\n</div>\n'
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: AlainConfigService
  }, {
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ALAIN_THEME_BTN_KEYS]
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    types: [{
      type: Input
    }],
    devTips: [{
      type: Input
    }],
    deployUrl: [{
      type: Input
    }],
    themeChange: [{
      type: Output
    }]
  });
})();
var COMPONENTS22 = [ThemeBtnComponent];
var _ThemeBtnModule = class _ThemeBtnModule {
};
_ThemeBtnModule.\u0275fac = function ThemeBtnModule_Factory(t) {
  return new (t || _ThemeBtnModule)();
};
_ThemeBtnModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ThemeBtnModule
});
_ThemeBtnModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, NzDropDownModule, NzToolTipModule, COMPONENTS22]
});
var ThemeBtnModule = _ThemeBtnModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThemeBtnModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NzDropDownModule, NzToolTipModule, ...COMPONENTS22],
      exports: COMPONENTS22
    }]
  }], null, null);
})();

// src/app/layout/basic/widgets/clear-storage.component.ts
var _HeaderClearStorageComponent = class _HeaderClearStorageComponent {
  constructor() {
    this.modalSrv = inject(NzModalService);
    this.messageSrv = inject(NzMessageService);
  }
  _click() {
    this.modalSrv.confirm({
      nzTitle: "Make sure clear all local storage?",
      nzOnOk: () => {
        localStorage.clear();
        this.messageSrv.success("Clear Finished!");
      }
    });
  }
};
_HeaderClearStorageComponent.\u0275fac = function HeaderClearStorageComponent_Factory(t) {
  return new (t || _HeaderClearStorageComponent)();
};
_HeaderClearStorageComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HeaderClearStorageComponent, selectors: [["header-clear-storage"]], hostVars: 2, hostBindings: function HeaderClearStorageComponent_HostBindings(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275listener("click", function HeaderClearStorageComponent_click_HostBindingHandler() {
      return ctx._click();
    });
  }
  if (rf & 2) {
    \u0275\u0275classProp("flex-1", true);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 3, vars: 3, consts: [["nz-icon", "", "nzType", "tool"]], template: function HeaderClearStorageComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 0);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "i18n");
  }
  if (rf & 2) {
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, "menu.clear.local.storage"), " ");
  }
}, dependencies: [NzIconModule, NzIconDirective, I18nPipe], encapsulation: 2, changeDetection: 0 });
var HeaderClearStorageComponent = _HeaderClearStorageComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HeaderClearStorageComponent, { className: "HeaderClearStorageComponent", filePath: "src\\app\\layout\\basic\\widgets\\clear-storage.component.ts", lineNumber: 20 });
})();

// node_modules/screenfull/index.js
var methodMap = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
];
var nativeAPI = (() => {
  if (typeof document === "undefined") {
    return false;
  }
  const unprefixedMethods = methodMap[0];
  const returnValue = {};
  for (const methodList of methodMap) {
    const exitFullscreenMethod = methodList?.[1];
    if (exitFullscreenMethod in document) {
      for (const [index, method] of methodList.entries()) {
        returnValue[unprefixedMethods[index]] = method;
      }
      return returnValue;
    }
  }
  return false;
})();
var eventNameMap = {
  change: nativeAPI.fullscreenchange,
  error: nativeAPI.fullscreenerror
};
var screenfull = {
  // eslint-disable-next-line default-param-last
  request(element = document.documentElement, options) {
    return new Promise((resolve, reject) => {
      const onFullScreenEntered = () => {
        screenfull.off("change", onFullScreenEntered);
        resolve();
      };
      screenfull.on("change", onFullScreenEntered);
      const returnPromise = element[nativeAPI.requestFullscreen](options);
      if (returnPromise instanceof Promise) {
        returnPromise.then(onFullScreenEntered).catch(reject);
      }
    });
  },
  exit() {
    return new Promise((resolve, reject) => {
      if (!screenfull.isFullscreen) {
        resolve();
        return;
      }
      const onFullScreenExit = () => {
        screenfull.off("change", onFullScreenExit);
        resolve();
      };
      screenfull.on("change", onFullScreenExit);
      const returnPromise = document[nativeAPI.exitFullscreen]();
      if (returnPromise instanceof Promise) {
        returnPromise.then(onFullScreenExit).catch(reject);
      }
    });
  },
  toggle(element, options) {
    return screenfull.isFullscreen ? screenfull.exit() : screenfull.request(element, options);
  },
  onchange(callback) {
    screenfull.on("change", callback);
  },
  onerror(callback) {
    screenfull.on("error", callback);
  },
  on(event, callback) {
    const eventName = eventNameMap[event];
    if (eventName) {
      document.addEventListener(eventName, callback, false);
    }
  },
  off(event, callback) {
    const eventName = eventNameMap[event];
    if (eventName) {
      document.removeEventListener(eventName, callback, false);
    }
  },
  raw: nativeAPI
};
Object.defineProperties(screenfull, {
  isFullscreen: {
    get: () => Boolean(document[nativeAPI.fullscreenElement])
  },
  element: {
    enumerable: true,
    get: () => document[nativeAPI.fullscreenElement] ?? void 0
  },
  isEnabled: {
    enumerable: true,
    // Coerce to boolean in case of old WebKit.
    get: () => Boolean(document[nativeAPI.fullscreenEnabled])
  }
});
if (!nativeAPI) {
  screenfull = { isEnabled: false };
}
var screenfull_default = screenfull;

// src/app/layout/basic/widgets/fullscreen.component.ts
var _HeaderFullScreenComponent = class _HeaderFullScreenComponent {
  constructor() {
    this.status = false;
  }
  _resize() {
    this.status = screenfull_default.isFullscreen;
  }
  _click() {
    if (screenfull_default.isEnabled) {
      screenfull_default.toggle();
    }
  }
};
_HeaderFullScreenComponent.\u0275fac = function HeaderFullScreenComponent_Factory(t) {
  return new (t || _HeaderFullScreenComponent)();
};
_HeaderFullScreenComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HeaderFullScreenComponent, selectors: [["header-fullscreen"]], hostVars: 2, hostBindings: function HeaderFullScreenComponent_HostBindings(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275listener("resize", function HeaderFullScreenComponent_resize_HostBindingHandler() {
      return ctx._resize();
    }, false, \u0275\u0275resolveWindow)("click", function HeaderFullScreenComponent_click_HostBindingHandler() {
      return ctx._click();
    });
  }
  if (rf & 2) {
    \u0275\u0275classProp("flex-1", true);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 3, vars: 4, consts: [["nz-icon", "", 3, "nzType"]], template: function HeaderFullScreenComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 0);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "i18n");
  }
  if (rf & 2) {
    \u0275\u0275property("nzType", ctx.status ? "fullscreen-exit" : "fullscreen");
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 2, ctx.status ? "menu.fullscreen.exit" : "menu.fullscreen"), " ");
  }
}, dependencies: [NzIconModule, NzIconDirective, I18nPipe], encapsulation: 2, changeDetection: 0 });
var HeaderFullScreenComponent = _HeaderFullScreenComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HeaderFullScreenComponent, { className: "HeaderFullScreenComponent", filePath: "src\\app\\layout\\basic\\widgets\\fullscreen.component.ts", lineNumber: 19 });
})();

// src/app/layout/basic/widgets/i18n.component.ts
function HeaderI18nComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "i", 3);
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "i18n");
    \u0275\u0275element(4, "i", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r2 = \u0275\u0275reference(3);
    \u0275\u0275property("nzDropdownMenu", _r2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(3, 2, "menu.lang"), " ");
  }
}
function HeaderI18nComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 5);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const _r2 = \u0275\u0275reference(3);
    \u0275\u0275property("nzDropdownMenu", _r2);
  }
}
function HeaderI18nComponent_For_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 6);
    \u0275\u0275listener("click", function HeaderI18nComponent_For_6_Template_li_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r10);
      const item_r4 = restoredCtx.$implicit;
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.change(item_r4.code));
    });
    \u0275\u0275elementStart(1, "span", 7);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("nzSelected", item_r4.code === ctx_r3.curLangCode);
    \u0275\u0275advance(1);
    \u0275\u0275attribute("aria-label", item_r4.text);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(item_r4.abbr);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", item_r4.text, " ");
  }
}
var _HeaderI18nComponent = class _HeaderI18nComponent {
  constructor() {
    this.settings = inject(SettingsService);
    this.i18n = inject(ALAIN_I18N_TOKEN);
    this.doc = inject(DOCUMENT);
    this.showLangText = true;
  }
  get langs() {
    return this.i18n.getLangs();
  }
  get curLangCode() {
    return this.settings.layout.lang;
  }
  change(lang) {
    const spinEl = this.doc.createElement("div");
    spinEl.setAttribute("class", `page-loading ant-spin ant-spin-lg ant-spin-spinning`);
    spinEl.innerHTML = `<span class="ant-spin-dot ant-spin-dot-spin"><i></i><i></i><i></i><i></i></span>`;
    this.doc.body.appendChild(spinEl);
    this.i18n.loadLangData(lang).subscribe((res) => {
      this.i18n.use(lang, res);
      this.settings.setLayout("lang", lang);
      setTimeout(() => this.doc.location.reload());
    });
  }
};
_HeaderI18nComponent.\u0275fac = function HeaderI18nComponent_Factory(t) {
  return new (t || _HeaderI18nComponent)();
};
_HeaderI18nComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HeaderI18nComponent, selectors: [["header-i18n"]], hostVars: 2, hostBindings: function HeaderI18nComponent_HostBindings(rf, ctx) {
  if (rf & 2) {
    \u0275\u0275classProp("flex-1", true);
  }
}, inputs: { showLangText: ["showLangText", "showLangText", booleanAttribute] }, standalone: true, features: [\u0275\u0275InputTransformsFeature, \u0275\u0275StandaloneFeature], decls: 7, vars: 1, consts: [["nz-dropdown", "", "nzPlacement", "bottomRight", 3, "nzDropdownMenu"], ["langMenu", "nzDropdownMenu"], ["nz-menu", ""], ["nz-icon", "", "nzType", "global"], ["nz-icon", "", "nzType", "down"], ["nz-dropdown", "", "nzPlacement", "bottomRight", "nz-icon", "", "nzType", "global", 3, "nzDropdownMenu"], ["nz-menu-item", "", 3, "nzSelected", "click"], ["role", "img", 1, "pr-xs"], ["nz-menu-item", "", 3, "nzSelected"]], template: function HeaderI18nComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, HeaderI18nComponent_Conditional_0_Template, 5, 4, "div", 0)(1, HeaderI18nComponent_Conditional_1_Template, 1, 1);
    \u0275\u0275elementStart(2, "nz-dropdown-menu", null, 1)(4, "ul", 2);
    \u0275\u0275repeaterCreate(5, HeaderI18nComponent_For_6_Template, 4, 4, "li", 8, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275conditional(0, ctx.showLangText ? 0 : 1);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx.langs);
  }
}, dependencies: [I18nPipe, NzDropDownModule, NzMenuDirective, NzMenuItemComponent, NzDropDownDirective, NzDropdownMenuComponent, NzIconModule, NzIconDirective, NzMenuModule], encapsulation: 2, changeDetection: 0 });
var HeaderI18nComponent = _HeaderI18nComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HeaderI18nComponent, { className: "HeaderI18nComponent", filePath: "src\\app\\layout\\basic\\widgets\\i18n.component.ts", lineNumber: 39 });
})();

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-auto-complete.mjs
function NzAutocompleteOptgroupComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(ctx_r0.nzLabel);
  }
}
var _c068 = [[["nz-auto-option"]]];
var _c141 = ["nz-auto-option"];
var _c227 = ["*"];
var _c319 = ["panel"];
var _c413 = ["content"];
function NzAutocompleteComponent_ng_template_0_4_ng_template_0_Template(rf, ctx) {
}
function NzAutocompleteComponent_ng_template_0_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzAutocompleteComponent_ng_template_0_4_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function NzAutocompleteComponent_ng_template_0_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
function NzAutocompleteComponent_ng_template_0_ng_template_7_nz_auto_option_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-auto-option", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r9 = ctx.$implicit;
    \u0275\u0275property("nzValue", option_r9.value)("nzLabel", option_r9.label);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", option_r9.label, " ");
  }
}
function NzAutocompleteComponent_ng_template_0_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, NzAutocompleteComponent_ng_template_0_ng_template_7_nz_auto_option_0_Template, 2, 3, "nz-auto-option", 7);
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngForOf", ctx_r5.normalizedDataSource);
  }
}
function NzAutocompleteComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 0, 1);
    \u0275\u0275listener("@slideMotion.done", function NzAutocompleteComponent_ng_template_0_Template_div_animation_slideMotion_done_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r10 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r10.onAnimationEvent($event));
    });
    \u0275\u0275elementStart(2, "div", 2)(3, "div", 3);
    \u0275\u0275template(4, NzAutocompleteComponent_ng_template_0_4_Template, 1, 0, null, 4);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(5, NzAutocompleteComponent_ng_template_0_ng_template_5_Template, 1, 0, "ng-template", null, 5, \u0275\u0275templateRefExtractor)(7, NzAutocompleteComponent_ng_template_0_ng_template_7_Template, 1, 1, "ng-template", null, 6, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const _r4 = \u0275\u0275reference(6);
    const _r6 = \u0275\u0275reference(8);
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("ant-select-dropdown-hidden", !ctx_r0.showPanel)("ant-select-dropdown-rtl", ctx_r0.dir === "rtl");
    \u0275\u0275property("ngClass", ctx_r0.nzOverlayClassName)("ngStyle", ctx_r0.nzOverlayStyle)("nzNoAnimation", ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation)("@slideMotion", void 0)("@.disabled", !!(ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation));
    \u0275\u0275advance(4);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.nzDataSource ? _r6 : _r4);
  }
}
var _NzAutocompleteOptgroupComponent = class _NzAutocompleteOptgroupComponent {
  constructor() {
  }
};
_NzAutocompleteOptgroupComponent.\u0275fac = function NzAutocompleteOptgroupComponent_Factory(t) {
  return new (t || _NzAutocompleteOptgroupComponent)();
};
_NzAutocompleteOptgroupComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzAutocompleteOptgroupComponent,
  selectors: [["nz-auto-optgroup"]],
  inputs: {
    nzLabel: "nzLabel"
  },
  exportAs: ["nzAutoOptgroup"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c141,
  decls: 3,
  vars: 1,
  consts: [[1, "ant-select-item", "ant-select-item-group"], [4, "nzStringTemplateOutlet"]],
  template: function NzAutocompleteOptgroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef(_c068);
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, NzAutocompleteOptgroupComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275projection(2);
    }
    if (rf & 2) {
      \u0275\u0275advance(1);
      \u0275\u0275property("nzStringTemplateOutlet", ctx.nzLabel);
    }
  },
  dependencies: [NzOutletModule, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var NzAutocompleteOptgroupComponent = _NzAutocompleteOptgroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAutocompleteOptgroupComponent, [{
    type: Component,
    args: [{
      selector: "nz-auto-optgroup",
      exportAs: "nzAutoOptgroup",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [NzOutletModule],
      template: `
    <div class="ant-select-item ant-select-item-group">
      <ng-container *nzStringTemplateOutlet="nzLabel">{{ nzLabel }}</ng-container>
    </div>
    <ng-content select="nz-auto-option"></ng-content>
  `
    }]
  }], () => [], {
    nzLabel: [{
      type: Input
    }]
  });
})();
var NzOptionSelectionChange = class {
  constructor(source, isUserInput = false) {
    this.source = source;
    this.isUserInput = isUserInput;
  }
};
var _NzAutocompleteOptionComponent = class _NzAutocompleteOptionComponent {
  constructor(ngZone, changeDetectorRef, element, nzAutocompleteOptgroupComponent) {
    this.ngZone = ngZone;
    this.changeDetectorRef = changeDetectorRef;
    this.element = element;
    this.nzAutocompleteOptgroupComponent = nzAutocompleteOptgroupComponent;
    this.nzDisabled = false;
    this.selectionChange = new EventEmitter();
    this.mouseEntered = new EventEmitter();
    this.active = false;
    this.selected = false;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.element.nativeElement, "mouseenter").pipe(filter(() => this.mouseEntered.observers.length > 0), takeUntil(this.destroy$)).subscribe(() => {
        this.ngZone.run(() => this.mouseEntered.emit(this));
      });
      fromEvent(this.element.nativeElement, "mousedown").pipe(takeUntil(this.destroy$)).subscribe((event) => event.preventDefault());
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  select(emit = true) {
    this.selected = true;
    this.changeDetectorRef.markForCheck();
    if (emit) {
      this.emitSelectionChangeEvent();
    }
  }
  deselect() {
    this.selected = false;
    this.changeDetectorRef.markForCheck();
    this.emitSelectionChangeEvent();
  }
  /** Git display label */
  getLabel() {
    return this.nzLabel || this.nzValue.toString();
  }
  /** Set active (only styles) */
  setActiveStyles() {
    if (!this.active) {
      this.active = true;
      this.changeDetectorRef.markForCheck();
    }
  }
  /** Unset active (only styles) */
  setInactiveStyles() {
    if (this.active) {
      this.active = false;
      this.changeDetectorRef.markForCheck();
    }
  }
  scrollIntoViewIfNeeded() {
    scrollIntoView(this.element.nativeElement);
  }
  selectViaInteraction() {
    if (!this.nzDisabled) {
      this.selected = !this.selected;
      if (this.selected) {
        this.setActiveStyles();
      } else {
        this.setInactiveStyles();
      }
      this.emitSelectionChangeEvent(true);
      this.changeDetectorRef.markForCheck();
    }
  }
  emitSelectionChangeEvent(isUserInput = false) {
    this.selectionChange.emit(new NzOptionSelectionChange(this, isUserInput));
  }
};
_NzAutocompleteOptionComponent.\u0275fac = function NzAutocompleteOptionComponent_Factory(t) {
  return new (t || _NzAutocompleteOptionComponent)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NzAutocompleteOptgroupComponent, 8));
};
_NzAutocompleteOptionComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzAutocompleteOptionComponent,
  selectors: [["nz-auto-option"]],
  hostAttrs: ["role", "menuitem", 1, "ant-select-item", "ant-select-item-option"],
  hostVars: 10,
  hostBindings: function NzAutocompleteOptionComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function NzAutocompleteOptionComponent_click_HostBindingHandler() {
        return ctx.selectViaInteraction();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("aria-selected", ctx.selected.toString())("aria-disabled", ctx.nzDisabled.toString());
      \u0275\u0275classProp("ant-select-item-option-grouped", ctx.nzAutocompleteOptgroupComponent)("ant-select-item-option-selected", ctx.selected)("ant-select-item-option-active", ctx.active)("ant-select-item-option-disabled", ctx.nzDisabled);
    }
  },
  inputs: {
    nzValue: "nzValue",
    nzLabel: "nzLabel",
    nzDisabled: "nzDisabled"
  },
  outputs: {
    selectionChange: "selectionChange",
    mouseEntered: "mouseEntered"
  },
  exportAs: ["nzAutoOption"],
  standalone: true,
  features: [\u0275\u0275StandaloneFeature],
  ngContentSelectors: _c227,
  decls: 2,
  vars: 0,
  consts: [[1, "ant-select-item-option-content"]],
  template: function NzAutocompleteOptionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NzAutocompleteOptionComponent = _NzAutocompleteOptionComponent;
__decorate([InputBoolean()], NzAutocompleteOptionComponent.prototype, "nzDisabled", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAutocompleteOptionComponent, [{
    type: Component,
    args: [{
      selector: "nz-auto-option",
      exportAs: "nzAutoOption",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      template: `
    <div class="ant-select-item-option-content">
      <ng-content></ng-content>
    </div>
  `,
      host: {
        role: "menuitem",
        class: "ant-select-item ant-select-item-option",
        "[class.ant-select-item-option-grouped]": "nzAutocompleteOptgroupComponent",
        "[class.ant-select-item-option-selected]": "selected",
        "[class.ant-select-item-option-active]": "active",
        "[class.ant-select-item-option-disabled]": "nzDisabled",
        "[attr.aria-selected]": "selected.toString()",
        "[attr.aria-disabled]": "nzDisabled.toString()",
        "(click)": "selectViaInteraction()"
      }
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: NzAutocompleteOptgroupComponent,
    decorators: [{
      type: Optional
    }]
  }], {
    nzValue: [{
      type: Input
    }],
    nzLabel: [{
      type: Input
    }],
    nzDisabled: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    mouseEntered: [{
      type: Output
    }]
  });
})();
var NZ_AUTOCOMPLETE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NzAutocompleteTriggerDirective),
  multi: true
};
function getNzAutocompleteMissingPanelError() {
  return Error("Attempting to open an undefined instance of `nz-autocomplete`. Make sure that the id passed to the `nzAutocomplete` is correct and that you're attempting to open it after the ngAfterContentInit hook.");
}
var _NzAutocompleteTriggerDirective = class _NzAutocompleteTriggerDirective {
  /** Current active option */
  get activeOption() {
    if (this.nzAutocomplete && this.nzAutocomplete.options.length) {
      return this.nzAutocomplete.activeItem;
    } else {
      return null;
    }
  }
  constructor(ngZone, elementRef, overlay, viewContainerRef, nzInputGroupWhitSuffixOrPrefixDirective, document2) {
    this.ngZone = ngZone;
    this.elementRef = elementRef;
    this.overlay = overlay;
    this.viewContainerRef = viewContainerRef;
    this.nzInputGroupWhitSuffixOrPrefixDirective = nzInputGroupWhitSuffixOrPrefixDirective;
    this.document = document2;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.panelOpen = false;
    this.destroy$ = new Subject();
    this.overlayRef = null;
    this.portal = null;
    this.previousValue = null;
  }
  ngAfterViewInit() {
    if (this.nzAutocomplete) {
      this.nzAutocomplete.animationStateChange.pipe(takeUntil(this.destroy$)).subscribe((event) => {
        if (event.toState === "void") {
          if (this.overlayRef) {
            this.overlayRef.dispose();
            this.overlayRef = null;
          }
        }
      });
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.destroyPanel();
  }
  writeValue(value) {
    this.ngZone.runOutsideAngular(() => Promise.resolve(null).then(() => this.setTriggerValue(value)));
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    const element = this.elementRef.nativeElement;
    element.disabled = isDisabled;
    this.closePanel();
  }
  openPanel() {
    this.previousValue = this.elementRef.nativeElement.value;
    this.attachOverlay();
    this.updateStatus();
  }
  closePanel() {
    if (this.panelOpen) {
      this.nzAutocomplete.isOpen = this.panelOpen = false;
      if (this.overlayRef && this.overlayRef.hasAttached()) {
        this.overlayRef.detach();
        this.selectionChangeSubscription.unsubscribe();
        this.overlayOutsideClickSubscription.unsubscribe();
        this.optionsChangeSubscription.unsubscribe();
        this.portal = null;
      }
    }
  }
  handleKeydown(event) {
    const keyCode = event.keyCode;
    const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
    if (keyCode === ESCAPE) {
      event.preventDefault();
    }
    if (this.panelOpen && (keyCode === ESCAPE || keyCode === TAB)) {
      if (this.activeOption && this.activeOption.getLabel() !== this.previousValue) {
        this.setTriggerValue(this.previousValue);
      }
      this.closePanel();
    } else if (this.panelOpen && keyCode === ENTER) {
      if (this.nzAutocomplete.showPanel) {
        event.preventDefault();
        if (this.activeOption) {
          this.activeOption.selectViaInteraction();
        } else {
          this.closePanel();
        }
      }
    } else if (this.panelOpen && isArrowKey && this.nzAutocomplete.showPanel) {
      event.stopPropagation();
      event.preventDefault();
      if (keyCode === UP_ARROW) {
        this.nzAutocomplete.setPreviousItemActive();
      } else {
        this.nzAutocomplete.setNextItemActive();
      }
      if (this.activeOption) {
        this.activeOption.scrollIntoViewIfNeeded();
      }
      this.doBackfill();
    }
  }
  handleInput(event) {
    const target = event.target;
    const document2 = this.document;
    let value = target.value;
    if (target.type === "number") {
      value = value === "" ? null : parseFloat(value);
    }
    if (this.previousValue !== value) {
      this.previousValue = value;
      this.onChange(value);
      if (this.canOpen() && document2.activeElement === event.target) {
        this.openPanel();
      }
    }
  }
  handleFocus() {
    if (this.canOpen()) {
      this.openPanel();
    }
  }
  handleBlur() {
    this.onTouched();
  }
  /**
   * Subscription data source changes event
   */
  subscribeOptionsChange() {
    const optionChanges = this.nzAutocomplete.options.changes.pipe(tap(() => this.positionStrategy.reapplyLastPosition()), delay(0));
    return optionChanges.subscribe(() => {
      this.resetActiveItem();
      if (this.panelOpen) {
        this.overlayRef.updatePosition();
      }
    });
  }
  /**
   * Subscription option changes event and set the value
   */
  subscribeSelectionChange() {
    return this.nzAutocomplete.selectionChange.subscribe((option) => {
      this.setValueAndClose(option);
    });
  }
  subscribeOverlayOutsideClick() {
    return this.overlayRef.outsidePointerEvents().pipe(filter((e) => !this.elementRef.nativeElement.contains(e.target))).subscribe(() => {
      this.closePanel();
    });
  }
  attachOverlay() {
    if (!this.nzAutocomplete) {
      throw getNzAutocompleteMissingPanelError();
    }
    if (!this.portal && this.nzAutocomplete.template) {
      this.portal = new TemplatePortal(this.nzAutocomplete.template, this.viewContainerRef);
    }
    if (!this.overlayRef) {
      this.overlayRef = this.overlay.create(this.getOverlayConfig());
    }
    if (this.overlayRef && !this.overlayRef.hasAttached()) {
      this.overlayRef.attach(this.portal);
      this.selectionChangeSubscription = this.subscribeSelectionChange();
      this.optionsChangeSubscription = this.subscribeOptionsChange();
      this.overlayOutsideClickSubscription = this.subscribeOverlayOutsideClick();
      this.overlayRef.detachments().pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.closePanel();
      });
    }
    this.nzAutocomplete.isOpen = this.panelOpen = true;
  }
  updateStatus() {
    if (this.overlayRef) {
      this.overlayRef.updateSize({
        width: this.nzAutocomplete.nzWidth || this.getHostWidth()
      });
    }
    this.nzAutocomplete.setVisibility();
    this.resetActiveItem();
    if (this.activeOption) {
      this.activeOption.scrollIntoViewIfNeeded();
    }
  }
  destroyPanel() {
    if (this.overlayRef) {
      this.closePanel();
    }
  }
  getOverlayConfig() {
    return new OverlayConfig({
      positionStrategy: this.getOverlayPosition(),
      disposeOnNavigation: true,
      scrollStrategy: this.overlay.scrollStrategies.reposition(),
      // default host element width
      width: this.nzAutocomplete.nzWidth || this.getHostWidth()
    });
  }
  getConnectedElement() {
    return this.nzInputGroupWhitSuffixOrPrefixDirective ? this.nzInputGroupWhitSuffixOrPrefixDirective.elementRef : this.elementRef;
  }
  getHostWidth() {
    return this.getConnectedElement().nativeElement.getBoundingClientRect().width;
  }
  getOverlayPosition() {
    const positions = [new ConnectionPositionPair({
      originX: "start",
      originY: "bottom"
    }, {
      overlayX: "start",
      overlayY: "top"
    }), new ConnectionPositionPair({
      originX: "start",
      originY: "top"
    }, {
      overlayX: "start",
      overlayY: "bottom"
    })];
    this.positionStrategy = this.overlay.position().flexibleConnectedTo(this.getConnectedElement()).withFlexibleDimensions(false).withPush(false).withPositions(positions).withTransformOriginOn(".ant-select-dropdown");
    return this.positionStrategy;
  }
  resetActiveItem() {
    const index = this.nzAutocomplete.getOptionIndex(this.previousValue);
    this.nzAutocomplete.clearSelectedOptions(null, true);
    if (index !== -1) {
      this.nzAutocomplete.setActiveItem(index);
      this.nzAutocomplete.activeItem.select(false);
    } else {
      this.nzAutocomplete.setActiveItem(this.nzAutocomplete.nzDefaultActiveFirstOption ? 0 : -1);
    }
  }
  setValueAndClose(option) {
    const value = option.nzValue;
    this.setTriggerValue(option.getLabel());
    this.onChange(value);
    this.elementRef.nativeElement.focus();
    this.closePanel();
  }
  setTriggerValue(value) {
    const option = this.nzAutocomplete.getOption(value);
    const displayValue = option ? option.getLabel() : value;
    this.elementRef.nativeElement.value = displayValue != null ? displayValue : "";
    if (!this.nzAutocomplete.nzBackfill) {
      this.previousValue = displayValue;
    }
  }
  doBackfill() {
    if (this.nzAutocomplete.nzBackfill && this.nzAutocomplete.activeItem) {
      this.setTriggerValue(this.nzAutocomplete.activeItem.getLabel());
    }
  }
  canOpen() {
    const element = this.elementRef.nativeElement;
    return !element.readOnly && !element.disabled;
  }
};
_NzAutocompleteTriggerDirective.\u0275fac = function NzAutocompleteTriggerDirective_Factory(t) {
  return new (t || _NzAutocompleteTriggerDirective)(\u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Overlay), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NzInputGroupWhitSuffixOrPrefixDirective, 8), \u0275\u0275directiveInject(DOCUMENT, 8));
};
_NzAutocompleteTriggerDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _NzAutocompleteTriggerDirective,
  selectors: [["input", "nzAutocomplete", ""], ["textarea", "nzAutocomplete", ""]],
  hostAttrs: ["autocomplete", "off", "aria-autocomplete", "list"],
  hostBindings: function NzAutocompleteTriggerDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("focusin", function NzAutocompleteTriggerDirective_focusin_HostBindingHandler() {
        return ctx.handleFocus();
      })("blur", function NzAutocompleteTriggerDirective_blur_HostBindingHandler() {
        return ctx.handleBlur();
      })("input", function NzAutocompleteTriggerDirective_input_HostBindingHandler($event) {
        return ctx.handleInput($event);
      })("keydown", function NzAutocompleteTriggerDirective_keydown_HostBindingHandler($event) {
        return ctx.handleKeydown($event);
      });
    }
  },
  inputs: {
    nzAutocomplete: "nzAutocomplete"
  },
  exportAs: ["nzAutocompleteTrigger"],
  standalone: true,
  features: [\u0275\u0275ProvidersFeature([NZ_AUTOCOMPLETE_VALUE_ACCESSOR])]
});
var NzAutocompleteTriggerDirective = _NzAutocompleteTriggerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAutocompleteTriggerDirective, [{
    type: Directive,
    args: [{
      selector: `input[nzAutocomplete], textarea[nzAutocomplete]`,
      exportAs: "nzAutocompleteTrigger",
      providers: [NZ_AUTOCOMPLETE_VALUE_ACCESSOR],
      standalone: true,
      host: {
        autocomplete: "off",
        "aria-autocomplete": "list",
        "(focusin)": "handleFocus()",
        "(blur)": "handleBlur()",
        "(input)": "handleInput($event)",
        "(keydown)": "handleKeydown($event)"
      }
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Overlay
  }, {
    type: ViewContainerRef
  }, {
    type: NzInputGroupWhitSuffixOrPrefixDirective,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }], {
    nzAutocomplete: [{
      type: Input
    }]
  });
})();
function normalizeDataSource(value) {
  return value?.map((item) => {
    if (typeof item === "number" || typeof item === "string") {
      return {
        label: item.toString(),
        value: item.toString()
      };
    }
    return item;
  });
}
var _NzAutocompleteComponent = class _NzAutocompleteComponent {
  /**
   * Options accessor, its source may be content or dataSource
   */
  get options() {
    if (this.nzDataSource) {
      return this.fromDataSourceOptions;
    } else {
      return this.fromContentOptions;
    }
  }
  constructor(changeDetectorRef, ngZone, directionality, noAnimation) {
    this.changeDetectorRef = changeDetectorRef;
    this.ngZone = ngZone;
    this.directionality = directionality;
    this.noAnimation = noAnimation;
    this.nzOverlayClassName = "";
    this.nzOverlayStyle = {};
    this.nzDefaultActiveFirstOption = true;
    this.nzBackfill = false;
    this.compareWith = (o1, o2) => o1 === o2;
    this.selectionChange = new EventEmitter();
    this.showPanel = true;
    this.isOpen = false;
    this.activeItem = null;
    this.dir = "ltr";
    this.normalizedDataSource = [];
    this.destroy$ = new Subject();
    this.animationStateChange = new EventEmitter();
    this.activeItemIndex = -1;
    this.selectionChangeSubscription = Subscription.EMPTY;
    this.optionMouseEnterSubscription = Subscription.EMPTY;
    this.dataSourceChangeSubscription = Subscription.EMPTY;
    this.optionSelectionChanges = defer(() => {
      if (this.options) {
        return merge(...this.options.map((option) => option.selectionChange));
      }
      return this.ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionSelectionChanges));
    });
    this.optionMouseEnter = defer(() => {
      if (this.options) {
        return merge(...this.options.map((option) => option.mouseEntered));
      }
      return this.ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionMouseEnter));
    });
  }
  ngOnInit() {
    this.directionality.change?.pipe(takeUntil(this.destroy$)).subscribe((direction) => {
      this.dir = direction;
      this.changeDetectorRef.detectChanges();
    });
    this.dir = this.directionality.value;
  }
  ngOnChanges(changes) {
    const {
      nzDataSource
    } = changes;
    if (nzDataSource) {
      this.normalizedDataSource = normalizeDataSource(nzDataSource.currentValue);
    }
  }
  onAnimationEvent(event) {
    this.animationStateChange.emit(event);
  }
  ngAfterContentInit() {
    if (!this.nzDataSource) {
      this.optionsInit();
    }
  }
  ngAfterViewInit() {
    if (this.nzDataSource) {
      this.optionsInit();
    }
  }
  ngOnDestroy() {
    this.dataSourceChangeSubscription.unsubscribe();
    this.selectionChangeSubscription.unsubscribe();
    this.optionMouseEnterSubscription.unsubscribe();
    this.dataSourceChangeSubscription = this.selectionChangeSubscription = this.optionMouseEnterSubscription = null;
    this.destroy$.next();
    this.destroy$.complete();
  }
  setVisibility() {
    this.showPanel = !!this.options.length;
    this.changeDetectorRef.markForCheck();
  }
  setActiveItem(index) {
    const activeItem = this.options.get(index);
    if (activeItem && !activeItem.active) {
      this.activeItem = activeItem;
      this.activeItemIndex = index;
      this.clearSelectedOptions(this.activeItem);
      this.activeItem.setActiveStyles();
    } else {
      this.activeItem = null;
      this.activeItemIndex = -1;
      this.clearSelectedOptions();
    }
    this.changeDetectorRef.markForCheck();
  }
  setNextItemActive() {
    const nextIndex = this.activeItemIndex + 1 <= this.options.length - 1 ? this.activeItemIndex + 1 : 0;
    this.setActiveItem(nextIndex);
  }
  setPreviousItemActive() {
    const previousIndex = this.activeItemIndex - 1 < 0 ? this.options.length - 1 : this.activeItemIndex - 1;
    this.setActiveItem(previousIndex);
  }
  getOptionIndex(value) {
    return this.options.reduce((result, current, index) => result === -1 ? this.compareWith(value, current.nzValue) ? index : -1 : result, -1);
  }
  getOption(value) {
    return this.options.find((item) => this.compareWith(value, item.nzValue)) || null;
  }
  optionsInit() {
    this.setVisibility();
    this.subscribeOptionChanges();
    const changes = this.nzDataSource ? this.fromDataSourceOptions.changes : this.fromContentOptions.changes;
    this.dataSourceChangeSubscription = changes.subscribe((e) => {
      if (!e.dirty && this.isOpen) {
        setTimeout(() => this.setVisibility());
      }
      this.subscribeOptionChanges();
    });
  }
  /**
   * Clear the status of options
   */
  clearSelectedOptions(skip2, deselect = false) {
    this.options.forEach((option) => {
      if (option !== skip2) {
        if (deselect) {
          option.deselect();
        }
        option.setInactiveStyles();
      }
    });
  }
  subscribeOptionChanges() {
    this.selectionChangeSubscription.unsubscribe();
    this.selectionChangeSubscription = this.optionSelectionChanges.pipe(filter((event) => event.isUserInput)).subscribe((event) => {
      event.source.select();
      event.source.setActiveStyles();
      this.activeItem = event.source;
      this.activeItemIndex = this.getOptionIndex(this.activeItem.nzValue);
      this.clearSelectedOptions(event.source, true);
      this.selectionChange.emit(event.source);
    });
    this.optionMouseEnterSubscription.unsubscribe();
    this.optionMouseEnterSubscription = this.optionMouseEnter.subscribe((event) => {
      event.setActiveStyles();
      this.activeItem = event;
      this.activeItemIndex = this.getOptionIndex(this.activeItem.nzValue);
      this.clearSelectedOptions(event);
    });
  }
};
_NzAutocompleteComponent.\u0275fac = function NzAutocompleteComponent_Factory(t) {
  return new (t || _NzAutocompleteComponent)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(NzNoAnimationDirective, 9));
};
_NzAutocompleteComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NzAutocompleteComponent,
  selectors: [["nz-autocomplete"]],
  contentQueries: function NzAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, NzAutocompleteOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.fromContentOptions = _t);
    }
  },
  viewQuery: function NzAutocompleteComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(TemplateRef, 5);
      \u0275\u0275viewQuery(_c319, 5);
      \u0275\u0275viewQuery(_c413, 5);
      \u0275\u0275viewQuery(NzAutocompleteOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.template = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.panel = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.content = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.fromDataSourceOptions = _t);
    }
  },
  inputs: {
    nzWidth: "nzWidth",
    nzOverlayClassName: "nzOverlayClassName",
    nzOverlayStyle: "nzOverlayStyle",
    nzDefaultActiveFirstOption: "nzDefaultActiveFirstOption",
    nzBackfill: "nzBackfill",
    compareWith: "compareWith",
    nzDataSource: "nzDataSource"
  },
  outputs: {
    selectionChange: "selectionChange"
  },
  exportAs: ["nzAutocomplete"],
  standalone: true,
  features: [\u0275\u0275NgOnChangesFeature, \u0275\u0275StandaloneFeature],
  ngContentSelectors: _c227,
  decls: 1,
  vars: 0,
  consts: [[1, "ant-select-dropdown", "ant-select-dropdown-placement-bottomLeft", 3, "ngClass", "ngStyle", "nzNoAnimation"], ["panel", ""], [2, "max-height", "256px", "overflow-y", "auto", "overflow-anchor", "none"], [2, "display", "flex", "flex-direction", "column"], [4, "ngTemplateOutlet"], ["contentTemplate", ""], ["optionsTemplate", ""], [3, "nzValue", "nzLabel", 4, "ngFor", "ngForOf"], [3, "nzValue", "nzLabel"]],
  template: function NzAutocompleteComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NzAutocompleteComponent_ng_template_0_Template, 9, 10, "ng-template");
    }
  },
  dependencies: [NgClass, NgForOf, NgStyle, NgTemplateOutlet, NzAutocompleteOptionComponent, NzNoAnimationDirective],
  encapsulation: 2,
  data: {
    animation: [slideMotion]
  },
  changeDetection: 0
});
var NzAutocompleteComponent = _NzAutocompleteComponent;
__decorate([InputBoolean()], NzAutocompleteComponent.prototype, "nzDefaultActiveFirstOption", void 0);
__decorate([InputBoolean()], NzAutocompleteComponent.prototype, "nzBackfill", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nz-autocomplete",
      exportAs: "nzAutocomplete",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [NgClass, NgForOf, NgStyle, NgTemplateOutlet, NzAutocompleteOptionComponent, NzNoAnimationDirective],
      template: `
    <ng-template>
      <div
        #panel
        class="ant-select-dropdown ant-select-dropdown-placement-bottomLeft"
        [class.ant-select-dropdown-hidden]="!showPanel"
        [class.ant-select-dropdown-rtl]="dir === 'rtl'"
        [ngClass]="nzOverlayClassName"
        [ngStyle]="nzOverlayStyle"
        [nzNoAnimation]="noAnimation?.nzNoAnimation"
        @slideMotion
        (@slideMotion.done)="onAnimationEvent($event)"
        [@.disabled]="!!noAnimation?.nzNoAnimation"
      >
        <div style="max-height: 256px; overflow-y: auto; overflow-anchor: none;">
          <div style="display: flex; flex-direction: column;">
            <ng-template *ngTemplateOutlet="nzDataSource ? optionsTemplate : contentTemplate"></ng-template>
          </div>
        </div>
      </div>
      <ng-template #contentTemplate>
        <ng-content></ng-content>
      </ng-template>
      <ng-template #optionsTemplate>
        <nz-auto-option *ngFor="let option of normalizedDataSource" [nzValue]="option.value" [nzLabel]="option.label">
          {{ option.label }}
        </nz-auto-option>
      </ng-template>
    </ng-template>
  `,
      animations: [slideMotion]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: NzNoAnimationDirective,
    decorators: [{
      type: Host
    }, {
      type: Optional
    }]
  }], {
    nzWidth: [{
      type: Input
    }],
    nzOverlayClassName: [{
      type: Input
    }],
    nzOverlayStyle: [{
      type: Input
    }],
    nzDefaultActiveFirstOption: [{
      type: Input
    }],
    nzBackfill: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    nzDataSource: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    fromContentOptions: [{
      type: ContentChildren,
      args: [NzAutocompleteOptionComponent, {
        descendants: true
      }]
    }],
    fromDataSourceOptions: [{
      type: ViewChildren,
      args: [NzAutocompleteOptionComponent]
    }],
    template: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: false
      }]
    }],
    panel: [{
      type: ViewChild,
      args: ["panel", {
        static: false
      }]
    }],
    content: [{
      type: ViewChild,
      args: ["content", {
        static: false
      }]
    }]
  });
})();
var _NzAutocompleteModule = class _NzAutocompleteModule {
};
_NzAutocompleteModule.\u0275fac = function NzAutocompleteModule_Factory(t) {
  return new (t || _NzAutocompleteModule)();
};
_NzAutocompleteModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NzAutocompleteModule
});
_NzAutocompleteModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [NzAutocompleteOptgroupComponent]
});
var NzAutocompleteModule = _NzAutocompleteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzAutocompleteModule, [{
    type: NgModule,
    args: [{
      exports: [NzAutocompleteComponent, NzAutocompleteOptionComponent, NzAutocompleteTriggerDirective, NzAutocompleteOptgroupComponent],
      imports: [NzAutocompleteComponent, NzAutocompleteOptionComponent, NzAutocompleteTriggerDirective, NzAutocompleteOptgroupComponent]
    }]
  }], null, null);
})();

// src/app/layout/basic/widgets/search.component.ts
function HeaderSearchComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 6);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("nzType", ctx_r0.focus ? "arrow-down" : "search");
  }
}
function HeaderSearchComponent_ng_template_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 7);
  }
}
function HeaderSearchComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, HeaderSearchComponent_ng_template_3_Conditional_0_Template, 1, 0, "i", 7);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275conditional(0, ctx_r2.loading ? 0 : -1);
  }
}
function HeaderSearchComponent_For_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-auto-option", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r7 = ctx.$implicit;
    \u0275\u0275property("nzValue", i_r7);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate(i_r7);
  }
}
var _HeaderSearchComponent = class _HeaderSearchComponent {
  constructor() {
    this.el = inject(ElementRef).nativeElement;
    this.cdr = inject(ChangeDetectorRef);
    this.q = "";
    this.qIpt = null;
    this.options = [];
    this.search$ = new BehaviorSubject("");
    this.loading = false;
    this.focus = false;
    this.searchToggled = false;
    this.toggleChangeChange = new EventEmitter();
  }
  set toggleChange(value) {
    if (typeof value === "undefined") {
      return;
    }
    this.searchToggled = value;
    this.focus = value;
    if (value) {
      setTimeout(() => this.qIpt.focus());
    }
  }
  ngAfterViewInit() {
    this.qIpt = this.el.querySelector(".ant-input");
    this.search$.pipe(debounceTime(500), distinctUntilChanged(), tap({
      complete: () => {
        this.loading = true;
      }
    })).subscribe((value) => {
      this.options = value ? [value, value + value, value + value + value] : [];
      this.loading = false;
      this.cdr.detectChanges();
    });
  }
  qFocus() {
    this.focus = true;
  }
  qBlur() {
    this.focus = false;
    this.searchToggled = false;
    this.options.length = 0;
    this.toggleChangeChange.emit(false);
  }
  search(ev) {
    this.search$.next(ev.target.value);
  }
  ngOnDestroy() {
    this.search$.complete();
    this.search$.unsubscribe();
  }
};
_HeaderSearchComponent.\u0275fac = function HeaderSearchComponent_Factory(t) {
  return new (t || _HeaderSearchComponent)();
};
_HeaderSearchComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HeaderSearchComponent, selectors: [["header-search"]], hostVars: 4, hostBindings: function HeaderSearchComponent_HostBindings(rf, ctx) {
  if (rf & 2) {
    \u0275\u0275classProp("alain-default__search-focus", ctx.focus)("alain-default__search-toggled", ctx.searchToggled);
  }
}, inputs: { toggleChange: "toggleChange" }, outputs: { toggleChangeChange: "toggleChangeChange" }, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 10, vars: 5, consts: [[3, "nzPrefix", "nzSuffix"], ["iconTpl", ""], ["loadingTpl", ""], ["type", "text", "nz-input", "", "hotkey", "F1", 3, "ngModel", "nzAutocomplete", "ngModelChange", "input", "focus", "blur"], ["nzBackfill", ""], ["auto", ""], ["nz-icon", "", 3, "nzType"], ["nz-icon", "", "nzType", "loading"], [3, "nzValue"]], template: function HeaderSearchComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nz-input-group", 0);
    \u0275\u0275template(1, HeaderSearchComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(3, HeaderSearchComponent_ng_template_3_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementStart(5, "input", 3);
    \u0275\u0275listener("ngModelChange", function HeaderSearchComponent_Template_input_ngModelChange_5_listener($event) {
      return ctx.q = $event;
    })("input", function HeaderSearchComponent_Template_input_input_5_listener($event) {
      return ctx.search($event);
    })("focus", function HeaderSearchComponent_Template_input_focus_5_listener() {
      return ctx.qFocus();
    })("blur", function HeaderSearchComponent_Template_input_blur_5_listener() {
      return ctx.qBlur();
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "nz-autocomplete", 4, 5);
    \u0275\u0275repeaterCreate(8, HeaderSearchComponent_For_9_Template, 2, 2, "nz-auto-option", 8, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const _r1 = \u0275\u0275reference(2);
    const _r3 = \u0275\u0275reference(4);
    const _r4 = \u0275\u0275reference(7);
    \u0275\u0275property("nzPrefix", _r1)("nzSuffix", _r3);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngModel", ctx.q)("nzAutocomplete", _r4);
    \u0275\u0275attribute("placeholder", "Search");
    \u0275\u0275advance(3);
    \u0275\u0275repeater(ctx.options);
  }
}, dependencies: [FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, NzInputModule, NzInputDirective, NzInputGroupComponent, NzInputGroupWhitSuffixOrPrefixDirective, NzIconModule, NzIconDirective, NzAutocompleteModule, NzAutocompleteComponent, NzAutocompleteOptionComponent, NzAutocompleteTriggerDirective], encapsulation: 2, changeDetection: 0 });
var HeaderSearchComponent = _HeaderSearchComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HeaderSearchComponent, { className: "HeaderSearchComponent", filePath: "src\\app\\layout\\basic\\widgets\\search.component.ts", lineNumber: 56 });
})();

// src/app/layout/basic/widgets/user.component.ts
var _HeaderUserComponent = class _HeaderUserComponent {
  constructor() {
    this.settings = inject(SettingsService);
    this.router = inject(Router);
    this.tokenService = inject(DA_SERVICE_TOKEN);
  }
  get user() {
    return this.settings.user;
  }
  logout() {
    this.tokenService.clear();
    this.router.navigateByUrl(this.tokenService.login_url);
  }
};
_HeaderUserComponent.\u0275fac = function HeaderUserComponent_Factory(t) {
  return new (t || _HeaderUserComponent)();
};
_HeaderUserComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HeaderUserComponent, selectors: [["header-user"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 23, vars: 15, consts: [["nz-dropdown", "", "nzPlacement", "bottomRight", 1, "alain-default__nav-item", "d-flex", "align-items-center", "px-sm", 3, "nzDropdownMenu"], ["nzSize", "small", 1, "mr-sm", 3, "nzSrc"], ["userMenu", "nzDropdownMenu"], ["nz-menu", "", 1, "width-sm"], ["nz-menu-item", "", "routerLink", "/pro/account/center"], ["nz-icon", "", "nzType", "user", 1, "mr-sm"], ["nz-menu-item", "", "routerLink", "/pro/account/settings"], ["nz-icon", "", "nzType", "setting", 1, "mr-sm"], ["nz-menu-item", "", "routerLink", "/exception/trigger"], ["nz-icon", "", "nzType", "close-circle", 1, "mr-sm"], ["nz-menu-divider", ""], ["nz-menu-item", "", 3, "click"], ["nz-icon", "", "nzType", "logout", 1, "mr-sm"]], template: function HeaderUserComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "nz-avatar", 1);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "nz-dropdown-menu", null, 2)(5, "div", 3)(6, "div", 4);
    \u0275\u0275element(7, "i", 5);
    \u0275\u0275text(8);
    \u0275\u0275pipe(9, "i18n");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 6);
    \u0275\u0275element(11, "i", 7);
    \u0275\u0275text(12);
    \u0275\u0275pipe(13, "i18n");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "div", 8);
    \u0275\u0275element(15, "i", 9);
    \u0275\u0275text(16);
    \u0275\u0275pipe(17, "i18n");
    \u0275\u0275elementEnd();
    \u0275\u0275element(18, "li", 10);
    \u0275\u0275elementStart(19, "div", 11);
    \u0275\u0275listener("click", function HeaderUserComponent_Template_div_click_19_listener() {
      return ctx.logout();
    });
    \u0275\u0275element(20, "i", 12);
    \u0275\u0275text(21);
    \u0275\u0275pipe(22, "i18n");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(4);
    \u0275\u0275property("nzDropdownMenu", _r0);
    \u0275\u0275advance(1);
    \u0275\u0275property("nzSrc", ctx.user.avatar);
    \u0275\u0275advance(1);
    \u0275\u0275textInterpolate1(" ", ctx.user.name, " ");
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(9, 7, "menu.account.center"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(13, 9, "menu.account.settings"), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(17, 11, "menu.account.trigger"), " ");
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(22, 13, "menu.account.logout"), " ");
  }
}, dependencies: [NzDropDownModule, NzMenuDirective, NzMenuItemComponent, NzMenuDividerDirective, NzDropDownDirective, NzDropdownMenuComponent, NzMenuModule, NzIconModule, NzIconDirective, I18nPipe, NzAvatarModule, NzAvatarComponent], encapsulation: 2, changeDetection: 0 });
var HeaderUserComponent = _HeaderUserComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HeaderUserComponent, { className: "HeaderUserComponent", filePath: "src\\app\\layout\\basic\\widgets\\user.component.ts", lineNumber: 43 });
})();

// src/app/layout/basic/basic.component.ts
function LayoutBasicComponent_ng_template_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18)(1, "div", 19)(2, "strong");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "p", 20);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(6, "nz-dropdown-menu", null, 21)(8, "ul", 22)(9, "li", 23);
    \u0275\u0275text(10);
    \u0275\u0275pipe(11, "i18n");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "li", 24);
    \u0275\u0275text(13);
    \u0275\u0275pipe(14, "i18n");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const _r5 = \u0275\u0275reference(7);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("nzDropdownMenu", _r5);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.user.name);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.user.email);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(11, 5, "menu.account.center"));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(14, 7, "menu.account.settings"));
  }
}
function LayoutBasicComponent_ng_template_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "router-outlet");
  }
}
var _LayoutBasicComponent = class _LayoutBasicComponent {
  constructor() {
    this.settings = inject(SettingsService);
    this.options = {
      logoExpanded: `https://www.cairothreea.com/images/ncmp-logo.gif`,
      logoCollapsed: `https://www.cairothreea.com/images/ncmp-logo.gif`
    };
    this.searchToggleStatus = false;
    this.showSettingDrawer = !environment2.production;
  }
  get user() {
    return this.settings.user;
  }
};
_LayoutBasicComponent.\u0275fac = function LayoutBasicComponent_Factory(t) {
  return new (t || _LayoutBasicComponent)();
};
_LayoutBasicComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LayoutBasicComponent, selectors: [["layout-basic"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 28, vars: 6, consts: [[3, "options", "asideUser", "content", "customError"], ["direction", "left", "hidden", "mobile"], ["layout-default-header-item-trigger", "", "routerLink", "/passport/lock"], ["nz-icon", "", "nzType", "lock"], ["direction", "left", "hidden", "pc"], ["layout-default-header-item-trigger", "", 3, "click"], ["nz-icon", "", "nzType", "search"], ["direction", "middle"], [1, "alain-default__search", 3, "toggleChange"], ["direction", "right", "hidden", "mobile"], ["layout-default-header-item-trigger", "", "nz-dropdown", "", "nzTrigger", "click", "nzPlacement", "bottomRight", 3, "nzDropdownMenu"], ["nz-icon", "", "nzType", "setting"], ["settingsMenu", "nzDropdownMenu"], ["nz-menu", "", 2, "width", "200px"], ["nz-menu-item", ""], ["direction", "right"], ["asideUserTpl", ""], ["contentTpl", ""], ["nz-dropdown", "", "nzTrigger", "click", 1, "alain-default__aside-user", 3, "nzDropdownMenu"], [1, "alain-default__aside-user-info"], [1, "mb0"], ["userMenu", "nzDropdownMenu"], ["nz-menu", ""], ["nz-menu-item", "", "routerLink", "/pro/account/center"], ["nz-menu-item", "", "routerLink", "/pro/account/settings"]], template: function LayoutBasicComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "layout-default", 0)(1, "layout-default-header-item", 1)(2, "a", 2);
    \u0275\u0275element(3, "i", 3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "layout-default-header-item", 4)(5, "div", 5);
    \u0275\u0275listener("click", function LayoutBasicComponent_Template_div_click_5_listener() {
      return ctx.searchToggleStatus = !ctx.searchToggleStatus;
    });
    \u0275\u0275element(6, "i", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "layout-default-header-item", 7);
    \u0275\u0275element(8, "header-search", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "layout-default-header-item", 9)(10, "div", 10);
    \u0275\u0275element(11, "i", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "nz-dropdown-menu", null, 12)(14, "div", 13)(15, "div", 14);
    \u0275\u0275element(16, "header-fullscreen");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "div", 14);
    \u0275\u0275element(18, "header-clear-storage");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "div", 14);
    \u0275\u0275element(20, "header-i18n");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(21, "layout-default-header-item", 15);
    \u0275\u0275element(22, "header-user");
    \u0275\u0275elementEnd();
    \u0275\u0275template(23, LayoutBasicComponent_ng_template_23_Template, 15, 9, "ng-template", null, 16, \u0275\u0275templateRefExtractor)(25, LayoutBasicComponent_ng_template_25_Template, 1, 0, "ng-template", null, 17, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275element(27, "theme-btn");
  }
  if (rf & 2) {
    const _r0 = \u0275\u0275reference(13);
    const _r2 = \u0275\u0275reference(24);
    const _r4 = \u0275\u0275reference(26);
    \u0275\u0275property("options", ctx.options)("asideUser", _r2)("content", _r4)("customError", null);
    \u0275\u0275advance(8);
    \u0275\u0275property("toggleChange", ctx.searchToggleStatus);
    \u0275\u0275advance(2);
    \u0275\u0275property("nzDropdownMenu", _r0);
  }
}, dependencies: [
  RouterOutlet,
  RouterLink,
  I18nPipe,
  LayoutDefaultModule,
  LayoutDefaultComponent,
  LayoutDefaultHeaderItemComponent,
  LayoutDefaultHeaderItemTriggerDirective,
  SettingDrawerModule,
  ThemeBtnComponent,
  NzIconModule,
  NzIconDirective,
  NzMenuModule,
  NzMenuDirective,
  NzMenuItemComponent,
  NzDropDownModule,
  NzDropDownDirective,
  NzDropdownMenuComponent,
  NzAvatarModule,
  HeaderSearchComponent,
  HeaderClearStorageComponent,
  HeaderFullScreenComponent,
  HeaderUserComponent,
  HeaderI18nComponent
], encapsulation: 2 });
var LayoutBasicComponent = _LayoutBasicComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LayoutBasicComponent, { className: "LayoutBasicComponent", filePath: "src\\app\\layout\\basic\\basic.component.ts", lineNumber: 104 });
})();

// src/app/layout/blank/blank.component.ts
var _LayoutBlankComponent = class _LayoutBlankComponent {
};
_LayoutBlankComponent.\u0275fac = function LayoutBlankComponent_Factory(t) {
  return new (t || _LayoutBlankComponent)();
};
_LayoutBlankComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LayoutBlankComponent, selectors: [["layout-blank"]], hostVars: 2, hostBindings: function LayoutBlankComponent_HostBindings(rf, ctx) {
  if (rf & 2) {
    \u0275\u0275classProp("alain-blank", true);
  }
}, standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 1, vars: 0, template: function LayoutBlankComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "router-outlet");
  }
}, dependencies: [RouterOutlet], encapsulation: 2 });
var LayoutBlankComponent = _LayoutBlankComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LayoutBlankComponent, { className: "LayoutBlankComponent", filePath: "src\\app\\layout\\blank\\blank.component.ts", lineNumber: 13 });
})();

// node_modules/@delon/abc/fesm2022/global-footer.mjs
var _c069 = ["host"];
function GlobalFooterItemComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c143 = ["*"];
function GlobalFooterComponent_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 3);
    \u0275\u0275listener("click", function GlobalFooterComponent_Conditional_0_For_2_Template_a_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r9);
      const i_r3 = restoredCtx.$implicit;
      const ctx_r8 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r8.to(i_r3));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r3 = ctx.$implicit;
    \u0275\u0275property("innerHTML", i_r3._title, \u0275\u0275sanitizeHtml);
  }
}
function GlobalFooterComponent_Conditional_0_For_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function GlobalFooterComponent_Conditional_0_For_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 4);
    \u0275\u0275listener("click", function GlobalFooterComponent_Conditional_0_For_4_Template_a_click_0_listener() {
      const restoredCtx = \u0275\u0275restoreView(_r17);
      const i_r10 = restoredCtx.$implicit;
      const ctx_r16 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r16.to(i_r10));
    });
    \u0275\u0275template(1, GlobalFooterComponent_Conditional_0_For_4_ng_container_1_Template, 1, 0, "ng-container", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const i_r10 = ctx.$implicit;
    \u0275\u0275advance(1);
    \u0275\u0275property("ngTemplateOutlet", i_r10.host);
  }
}
function GlobalFooterComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275repeaterCreate(1, GlobalFooterComponent_Conditional_0_For_2_Template, 1, 1, "a", 6, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275repeaterCreate(3, GlobalFooterComponent_Conditional_0_For_4_Template, 2, 1, "a", 7, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(1);
    \u0275\u0275repeater(ctx_r0.links);
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r0.items);
  }
}
var _GlobalFooterItemComponent = class _GlobalFooterItemComponent {
};
_GlobalFooterItemComponent.\u0275fac = function GlobalFooterItemComponent_Factory(t) {
  return new (t || _GlobalFooterItemComponent)();
};
_GlobalFooterItemComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GlobalFooterItemComponent,
  selectors: [["global-footer-item"]],
  viewQuery: function GlobalFooterItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c069, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.host = _t.first);
    }
  },
  inputs: {
    href: "href",
    blankTarget: "blankTarget"
  },
  exportAs: ["globalFooterItem"],
  ngContentSelectors: _c143,
  decls: 2,
  vars: 0,
  consts: [["host", ""]],
  template: function GlobalFooterItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, GlobalFooterItemComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var GlobalFooterItemComponent = _GlobalFooterItemComponent;
__decorate([InputBoolean2()], GlobalFooterItemComponent.prototype, "blankTarget", void 0);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GlobalFooterItemComponent, [{
    type: Component,
    args: [{
      selector: "global-footer-item",
      exportAs: "globalFooterItem",
      template: ` <ng-template #host><ng-content /></ng-template> `,
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, {
    host: [{
      type: ViewChild,
      args: ["host", {
        static: true
      }]
    }],
    href: [{
      type: Input
    }],
    blankTarget: [{
      type: Input
    }]
  });
})();
var _GlobalFooterComponent = class _GlobalFooterComponent {
  set links(val) {
    val.forEach((i) => i._title = this.dom.bypassSecurityTrustHtml(i.title));
    this._links = val;
  }
  get links() {
    return this._links;
  }
  constructor(router, win, dom, directionality, cdr) {
    this.router = router;
    this.win = win;
    this.dom = dom;
    this.directionality = directionality;
    this.cdr = cdr;
    this.dir$ = this.directionality.change?.pipe(takeUntilDestroyed());
    this._links = [];
    this.dir = "ltr";
  }
  to(item) {
    if (!item.href) {
      return;
    }
    if (item.blankTarget) {
      this.win.open(item.href);
      return;
    }
    if (/^https?:\/\//.test(item.href)) {
      this.win.location.href = item.href;
    } else {
      this.router.navigateByUrl(item.href);
    }
  }
  ngOnInit() {
    this.dir = this.directionality.value;
    this.dir$.subscribe((direction) => {
      this.dir = direction;
      this.cdr.detectChanges();
    });
  }
};
_GlobalFooterComponent.\u0275fac = function GlobalFooterComponent_Factory(t) {
  return new (t || _GlobalFooterComponent)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(WINDOW), \u0275\u0275directiveInject(DomSanitizer), \u0275\u0275directiveInject(Directionality, 8), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_GlobalFooterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GlobalFooterComponent,
  selectors: [["global-footer"]],
  contentQueries: function GlobalFooterComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, GlobalFooterItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.items = _t);
    }
  },
  hostVars: 4,
  hostBindings: function GlobalFooterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("global-footer", true)("global-footer-rtl", ctx.dir === "rtl");
    }
  },
  inputs: {
    links: "links"
  },
  exportAs: ["globalFooter"],
  ngContentSelectors: _c143,
  decls: 3,
  vars: 1,
  consts: [["class", "global-footer__links"], [1, "global-footer__copyright"], [1, "global-footer__links"], [1, "global-footer__links-item", 3, "innerHTML", "click"], [1, "global-footer__links-item", 3, "click"], [4, "ngTemplateOutlet"], ["class", "global-footer__links-item", 3, "innerHTML"], ["class", "global-footer__links-item"]],
  template: function GlobalFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, GlobalFooterComponent_Conditional_0_Template, 5, 0, "div", 0);
      \u0275\u0275elementStart(1, "div", 1);
      \u0275\u0275projection(2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275conditional(0, ctx.links.length > 0 || ctx.items.length > 0 ? 0 : -1);
    }
  },
  dependencies: [NgTemplateOutlet],
  encapsulation: 2,
  changeDetection: 0
});
var GlobalFooterComponent = _GlobalFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GlobalFooterComponent, [{
    type: Component,
    args: [{
      selector: "global-footer",
      exportAs: "globalFooter",
      host: {
        "[class.global-footer]": "true",
        "[class.global-footer-rtl]": `dir === 'rtl'`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: '@if (links.length > 0 || items.length > 0) {\n  <div class="global-footer__links">\n    @for (i of links; track $index) {\n      <a class="global-footer__links-item" (click)="to(i)" [innerHTML]="i._title"></a>\n    }\n    @for (i of items; track $index) {\n      <a class="global-footer__links-item" (click)="to(i)">\n        <ng-container *ngTemplateOutlet="i.host" />\n      </a>\n    }\n  </div>\n}\n<div class="global-footer__copyright">\n  <ng-content />\n</div>\n'
    }]
  }], () => [{
    type: Router
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [WINDOW]
    }]
  }, {
    type: DomSanitizer
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    links: [{
      type: Input
    }],
    items: [{
      type: ContentChildren,
      args: [GlobalFooterItemComponent]
    }]
  });
})();
var COMPONENTS23 = [GlobalFooterComponent, GlobalFooterItemComponent];
var _GlobalFooterModule = class _GlobalFooterModule {
};
_GlobalFooterModule.\u0275fac = function GlobalFooterModule_Factory(t) {
  return new (t || _GlobalFooterModule)();
};
_GlobalFooterModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _GlobalFooterModule
});
_GlobalFooterModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, RouterModule]
});
var GlobalFooterModule = _GlobalFooterModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GlobalFooterModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule],
      declarations: COMPONENTS23,
      exports: COMPONENTS23
    }]
  }], null, null);
})();

// src/app/layout/passport/passport.component.ts
var _LayoutPassportComponent = class _LayoutPassportComponent {
  constructor() {
    this.tokenService = inject(DA_SERVICE_TOKEN);
    this.links = [
      {
        title: "\u5E2E\u52A9",
        href: ""
      },
      {
        title: "\u9690\u79C1",
        href: ""
      },
      {
        title: "\u6761\u6B3E",
        href: ""
      }
    ];
  }
  ngOnInit() {
    this.tokenService.clear();
  }
};
_LayoutPassportComponent.\u0275fac = function LayoutPassportComponent_Factory(t) {
  return new (t || _LayoutPassportComponent)();
};
_LayoutPassportComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LayoutPassportComponent, selectors: [["layout-passport"]], standalone: true, features: [\u0275\u0275StandaloneFeature], decls: 4, vars: 0, consts: [[1, "container"], ["showLangText", "false", 1, "langs"], [1, "wrap"]], template: function LayoutPassportComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "header-i18n", 1);
    \u0275\u0275elementStart(2, "div", 2);
    \u0275\u0275element(3, "router-outlet");
    \u0275\u0275elementEnd()();
  }
}, dependencies: [RouterOutlet, HeaderI18nComponent, GlobalFooterModule, NzIconModule], styles: ['\n\n[_nghost-%COMP%]     .container {\n  display: flex;\n  flex-direction: column;\n  min-height: 100%;\n  background: #f0f2f5;\n}\n[_nghost-%COMP%]     .langs {\n  width: 100%;\n  height: 40px;\n  line-height: 44px;\n  text-align: right;\n}\n[_nghost-%COMP%]     .langs .anticon {\n  cursor: pointer;\n  margin-top: 24px;\n  margin-right: 24px;\n  font-size: 14px;\n  vertical-align: top;\n}\n[_nghost-%COMP%]     .wrap {\n  flex: 1;\n  padding: 32px 0;\n}\n[_nghost-%COMP%]     .ant-form-item {\n  display: flex;\n  justify-content: space-between;\n  margin-bottom: 24px;\n}\n[_nghost-%COMP%]     .top {\n  text-align: center;\n}\n[_nghost-%COMP%]     .header {\n  height: 44px;\n  line-height: 44px;\n}\n[_nghost-%COMP%]     .header a {\n  text-decoration: none;\n}\n[_nghost-%COMP%]     .logo {\n  height: 44px;\n  margin-right: 16px;\n}\n[_nghost-%COMP%]     .title {\n  position: relative;\n  font-family:\n    "Myriad Pro",\n    "Helvetica Neue",\n    Arial,\n    Helvetica,\n    sans-serif;\n  font-size: 33px;\n  font-weight: 600;\n  color: rgba(0, 0, 0, 0.85);\n  vertical-align: middle;\n}\n[_nghost-%COMP%]     .desc {\n  margin-top: 12px;\n  margin-bottom: 40px;\n  font-size: 14px;\n  color: rgba(0, 0, 0, 0.45);\n}\n@media (min-width: 768px) {\n  [_nghost-%COMP%]     .container {\n    background-image: url(https://gw.alipayobjects.com/zos/rmsportal/TVYTbAXWheQpRcWDaDMu.svg);\n    background-repeat: no-repeat;\n    background-position: center 110px;\n    background-size: 100%;\n  }\n  [_nghost-%COMP%]     .wrap {\n    padding: 32px 0 24px;\n  }\n}\n[data-theme=dark]   [_nghost-%COMP%]     .container {\n  background: #141414;\n}\n[data-theme=dark]   [_nghost-%COMP%]     .title {\n  color: rgba(255, 255, 255, 0.85);\n}\n[data-theme=dark]   [_nghost-%COMP%]     .desc {\n  color: rgba(255, 255, 255, 0.45);\n}\n@media (min-width: 768px) {\n  [data-theme=dark]   [_nghost-%COMP%]     .container {\n    background-image: none;\n  }\n}\n[data-theme=compact]   [_nghost-%COMP%]     .ant-form-item {\n  margin-bottom: 16px;\n}\n/*# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL2FwcC9sYXlvdXQvcGFzc3BvcnQvRTovcHJvamVjdHMvaW90LWFwcC9zcmMvYXBwL2xheW91dC9wYXNzcG9ydC9wYXNzcG9ydC5jb21wb25lbnQubGVzcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiQGltcG9ydCAnQGRlbG9uL3RoZW1lL2luZGV4JztcblxuOmhvc3QgOjpuZy1kZWVwIHtcbiAgLmNvbnRhaW5lciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIG1pbi1oZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogI2YwZjJmNTtcbiAgfVxuXG4gIC5sYW5ncyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiA0MHB4O1xuICAgIGxpbmUtaGVpZ2h0OiA0NHB4O1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuXG4gICAgLmFudGljb24ge1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgbWFyZ2luLXRvcDogMjRweDtcbiAgICAgIG1hcmdpbi1yaWdodDogMjRweDtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgfVxuICB9XG5cbiAgLndyYXAge1xuICAgIGZsZXg6IDE7XG4gICAgcGFkZGluZzogMzJweCAwO1xuICB9XG5cbiAgLmFudC1mb3JtLWl0ZW0ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIG1hcmdpbi1ib3R0b206IDI0cHg7XG4gIH1cblxuICAudG9wIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIH1cblxuICAuaGVhZGVyIHtcbiAgICBoZWlnaHQ6IDQ0cHg7XG4gICAgbGluZS1oZWlnaHQ6IDQ0cHg7XG5cbiAgICBhIHtcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICB9XG4gIH1cblxuICAubG9nbyB7XG4gICAgaGVpZ2h0OiA0NHB4O1xuICAgIG1hcmdpbi1yaWdodDogMTZweDtcbiAgfVxuXG4gIC50aXRsZSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZvbnQtZmFtaWx5OiAnTXlyaWFkIFBybycsICdIZWx2ZXRpY2EgTmV1ZScsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XG4gICAgZm9udC1zaXplOiAzM3B4O1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgY29sb3I6IEBoZWFkaW5nLWNvbG9yO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gIH1cblxuICAuZGVzYyB7XG4gICAgbWFyZ2luLXRvcDogMTJweDtcbiAgICBtYXJnaW4tYm90dG9tOiA0MHB4O1xuICAgIGZvbnQtc2l6ZTogQGZvbnQtc2l6ZS1iYXNlO1xuICAgIGNvbG9yOiBAdGV4dC1jb2xvci1zZWNvbmRhcnk7XG4gIH1cblxuICBAbWVkaWEgKG1pbi13aWR0aDogQHNjcmVlbi1tZC1taW4pIHtcbiAgICAuY29udGFpbmVyIHtcbiAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnaHR0cHM6Ly9ndy5hbGlwYXlvYmplY3RzLmNvbS96b3Mvcm1zcG9ydGFsL1RWWVRiQVhXaGVRcFJjV0RhRE11LnN2ZycpO1xuICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciAxMTBweDtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogMTAwJTtcbiAgICB9XG5cbiAgICAud3JhcCB7XG4gICAgICBwYWRkaW5nOiAzMnB4IDAgMjRweDtcbiAgICB9XG4gIH1cbn1cblxuW2RhdGEtdGhlbWU9J2RhcmsnXSB7XG4gIDpob3N0IDo6bmctZGVlcCB7XG4gICAgLmNvbnRhaW5lciB7XG4gICAgICBiYWNrZ3JvdW5kOiAjMTQxNDE0O1xuICAgIH1cblxuICAgIC50aXRsZSB7XG4gICAgICBjb2xvcjogZmFkZShAd2hpdGUsIDg1JSk7XG4gICAgfVxuXG4gICAgLmRlc2Mge1xuICAgICAgY29sb3I6IGZhZGUoQHdoaXRlLCA0NSUpO1xuICAgIH1cblxuICAgIEBtZWRpYSAobWluLXdpZHRoOiBAc2NyZWVuLW1kLW1pbikge1xuICAgICAgLmNvbnRhaW5lciB7XG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbltkYXRhLXRoZW1lPSdjb21wYWN0J10ge1xuICA6aG9zdCA6Om5nLWRlZXAge1xuICAgIC5hbnQtZm9ybS1pdGVtIHtcbiAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gICAgfVxuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiO0FBRUEsTUFBTSxVQUNKLENBQUE7QUFDRSxXQUFBO0FBQ0Esa0JBQUE7QUFDQSxjQUFBO0FBQ0EsY0FBQTs7QUFMSixNQUFNLFVBUUosQ0FBQTtBQUNFLFNBQUE7QUFDQSxVQUFBO0FBQ0EsZUFBQTtBQUNBLGNBQUE7O0FBWkosTUFBTSxVQVFKLENBQUEsTUFNRSxDQUFBO0FBQ0UsVUFBQTtBQUNBLGNBQUE7QUFDQSxnQkFBQTtBQUNBLGFBQUE7QUFDQSxrQkFBQTs7QUFuQk4sTUFBTSxVQXVCSixDQUFBO0FBQ0UsUUFBQTtBQUNBLFdBQUEsS0FBQTs7QUF6QkosTUFBTSxVQTRCSixDQUFBO0FBQ0UsV0FBQTtBQUNBLG1CQUFBO0FBQ0EsaUJBQUE7O0FBL0JKLE1BQU0sVUFrQ0osQ0FBQTtBQUNFLGNBQUE7O0FBbkNKLE1BQU0sVUFzQ0osQ0FBQTtBQUNFLFVBQUE7QUFDQSxlQUFBOztBQXhDSixNQUFNLFVBc0NKLENBQUEsT0FJRTtBQUNFLG1CQUFBOztBQTNDTixNQUFNLFVBK0NKLENBQUE7QUFDRSxVQUFBO0FBQ0EsZ0JBQUE7O0FBakRKLE1BQU0sVUFvREosQ0FBQTtBQUNFLFlBQUE7QUFDQTtJQUFhLFlBQUE7SUFBYyxnQkFBQTtJQUFBLEtBQUE7SUFBQSxTQUFBO0lBQUE7QUFDM0IsYUFBQTtBQUNBLGVBQUE7QUFDQSxTQUFBLEtBQUEsQ0FBQSxFQUFBLENBQUEsRUFBQSxDQUFBLEVBQUE7QUFDQSxrQkFBQTs7QUExREosTUFBTSxVQTZESixDQUFBO0FBQ0UsY0FBQTtBQUNBLGlCQUFBO0FBQ0EsYUFBQTtBQUNBLFNBQUEsS0FBQSxDQUFBLEVBQUEsQ0FBQSxFQUFBLENBQUEsRUFBQTs7QUFHRixPQUFBLENBQW1DLFNBQUEsRUFBQTtBQUFuQyxRQXBFSSxVQXFFRixDQXBFRjtBQXFFSSxzQkFBQTtBQUNBLHVCQUFBO0FBQ0EseUJBQUEsT0FBQTtBQUNBLHFCQUFBOztBQUxKLFFBcEVJLFVBNEVGLENBckRGO0FBc0RJLGFBQUEsS0FBQSxFQUFBOzs7QUFLTixDQUFBLGlCQUNFLE1BQU0sVUFDSixDQW5GRjtBQW9GSSxjQUFBOztBQUhOLENBQUEsaUJBQ0UsTUFBTSxVQUtKLENBcENGO0FBcUNJLFNBQUEsS0FBQSxHQUFBLEVBQUEsR0FBQSxFQUFBLEdBQUEsRUFBQTs7QUFQTixDQUFBLGlCQUNFLE1BQU0sVUFTSixDQS9CRjtBQWdDSSxTQUFBLEtBQUEsR0FBQSxFQUFBLEdBQUEsRUFBQSxHQUFBLEVBQUE7O0FBR0YsT0FBQSxDQUFtQyxTQUFBLEVBQUE7QUFBbkMsR0FBQSxpQkFiRixNQUFNLFVBY0YsQ0FoR0o7QUFpR00sc0JBQUE7OztBQU1SLENBQUEsb0JBQ0UsTUFBTSxVQUNKLENBOUVGO0FBK0VJLGlCQUFBOzsiLAogICJuYW1lcyI6IFtdCn0K */'] });
var LayoutPassportComponent = _LayoutPassportComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LayoutPassportComponent, { className: "LayoutPassportComponent", filePath: "src\\app\\layout\\passport\\passport.component.ts", lineNumber: 35 });
})();

// src/app/routes/routes.ts
var routes = [
  {
    path: "",
    component: LayoutBasicComponent,
    // canActivate: [startPageGuard, authSimpleCanActivate],
    // canActivateChild: [authSimpleCanActivateChild],
    // data: {},
    children: [
      { path: "", redirectTo: "dashboard", pathMatch: "full" },
      { path: "dashboard", component: DashboardV1Component },
      { path: "maintenance", component: MaintenanceComponent },
      { path: "inventory", component: InventoryComponent },
      { path: "supply-chain", component: SupplyChainComponent },
      { path: "vehicles", component: VehiclesComponent },
      { path: "machines", component: MachineComponent },
      { path: "orders", component: OrdersComponent },
      { path: "semi-corn", component: SemiCornComponent },
      { path: "ai", component: AiComponent },
      { path: "power", component: PowerComponent }
    ]
  },
  // passport
  // { path: '', loadChildren: () => import('./passport/routes').then(m => m.routes) },
  { path: "exception", loadChildren: () => import("./chunk-R43XHR22.js").then((m) => m.routes) },
  { path: "**", redirectTo: "exception/404" }
];

// src/style-icons.ts
var ICONS = [AppstoreOutline];

// src/style-icons-auto.ts
var ICONS_AUTO = [
  AlipayCircleOutline,
  LoadingOutline,
  ApiOutline,
  AppstoreOutline,
  ArrowDownOutline,
  AuditOutline,
  BookOutline,
  BorderLeftOutline,
  BorderRightOutline,
  CloudOutline,
  ContainerOutline,
  CopyrightOutline,
  CustomerServiceOutline,
  DashboardOutline,
  DatabaseOutline,
  DingdingOutline,
  DislikeOutline,
  DownloadOutline,
  ForkOutline,
  FrownOutline,
  FullscreenExitOutline,
  FullscreenOutline,
  GithubOutline,
  GlobalOutline,
  HddOutline,
  LaptopOutline,
  LikeOutline,
  LockOutline,
  LogoutOutline,
  MailOutline,
  MenuFoldOutline,
  MenuUnfoldOutline,
  MessageOutline,
  PayCircleOutline,
  PieChartOutline,
  PrinterOutline,
  ReloadOutline,
  RocketOutline,
  ScanOutline,
  SettingOutline,
  ShareAltOutline,
  ShoppingCartOutline,
  SoundOutline,
  StarOutline,
  TaobaoCircleOutline,
  TaobaoOutline,
  TeamOutline,
  ToolOutline,
  TrophyOutline,
  TranslationOutline,
  UsbOutline,
  UserOutline,
  WeiboCircleOutline,
  PayCircleOutline,
  CalculatorOutline,
  StopOutline,
  FormOutline,
  CheckOutline,
  CheckCircleOutline,
  CheckSquareOutline,
  SmileOutline,
  SafetyCertificateOutline,
  DesktopOutline,
  ApartmentOutline,
  UploadOutline,
  CreditCardOutline,
  DollarCircleFill,
  DollarOutline,
  BoxPlotOutline,
  ClockCircleOutline,
  SolutionOutline,
  SmileOutline,
  CheckCircleFill,
  ApiFill,
  ThunderboltOutline,
  FileDoneOutline,
  CloudOutline,
  FunnelPlotOutline,
  FilterOutline,
  ArrowUpOutline
];

// src/app/app.config.ts
var defaultLang = {
  abbr: "en",
  ng: en_default,
  zorro: en_US,
  date: en_US_default,
  delon: enUS
};
var alainConfig = {
  auth: { login_url: "/passport/login" }
};
var ngZorroConfig = {};
var routerFeatures = [withComponentInputBinding(), withInMemoryScrolling({ scrollPositionRestoration: "top" })];
if (environment2.useHash)
  routerFeatures.push(withHashLocation());
var providers = [
  provideHttpClient(withInterceptors([...environment2.interceptorFns ?? [], authSimpleInterceptor, defaultInterceptor])),
  provideAnimations(),
  provideRouter(routes, ...routerFeatures),
  provideAlain({ config: alainConfig, defaultLang, i18nClass: I18NService, icons: [...ICONS_AUTO, ...ICONS] }),
  provideNzConfig(ngZorroConfig),
  provideAuth(),
  provideCellWidgets(...CELL_WIDGETS),
  provideSTWidgets(...ST_WIDGETS),
  provideSFConfig({
    widgets: [...SF_WIDGETS]
  }),
  provideStartup(),
  ...environment2.providers || []
];
if (environment2.api?.refreshTokenEnabled && environment2.api.refreshTokenType === "auth-refresh") {
  providers.push(provideBindAuthRefresh());
}
var appConfig = {
  providers
};

// src/main.ts
bootstrapApplication(AppComponent, appConfig).catch((err) => console.error(err));
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

apexcharts/dist/apexcharts.common.js:
  (*!
   * ApexCharts v3.45.1
   * (c) 2018-2023 ApexCharts
   * Released under the MIT License.
   *)

@angular/common/locales/en.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/common/locales/zh.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/common/locales/zh-Hant.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v17.0.8
   * (c) 2010-2022 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=main.js.map
